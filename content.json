[{"title":"Android开发规范","date":"2017-12-06T17:01:01.000Z","path":"2017/12/07/android-standard-develop/","text":"原文地址 Android开发规范 摘要 1 前言 2 AS 规范 3 命名规范 4 代码样式规范 5 资源文件规范 6 版本统一规范 7 第三方库规范 8 注释规范 9 测试规范 10 其他的一些规范 1 前言为了有利于项目维护、增强代码可读性、提升 Code Review 效率以及规范团队安卓开发，故提出以下安卓开发规范，该规范结合本人多年的开发经验并吸取多家之精华，可谓是本人的呕心沥血之作，称其为当前最完善的安卓开发规范一点也不为过，如有更好建议，欢迎到 GitHub 提 issue，原文地址：Android 开发规范（完结版）。相关 Demo，可以查看我的 Android 开发工具类集合项目：Android 开发人员不得不收集的代码。后续可能会根据该规范出一个 CheckStyle 插件来检查是否规范，当然也支持在 CI 上运行。 2 AS 规范工欲善其事，必先利其器。 尽量使用最新的稳定版的 IDE 进行开发； 编码格式统一为 UTF-8； 编辑完 .java、.xml 等文件后一定要 格式化，格式化，格式化（如果团队有公共的样式包，那就遵循它，否则统一使用 AS 默认模板即可）； 删除多余的 import，减少警告出现，可利用 AS 的 Optimize Imports（Settings -&gt; Keymap -&gt; Optimize Imports）快捷键； Android 开发者工具可以参考这里：Android 开发者工具； 3 命名规范代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解，避免歧义。 注意：即使纯拼音命名方式也要避免采用。但 alibaba、taobao、youku、hangzhou 等国际通用的名称，可视同英文。 3.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。一级包名是顶级域名，通常为 com、edu、gov、net、org 等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐采用 PBF（按功能分包 Package By Feature），一开始我们采用的也是 PBL（按层分包 Package By Layer），很坑爹。PBF 可能不是很好区分在哪个功能中，不过也比 PBL 要好找很多，且 PBF 与 PBL 相比较有如下优势： package 内高内聚，package 间低耦合 哪块要添新功能，只改某一个 package 下的东西。 PBL 降低了代码耦合，但带来了 package 耦合，要添新功能，需要改 model、dbHelper、view、service 等等，需要改动好几个 package 下的代码，改动的地方越多，越容易产生新问题，不是吗？ PBF 的话 featureA 相关的所有东西都在 featureA 包，feature 内高内聚、高度模块化，不同 feature 之间低耦合，相关的东西都放在一起，还好找。 package 有私有作用域（package-private scope） 你负责开发这块功能，这个目录下所有东西都是你的。 PBL 的方式是把所有工具方法都放在 util 包下，小张开发新功能时候发现需要一个 xxUtil，但它又不是通用的，那应该放在哪里？没办法，按照分层原则，我们还得放在 util 包下，好像不太合适，但放在其它包更不合适，功能越来越多，util 类也越定义越多。后来小李负责开发一块功能时发现需要一个 xxUtil，同样不通用，去 util 包一看，怎么已经有了，而且还没法复用，只好放弃 xx 这个名字，改为 xxxUtil……，因为 PBL 的 package 没有私有作用域，每一个包都是 public（跨包方法调用是很平常的事情，每一个包对其它包来说都是可访问的）；如果是 PBF，小张的 xxUtil 自然放在 featureA 下，小李的 xxUtil 在 featureB 下，如果觉得 util 好像是通用的，就去 util 包看看要不要把工具方法添进 xxUtil, class 命名冲突没有了。 PBF 的 package 有私有作用域，featureA 不应该访问 featureB 下的任何东西（如果非访问不可，那就说明接口定义有问题）。 很容易删除功能 统计发现新功能没人用，这个版本那块功能得去掉。 如果是 PBL，得从功能入口到整个业务流程把受到牵连的所有能删的代码和 class 都揪出来删掉，一不小心就完蛋。 如果是 PBF，好说，先删掉对应包，再删掉功能入口（删掉包后入口肯定报错了），完事。 高度抽象 解决问题的一般方法是从抽象到具体，PBF 包名是对功能模块的抽象，包内的 class 是实现细节，符合从抽象到具体，而 PBL 弄反了。 PBF 从确定 AppName 开始，根据功能模块划分 package，再考虑每块的具体实现细节，而 PBL 从一开始就要考虑要不要 dao 层，要不要 com 层等等。 只通过 class 来分离逻辑代码 PBL 既分离 class 又分离 package，而 PBF 只通过 class 来分离逻辑代码。 没有必要通过 package 分离，因为 PBL 中也可能出现尴尬的情况： 12├── service ├── MainService.java 按照 PBL, service 包下的所有东西都是 Service，应该不需要 Service 后缀，但实际上通常为了方便，直接 import service 包，Service 后缀是为了避免引入的 class 和当前包下的 class 命名冲突，当然，不用后缀也可以，得写清楚包路径，比如 new com.domain.service.MainService()，麻烦；而 PBF 就很方便，无需 import，直接 new MainService() 即可。 package 的大小有意义了 PBL 中包的大小无限增长是合理的，因为功能越添越多，而 PBF 中包太大（包里 class 太多）表示这块需要重构（划分子包）。 如要知道更多好处，可以查看这篇博文：Package by features, not layers，当然，我们大谷歌也有相应的 Sample：todo-mvp，其结构如下所示，很值得学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445com└── example └── android └── architecture └── blueprints └── todoapp ├── BasePresenter.java ├── BaseView.java ├── addedittask │ ├── AddEditTaskActivity.java │ ├── AddEditTaskContract.java │ ├── AddEditTaskFragment.java │ └── AddEditTaskPresenter.java ├── data │ ├── Task.java │ └── source │ ├── TasksDataSource.java │ ├── TasksRepository.java │ ├── local │ │ ├── TasksDbHelper.java │ │ ├── TasksLocalDataSource.java │ │ └── TasksPersistenceContract.java │ └── remote │ └── TasksRemoteDataSource.java ├── statistics │ ├── StatisticsActivity.java │ ├── StatisticsContract.java │ ├── StatisticsFragment.java │ └── StatisticsPresenter.java ├── taskdetail │ ├── TaskDetailActivity.java │ ├── TaskDetailContract.java │ ├── TaskDetailFragment.java │ └── TaskDetailPresenter.java ├── tasks │ ├── ScrollChildSwipeRefreshLayout.java │ ├── TasksActivity.java │ ├── TasksContract.java │ ├── TasksFilterType.java │ ├── TasksFragment.java │ └── TasksPresenter.java └── util ├── ActivityUtils.java ├── EspressoIdlingResource.java └── SimpleCountingIdlingResource.java 参考以上的代码结构，按功能分包具体可以这样做： 12345678910111213141516171819202122com└── domain └── app ├── App.java 定义 Application 类 ├── Config.java 定义配置数据（常量） ├── base 基础组件 ├── custom_view 自定义视图 ├── data 数据处理 │ ├── DataManager.java 数据管理器， │ ├── local 来源于本地的数据，比如 SP，Database，File │ ├── model 定义 model（数据结构以及 getter/setter、compareTo、equals 等等，不含复杂操作） │ └── remote 来源于远端的数据 ├── feature 功能 │ ├── feature0 功能 0 │ │ ├── feature0Activity.java │ │ ├── feature0Fragment.java │ │ ├── xxAdapter.java │ │ └── ... 其他 class │ └── ...其他功能 ├── injection 依赖注入 ├── util 工具类 └── widget 小部件 3.2 类名类名都以 UpperCamelCase 风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如 HTML、URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity 为后缀标识 欢迎页面类 WelcomeActivity Adapter 类 Adapter 为后缀标识 新闻详情适配器 NewsDetailAdapter 解析类 Parser 为后缀标识 首页解析类 HomePosterParser 工具方法类 Utils 或 Manager 为后缀标识 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger 也可）打印工具类：PrinterUtils 数据库类 以 DBHelper 后缀标识 新闻数据库：NewsDBHelper Service 类 以 Service 为后缀标识 时间服务 TimeService BroadcastReceiver 类 以 Receiver 为后缀标识 推送接收 JPushReceiver ContentProvider 类 以 Provider 为后缀标识 ShareProvider 自定义的共享基础类 以 Base 开头 BaseActivity, BaseFragment 测试类的命名以它要测试的类的名称开始，以 Test 结束。例如：HashTest 或 HashIntegrationTest。 接口（interface）：命名规则与类一样采用大驼峰命名法，多以 able 或 ible 结尾，如 interface Runnable、interface Accessible。 注意：如果项目采用 MVP，所有 Model、View、Presenter 的接口都以 I 为前缀，不加后缀，其他的接口采用上述命名规则。 3.3 方法名方法名都以 lowerCamelCase 风格编写。 方法名通常是动词或动词短语。 方法 说明 initXX() 初始化相关方法，使用 init 为前缀标识，如初始化布局 initView() isXX(), checkXX() 方法返回值为 boolean 型的请使用 is/check 为前缀标识 getXX() 返回某个值的方法，使用 get 为前缀标识 setXX() 设置某个属性值 handleXX(), processXX() 对数据进行处理的方法 displayXX(), showXX() 弹出提示框和提示信息，使用 display/show 为前缀标识 updateXX() 更新数据 saveXX(), insertXX() 保存或插入数据 resetXX() 重置数据 clearXX() 清除数据 removeXX(), deleteXX() 移除数据或者视图等，如 removeView() drawXX() 绘制数据或效果相关的，使用 draw 前缀标识 3.4 常量名常量名命名模式为 CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量？ 每个常量都是一个 static final 字段，但不是所有 static final 字段都是常量。在决定一个字段是否是一个常量时，得考虑它是否真的感觉像是一个常量。例如，如果观测任何一个该实例的状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变的对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of(\"Ed\", \"Ann\");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = \"non-final\";final String nonStatic = \"non-static\";static final SetmutableCollection = new HashSet();static final ImmutableSetmutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;\"these\", \"can\", \"change\"&#125;; 3.5 非常量字段名非常量字段名以 lowerCamelCase 风格的基础上改造为如下风格：基本结构为 scope{Type0}VariableName{Type1}、type0VariableName{Type1}、variableName{Type1}。 说明：{} 中的内容为可选。 注意：所有的 VO（值对象）统一采用标准的 lowerCamelCase 风格编写，所有的 DTO（数据传输对象）就按照接口文档中定义的字段名编写。 3.5.1 scope（范围）非公有，非静态字段命名以 m 开头。 静态字段命名以 s 开头。 其他字段以小写字母开头。 例如： 1234567public class MyClass &#123; public int publicField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected;&#125; 使用 1 个字符前缀来表示作用范围，1 个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。 3.5.2 Type0（控件类型）考虑到 Android 众多的 UI 控件，为避免控件和普通成员变量混淆以及更好地表达意思，所有用来表示控件的成员变量统一加上控件缩写作为前缀（具体见附录UI 控件缩写表）。 例如：mIvAvatar、rvBooks、flContainer。 3.5.3 VariableName（变量名）变量名中可能会出现量词，我们需要创建统一的量词，它们更容易理解，也更容易搜索。 例如：mFirstBook、mPreBook、curBook。 量词列表 量词后缀说明 First 一组变量中的第一个 Last 一组变量中的最后一个 Next 一组变量中的下一个 Pre 一组变量中的上一个 Cur 一组变量中的当前变量 3.5.4 Type1（数据类型）对于表示集合或者数组的非常量字段名，我们可以添加后缀来增强字段的可读性，比如： 集合添加如下后缀：List、Map、Set。 数组添加如下后缀：Arr。 例如：mIvAvatarList、userArr、firstNameSet。 注意：如果数据类型不确定的话，比如表示的是很多书，那么使用其复数形式来表示也可，例如 mBooks。 3.6 参数名参数名以 lowerCamelCase 风格编写，参数应该避免用单个字符命名。 3.7 局部变量名局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 3.8 临时变量临时变量通常被取名为 i、j、k、m 和 n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：for (int i = 0; i &lt; len; i++)。 3.9 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字（如：E, T, X, T2）。 以类命名方式（参考3.2 类名），后面加个大写的 T（如：RequestT, FooBarT）。 更多还可参考：阿里巴巴 Java 开发手册 4 代码样式规范4.1 使用标准大括号样式左大括号不单独占一行，与其前面的代码位于同一行： 1234567891011class MyClass &#123; int func() &#123; if (something) &#123; // ... &#125; else if (somethingElse) &#123; // ... &#125; else &#123; // ... &#125; &#125;&#125; 我们需要在条件语句周围添加大括号。例外情况：如果整个条件语句（条件和主体）适合放在同一行，那么您可以（但不是必须）将其全部放在一行上。例如，我们接受以下样式： 123if (condition) &#123; body();&#125; 同样也接受以下样式： 1if (condition) body(); 但不接受以下样式： 12if (condition) body(); // bad! 4.2 编写简短方法在可行的情况下，尽量编写短小精炼的方法。我们了解，有些情况下较长的方法是恰当的，因此对方法的代码长度没有做出硬性限制。如果某个方法的代码超出 40 行，请考虑是否可以在不破坏程序结构的前提下对其拆解。 4.3 类成员的顺序这并没有唯一的正确解决方案，但如果都使用一致的顺序将会提高代码的可读性，推荐使用如下排序： 常量 字段 构造函数 重写函数和回调 公有函数 私有函数 内部类或接口 例如： 123456789101112131415161718192021222324public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private String mTitle; private TextView mTextViewTitle; @Override public void onCreate() &#123; ... &#125; public void setTitle(String title) &#123; mTitle = title; &#125; private void setUpView() &#123; ... &#125; static class AnInnerClass &#123; &#125;&#125; 如果类继承于 Android 组件（例如 Activity 或 Fragment），那么把重写函数按照他们的生命周期进行排序是一个非常好的习惯，例如，Activity 实现了 onCreate()、onDestroy()、onPause()、onResume()，它的正确排序如下所示： 1234567891011121314public class MainActivity extends Activity &#123; //Order matches Activity lifecycle @Override public void onCreate() &#123;&#125; @Override public void onResume() &#123;&#125; @Override public void onPause() &#123;&#125; @Override public void onDestroy() &#123;&#125;&#125; 4.4 函数参数的排序在 Android 开发过程中，Context 在函数参数中是再常见不过的了，我们最好把 Context 作为其第一个参数。 正相反，我们把回调接口应该作为其最后一个参数。 例如： 12345// Context always goes firstpublic User loadUser(Context context, int userId);// Callbacks always go lastpublic void loadUserAsync(Context context, int userId, UserCallback callback); 4.5 字符串常量的命名和值Android SDK 中的很多类都用到了键值对函数，比如SharedPreferences、Bundle、Intent，所以，即便是一个小应用，我们最终也不得不编写大量的字符串常量。 当时用到这些类的时候，我们 必须 将它们的键定义为 static final 字段，并遵循以下指示作为前缀。 类 字段名前缀 SharedPreferences PREF_ Bundle BUNDLE_ Fragment Arguments ARGUMENT_ Intent Extra EXTRA_ Intent Action ACTION_ 说明：虽然 Fragment.getArguments() 得到的也是 Bundle ，但因为这是 Bundle 的常用用法，所以特意为此定义一个不同的前缀。 例如： 12345678// 注意：字段的值与名称相同以避免重复问题static final String PREF_EMAIL = \"PREF_EMAIL\";static final String BUNDLE_AGE = \"BUNDLE_AGE\";static final String ARGUMENT_USER_ID = \"ARGUMENT_USER_ID\";// 与意图相关的项使用完整的包名作为值的前缀static final String EXTRA_SURNAME = \"com.myapp.extras.EXTRA_SURNAME\";static final String ACTION_OPEN_USER = \"com.myapp.action.ACTION_OPEN_USER\"; 4.6 Activities 和 Fragments 的传参当 Activity 或 Fragment 传递数据通过 Intent 或 Bundle 时，不同值的键须遵循上一条所提及到的。 当 Activity 或 Fragment 启动需要传递参数时，那么它需要提供一个 public static 的函数来帮助启动或创建它。 这方面，AS 已帮你写好了相关的 Live Templates，启动相关 Activity 的只需要在其内部输入 starter 即可生成它的启动器，如下所示： 12345public static void start(Context context, User user) &#123; Intent starter = new Intent(context, MainActivity.class); starter.putParcelableExtra(EXTRA_USER, user); context.startActivity(starter);&#125; 同理，启动相关 Fragment 在其内部输入 newInstance 即可，如下所示： 1234567public static MainFragment newInstance(User user) &#123; Bundle args = new Bundle(); args.putParcelable(ARGUMENT_USER, user); MainFragment fragment = new MainFragment(); fragment.setArguments(args); return fragment;&#125; 注意：这些函数需要放在 onCreate() 之前的类的顶部；如果我们使用了这种方式，那么 extras 和 arguments 的键应该是 private 的，因为它们不再需要暴露给其他类来使用。 4.7 行长限制代码中每一行文本的长度都应该不超过 100 个字符。虽然关于此规则存在很多争论，但最终决定仍是以 100 个字符为上限，如果行长超过了 100（AS 窗口右侧的竖线就是设置的行宽末尾 ），我们通常有两种方法来缩减行长。 提取一个局部变量或方法（最好）。 使用换行符将一行换成多行。 不过存在以下例外情况： 如果备注行包含长度超过 100 个字符的示例命令或文字网址，那么为了便于剪切和粘贴，该行可以超过 100 个字符。 导入语句行可以超出此限制，因为用户很少会看到它们（这也简化了工具编写流程）。 4.7.1 换行策略这没有一个准确的解决方案来决定如何换行，通常不同的解决方案都是有效的，但是有一些规则可以应用于常见的情况。 4.7.1.1 操作符的换行除赋值操作符之外，我们把换行符放在操作符之前，例如： 12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 赋值操作符的换行我们放在其后，例如： 12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 4.7.1.2 函数链的换行当同一行中调用多个函数时（比如使用构建器时），对每个函数的调用应该在新的一行中，我们把换行符插入在 . 之前。 例如： 1Picasso.with(context).load(\"https://blankj.com/images/avatar.jpg\").into(ivAvatar); 我们应该使用如下规则： 123Picasso.with(context) .load(\"https://blankj.com/images/avatar.jpg\") .into(ivAvatar); 4.7.1.3 多参数的换行当一个方法有很多参数或者参数很长的时候，我们应该在每个 , 后面进行换行。 比如： 1loadPicture(context, \"https://blankj.com/images/avatar.jpg\", ivAvatar, \"Avatar of the user\", clickListener); 我们应该使用如下规则： 12345loadPicture(context, \"https://blankj.com/images/avatar.jpg\", ivAvatar, \"Avatar of the user\", clickListener); 4.7.1.4 RxJava 链式的换行RxJava 的每个操作符都需要换新行，并且把换行符插入在 . 之前。 例如： 123456789101112131415public Observable&lt;Location&gt; syncLocations() &#123; return mDatabaseHelper.getAllLocations() .concatMap(new Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() &#123; @Override public Observable&lt;? extends Location&gt; call(Location location) &#123; return mRetrofitService.getLocation(location.id); &#125; &#125;) .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123; @Override public Boolean call(Integer numRetries, Throwable throwable) &#123; return throwable instanceof RetrofitError; &#125; &#125;);&#125; 5 资源文件规范资源文件命名为全部小写，采用下划线命名法。 如果想对资源文件进行分包可以参考我这篇文章：Android Studio 下对资源进行分包。 5.1 动画资源文件（anim/ 和 animator/）安卓主要包含属性动画和视图动画，其视图动画包括补间动画和逐帧动画。属性动画文件需要放在 res/animator/ 目录下，视图动画文件需放在 res/anim/ 目录下。 命名规则：{模块名_}逻辑名称。 说明：{} 中的内容为可选，逻辑名称 可由多个单词加下划线组成。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 如果是普通的补间动画或者属性动画，可采用：动画类型_方向 的命名方式。 例如： 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 5.2 颜色资源文件（color/）专门存放颜色相关的资源文件。 命名规则：类型_逻辑名称。 例如：sel_btn_font.xml。 颜色资源也可以放于 res/drawable/ 目录，引用时则用 @drawable 来引用，但不推荐这么做，最好还是把两者分开。 5.3 图片资源文件（drawable/ 和 mipmap/）res/drawable/ 目录下放的是位图文件（.png、.9.png、.jpg、.gif）或编译为可绘制对象资源子类型的 XML 文件，而 res/mipmap/ 目录下放的是不同密度的启动图标，所以 res/mipmap/ 只用于存放启动图标，其余图片资源文件都应该放到 res/drawable/ 目录下。 命名规则：类型{_模块名}_逻辑名称、类型{_模块名}_颜色。 说明：{} 中的内容为可选；类型 可以是可绘制对象资源类型，也可以是控件类型（具体见附录UI 控件缩写表）；最后可加后缀 _small 表示小图，_big 表示大图。 例如： 名称 说明 btn_main_about.png 主页关于按键 类型_模块名_逻辑名称 btn_back.png 返回按键 类型_逻辑名称 divider_maket_white.png 商城白色分割线 类型_模块名_颜色 ic_edit.png 编辑图标 类型_逻辑名称 bg_main.png 主页背景 类型_逻辑名称 btn_red.png 红色按键 类型_颜色 btn_red_big.png 红色大按键 类型_颜色 ic_head_small.png 小头像图标 类型_逻辑名称 bg_input.png 输入框背景 类型_逻辑名称 divider_white.png 白色分割线 类型_颜色 bg_main_head.png 主页头部背景 类型_模块名_逻辑名称 def_search_cell.png 搜索页面默认单元图片 类型_模块名_逻辑名称 ic_more_help.png 更多帮助图标 类型_逻辑名称 divider_list_line.png 列表分割线 类型_逻辑名称 sel_search_ok.xml 搜索界面确认选择器 类型_模块名_逻辑名称 shape_music_ring.xml 音乐界面环形形状 类型_模块名_逻辑名称 如果有多种形态，如按钮选择器：sel_btn_xx.xml，采用如下命名： 名称 说明 sel_btn_xx 作用在 btn_xx 上的 selector btn_xx_normal 默认状态效果 btn_xx_pressed state_pressed 点击效果 btn_xx_focused state_focused 聚焦效果 btn_xx_disabled state_enabled 不可用效果 btn_xx_checked state_checked 选中效果 btn_xx_selected state_selected 选中效果 btn_xx_hovered state_hovered 悬停效果 btn_xx_checkable state_checkable 可选效果 btn_xx_activated state_activated 激活效果 btn_xx_window_focused state_window_focused 窗口聚焦效果 注意：使用 Android Studio 的插件 SelectorChapek 可以快速生成 selector，前提是命名要规范。 5.4 布局资源文件（layout/）命名规则：类型_模块名、类型{_模块名}_逻辑名称。 说明：{} 中的内容为可选。 例如： 名称 说明 activity_main.xml 主窗体 类型_模块名 activity_main_head.xml 主窗体头部 类型_模块名_逻辑名称 fragment_music.xml 音乐片段 类型_模块名 fragment_music_player.xml 音乐片段的播放器 类型_模块名_逻辑名称 dialog_loading.xml 加载对话框 类型_逻辑名称 ppw_info.xml 信息弹窗（PopupWindow） 类型_逻辑名称 item_main_song.xml 主页歌曲列表项 类型_模块名_逻辑名称 5.5 菜单资源文件（menu/）菜单相关的资源文件应放在该目录下。 命名规则：{模块名_}逻辑名称 说明：{} 中的内容为可选。 例如：main_drawer.xml、navigation.xml。 5.6 values 资源文件（values/）values/ 资源文件下的文件都以 s 结尾，如 attrs.xml、colors.xml、dimens.xml，起作用的不是文件名称，而是 &lt;resources&gt; 标签下的各种标签，比如 &lt;style&gt; 决定样式，&lt;color&gt; 决定颜色，所以，可以把一个大的 xml 文件分割成多个小的文件，比如可以有多个 style 文件，如 styles.xml、styles_home.xml、styles_item_details.xml、styles_forms.xml。 5.6.1 colors.xml&lt;color&gt; 的 name 命名使用下划线命名法，在你的 colors.xml 文件中应该只是映射颜色的名称一个 ARGB 值，而没有其它的。不要使用它为不同的按钮来定义 ARGB 值。 例如，不要像下面这样做： 123456789&lt;resources&gt; &lt;color name=\"button_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"button_background\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"comment_background_inactive\"&gt;#5F5F5F&lt;/color&gt; &lt;color name=\"comment_background_active\"&gt;#939393&lt;/color&gt; &lt;color name=\"comment_foreground\"&gt;#FFFFFF&lt;/color&gt; &lt;color name=\"comment_foreground_important\"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name=\"comment_shadow\"&gt;#323232&lt;/color&gt; 使用这种格式，会非常容易重复定义 ARGB 值，而且如果应用要改变基色的话会非常困难。同时，这些定义是跟一些环境关联起来的，如 button 或者 comment，应该放到一个按钮风格中，而不是在 colors.xml 文件中。 相反，应该这样做： 12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name=\"white\" &gt;#FFFFFF&lt;/color&gt; &lt;color name=\"gray_light\"&gt;#DBDBDB&lt;/color&gt; &lt;color name=\"gray\" &gt;#939393&lt;/color&gt; &lt;color name=\"gray_dark\" &gt;#5F5F5F&lt;/color&gt; &lt;color name=\"black\" &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name=\"green\"&gt;#27D34D&lt;/color&gt; &lt;color name=\"blue\"&gt;#2A91BD&lt;/color&gt; &lt;color name=\"orange\"&gt;#FF9D2F&lt;/color&gt; &lt;color name=\"red\"&gt;#FF432F&lt;/color&gt;&lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟 &quot;green&quot;、&quot;blue&quot; 等等相同。&quot;brand_primary&quot;、&quot;brand_secondary&quot;、&quot;brand_negative&quot; 这样的名字也是完全可以接受的。像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。通常一个具有审美价值的 UI 来说，减少使用颜色的种类是非常重要的。 注意：如果某些颜色和主题有关，那就单独写一个 colors_theme.xml。 5.6.2 dimens.xml像对待 colors.xml 一样对待 dimens.xml 文件，与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示： 123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name=\"font_22\"&gt;22sp&lt;/dimen&gt; &lt;dimen name=\"font_18\"&gt;18sp&lt;/dimen&gt; &lt;dimen name=\"font_15\"&gt;15sp&lt;/dimen&gt; &lt;dimen name=\"font_12\"&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name=\"spacing_40\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"spacing_24\"&gt;24dp&lt;/dimen&gt; &lt;dimen name=\"spacing_14\"&gt;14dp&lt;/dimen&gt; &lt;dimen name=\"spacing_10\"&gt;10dp&lt;/dimen&gt; &lt;dimen name=\"spacing_4\"&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name=\"button_height_60\"&gt;60dp&lt;/dimen&gt; &lt;dimen name=\"button_height_40\"&gt;40dp&lt;/dimen&gt; &lt;dimen name=\"button_height_32\"&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写 margins 和 paddings 时，你应该使用 spacing_xx 尺寸格式来布局，而不是像对待 string 字符串一样直接写值，像这样规范的尺寸很容易修改或重构，会使应用所有用到的尺寸一目了然。 这样写会非常有感觉，会使组织和改变风格或布局非常容易。 5.6.3 strings.xml&lt;string&gt; 的 name 命名使用下划线命名法，采用以下规则：{模块名_}逻辑名称，这样方便同一个界面的所有 string 都放到一起，方便查找。 名称 说明 main_menu_about 主菜单按键文字 friend_title 好友模块标题栏 friend_dialog_del 好友删除提示 login_check_email 登录验证 dialog_title 弹出框标题 button_ok 确认键 loading 加载文字 5.6.4 styles.xml&lt;style&gt; 的 name 命名使用大驼峰命名法，几乎每个项目都需要适当的使用 styles.xml 文件，因为对于一个视图来说，有一个重复的外观是很常见的，将所有的外观细节属性（colors、padding、font）放在 styles.xml 文件中。 在应用中对于大多数文本内容，最起码你应该有一个通用的 styles.xml 文件，例如： 1234&lt;style name=&quot;ContentText&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到 TextView 中： 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/price&quot; style=&quot;@style/ContentText&quot; /&gt; 或许你需要为按钮控件做同样的事情，不要停止在那里，将一组相关的和重复 android:xxxx 的属性放到一个通用的 &lt;style&gt; 中。 5.7 id 命名命名规则：view缩写{_模块名}_逻辑名，例如： btn_main_search、btn_back。 如果在项目中有用黄油刀的话，使用 AS 的插件：ButterKnife Zelezny，可以非常方便帮助你生成注解；没用黄油刀的话可以使用 Android Code Generator 插件。 6 版本统一规范Android 开发存在着众多版本的不同，比如 compileSdkVersion、minSdkVersion、targetSdkVersion 以及项目中依赖第三方库的版本，不同的 module 及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件。 具体可以参考我写的这篇博文：Android 开发之版本统一规范。 如果是开发多个系统级别的应用，当多个应用同时用到相同的 so 库时，一定要确保 so 库的版本一致，否则可能会引发应用崩溃。 7 第三方库规范别再闭门造车了，用用最新最火的技术吧，安利一波：Android 流行框架查速表，顺便带上自己的干货：Android 开发人员不得不收集的代码。 希望 Team 能用时下较新的技术，对开源库的选取，一般都需要选择比较稳定的版本，作者在维护的项目，要考虑作者对 issue 的解决，以及开发者的知名度等各方面。选取之后，一定的封装是必要的。 个人推荐 Team 可使用如下优秀轮子： Retrofit RxAndroid OkHttp Glide/Fresco Gson/Fastjson EventBus/AndroidEventBus GreenDao Dagger2（选用） Tinker（选用） 8 注释规范为了减少他人阅读你代码的痛苦值，请在关键地方做好注释。 8.1 类注释每个类完成后应该有作者姓名和联系方式的注释，对自己的代码负责。 123456789101112/** * &lt;pre&gt; * author : Blankj * e-mail : xxx@xx * time : 2017/03/07 * desc : xxxx 描述 * version: 1.0 * &lt;/pre&gt; */public class WelcomeActivity &#123; ...&#125; 具体可以在 AS 中自己配制，进入 Settings -&gt; Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header，输入 123456789/** * &lt;pre&gt; * author : $&#123;USER&#125; * e-mail : xxx@xx * time : $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125; * desc : * version: 1.0 * &lt;/pre&gt; */ 这样便可在每次新建类的时候自动加上该头注释。 8.2 方法注释每一个成员方法（包括自定义成员方法、覆盖方法、属性方法）的方法头都必须做方法头注释，在方法前一行输入 /** + 回车 或者设置 Fix doc comment（Settings -&gt; Keymap -&gt; Fix doc comment）快捷键，AS 便会帮你生成模板，我们只需要补全参数即可，如下所示。 12345678910111213/** * bitmap 转 byteArr * * @param bitmap bitmap 对象 * @param format 格式 * @return 字节数组 */public static byte[] bitmap2Bytes(Bitmap bitmap, CompressFormat format) &#123; if (bitmap == null) return null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); bitmap.compress(format, 100, baos); return baos.toByteArray();&#125; 8.3 块注释块注释与其周围的代码在同一缩进级别。它们可以是 /* ... */ 风格，也可以是 // ... 风格（//后最好带一个空格）。对于多行的 /* ... */ 注释，后续行必须从 * 开始， 并且与前一行的 * 对齐。以下示例注释都是 OK 的。 12345678910/* * This is * okay. */// And so// is this./* Or you can* even do this. */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行（即注释像段落风格一样），那么使用 /* ... */。 8.4 其他一些注释AS 已帮你集成了一些注释模板，我们只需要直接使用即可，在代码中输入 todo、fixme 等这些注释模板，回车后便会出现如下注释。 12// TODO: 17/3/14 需要实现，但目前还未实现的功能的说明// FIXME: 17/3/14 需要修正，甚至代码是错误的，不能工作，需要修复的说明 9 测试规范业务开发完成之后，开发人员做单元测试，单元测试完成之后，保证单元测试全部通过，同时单元测试代码覆盖率达到一定程度（这个需要开发和测试约定，理论上越高越好），开发提测。 9.1 单元测试测试类的名称应该是所测试类的名称加 Test，我们创建 DatabaseHelper 的测试类，其名应该叫 DatabaseHelperTest。 测试函数被 @Test 所注解，函数名通常以被测试的方法为前缀，然后跟随是前提条件和预期的结果。 模板：void methodName前提条件和预期结果() 例子：void signInWithEmptyEmailFails() 注意：如果函数足够清晰，那么前提条件和预期的结果是可以省略的。 有时一个类可能包含大量的方法，同时需要对每个方法进行几次测试。在这种情况下，建议将测试类分成多个类。例如，如果 DataManager 包含很多方法，我们可能要把它分成 DataManagerSignInTest、DataManagerLoadUsersTest 等等。 9.2 Espresso 测试每个 Espresso 测试通常是针对 Activity，所以其测试名就是其被测的 Activity 的名称加 Test，比如 SignInActivityTest。 10 其他的一些规范 合理布局，有效运用 &lt;merge&gt;、&lt;ViewStub&gt;、&lt;include&gt; 标签； Activity 和 Fragment 里面有许多重复的操作以及操作步骤，所以我们都需要提供一个 BaseActivity 和 BaseFragment，让所有的 Activity 和 Fragment 都继承这个基类。 方法基本上都按照调用的先后顺序在各自区块中排列； 相关功能作为小区块放在一起（或者封装掉）； 当一个类有多个构造函数，或是多个同名函数，这些函数应该按顺序出现在一起，中间不要放进其它函数； 数据提供统一的入口。无论是在 MVP、MVC 还是 MVVM 中，提供一个统一的数据入口，都可以让代码变得更加易于维护。比如可使用一个 DataManager，把 http、preference、eventpost、database 都放在 DataManager 里面进行操作，我们只需要与 DataManager打交道； 多用组合，少用继承； 提取方法，去除重复代码。对于必要的工具类抽取也很重要，这在以后的项目中是可以重用的。 可引入 Dagger2 减少模块之间的耦合性。Dagger2 是一个依赖注入框架，使用代码自动生成创建依赖关系需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块； 项目引入 RxAndroid 响应式编程，可以极大的减少逻辑代码； 通过引入事件总线，如：EventBus、AndroidEventBus、RxBus，它允许我们在 DataLayer 中发送事件，以便 ViewLayer 中的多个组件都能够订阅到这些事件，减少回调； 尽可能使用局部变量； 及时关闭流； 尽量减少对变量的重复计算； 如下面的操作： 123for (int i = 0; i &lt; list.size(); i++) &#123; ...&#125; 建议替换为： 123for (int i = 0, len = list.size(); i &lt; len; i++) &#123; ...&#125; 尽量采用懒加载的策略，即在需要的时候才创建； 例如： 1234String str = \"aaa\";if (i == 1) &#123; list.add(str);&#125; 建议替换为： 1234if (i == 1) &#123; String str = \"aaa\"; list.add(str);&#125; 不要在循环中使用 try…catch…，应该把其放在最外层； 使用带缓冲的输入输出流进行 IO 操作； 尽量使用 HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用 HashTable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销； 尽量在合适的场合使用单例； 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问。 控制实例的产生，以达到节约资源的目的。 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。 把一个基本数据类型转为字符串，基本数据类型.toString() 是最快的方式，String.valueOf(数据) 次之，数据 + &quot;&quot; 最慢； 使用 AS 自带的 Lint 来优化代码结构（什么，你不会？右键 module、目录或者文件，选择 Analyze -&gt; Inspect Code）； 最后不要忘了内存泄漏的检测； 最后啰嗦几句： 好的命名规则能够提高代码质量，使得新人加入项目的时候降低理解代码的难度； 规矩终究是死的，适合团队的才是最好的； 命名规范需要团队一起齐心协力来维护执行，在团队生活里，谁都不可能独善其身； 一开始可能会有些不习惯，持之以恒，总会成功的。 附录UI 控件缩写表 名称 缩写 Button btn CheckBox cb EditText et FrameLayout fl GridView gv ImageButton ib ImageView iv LinearLayout ll ListView lv ProgressBar pb RadioButtion rb RecyclerView rv RelativeLayout rl ScrollView sv SeekBar sb Spinner spn TextView tv ToggleButton tb VideoView vv WebView wv 常见的英文单词缩写表 名称 缩写 average avg background bg（主要用于布局和子布局的背景） buffer buf control ctrl current cur default def delete del document doc error err escape esc icon ic（主要用在 App 的图标） increment inc information info initial init image img Internationalization I18N length len library lib message msg password pwd position pos previous pre selector sel（主要用于某一 view 多种状态，不仅包括 ListView 中的 selector，还包括按钮的 selector） server srv string str temporary tmp window win 程序中使用单词缩写原则：不要用缩写，除非该缩写是约定俗成的。 参考Android 包命名规范 Android 开发最佳实践 Android 编码规范 阿里巴巴 Java 开发手册 Project and code style guidelines Google Java 编程风格指南 小细节，大用途，35 个 Java 代码性能优化总结！ 版本日志 17/12/05: 新增 logo； 17/12/04: 完善按功能分包，修复 typo，定该版为完结版； 17/12/03: 完善代码样式规范和测试规范； 17/12/02: 新增代码样式规范； 17/12/01: 对资源文件规范进行重构； 17/11/29: 格式化中英混排； 17/03/14: 包名划分为按功能划分； 17/03/13: 新增其他注释； 17/03/08: 规范排版，修复 typo 及新增一些规范； 17/03/07: 修订目录排版，完善某些细节； 17/03/06: 发布初版；","tags":[{"name":"Android","slug":"Android","permalink":"https://smuwjs.github.io/tags/Android/"}]},{"title":"浅谈Android Architecture Components","date":"2017-07-27T17:01:01.000Z","path":"2017/07/28/android-architecture-components/","text":"原文地址 浅谈Android Architecture Components [TOC] 简介Google IO 2017发布Android Architecture Components，自己先研究了一下，蛮有意思的，特来记录一下。本文内容主要是参考官方文档以及自己的理解，如有错误之处，恳请指出。 Android Architecture ComponentsAndroid Architecture Components是Google发布的一套新的架构组件，使App的架构更加健壮，后面简称AAC。 AAC主要提供了Lifecycle，ViewModel，LiveData，Room等功能，下面依次说明： Lifecycle 生命周期管理，把原先Android生命周期的中的代码抽取出来，如将原先需要在onStart()等生命周期中执行的代码分离到Activity或者Fragment之外。 LiveData 一个数据持有类，持有数据并且这个数据可以被观察被监听，和其他Observer不同的是，它是和Lifecycle是绑定的，在生命周期内使用有效，减少内存泄露和引用问题。 ViewModel 用于实现架构中的ViewModel，同时是与Lifecycle绑定的，使用者无需担心生命周期。可以在多个Fragment之间共享数据，比如旋转屏幕后Activity会重新create，这时候使用ViewModel还是之前的数据，不需要再次请求网络数据。 Room 谷歌推出的一个Sqlite ORM库，不过使用起来还不错，使用注解，极大简化数据库的操作，有点类似Retrofit的风格。 AAC的架构是这样的： 新的架构 Activity/Fragment UI层，通常是Activity/Fragment等，监听ViewModel，当VIewModel数据更新时刷新UI，监听用户事件反馈到ViewModel，主流的数据驱动界面。 ViewModel 持有或保存数据，向Repository中获取数据，响应UI层的事件，执行响应的操作，响应数据变化并通知到UI层。 Repository App的完全的数据模型，ViewModel交互的对象，提供简单的数据修改和获取的接口，配合好网络层数据的更新与本地持久化数据的更新，同步等 Data Source 包含本地的数据库等，网络api等，这些基本上和现有的一些MVVM，以及Clean架构的组合比较相似 Gradle 集成根目录gradle文件中添加Google Maven Repository 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url 'https://maven.google.com' &#125; &#125;&#125; 在模块中添加对应的依赖 如使用Lifecycle,LiveData、ViewModel，添加如下依赖。 123compile \"android.arch.lifecycle:runtime:1.0.0-alpha1\"compile \"android.arch.lifecycle:extensions:1.0.0-alpha1\"annotationProcessor \"android.arch.lifecycle:compiler:1.0.0-alpha1\" 如使用Room功能，添加如下依赖。 12345678compile \"android.arch.persistence.room:runtime:1.0.0-alpha1\"annotationProcessor \"android.arch.persistence.room:compiler:1.0.0-alpha1\"// For testing Room migrations, add:testCompile \"android.arch.persistence.room:testing:1.0.0-alpha1\"// For Room RxJava support, add:compile \"android.arch.persistence.room:rxjava2:1.0.0-alpha1\" LifeCyclesAndroid开发中，经常需要管理生命周期。举个栗子，我们需要获取用户的地址位置，当这个Activity在显示的时候，我们开启定位功能，然后实时获取到定位信息，当页面被销毁的时候，需要关闭定位功能。 下面是简单的示例代码。 12345678910111213141516171819202122232425262728293031323334class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; public void onStart() &#123; super.onStart(); myLocationListener.start(); &#125; public void onStop() &#123; super.onStop(); myLocationListener.stop(); &#125;&#125; 上面只是一个简单的场景，我们来个复杂一点的场景。当定位功能需要满足一些条件下才开启，那么会变得复杂多了。可能在执行Activity的stop方法时，定位的start方法才刚刚开始执行，比如如下代码，这样生命周期管理就变得很麻烦了。 123456789101112131415161718192021222324class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, location -&gt; &#123; // update UI &#125;); &#125; public void onStart() &#123; super.onStart(); Util.checkUserStatus(result -&gt; &#123; // what if this callback is invoked AFTER activity is stopped? if (result) &#123; myLocationListener.start(); &#125; &#125;); &#125; public void onStop() &#123; super.onStop(); myLocationListener.stop(); &#125;&#125; AAC中提供了Lifecycle，用来帮助我们解决这样的问题。LifeCycle使用2个枚举类来解决生命周期管理问题。一个是事件，一个是状态。 事件： 生命周期事件由系统来分发，这些事件对于与Activity和Fragment的生命周期函数。 状态： Lifecycle的状态，用于追踪中Lifecycle对象，如下图所示。 Lifecycle的状态 上面的定位功能代码，使用LifeCycle实现以后是这样的，实现一个LifecycleObserver接口，然后用注解标注状态，最后在LifecycleOwner中添加监听。 123456789101112public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void onResume() &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void onPause() &#123; &#125;&#125;aLifecycleOwner.getLifecycle().addObserver(new MyObserver()); 上面代码中用到了aLifecycleOwner是LifecycleOwner接口对象，LifecycleOwner是一个只有一个方法的接口getLifecycle()，需要由子类来实现。 在Lib中已经有实现好的子类，我们可以直接拿来使用。比如LifecycleActivity和LifecycleFragment，我们只需要继承此类就行了。 当然实际开发的时候我们会自己定义BaseActivity，Java是单继承模式，那么需要自己实现LifecycleRegistryOwner接口。 如下所示即可，代码很近简单 123456789public class BaseFragment extends Fragment implements LifecycleRegistryOwner &#123; LifecycleRegistry lifecycleRegistry = new LifecycleRegistry(this); @Override public LifecycleRegistry getLifecycle() &#123; return lifecycleRegistry; &#125;&#125; LiveDataLiveData 是一个 Data Holder 类，可以持有数据，同时这个数据可以被监听的，当数据改变的时候，可以触发回调。但是又不像普通的Observable，LiveData绑定了App的组件，LiveData可以指定在LifeCycle的某个状态被触发。比如LiveData可以指定在LifeCycle的 STARTED 或 RESUMED状体被触发。 12345678910111213141516171819202122232425public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private LocationManager locationManager; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; public LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125; onActive() 这个方法在LiveData在被激活的状态下执行，我们可以开始执行一些操作。 onActive() 这个方法在LiveData在的失去活性状态下执行，我们可以结束执行一些操作。 setValue() 执行这个方法的时候，LiveData可以触发它的回调。 LocationLiveData可以这样使用。 12345678910111213public class MyFragment extends LifecycleFragment &#123; public void onActivityCreated (Bundle savedInstanceState) &#123; LiveData&lt;Location&gt; myLocationListener = ...; Util.checkUserStatus(result -&gt; &#123; if (result) &#123; myLocationListener.addObserver(this, location -&gt; &#123; // update UI &#125;); &#125; &#125;); &#125;&#125; 注意，上面的addObserver方法，必须传LifecycleOwner对象，也就是说添加的对象必须是可以被LifeCycle管理的。 如果LifeCycle没有触发对对应的状态（STARTED or RESUMED），它的值被改变了，那么Observe就不会被执行， 如果LifeCycle被销毁了，那么Observe将自动被删除。 实际上LiveData就提供一种新的供数据共享方式。可以用它在多个Activity、Fragment等其他有生命周期管理的类中实现数据共享。 还是上面的定位例子。 1234567891011121314151617181920212223242526272829303132333435public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private static LocationLiveData sInstance; private LocationManager locationManager; @MainThread public static LocationLiveData get(Context context) &#123; if (sInstance == null) &#123; sInstance = new LocationLiveData(context.getApplicationContext()); &#125; return sInstance; &#125; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; private LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125; 然后在Fragment中调用。 12345678910111213public class MyFragment extends LifecycleFragment &#123; public void onActivityCreated (Bundle savedInstanceState) &#123; Util.checkUserStatus(result -&gt; &#123; if (result) &#123; LocationLiveData.get(getActivity()).observe(this, location -&gt; &#123; // update UI &#125;); &#125; &#125;); &#125;&#125; 从上面的示例，可以得到使用LiveData优点： 没有内存泄露的风险，全部绑定到对应的生命周期，当LifeCycle被销毁的时候，它们也自动被移除 降低Crash，当Activity被销毁的时候，LiveData的Observer自动被删除，然后UI就不会再接受到通知 实时数据，因为LiveData是持有真正的数据的，所以当生命周期又重新开始的时候，又可以重新拿到数据 正常配置改变，当Activity或者Fragment重新创建的时候，可以从LiveData中获取上一次有用的数据 不再需要手动的管理生命周期 Transformations有时候需要对一个LiveData做Observer，但是这个LiveData是依赖另外一个LiveData，有点类似于RxJava中的操作符，我们可以这样做。 Transformations.map() 用于事件流的传递，用于触发下游数据。 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); Transformations.switchMap() 这个和map类似，只不过这个是用来触发上游数据。 123456private LiveData&lt;User&gt; getUser(String id) &#123; // ...&#125;LiveData&lt;String&gt; userId = ...;LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) ); ViewModelViewModel是用来存储UI层的数据，以及管理对应的数据，当数据修改的时候，可以马上刷新UI。 Android系统提供控件，比如Activity和Fragment，这些控件都是具有生命周期方法，这些生命周期方法被系统调用。 当这些控件被销毁或者被重建的时候，如果数据保存在这些对象中，那么数据就会丢失。比如在一个界面，保存了一些用户信息，当界面重新创建的时候，就需要重新去获取数据。当然了也可以使用控件自动再带的方法，在onSaveInstanceState方法中保存数据，在onCreate中重新获得数据，但这仅仅在数据量比较小的情况下。如果数据量很大，这种方法就不能适用了。 另外一个问题就是，经常需要在Activity中加载数据，这些数据可能是异步的，因为获取数据需要花费很长的时间。那么Activity就需要管理这些数据调用，否则很有可能会产生内存泄露问题。最后需要做很多额外的操作，来保证程序的正常运行。 同时Activity不仅仅只是用来加载数据的，还要加载其他资源，做其他的操作，最后Activity类变大，就是我们常讲的上帝类。也有不少架构是把一些操作放到单独的类中，比如MVP就是这样，创建相同类似于生命周期的函数做代理，这样可以减少Activity的代码量，但是这样就会变得很复杂，同时也难以测试。 AAC中提供ViewModel可以很方便的用来管理数据。我们可以利用它来管理UI组件与数据的绑定关系。ViewModel提供自动绑定的形式，当数据源有更新的时候，可以自动立即的更新UI。 下面是一个简单的代码示例。 123456789101112131415public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;Users&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // do async operation to fetch users &#125;&#125; 123456789public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // update UI &#125;); &#125;&#125; 当我们获取ViewModel实例的时候，ViewModel是通过ViewModelProvider保存在LifeCycle中，ViewModel会一直保存在LifeCycle中，直到Activity或者Fragment销毁了，触发LifeCycle被销毁，那么ViewModel也会被销毁的。下面是ViewModel的生命周期图。 RoomRoom是一个持久化工具，和ormlite、greenDao类似，都是ORM工具。在开发中我们可以利用Room来操作sqlite数据库。 Room主要分为三个部分: Database 使用注解申明一个类，注解中包含若干个Entity类，这个Database类主要负责创建数据库以及获取数据对象的。 Entity 表示每个数据库的总的一个表结构，同样也是使用注解表示，类中的每个字段都对应表中的一列。 DAO DAO是 Data Access Object的缩写，表示从从代码中直接访问数据库，屏蔽sql语句。 下面是官方给的结构图。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041// User.java@Entitypublic class User &#123; @PrimaryKey private int uid; @ColumnInfo(name = \"first_name\") private String firstName; @ColumnInfo(name = \"last_name\") private String lastName; // Getters and setters are ignored for brevity, // but they're required for Room to work.&#125;// UserDao.java@Daopublic interface UserDao &#123; @Query(\"SELECT * FROM user\") List&lt;User&gt; getAll(); @Query(\"SELECT * FROM user WHERE uid IN (:userIds)\") List&lt;User&gt; loadAllByIds(int[] userIds); @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" + \"last_name LIKE :last LIMIT 1\") User findByName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125;// AppDatabase.java@Database(entities = &#123;User.class&#125;, version = 1)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125; 最后在代码中调用Database对象 1AppDatabase db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database-name\").build(); 注意： Database最好设计成单利模式，否则对象太多会有性能的影响。 Entities1234567891011121314@Entityclass User &#123; @PrimaryKey public int id; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; @Entity用来注解一个实体类，对应数据库一张表。默认情况下，Room为实体中定义的每个成员变量在数据中创建对应的字段，我们可能不想保存到数据库的字段，这时候就要用道@Ignore注解。 注意： 为了保存每一个字段，这个字段需要有可以访问的gettter/setter方法或者是public的属性 Entity的参数 primaryKeys每个实体必须至少定义1个字段作为主键，即使只有一个成员变量，除了使用@PrimaryKey 将字段标记为主键的方式之外，还可以通过在@Entity注解中指定参数的形式 12345678@Entity(primaryKeys = &#123;\"firstName\", \"lastName\"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; Entity的参数 tableName默认情况下，Room使用类名作为数据库表名。如果你想表都有一个不同的名称，就可以在@Entity中使用tableName参数指定 1234@Entity(tableName = \"users\")class User &#123; ...&#125; 和tableName作用类似； @ColumnInfo注解是改变成员变量对应的数据库的字段名称。 Entity的参数 indicesindices的参数值是@Index的数组，在某些情况写为了加快查询速度我们可以需要加入索引 1234567891011121314@Entity(indices = &#123;@Index(\"name\"), @Index(\"last_name\", \"address\")&#125;)class User &#123; @PrimaryKey public int id; public String firstName; public String address; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; 有时，数据库中某些字段或字段组必须是唯一的。通过将@Index的unique 设置为true，可以强制执行此唯一性属性。 下面的代码示例防止表有两行包含FirstName和LastName列值相同的一组： 1234567891011121314@Entity(indices = &#123;@Index(value = &#123;\"first_name\", \"last_name\"&#125;, unique = true)&#125;)class User &#123; @PrimaryKey public int id; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; Entity的参数 foreignKeys因为SQLite是一个关系型数据库，你可以指定对象之间的关系。尽管大多数ORM库允许实体对象相互引用，但Room明确禁止。实体之间没有对象引用。 不能使用直接关系，所以就要用到foreignKeys（外键）。 123456789101112@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = \"id\", childColumns = \"user_id\"))class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = \"user_id\") public int userId;&#125; 外键是非常强大的，因为它允许指定引用实体更新时发生的操作。例如，级联删除，你可以告诉SQLite删除所有书籍的用户如果用户对应的实例是由包括OnDelete =CASCADE在@ForeignKey注释。ON_CONFLICT ： @Insert(onConflict=REPLACE) REMOVE 或者 REPLACE 有时候可能还需要对象嵌套这时候可以用@Embedded注解 12345678910111213141516171819class Address &#123; public String street; public String state; public String city; @ColumnInfo(name = \"post_code\") public int postCode;&#125;@Entityclass User &#123; @PrimaryKey public int id; public String firstName; @Embedded public Address address;&#125; Dao123456789101112131415161718@Daopublic interface UserDao &#123; @Query(\"SELECT * FROM user\") List&lt;User&gt; getAll(); @Query(\"SELECT * FROM user WHERE uid IN (:userIds)\") List&lt;User&gt; loadAllByIds(int[] userIds); @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" + \"last_name LIKE :last LIMIT 1\") User findByName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125; 数据访问对象Data Access Objects (DAOs)是一种抽象访问数据库的干净的方式。 DAO的Insert 操作当创建DAO方法并用@Insert注释它时，生成一个实现时会在一个事务中完成插入所有参数到数据库。 1234567891011@Daopublic interface MyDao &#123; @Insert(onConflict = OnConflictStrategy.REPLACE) public void insertUsers(User... users); @Insert public void insertBothUsers(User user1, User user2); @Insert public void insertUsersAndFriends(User user, List&lt;User&gt; friends);&#125; DAO的Update、Delete操作与上面类似 12345678@Daopublic interface MyDao &#123; @Update public void updateUsers(User... users); @Delete public void deleteUsers(User... users);&#125; DAO的Query 操作一个简单查询示例 12345@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user\") public User[] loadAllUsers();&#125; 稍微复杂的，带参数的查询操作 12345@Daopublic interface MyDao &#123; @Query(&quot;SELECT * FROM user WHERE age &gt; :minAge&quot;) public User[] loadAllUsersOlderThan(int minAge);&#125; 也可以带多个参数 12345678@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge\") public User[] loadAllUsersBetweenAges(int minAge, int maxAge); @Query(\"SELECT * FROM user WHERE first_name LIKE :search OR last_name LIKE :search\") public List&lt;User&gt; findUserWithName(String search);&#125; 返回子集上面示例都是查询一个表中的所有字段，结果用对应的Entity即可，但是如果我只要其中的几个字段，那么该怎么使用呢？ 比如上面的User，我只需要firstName和lastName，首先定义一个子集，然后结果改成对应子集即可。 12345678910111213public class NameTuple &#123; @ColumnInfo(name=\"first_name\") public String firstName; @ColumnInfo(name=\"last_name\") public String lastName;&#125;@Daopublic interface MyDao &#123; @Query(\"SELECT first_name, last_name FROM user\") public List&lt;NameTuple&gt; loadFullName();&#125; 支持集合参数有个这样一个查询需求，比如要查询某两个地区的所有用户，直接用sql中的in即可，但是如果这个地区是程序指定的，个数不确定，那么改怎么办？ 12345@Daopublic interface MyDao &#123; @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;) public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);&#125; 支持Observable前面提到了LiveData，可以异步的获取数据，那么我们的Room也是支持异步查询的。 12345@Daopublic interface MyDao &#123; @Query(&quot;SELECT first_name, last_name FROM user WHERE region IN (:regions)&quot;) public LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);&#125; 支持RxJavaRxJava是另外一个异步操作库，同样也是支持的。 12345@Daopublic interface MyDao &#123; @Query(\"SELECT * from user where id = :id LIMIT 1\") public Flowable&lt;User&gt; loadUserById(int id);&#125; 支持Cursor原始的Android系统查询结果是通过Cursor来获取的，同样也支持。 12345@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age &gt; :minAge LIMIT 5\") public Cursor loadRawUsersOlderThan(int minAge);&#125; 多表查询有时候数据库存在范式相关，数据拆到了多个表中，那么就需要关联多个表进行查询，如果结果只是一个表的数据，那么很简单，直接用Entity定义的类型即可。 12345678@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM book \" + \"INNER JOIN loan ON loan.book_id = book.id \" + \"INNER JOIN user ON user.id = loan.user_id \" + \"WHERE user.name LIKE :userName\") public List&lt;Book&gt; findBooksBorrowedByNameSync(String userName);&#125; 如果结果是部分字段，同上面一样，需要单独定义一个POJO，来接受数据。 123456789101112public class UserPet &#123; public String userName; public String petName;&#125;@Daopublic interface MyDao &#123; @Query(\"SELECT user.name AS userName, pet.name AS petName \" + \"FROM user, pet \" + \"WHERE user.id = pet.user_id\") public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames();&#125; 类型转换有时候Java定义的数据类型和数据库中存储的数据类型是不一样的，Room提供类型转换，这样在操作数据库的时候，可以自动转换。 比如在Java中，时间用Date表示，但是在数据库中类型确实long，这样有利于存储。 1234567891011public class Converters &#123; @TypeConverter public static Date fromTimestamp(Long value) &#123; return value == null ? null : new Date(value); &#125; @TypeConverter public static Long dateToTimestamp(Date date) &#123; return date == null ? null : date.getTime(); &#125;&#125; 定义数据库时候需要指定类型转换，同时定义好Entity和Dao。 123456789101112131415161718@Database(entities = &#123;User.java&#125;, version = 1)@TypeConverters(&#123;Converter.class&#125;)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125;@Entitypublic class User &#123; ... private Date birthday;&#125;@Daopublic interface UserDao &#123; ... @Query(\"SELECT * FROM user WHERE birthday BETWEEN :from AND :to\") List&lt;User&gt; findUsersBornBetweenDates(Date from, Date to);&#125; 数据库升级版本迭代中，我们不可避免的会遇到数据库升级问题，Room也为我们提供了数据库升级的处理接口。 123456789101112131415Room.databaseBuilder(getApplicationContext(), MyDb.class, &quot;database-name&quot;).addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();static final Migration MIGRATION_1_2 = new Migration(1, 2) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL(&quot;CREATE TABLE `Fruit` (`id` INTEGER, `name` TEXT, PRIMARY KEY(`id`))&quot;); &#125;&#125;;static final Migration MIGRATION_2_3 = new Migration(2, 3) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL(&quot;ALTER TABLE Book ADD COLUMN pub_year INTEGER&quot;); &#125;&#125;; 迁移过程结束后，Room将验证架构以确保迁移正确发生。如果Room发现问题，则抛出包含不匹配信息的异常。 警告： 如果不提供必要的迁移，Room会重新构建数据库，这意味着将丢失数据库中的所有数据。 输出模式可以在gradle中设置开启输出模式，便于我们调试，查看数据库表情况，以及做数据库迁移。 123456789101112android &#123; ... defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [\"room.schemaLocation\": \"$projectDir/schemas\".toString()] &#125; &#125; &#125;&#125; Sample这里是官方示例，本人自己参考官方文档和示例Android Architecture Components samples后，也写出了一个类似的示例项目XiaoxiaZhihu_AAC，还请多多指教。 总结原先IO是在5月底已经结束，本来想尽快参照官方文档和示例，把API撸一遍，然后写个Demo和文章来介绍一下。代码示例早已经写出来了，但6月分工作太忙，然后又出差到北京，最后等到了6月底了，才把这篇文章给写出来了。中间可能有内容以及改变，如果有发现稳重有错误，请及时指出，不理赐教。同时以后做事一定要有始有终，确定的事一定要坚持。 相关资料Android Architecture Components 简单聊聊Android Architecture Componets Android Architecture Components samples XiaoxiaZhihu_AAC 浅谈Android Architecture Components Room ORM 数据库框架","tags":[{"name":"Android","slug":"Android","permalink":"https://smuwjs.github.io/tags/Android/"},{"name":"Android Architecture","slug":"Android-Architecture","permalink":"https://smuwjs.github.io/tags/Android-Architecture/"}]},{"title":"使用Travis CI自动部署Hexo博客到Github上","date":"2017-05-04T15:27:53.000Z","path":"2017/05/04/travisci-hexo/","text":"写在前面自从在github page上搭建博客以来，都是使用的hexo，每次都是通过hexo命令build生成静态文件，再push到github上，后来找到一个deploy插件，只需要填写好github的repos地址就好。但是源码的保存是个问题，更换电脑想要写博客很不方便，甚至蠢到将源码保存到u盘里面，这样每次提交后又要备份一次，很容易忘记。说到这里那为什么不将源码保存到github上呢。 其实也是因为懒，给博客换了几次主题后，使得博客源码很乱，甚至自己也忘了改了主题的哪些代码，加上主题也是个repos，直接提交博客源码是提不上的，涉及到子模块问题，麻烦。想到自己还喜欢改动别人的主题，索性将主题文件夹.git文件删掉，让他成为一个普通的文件夹，这样就能提交到github了。废话不多说，估计是很久没写博客了，没有重点，下面简单说说使用Travis CI自动部署Hexo博客到github上。 什么是Travis CI？ Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。 构建首先进入Travis CI官网，使用github账号登录，如下图 travis 登录成功后进入如下界面，以为我再此之前已经构建过，所以会用红色框内的内容，如果没有使用过是没有的。 list 然后点击My Repositories右边的+，添加需要自动构建的repos，进入如下页面。 new 可以看到这个界面会显示当前github账号的所以项目，如果没有显示，点击右上角的Sync account按钮，就可以同步过来了，点击需要构建的repos前面的按钮为ON，再点击其后的原形设置图标，进入如下界面 config 如图中设置，将Build only if .travis.yml is present及另外两个设置为ON，功能如字面意思不多说。到目前为止，已经将需要构建的repos开启，那么，我们如何在将源码提交到github的时候，它就自动构建并将build后的静态文件push到我的静态文件branch或者repos呢（我是将build后的静态文件放到一个单独的repos了，也可以放在源码repos的另一个branch，例如起名叫hexo），接下来说如何让Travis CI访问github. Access Token我们需要在Travis上配置Access Token，就可以在构建完毕后自动push到github上保存静态文件的repos了。 生成Access Token登录github，进入个人主页，点击setting，进入界面后找到下图所指位置。 token 点击Personal access tokens，进入页面后，在点击右上角Generate new token,会再次让输入github密码，然后在Token description下起一个名字，再勾选一些权限，我是全给勾选上了，在点击下面Generate token这里就不多截图了。复制生成的token码。 配置Travis CI回到Travis的setting页面，如上面图，在Environment Variables这一栏，点击Add，起一个名字到Name，将复制的token码粘贴到Value框中，到这步为止，已经完成了Travis的设置。到博客源码根目录，创建一个.travis.yml的配置文件，内容如下，附注释，注意缩进1234567891011121314151617181920212223242526language: node_js #设置语言node_js: stable #设置相应的版本install: - npm install #安装hexo及插件script: - hexo clean #清除，或者缩写hexo c - hexo generate #生成，或者缩写hexo gafter_script: - cd ./public - git init - git config user.name &quot;smuwjs&quot; #修改name - git config user.email &quot;smuwjs@163.com&quot; #修改email - git add . - git commit -m &quot;update site&quot; - git push --force &quot;https://$&#123;travis&#125;@$&#123;GH_REF&#125;&quot; master:master #travis是在Travis中配置token的名称branches: only: - blog-source #只监测blog-source，可根据自己情况设置，若是存放同一个仓库，这儿可以选择存放源码的branch，如hexoenv: global: - GH_REF: github.com/smuwjs/smuwjs.github.io.git #设置GH_REF，注意更改yourname 因为我是新起了一个repos来存放静态文件了，所以上面的GH_REF是对应那个repos地址，若是放同一个repos中，那这儿一般都是yourname.github.io那个仓库。到此，配置已经完成了。 创建文章我们可以创建一篇文章hexo new post use-travis-build-your-hexo-site，添加内容后，并push到github，正常情况下，进入Travis网站就可以看到已经在构建了，如图 success 完成后，访问链接就可以看到这篇文章了。 写在后面很久没有花时间写点东西了，不管有没有价值，总是一种对知识的积累和总结，输出也意味着输入，所以以后还是将学到的东西和积累总结下，自己可以将知识梳理的同时能帮助到别人是更好的了。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://smuwjs.github.io/tags/Hexo/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"https://smuwjs.github.io/tags/Travis-CI/"}]},{"title":"Java 字符串系列03 StringBuffer详解","date":"2017-04-02T16:00:00.000Z","path":"2017/04/03/java-source-analysis-charsequence-series/Java 字符串系列03 StringBuffer详解/","text":"本章介绍StringBuffer以及它的API的详细使用方法。 目录1. StringBuffer 简介2. StringBuffer 示例 1. StringBuffer 简介StringBuffer 是一个线程安全的可变的字符序列。它继承于AbstractStringBuilder，实现了CharSequence接口。StringBuilder 也是继承于AbstractStringBuilder的子类；但是，StringBuilder和StringBuffer不同，前者是非线程安全的，后者是线程安全的。 StringBuffer 和 CharSequence之间的关系图如下： img StringBuffer 函数列表 StringBuffer() StringBuffer(int capacity) StringBuffer(String string) StringBuffer(CharSequence cs) StringBuffer append(boolean b) StringBuffer append(int i) StringBuffer append(long l) StringBuffer append(float f) StringBuffer append(double d) synchronized StringBuffer append(char ch) synchronized StringBuffer append(char[] chars) synchronized StringBuffer append(char[] chars, int start, int length) synchronized StringBuffer append(Object obj) synchronized StringBuffer append(String string) synchronized StringBuffer append(StringBuffer sb) synchronized StringBuffer append(CharSequence s) synchronized StringBuffer append(CharSequence s, int start, int end) StringBuffer appendCodePoint(int codePoint) int capacity() synchronized char charAt(int index) synchronized int codePointAt(int index) synchronized int codePointBefore(int index) synchronized int codePointCount(int beginIndex, int endIndex) synchronized StringBuffer delete(int start, int end) synchronized StringBuffer deleteCharAt(int location) synchronized void ensureCapacity(int min) synchronized void getChars(int start, int end, char[] buffer, int idx) synchronized int indexOf(String subString, int start) int indexOf(String string) StringBuffer insert(int index, boolean b) StringBuffer insert(int index, int i) StringBuffer insert(int index, long l) StringBuffer insert(int index, float f) StringBuffer insert(int index, double d) synchronized StringBuffer insert(int index, char ch) synchronized StringBuffer insert(int index, char[] chars) synchronized StringBuffer insert(int index, char[] chars, int start, int length) synchronized StringBuffer insert(int index, String string) StringBuffer insert(int index, Object obj) synchronized StringBuffer insert(int index, CharSequence s) synchronized StringBuffer insert(int index, CharSequence s, int start, int end) int lastIndexOf(String string) synchronized int lastIndexOf(String subString, int start) int length() synchronized int offsetByCodePoints(int index, int codePointOffset) synchronized StringBuffer replace(int start, int end, String string) synchronized StringBuffer reverse() synchronized void setCharAt(int index, char ch) synchronized void setLength(int length) synchronized CharSequence subSequence(int start, int end) synchronized String substring(int start) synchronized String substring(int start, int end) synchronized String toString() synchronized void trimToSize() 2. StringBuffer 示例源码如下(StringBufferTest.java): /** * StringBuffer 演示程序 * * @author skywang */ import java.util.HashMap; public class StringBufferTest { public static void main(String[] args) { testInsertAPIs() ; testAppendAPIs() ; testReplaceAPIs() ; testDeleteAPIs() ; testIndexAPIs() ; testOtherAPIs() ; } /** * StringBuffer 的其它API示例 */ private static void testOtherAPIs() { System.out.println(&quot;-------------------------------- testOtherAPIs --------------------------------&quot;); StringBuffer sbuilder = new StringBuffer(&quot;0123456789&quot;); int cap = sbuilder.capacity(); System.out.printf(&quot;cap=%d\\n&quot;, cap); char c = sbuilder.charAt(6); System.out.printf(&quot;c=%c\\n&quot;, c); char[] carr = new char[4]; sbuilder.getChars(3, 7, carr, 0); for (int i=0; i&lt;carr.length; i++) System.out.printf(&quot;carr[%d]=%c &quot;, i, carr[i]); System.out.println(); System.out.println(); } /** * StringBuffer 中index相关API演示 */ private static void testIndexAPIs() { System.out.println(&quot;-------------------------------- testIndexAPIs --------------------------------&quot;); StringBuffer sbuilder = new StringBuffer(&quot;abcAbcABCabCaBcAbCaBCabc&quot;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); // 1. 从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.indexOf(&quot;bc&quot;)); // 2. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;, 5)&quot;, sbuilder.indexOf(&quot;bc&quot;, 5)); // 3. 从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;)); // 4. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;, 4)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;, 4)); System.out.println(); } /** * StringBuffer 的replace()示例 */ private static void testReplaceAPIs() { System.out.println(&quot;-------------------------------- testReplaceAPIs ------------------------------&quot;); StringBuffer sbuilder; sbuilder = new StringBuffer(&quot;0123456789&quot;); sbuilder.replace(0, 3, &quot;ABCDE&quot;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); sbuilder = new StringBuffer(&quot;0123456789&quot;); sbuilder.reverse(); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); sbuilder = new StringBuffer(&quot;0123456789&quot;); sbuilder.setCharAt(0, &apos;M&apos;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); System.out.println(); } /** * StringBuffer 的delete()示例 */ private static void testDeleteAPIs() { System.out.println(&quot;-------------------------------- testDeleteAPIs -------------------------------&quot;); StringBuffer sbuilder = new StringBuffer(&quot;0123456789&quot;); // 删除位置0的字符，剩余字符是“123456789”。 sbuilder.deleteCharAt(0); // 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。 sbuilder.delete(3,6); // 获取sb中从位置1开始的字符串 String str1 = sbuilder.substring(1); // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串 String str2 = sbuilder.substring(3, 5); // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为String String str3 = (String)sbuilder.subSequence(3, 5); System.out.printf(&quot;sbuilder=%s\\nstr1=%s\\nstr2=%s\\nstr3=%s\\n&quot;, sbuilder, str1, str2, str3); System.out.println(); } /** * StringBuffer 的insert()示例 */ private static void testInsertAPIs() { System.out.println(&quot;-------------------------------- testInsertAPIs -------------------------------&quot;); StringBuffer sbuilder = new StringBuffer(); // 在位置0处插入字符数组 sbuilder.insert(0, new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}); // 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度 sbuilder.insert(0, new char[]{&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;}, 0, 3); // 在位置0处插入float sbuilder.insert(0, 1.414f); // 在位置0处插入double sbuilder.insert(0, 3.14159d); // 在位置0处插入boolean sbuilder.insert(0, true); // 在位置0处插入char sbuilder.insert(0, &apos;\\n&apos;); // 在位置0处插入int sbuilder.insert(0, 100); // 在位置0处插入long sbuilder.insert(0, 12345L); // 在位置0处插入StringBuilder对象 sbuilder.insert(0, new StringBuffer(&quot;StringBuilder&quot;)); // 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括) sbuilder.insert(0, new StringBuffer(&quot;STRINGBUILDER&quot;), 6, 13); // 在位置0处插入StringBuffer对象。 sbuilder.insert(0, new StringBuffer(&quot;StringBuffer&quot;)); // 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括) sbuilder.insert(0, new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12); // 在位置0处插入String对象。 sbuilder.insert(0, &quot;String&quot;); // 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括) sbuilder.insert(0, &quot;0123456789&quot;, 1, 6); sbuilder.insert(0, &apos;\\n&apos;); // 在位置0处插入Object对象。此处以HashMap为例 HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); sbuilder.insert(0, map); System.out.printf(&quot;%s\\n\\n&quot;, sbuilder); } /** * StringBuffer 的append()示例 */ private static void testAppendAPIs() { System.out.println(&quot;-------------------------------- testAppendAPIs -------------------------------&quot;); StringBuffer sbuilder = new StringBuffer(); // 追加字符数组 sbuilder.append(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}); // 追加字符数组。0表示字符数组起始位置，3表示长度 sbuilder.append(new char[]{&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;}, 0, 3); // 追加float sbuilder.append(1.414f); // 追加double sbuilder.append(3.14159d); // 追加boolean sbuilder.append(true); // 追加char sbuilder.append(&apos;\\n&apos;); // 追加int sbuilder.append(100); // 追加long sbuilder.append(12345L); // 追加StringBuilder对象 sbuilder.append(new StringBuffer(&quot;StringBuilder&quot;)); // 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括) sbuilder.append(new StringBuffer(&quot;STRINGBUILDER&quot;), 6, 13); // 追加StringBuffer对象。 sbuilder.append(new StringBuffer(&quot;StringBuffer&quot;)); // 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括) sbuilder.append(new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12); // 追加String对象。 sbuilder.append(&quot;String&quot;); // 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括) sbuilder.append(&quot;0123456789&quot;, 1, 6); sbuilder.append(&apos;\\n&apos;); // 追加Object对象。此处以HashMap为例 HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); sbuilder.append(map); sbuilder.append(&apos;\\n&apos;); // 追加unicode编码 sbuilder.appendCodePoint(0x5b57); // 0x5b57是“字”的unicode编码 sbuilder.appendCodePoint(0x7b26); // 0x7b26是“符”的unicode编码 sbuilder.appendCodePoint(0x7f16); // 0x7f16是“编”的unicode编码 sbuilder.appendCodePoint(0x7801); // 0x7801是“码”的unicode编码 System.out.printf(&quot;%s\\n\\n&quot;, sbuilder); } } 运行结果： -------------------------------- testInsertAPIs ------------------------------- {3=three, 2=two, 1=one} 12345StringBUFFERStringBufferBUILDERStringBuilder12345100 true3.141591.414ABCabcde -------------------------------- testAppendAPIs ------------------------------- abcdeABC1.4143.14159true 10012345StringBuilderBUILDERStringBufferBUFFERString12345 {3=three, 2=two, 1=one} 字符编码 -------------------------------- testReplaceAPIs ------------------------------ sbuilder=ABCDE3456789 sbuilder=9876543210 sbuilder=M123456789 -------------------------------- testDeleteAPIs ------------------------------- sbuilder=123789 str1=23789 str2=78 str3=78 -------------------------------- testIndexAPIs -------------------------------- sbuilder=abcAbcABCabCaBcAbCaBCabc sbuilder.indexOf(&quot;bc&quot;) = 1 sbuilder.indexOf(&quot;bc&quot;, 5) = 22 sbuilder.lastIndexOf(&quot;bc&quot;) = 22 sbuilder.lastIndexOf(&quot;bc&quot;, 4) = 4 -------------------------------- testOtherAPIs -------------------------------- cap=26 c=6 carr[0]=3 carr[1]=4 carr[2]=5 carr[3]=6","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 字符串系列","slug":"Java-字符串系列","permalink":"https://smuwjs.github.io/tags/Java-字符串系列/"}]},{"title":"Java 字符串系列02 StringBuilder详解","date":"2017-04-01T16:00:00.000Z","path":"2017/04/02/java-source-analysis-charsequence-series/Java 字符串系列02 StringBuilder详解/","text":"本章介绍StringBuilder以及它的API的详细使用方法。 目录1. StringBuilder 简介2. StringBuilder的API测试代码3. StringBuilder 完整示例 1. StringBuilder 简介StringBuilder 是一个可变的字符序列。它继承于AbstractStringBuilder，实现了CharSequence接口。StringBuffer 也是继承于AbstractStringBuilder的子类；但是，StringBuilder和StringBuffer不同，前者是非线程安全的，后者是线程安全的。 StringBuilder 和 CharSequence之间的关系图如下： img StringBuilder函数列表 StringBuilder() StringBuilder(int capacity) StringBuilder(CharSequence seq) StringBuilder(String str) StringBuilder append(float f) StringBuilder append(double d) StringBuilder append(boolean b) StringBuilder append(int i) StringBuilder append(long l) StringBuilder append(char c) StringBuilder append(char[] chars) StringBuilder append(char[] str, int offset, int len) StringBuilder append(String str) StringBuilder append(Object obj) StringBuilder append(StringBuffer sb) StringBuilder append(CharSequence csq) StringBuilder append(CharSequence csq, int start, int end) StringBuilder appendCodePoint(int codePoint) int capacity() char charAt(int index) int codePointAt(int index) int codePointBefore(int index) int codePointCount(int start, int end) StringBuilder delete(int start, int end) StringBuilder deleteCharAt(int index) void ensureCapacity(int min) void getChars(int start, int end, char[] dst, int dstStart) int indexOf(String subString, int start) int indexOf(String string) StringBuilder insert(int offset, boolean b) StringBuilder insert(int offset, int i) StringBuilder insert(int offset, long l) StringBuilder insert(int offset, float f) StringBuilder insert(int offset, double d) StringBuilder insert(int offset, char c) StringBuilder insert(int offset, char[] ch) StringBuilder insert(int offset, char[] str, int strOffset, int strLen) StringBuilder insert(int offset, String str) StringBuilder insert(int offset, Object obj) StringBuilder insert(int offset, CharSequence s) StringBuilder insert(int offset, CharSequence s, int start, int end) int lastIndexOf(String string) int lastIndexOf(String subString, int start) int length() int offsetByCodePoints(int index, int codePointOffset) StringBuilder replace(int start, int end, String string) StringBuilder reverse() void setCharAt(int index, char ch) void setLength(int length) CharSequence subSequence(int start, int end) String substring(int start) String substring(int start, int end) String toString() void trimToSize() 由于AbstractStringBuilder和StringBuilder源码太长，这里就不列出源码了。感兴趣的读者可以自行研究。 2. StringBuilder的API测试代码2.1 StringBuilder 中插入(insert)相关的API源码如下(StringBuilderInsertTest.java): /** * StringBuilder 的insert()示例 * * @author skywang */ import java.util.HashMap; public class StringBuilderInsertTest { public static void main(String[] args) { testInsertAPIs() ; } /** * StringBuilder 的insert()示例 */ private static void testInsertAPIs() { System.out.println(&quot;-------------------------------- testInsertAPIs -------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(); // 在位置0处插入字符数组 sbuilder.insert(0, new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}); // 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度 sbuilder.insert(0, new char[]{&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;}, 0, 3); // 在位置0处插入float sbuilder.insert(0, 1.414f); // 在位置0处插入double sbuilder.insert(0, 3.14159d); // 在位置0处插入boolean sbuilder.insert(0, true); // 在位置0处插入char sbuilder.insert(0, &apos;\\n&apos;); // 在位置0处插入int sbuilder.insert(0, 100); // 在位置0处插入long sbuilder.insert(0, 12345L); // 在位置0处插入StringBuilder对象 sbuilder.insert(0, new StringBuilder(&quot;StringBuilder&quot;)); // 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括) sbuilder.insert(0, new StringBuilder(&quot;STRINGBUILDER&quot;), 6, 13); // 在位置0处插入StringBuffer对象。 sbuilder.insert(0, new StringBuffer(&quot;StringBuffer&quot;)); // 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括) sbuilder.insert(0, new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12); // 在位置0处插入String对象。 sbuilder.insert(0, &quot;String&quot;); // 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括) sbuilder.insert(0, &quot;0123456789&quot;, 1, 6); sbuilder.insert(0, &apos;\\n&apos;); // 在位置0处插入Object对象。此处以HashMap为例 HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); sbuilder.insert(0, map); System.out.printf(&quot;%s\\n\\n&quot;, sbuilder); } } 运行结果： -------------------------------- testInsertAPIs ------------------------------- {3=three, 2=two, 1=one} 12345StringBUFFERStringBufferBUILDERStringBuilder12345100 true3.141591.414ABCabcde 2.2 StringBuilder 中追加(append)相关的API源码如下(StringBuilderAppendTest.java): /** * StringBuilder 的append()示例 * * @author skywang */ import java.util.HashMap; public class StringBuilderAppendTest { public static void main(String[] args) { testAppendAPIs() ; } /** * StringBuilder 的append()示例 */ private static void testAppendAPIs() { System.out.println(&quot;-------------------------------- testAppendAPIs -------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(); // 追加字符数组 sbuilder.append(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}); // 追加字符数组。0表示字符数组起始位置，3表示长度 sbuilder.append(new char[]{&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;}, 0, 3); // 追加float sbuilder.append(1.414f); // 追加double sbuilder.append(3.14159d); // 追加boolean sbuilder.append(true); // 追加char sbuilder.append(&apos;\\n&apos;); // 追加int sbuilder.append(100); // 追加long sbuilder.append(12345L); // 追加StringBuilder对象 sbuilder.append(new StringBuilder(&quot;StringBuilder&quot;)); // 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括) sbuilder.append(new StringBuilder(&quot;STRINGBUILDER&quot;), 6, 13); // 追加StringBuffer对象。 sbuilder.append(new StringBuffer(&quot;StringBuffer&quot;)); // 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括) sbuilder.append(new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12); // 追加String对象。 sbuilder.append(&quot;String&quot;); // 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括) sbuilder.append(&quot;0123456789&quot;, 1, 6); sbuilder.append(&apos;\\n&apos;); // 追加Object对象。此处以HashMap为例 HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); sbuilder.append(map); sbuilder.append(&apos;\\n&apos;); // 追加unicode编码 sbuilder.appendCodePoint(0x5b57); // 0x5b57是“字”的unicode编码 sbuilder.appendCodePoint(0x7b26); // 0x7b26是“符”的unicode编码 sbuilder.appendCodePoint(0x7f16); // 0x7f16是“编”的unicode编码 sbuilder.appendCodePoint(0x7801); // 0x7801是“码”的unicode编码 System.out.printf(&quot;%s\\n\\n&quot;, sbuilder); } } 运行结果： -------------------------------- testAppendAPIs ------------------------------- abcdeABC1.4143.14159true 10012345StringBuilderBUILDERStringBufferBUFFERString12345 {3=three, 2=two, 1=one} 字符编码 2.3 StringBuilder 中替换(replace)相关的API源码如下(StringBuilderReplaceTest.java): /** * StringBuilder 的replace()示例 * * @author skywang */ import java.util.HashMap; public class StringBuilderReplaceTest { public static void main(String[] args) { testReplaceAPIs() ; } /** * StringBuilder 的replace()示例 */ private static void testReplaceAPIs() { System.out.println(&quot;-------------------------------- testReplaceAPIs ------------------------------&quot;); StringBuilder sbuilder; sbuilder = new StringBuilder(&quot;0123456789&quot;); sbuilder.replace(0, 3, &quot;ABCDE&quot;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); sbuilder = new StringBuilder(&quot;0123456789&quot;); sbuilder.reverse(); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); sbuilder = new StringBuilder(&quot;0123456789&quot;); sbuilder.setCharAt(0, &apos;M&apos;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); System.out.println(); } } 运行结果： -------------------------------- testReplaceAPIs ------------------------------ sbuilder=ABCDE3456789 sbuilder=9876543210 sbuilder=M123456789 2.4 StringBuilder 中删除(delete)相关的API源码如下(StringBuilderDeleteTest.java): /** * StringBuilder 的delete()示例 * * @author skywang */ import java.util.HashMap; public class StringBuilderDeleteTest { public static void main(String[] args) { testDeleteAPIs() ; } /** * StringBuilder 的delete()示例 */ private static void testDeleteAPIs() { System.out.println(&quot;-------------------------------- testDeleteAPIs -------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(&quot;0123456789&quot;); // 删除位置0的字符，剩余字符是“123456789”。 sbuilder.deleteCharAt(0); // 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。 sbuilder.delete(3,6); // 获取sb中从位置1开始的字符串 String str1 = sbuilder.substring(1); // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串 String str2 = sbuilder.substring(3, 5); // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为String String str3 = (String)sbuilder.subSequence(3, 5); System.out.printf(&quot;sbuilder=%s\\nstr1=%s\\nstr2=%s\\nstr3=%s\\n&quot;, sbuilder, str1, str2, str3); } } 运行结果： -------------------------------- testDeleteAPIs ------------------------------- sbuilder=123789 str1=23789 str2=78 str3=78 2.5 StringBuilder 中index相关的API源码如下(StringBuilderIndexTest.java): /** * StringBuilder 中index相关API演示 * * @author skywang */ import java.util.HashMap; public class StringBuilderIndexTest { public static void main(String[] args) { testIndexAPIs() ; } /** * StringBuilder 中index相关API演示 */ private static void testIndexAPIs() { System.out.println(&quot;-------------------------------- testIndexAPIs --------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(&quot;abcAbcABCabCaBcAbCaBCabc&quot;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); // 1. 从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.indexOf(&quot;bc&quot;)); // 2. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;, 5)&quot;, sbuilder.indexOf(&quot;bc&quot;, 5)); // 3. 从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;)); // 4. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;, 4)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;, 4)); System.out.println(); } } 运行结果： -------------------------------- testIndexAPIs -------------------------------- sbuilder=abcAbcABCabCaBcAbCaBCabc sbuilder.indexOf(&quot;bc&quot;) = 1 sbuilder.indexOf(&quot;bc&quot;, 5) = 22 sbuilder.lastIndexOf(&quot;bc&quot;) = 22 sbuilder.lastIndexOf(&quot;bc&quot;, 4) = 4 2.6 StringBuilder 剩余的API源码如下(StringBuilderOtherTest.java): /** * StringBuilder 的其它API示例 * * @author skywang */ import java.util.HashMap; public class StringBuilderOtherTest { public static void main(String[] args) { testOtherAPIs() ; } /** * StringBuilder 的其它API示例 */ private static void testOtherAPIs() { System.out.println(&quot;-------------------------------- testOtherAPIs --------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(&quot;0123456789&quot;); int cap = sbuilder.capacity(); System.out.printf(&quot;cap=%d\\n&quot;, cap); char c = sbuilder.charAt(6); System.out.printf(&quot;c=%c\\n&quot;, c); char[] carr = new char[4]; sbuilder.getChars(3, 7, carr, 0); for (int i=0; i&lt;carr.length; i++) System.out.printf(&quot;carr[%d]=%c &quot;, i, carr[i]); System.out.println(); System.out.println(); } } 运行结果： -------------------------------- testOtherAPIs -------------------------------- cap=26 c=6 carr[0]=3 carr[1]=4 carr[2]=5 carr[3]=6 3. StringBuilder 完整示例下面的示例是整合上面的几个示例的完整的StringBuilder演示程序，源码如下(StringBuilderTest.java): /** * StringBuilder 演示程序 * * @author skywang */ import java.util.HashMap; public class StringBuilderTest { public static void main(String[] args) { testOtherAPIs() ; testIndexAPIs() ; testInsertAPIs() ; testAppendAPIs() ; testReplaceAPIs() ; testDeleteAPIs() ; } /** * StringBuilder 的其它API示例 */ private static void testOtherAPIs() { System.out.println(&quot;-------------------------------- testOtherAPIs --------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(&quot;0123456789&quot;); int cap = sbuilder.capacity(); System.out.printf(&quot;cap=%d\\n&quot;, cap); char c = sbuilder.charAt(6); System.out.printf(&quot;c=%c\\n&quot;, c); char[] carr = new char[4]; sbuilder.getChars(3, 7, carr, 0); for (int i=0; i&lt;carr.length; i++) System.out.printf(&quot;carr[%d]=%c &quot;, i, carr[i]); System.out.println(); System.out.println(); } /** * StringBuilder 中index相关API演示 */ private static void testIndexAPIs() { System.out.println(&quot;-------------------------------- testIndexAPIs --------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(&quot;abcAbcABCabCaBcAbCaBCabc&quot;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); // 1. 从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.indexOf(&quot;bc&quot;)); // 2. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.indexOf(\\&quot;bc\\&quot;, 5)&quot;, sbuilder.indexOf(&quot;bc&quot;, 5)); // 3. 从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;)); // 4. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;sbuilder.lastIndexOf(\\&quot;bc\\&quot;, 4)&quot;, sbuilder.lastIndexOf(&quot;bc&quot;, 4)); System.out.println(); } /** * StringBuilder 的replace()示例 */ private static void testReplaceAPIs() { System.out.println(&quot;-------------------------------- testReplaceAPIs ------------------------------&quot;); StringBuilder sbuilder; sbuilder = new StringBuilder(&quot;0123456789&quot;); sbuilder.replace(0, 3, &quot;ABCDE&quot;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); sbuilder = new StringBuilder(&quot;0123456789&quot;); sbuilder.reverse(); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); sbuilder = new StringBuilder(&quot;0123456789&quot;); sbuilder.setCharAt(0, &apos;M&apos;); System.out.printf(&quot;sbuilder=%s\\n&quot;, sbuilder); System.out.println(); } /** * StringBuilder 的delete()示例 */ private static void testDeleteAPIs() { System.out.println(&quot;-------------------------------- testDeleteAPIs -------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(&quot;0123456789&quot;); // 删除位置0的字符，剩余字符是“123456789”。 sbuilder.deleteCharAt(0); // 删除位置3(包括)到位置6(不包括)之间的字符，剩余字符是“123789”。 sbuilder.delete(3,6); // 获取sb中从位置1开始的字符串 String str1 = sbuilder.substring(1); // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串 String str2 = sbuilder.substring(3, 5); // 获取sb中从位置3(包括)到位置5(不包括)之间的字符串，获取的对象是CharSequence对象，此处转型为String String str3 = (String)sbuilder.subSequence(3, 5); System.out.printf(&quot;sbuilder=%s\\nstr1=%s\\nstr2=%s\\nstr3=%s\\n&quot;, sbuilder, str1, str2, str3); } /** * StringBuilder 的insert()示例 */ private static void testInsertAPIs() { System.out.println(&quot;-------------------------------- testInsertAPIs -------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(); // 在位置0处插入字符数组 sbuilder.insert(0, new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}); // 在位置0处插入字符数组。0表示字符数组起始位置，3表示长度 sbuilder.insert(0, new char[]{&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;}, 0, 3); // 在位置0处插入float sbuilder.insert(0, 1.414f); // 在位置0处插入double sbuilder.insert(0, 3.14159d); // 在位置0处插入boolean sbuilder.insert(0, true); // 在位置0处插入char sbuilder.insert(0, &apos;\\n&apos;); // 在位置0处插入int sbuilder.insert(0, 100); // 在位置0处插入long sbuilder.insert(0, 12345L); // 在位置0处插入StringBuilder对象 sbuilder.insert(0, new StringBuilder(&quot;StringBuilder&quot;)); // 在位置0处插入StringBuilder对象。6表示被在位置0处插入对象的起始位置(包括)，13是结束位置(不包括) sbuilder.insert(0, new StringBuilder(&quot;STRINGBUILDER&quot;), 6, 13); // 在位置0处插入StringBuffer对象。 sbuilder.insert(0, new StringBuffer(&quot;StringBuffer&quot;)); // 在位置0处插入StringBuffer对象。6表示被在位置0处插入对象的起始位置(包括)，12是结束位置(不包括) sbuilder.insert(0, new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12); // 在位置0处插入String对象。 sbuilder.insert(0, &quot;String&quot;); // 在位置0处插入String对象。1表示被在位置0处插入对象的起始位置(包括)，6是结束位置(不包括) sbuilder.insert(0, &quot;0123456789&quot;, 1, 6); sbuilder.insert(0, &apos;\\n&apos;); // 在位置0处插入Object对象。此处以HashMap为例 HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); sbuilder.insert(0, map); System.out.printf(&quot;%s\\n\\n&quot;, sbuilder); } /** * StringBuilder 的append()示例 */ private static void testAppendAPIs() { System.out.println(&quot;-------------------------------- testAppendAPIs -------------------------------&quot;); StringBuilder sbuilder = new StringBuilder(); // 追加字符数组 sbuilder.append(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}); // 追加字符数组。0表示字符数组起始位置，3表示长度 sbuilder.append(new char[]{&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;}, 0, 3); // 追加float sbuilder.append(1.414f); // 追加double sbuilder.append(3.14159d); // 追加boolean sbuilder.append(true); // 追加char sbuilder.append(&apos;\\n&apos;); // 追加int sbuilder.append(100); // 追加long sbuilder.append(12345L); // 追加StringBuilder对象 sbuilder.append(new StringBuilder(&quot;StringBuilder&quot;)); // 追加StringBuilder对象。6表示被追加对象的起始位置(包括)，13是结束位置(不包括) sbuilder.append(new StringBuilder(&quot;STRINGBUILDER&quot;), 6, 13); // 追加StringBuffer对象。 sbuilder.append(new StringBuffer(&quot;StringBuffer&quot;)); // 追加StringBuffer对象。6表示被追加对象的起始位置(包括)，12是结束位置(不包括) sbuilder.append(new StringBuffer(&quot;STRINGBUFFER&quot;), 6, 12); // 追加String对象。 sbuilder.append(&quot;String&quot;); // 追加String对象。1表示被追加对象的起始位置(包括)，6是结束位置(不包括) sbuilder.append(&quot;0123456789&quot;, 1, 6); sbuilder.append(&apos;\\n&apos;); // 追加Object对象。此处以HashMap为例 HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); sbuilder.append(map); sbuilder.append(&apos;\\n&apos;); // 追加unicode编码 sbuilder.appendCodePoint(0x5b57); // 0x5b57是“字”的unicode编码 sbuilder.appendCodePoint(0x7b26); // 0x7b26是“符”的unicode编码 sbuilder.appendCodePoint(0x7f16); // 0x7f16是“编”的unicode编码 sbuilder.appendCodePoint(0x7801); // 0x7801是“码”的unicode编码 System.out.printf(&quot;%s\\n\\n&quot;, sbuilder); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 字符串系列","slug":"Java-字符串系列","permalink":"https://smuwjs.github.io/tags/Java-字符串系列/"}]},{"title":"Java 字符串系列01 String和CharSequence详解","date":"2017-03-31T16:00:00.000Z","path":"2017/04/01/java-source-analysis-charsequence-series/Java 字符串系列01 String和CharSequence详解/","text":"本章主要介绍String和CharSequence的区别，以及它们的API详细使用方法。 目录1. String 简介2. CharSequence和String源码3. String的API测试代码4. String 完整示例 1. String 简介String 是java中的字符串，它继承于CharSequence。String类所包含的API接口非常多。为了便于今后的使用，我对String的API进行了分类，并都给出的演示程序。 String 和 CharSequence 关系 String 继承于CharSequence，也就是说String也是CharSequence类型。CharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口。除了String实现了CharSequence之外，StringBuffer和StringBuilder也实现了CharSequence接口。需要说明的是，CharSequence就是字符序列，String, StringBuilder和StringBuffer本质上都是通过字符数组实现的！ StringBuilder 和 StringBuffer 的区别 StringBuilder 和 StringBuffer都是可变的字符序列。它们都继承于AbstractStringBuilder，实现了CharSequence接口。但是，StringBuilder是非线程安全的，而StringBuffer是线程安全的。 它们之间的关系图如下： img String 函数列表 public String() public String(String original) public String(char[] value) public String(char[] value, int offset, int count) public String(byte[] bytes) public String(byte[] bytes, int offset, int length) public String(byte[] ascii, int hibyte) public String(byte[] ascii, int hibyte, int offset, int count) public String(byte[] bytes, String charsetName) public String(byte[] bytes, int offset, int length, String charsetName) public String(byte[] bytes, Charset charset) public String(byte[] bytes, int offset, int length, Charset charset) public String(int[] codePoints, int offset, int count) public String(StringBuffer buffer) public String(StringBuilder builder) public char charAt(int index) public int codePointAt(int index) public int codePointBefore(int index) public int codePointCount(int beginIndex, int endIndex) public int compareTo(String anotherString) public int compareToIgnoreCase(String str) public String concat(String str) public boolean contains(CharSequence s) public boolean contentEquals(StringBuffer sb) public boolean contentEquals(CharSequence cs) public static String copyValueOf(char[] data, int offset, int count) public static String copyValueOf(char[] data) public boolean endsWith(String suffix) public boolean equals(Object anObject) public boolean equalsIgnoreCase(String anotherString) public static String format(String format, Object[] args) public static String format(Locale l, String format, Object[] args) public int hashCode() public int indexOf(int ch) public int indexOf(int ch, int fromIndex) public int indexOf(String str) public int indexOf(String str, int fromIndex) public String intern() public int lastIndexOf(int ch) public int lastIndexOf(int ch, int fromIndex) public int lastIndexOf(String str) public int lastIndexOf(String str, int fromIndex) public int length() public boolean matches(String regex) public int offsetByCodePoints(int index, int codePointOffset) public boolean regionMatches(int toffset, String other, int ooffset, int len) public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) public String replace(char oldChar, char newChar) public String replace(CharSequence target, CharSequence replacement) public String replaceAll(String regex, String replacement) public String replaceFirst(String regex, String replacement) public String[] split(String regex, int limit) public String[] split(String regex) public boolean startsWith(String prefix, int toffset) public boolean startsWith(String prefix) public CharSequence subSequence(int beginIndex, int endIndex) public String substring(int beginIndex) public String substring(int beginIndex, int endIndex) public char[] toCharArray() public String toLowerCase(Locale locale) public String toLowerCase() public String toString() public String toUpperCase(Locale locale) public String toUpperCase() public String trim() public static String valueOf(Object obj) public static String valueOf(char[] data) public static String valueOf(char[] data, int offset, int count) public static String valueOf(boolean b) public static String valueOf(char c) public static String valueOf(int i) public static String valueOf(long l) public static String valueOf(float f) public static String valueOf(double d) public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) public byte[] getBytes(String charsetName) public byte[] getBytes(Charset charset) public byte[] getBytes() public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) public boolean isEmpty() 2. CharSequence和String源码2.1 CharSequence源码(基于jdk1.7.40)package java.lang; public interface CharSequence { int length(); char charAt(int index); CharSequence subSequence(int start, int end); public String toString(); } 2.2 String.java源码(基于jdk1.7.40)package java.lang; import java.io.ObjectStreamField; import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Formatter; import java.util.Locale; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException; public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { private final char value[]; private int hash; private static final long serialVersionUID = -6849794470754667710L; private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; public String() { this.value = new char[0]; } public String(String original) { this.value = original.value; this.hash = original.hash; } public String(char value[]) { this.value = Arrays.copyOf(value, value.length); } public String(char value[], int offset, int count) { if (offset &lt; 0) { throw new StringIndexOutOfBoundsException(offset); } if (count &lt; 0) { throw new StringIndexOutOfBoundsException(count); } // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = Arrays.copyOfRange(value, offset, offset+count); } public String(int[] codePoints, int offset, int count) { if (offset &lt; 0) { throw new StringIndexOutOfBoundsException(offset); } if (count &lt; 0) { throw new StringIndexOutOfBoundsException(count); } // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) { int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); } // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) { int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); } this.value = v; } @Deprecated public String(byte ascii[], int hibyte, int offset, int count) { checkBounds(ascii, offset, count); char value[] = new char[count]; if (hibyte == 0) { for (int i = count; i-- &gt; 0;) { value[i] = (char)(ascii[i + offset] &amp; 0xff); } } else { hibyte &lt;&lt;= 8; for (int i = count; i-- &gt; 0;) { value[i] = (char)(hibyte | (ascii[i + offset] &amp; 0xff)); } } this.value = value; } @Deprecated public String(byte ascii[], int hibyte) { this(ascii, hibyte, 0, ascii.length); } private static void checkBounds(byte[] bytes, int offset, int length) { if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); } public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException { if (charsetName == null) throw new NullPointerException(&quot;charsetName&quot;); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length); } public String(byte bytes[], int offset, int length, Charset charset) { if (charset == null) throw new NullPointerException(&quot;charset&quot;); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length); } public String(byte bytes[], String charsetName) throws UnsupportedEncodingException { this(bytes, 0, bytes.length, charsetName); } public String(byte bytes[], Charset charset) { this(bytes, 0, bytes.length, charset); } public String(byte bytes[], int offset, int length) { checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length); } public String(byte bytes[]) { this(bytes, 0, bytes.length); } public String(StringBuffer buffer) { synchronized(buffer) { this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); } } public String(StringBuilder builder) { this.value = Arrays.copyOf(builder.getValue(), builder.length()); } String(char[] value, boolean share) { // assert share : &quot;unshared not supported&quot;; this.value = value; } @Deprecated String(int offset, int count, char[] value) { this(value, offset, count); } public int length() { return value.length; } public boolean isEmpty() { return value.length == 0; } public char charAt(int index) { if ((index &lt; 0) || (index &gt;= value.length)) { throw new StringIndexOutOfBoundsException(index); } return value[index]; } public int codePointAt(int index) { if ((index &lt; 0) || (index &gt;= value.length)) { throw new StringIndexOutOfBoundsException(index); } return Character.codePointAtImpl(value, index, value.length); } public int codePointBefore(int index) { int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) { throw new StringIndexOutOfBoundsException(index); } return Character.codePointBeforeImpl(value, index, 0); } public int codePointCount(int beginIndex, int endIndex) { if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) { throw new IndexOutOfBoundsException(); } return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex); } public int offsetByCodePoints(int index, int codePointOffset) { if (index &lt; 0 || index &gt; value.length) { throw new IndexOutOfBoundsException(); } return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset); } void getChars(char dst[], int dstBegin) { System.arraycopy(value, 0, dst, dstBegin, value.length); } public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) { if (srcBegin &lt; 0) { throw new StringIndexOutOfBoundsException(srcBegin); } if (srcEnd &gt; value.length) { throw new StringIndexOutOfBoundsException(srcEnd); } if (srcBegin &gt; srcEnd) { throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); } System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); } @Deprecated public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) { if (srcBegin &lt; 0) { throw new StringIndexOutOfBoundsException(srcBegin); } if (srcEnd &gt; value.length) { throw new StringIndexOutOfBoundsException(srcEnd); } if (srcBegin &gt; srcEnd) { throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); } int j = dstBegin; int n = srcEnd; int i = srcBegin; char[] val = value; /* avoid getfield opcode */ while (i &lt; n) { dst[j++] = (byte)val[i++]; } } public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length); } public byte[] getBytes(Charset charset) { if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length); } public byte[] getBytes() { return StringCoding.encode(value, 0, value.length); } public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } public boolean contentEquals(StringBuffer sb) { synchronized (sb) { return contentEquals((CharSequence) sb); } } public boolean contentEquals(CharSequence cs) { if (value.length != cs.length()) return false; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) { char v1[] = value; char v2[] = ((AbstractStringBuilder) cs).getValue(); int i = 0; int n = value.length; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } // Argument is a String if (cs.equals(this)) return true; // Argument is a generic CharSequence char v1[] = value; int i = 0; int n = value.length; while (n-- != 0) { if (v1[i] != cs.charAt(i)) return false; i++; } return true; } public boolean equalsIgnoreCase(String anotherString) { return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); } public int compareTo(String anotherString) { int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) { char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) { return c1 - c2; } k++; } return len1 - len2; } public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable { // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) { int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) { char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) { c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) { c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) { // No overflow because of numeric promotion return c1 - c2; } } } } return n1 - n2; } } public int compareToIgnoreCase(String str) { return CASE_INSENSITIVE_ORDER.compare(this, str); } public boolean regionMatches(int toffset, String other, int ooffset, int len) { char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) { return false; } while (len-- &gt; 0) { if (ta[to++] != pa[po++]) { return false; } } return true; } public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) { char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) { return false; } while (len-- &gt; 0) { char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) { continue; } if (ignoreCase) { // If characters don&apos;t match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) { continue; } // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) { continue; } } return false; } return true; } public boolean startsWith(String prefix, int toffset) { char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) { return false; } while (--pc &gt;= 0) { if (ta[to++] != pa[po++]) { return false; } } return true; } public boolean startsWith(String prefix) { return startsWith(prefix, 0); } public boolean endsWith(String suffix) { return startsWith(suffix, value.length - suffix.value.length); } public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } public int indexOf(int ch) { return indexOf(ch, 0); } public int indexOf(int ch, int fromIndex) { final int max = value.length; if (fromIndex &lt; 0) { fromIndex = 0; } else if (fromIndex &gt;= max) { // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; } if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) { // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; for (int i = fromIndex; i &lt; max; i++) { if (value[i] == ch) { return i; } } return -1; } else { return indexOfSupplementary(ch, fromIndex); } } private int indexOfSupplementary(int ch, int fromIndex) { if (Character.isValidCodePoint(ch)) { final char[] value = this.value; final char hi = Character.highSurrogate(ch); final char lo = Character.lowSurrogate(ch); final int max = value.length - 1; for (int i = fromIndex; i &lt; max; i++) { if (value[i] == hi &amp;&amp; value[i + 1] == lo) { return i; } } } return -1; } public int lastIndexOf(int ch) { return lastIndexOf(ch, value.length - 1); } public int lastIndexOf(int ch, int fromIndex) { if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) { // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) { if (value[i] == ch) { return i; } } return -1; } else { return lastIndexOfSupplementary(ch, fromIndex); } } private int lastIndexOfSupplementary(int ch, int fromIndex) { if (Character.isValidCodePoint(ch)) { final char[] value = this.value; char hi = Character.highSurrogate(ch); char lo = Character.lowSurrogate(ch); int i = Math.min(fromIndex, value.length - 2); for (; i &gt;= 0; i--) { if (value[i] == hi &amp;&amp; value[i + 1] == lo) { return i; } } } return -1; } public int indexOf(String str) { return indexOf(str, 0); } public int indexOf(String str, int fromIndex) { return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); } static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex &gt;= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } if (fromIndex &lt; 0) { fromIndex = 0; } if (targetCount == 0) { return fromIndex; } char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) { /* Look for first character. */ if (source[i] != first) { while (++i &lt;= max &amp;&amp; source[i] != first); } /* Found first character, now look at the rest of v2 */ if (i &lt;= max) { int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) { /* Found whole string. */ return i - sourceOffset; } } } return -1; } public int lastIndexOf(String str) { return lastIndexOf(str, value.length); } public int lastIndexOf(String str, int fromIndex) { return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); } static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { /* * Check arguments; return immediately where possible. For * consistency, don&apos;t check for null str. */ int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) { return -1; } if (fromIndex &gt; rightIndex) { fromIndex = rightIndex; } /* Empty string always matches. */ if (targetCount == 0) { return fromIndex; } int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex; startSearchForLastChar: while (true) { while (i &gt;= min &amp;&amp; source[i] != strLastChar) { i--; } if (i &lt; min) { return -1; } int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) { if (source[j--] != target[k--]) { i--; continue startSearchForLastChar; } } return start - sourceOffset + 1; } } public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); } public String substring(int beginIndex, int endIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex &gt; value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); } public CharSequence subSequence(int beginIndex, int endIndex) { return this.substring(beginIndex, endIndex); } public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); } public String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) { if (val[i] == oldChar) { break; } } if (i &lt; len) { char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) { buf[j] = val[j]; } while (i &lt; len) { char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; } return new String(buf, true); } } return this; } public boolean matches(String regex) { return Pattern.matches(regex, this); } public boolean contains(CharSequence s) { return indexOf(s.toString()) &gt; -1; } public String replaceFirst(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceFirst(replacement); } public String replaceAll(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceAll(replacement); } public String replace(CharSequence target, CharSequence replacement) { return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString())); } public String[] split(String regex, int limit) { /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx&apos;s meta characters &quot;.$|()[{^?*+\\\\&quot;, or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; &quot;.$|()[{^?*+\\\\&quot;.indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == &apos;\\\\&apos; &amp;&amp; (((ch = regex.charAt(1))-&apos;0&apos;)|(&apos;9&apos;-ch)) &lt; 0 &amp;&amp; ((ch-&apos;a&apos;)|(&apos;z&apos;-ch)) &lt; 0 &amp;&amp; ((ch-&apos;A&apos;)|(&apos;Z&apos;-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) { int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) { if (!limited || list.size() &lt; limit - 1) { list.add(substring(off, next)); off = next + 1; } else { // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; } } // If no match was found, return this if (off == 0) return new String[]{this}; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) resultSize--; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); } return Pattern.compile(regex).split(this, limit); } public String[] split(String regex) { return split(regex, 0); } public String toLowerCase(Locale locale) { if (locale == null) { throw new NullPointerException(); } int firstUpper; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: { for (firstUpper = 0 ; firstUpper &lt; len; ) { char c = value[firstUpper]; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) { int supplChar = codePointAt(firstUpper); if (supplChar != Character.toLowerCase(supplChar)) { break scan; } firstUpper += Character.charCount(supplChar); } else { if (c != Character.toLowerCase(c)) { break scan; } firstUpper++; } } return this; } char[] result = new char[len]; int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few lowerCase characters. */ System.arraycopy(value, 0, result, 0, firstUpper); String lang = locale.getLanguage(); boolean localeDependent = (lang == &quot;tr&quot; || lang == &quot;az&quot; || lang == &quot;lt&quot;); char[] lowerCharArray; int lowerChar; int srcChar; int srcCount; for (int i = firstUpper; i &lt; len; i += srcCount) { srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) { srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); } else { srcCount = 1; } if (localeDependent || srcChar == &apos;\\u03A3&apos;) { // GREEK CAPITAL LETTER SIGMA lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale); } else if (srcChar == &apos;\\u0130&apos;) { // LATIN CAPITAL LETTER I DOT lowerChar = Character.ERROR; } else { lowerChar = Character.toLowerCase(srcChar); } if ((lowerChar == Character.ERROR) || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) { if (lowerChar == Character.ERROR) { if (!localeDependent &amp;&amp; srcChar == &apos;\\u0130&apos;) { lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, Locale.ENGLISH); } else { lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale); } } else if (srcCount == 2) { resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount; continue; } else { lowerCharArray = Character.toChars(lowerChar); } /* Grow result if needed */ int mapLen = lowerCharArray.length; if (mapLen &gt; srcCount) { char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; } for (int x = 0; x &lt; mapLen; ++x) { result[i + resultOffset + x] = lowerCharArray[x]; } resultOffset += (mapLen - srcCount); } else { result[i + resultOffset] = (char)lowerChar; } } return new String(result, 0, len + resultOffset); } public String toLowerCase() { return toLowerCase(Locale.getDefault()); } public String toUpperCase(Locale locale) { if (locale == null) { throw new NullPointerException(); } int firstLower; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: { for (firstLower = 0 ; firstLower &lt; len; ) { int c = (int)value[firstLower]; int srcCount; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) { c = codePointAt(firstLower); srcCount = Character.charCount(c); } else { srcCount = 1; } int upperCaseChar = Character.toUpperCaseEx(c); if ((upperCaseChar == Character.ERROR) || (c != upperCaseChar)) { break scan; } firstLower += srcCount; } return this; } char[] result = new char[len]; /* may grow */ int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few upperCase characters. */ System.arraycopy(value, 0, result, 0, firstLower); String lang = locale.getLanguage(); boolean localeDependent = (lang == &quot;tr&quot; || lang == &quot;az&quot; || lang == &quot;lt&quot;); char[] upperCharArray; int upperChar; int srcChar; int srcCount; for (int i = firstLower; i &lt; len; i += srcCount) { srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) { srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); } else { srcCount = 1; } if (localeDependent) { upperChar = ConditionalSpecialCasing.toUpperCaseEx(this, i, locale); } else { upperChar = Character.toUpperCaseEx(srcChar); } if ((upperChar == Character.ERROR) || (upperChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) { if (upperChar == Character.ERROR) { if (localeDependent) { upperCharArray = ConditionalSpecialCasing.toUpperCaseCharArray(this, i, locale); } else { upperCharArray = Character.toUpperCaseCharArray(srcChar); } } else if (srcCount == 2) { resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount; continue; } else { upperCharArray = Character.toChars(upperChar); } /* Grow result if needed */ int mapLen = upperCharArray.length; if (mapLen &gt; srcCount) { char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; } for (int x = 0; x &lt; mapLen; ++x) { result[i + resultOffset + x] = upperCharArray[x]; } resultOffset += (mapLen - srcCount); } else { result[i + resultOffset] = (char)upperChar; } } return new String(result, 0, len + resultOffset); } public String toUpperCase() { return toUpperCase(Locale.getDefault()); } public String trim() { int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= &apos; &apos;)) { st++; } while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &apos; &apos;)) { len--; } return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; } public String toString() { return this; } public char[] toCharArray() { // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; } public static String format(String format, Object... args) { return new Formatter().format(format, args).toString(); } public static String format(Locale l, String format, Object... args) { return new Formatter(l).format(format, args).toString(); } public static String valueOf(Object obj) { return (obj == null) ? &quot;null&quot; : obj.toString(); } public static String valueOf(char data[]) { return new String(data); } public static String valueOf(char data[], int offset, int count) { return new String(data, offset, count); } public static String copyValueOf(char data[], int offset, int count) { // All public String constructors now copy the data. return new String(data, offset, count); } public static String copyValueOf(char data[]) { return new String(data); } public static String valueOf(boolean b) { return b ? &quot;true&quot; : &quot;false&quot;; } public static String valueOf(char c) { char data[] = {c}; return new String(data, true); } public static String valueOf(int i) { return Integer.toString(i); } public static String valueOf(long l) { return Long.toString(l); } public static String valueOf(float f) { return Float.toString(f); } public static String valueOf(double d) { return Double.toString(d); } public native String intern(); private static final int HASHING_SEED; static { long nanos = System.nanoTime(); long now = System.currentTimeMillis(); int SEED_MATERIAL[] = { System.identityHashCode(String.class), System.identityHashCode(System.class), (int) (nanos &gt;&gt;&gt; 32), (int) nanos, (int) (now &gt;&gt;&gt; 32), (int) now, (int) (System.nanoTime() &gt;&gt;&gt; 2) }; // Use murmur3 to scramble the seeding material. // Inline implementation to avoid loading classes int h1 = 0; // body for (int k1 : SEED_MATERIAL) { k1 *= 0xcc9e2d51; k1 = (k1 &lt;&lt; 15) | (k1 &gt;&gt;&gt; 17); k1 *= 0x1b873593; h1 ^= k1; h1 = (h1 &lt;&lt; 13) | (h1 &gt;&gt;&gt; 19); h1 = h1 * 5 + 0xe6546b64; } // tail (always empty, as body is always 32-bit chunks) // finalization h1 ^= SEED_MATERIAL.length * 4; // finalization mix force all bits of a hash block to avalanche h1 ^= h1 &gt;&gt;&gt; 16; h1 *= 0x85ebca6b; h1 ^= h1 &gt;&gt;&gt; 13; h1 *= 0xc2b2ae35; h1 ^= h1 &gt;&gt;&gt; 16; HASHING_SEED = h1; } private transient int hash32 = 0; int hash32() { int h = hash32; if (0 == h) { // harmless data race on hash32 here. h = sun.misc.Hashing.murmur3_32(HASHING_SEED, value, 0, value.length); // ensure result is not zero to avoid recalcing h = (0 != h) ? h : 1; hash32 = h; } return h; } } 说明：String的本质是字符序列，它是通过字符数组实现的！ 3. String的API测试代码3.1 CharSequence下面通过示例，演示CharSequence的使用方法！源码如下(CharSequenceTest.java): /** * CharSequence 演示程序 * * @author skywang */ import java.nio.charset.Charset; import java.io.UnsupportedEncodingException; public class CharSequenceTest { public static void main(String[] args) { testCharSequence(); } /** * CharSequence 测试程序 */ private static void testCharSequence() { System.out.println(&quot;-------------------------------- testCharSequence -----------------------------&quot;); // 1. CharSequence的子类String String str = &quot;abcdefghijklmnopqrstuvwxyz&quot;; System.out.println(&quot;1. String&quot;); System.out.printf(&quot; %-30s=%d\\n&quot;, &quot;str.length()&quot;, str.length()); System.out.printf(&quot; %-30s=%c\\n&quot;, &quot;str.charAt(5)&quot;, str.charAt(5)); String substr = (String)str.subSequence(0,5); System.out.printf(&quot; %-30s=%s\\n&quot;, &quot;str.subSequence(0,5)&quot;, substr.toString()); // 2. CharSequence的子类StringBuilder StringBuilder strbuilder = new StringBuilder(&quot;abcdefghijklmnopqrstuvwxyz&quot;); System.out.println(&quot;2. StringBuilder&quot;); System.out.printf(&quot; %-30s=%d\\n&quot;, &quot;strbuilder.length()&quot;, strbuilder.length()); System.out.printf(&quot; %-30s=%c\\n&quot;, &quot;strbuilder.charAt(5)&quot;, strbuilder.charAt(5)); // 注意：StringBuilder的subSequence()返回的是，实际上是一个String对象！ String substrbuilder = (String)strbuilder.subSequence(0,5); System.out.printf(&quot; %-30s=%s\\n&quot;, &quot;strbuilder.subSequence(0,5)&quot;, substrbuilder.toString()); // 3. CharSequence的子类StringBuffer StringBuffer strbuffer = new StringBuffer(&quot;abcdefghijklmnopqrstuvwxyz&quot;); System.out.println(&quot;3. StringBuffer&quot;); System.out.printf(&quot; %-30s=%d\\n&quot;, &quot;strbuffer.length()&quot;, strbuffer.length()); System.out.printf(&quot; %-30s=%c\\n&quot;, &quot;strbuffer.charAt(5)&quot;, strbuffer.charAt(5)); // 注意：StringBuffer的subSequence()返回的是，实际上是一个String对象！ String substrbuffer = (String)strbuffer.subSequence(0,5); System.out.printf(&quot; %-30s=%s\\n&quot;, &quot;strbuffer.subSequence(0,5)&quot;, substrbuffer.toString()); System.out.println(); } } 运行结果： -------------------------------- testCharSequence ----------------------------- 1. String str.length() =26 str.charAt(5) =f str.subSequence(0,5) =abcde 2. StringBuilder strbuilder.length() =26 strbuilder.charAt(5) =f strbuilder.subSequence(0,5) =abcde 3. StringBuffer strbuffer.length() =26 strbuffer.charAt(5) =f strbuffer.subSequence(0,5) =abcde 3.2 String 构造函数下面通过示例，演示String的各种构造函数的使用方法！源码如下(StringContructorTest.java): /** * String 构造函数演示程序 * * @author skywang */ import java.nio.charset.Charset; import java.io.UnsupportedEncodingException; public class StringContructorTest { public static void main(String[] args) { testStringConstructors() ; } /** * String 构造函数测试程序 */ private static void testStringConstructors() { try { System.out.println(&quot;-------------------------------- testStringConstructors -----------------------&quot;); String str01 = new String(); String str02 = new String(&quot;String02&quot;); String str03 = new String(new char[]{&apos;s&apos;,&apos;t&apos;,&apos;r&apos;,&apos;0&apos;,&apos;3&apos;}); String str04 = new String(new char[]{&apos;s&apos;,&apos;t&apos;,&apos;r&apos;,&apos;0&apos;,&apos;4&apos;}, 1, 3); // 1表示起始位置，3表示个数 String str05 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}); // 0x61在ASC表中，对应字符&quot;a&quot;; 1表示起始位置，3表示长度 String str06 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}, 1, 3); // 0x61在ASC表中，对应字符&quot;a&quot;; 1表示起始位置，3表示长度 String str07 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}, 0); // 0x61在ASC表中，对应字符&quot;a&quot;;0，表示“高字节” String str08 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}, 0, 1, 3); // 0x61在ASC表中，对应字符&quot;a&quot;; 0，表示“高字节”；1表示起始位置，3表示长度 String str09 = new String(new byte[]{(byte)0xe5, (byte)0xad, (byte)0x97, /* 字-对应的utf-8编码 */ (byte)0xe7, (byte)0xac, (byte)0xa6, /* 符-对应的utf-8编码 */ (byte)0xe7, (byte)0xbc, (byte)0x96, /* 编-对应的utf-8编码 */ (byte)0xe7, (byte)0xa0, (byte)0x81, /* 码-对应的utf-8编码 */ }, 0, 12, &quot;utf-8&quot;); // 0表示起始位置，12表示长度。 String str10 = new String(new byte[]{(byte)0x5b, (byte)0x57, /* 字-对应的utf-16编码 */ (byte)0x7b, (byte)0x26, /* 符-对应的utf-16编码 */ (byte)0x7f, (byte)0x16, /* 编-对应的utf-16编码 */ (byte)0x78, (byte)0x01, /* 码-对应的utf-16编码 */ }, 0, 8, &quot;utf-16&quot;); // 0表示起始位置，8表示长度。 String str11 = new String(new byte[]{(byte)0xd7, (byte)0xd6, /* 字-对应的gb2312编码 */ (byte)0xb7, (byte)0xfb, /* 符-对应的gb2312编码 */ (byte)0xb1, (byte)0xe0, /* 编-对应的gb2312编码 */ (byte)0xc2, (byte)0xeb, /* 码-对应的gb2312编码 */ }, Charset.forName(&quot;gb2312&quot;)); String str12 = new String(new byte[]{(byte)0xd7, (byte)0xd6, /* 字-对应的gbk编码 */ (byte)0xb7, (byte)0xfb, /* 符-对应的gbk编码 */ (byte)0xb1, (byte)0xe0, /* 编-对应的gbk编码 */ (byte)0xc2, (byte)0xeb, /* 码-对应的gbk编码 */ }, 0, 8, Charset.forName(&quot;gbk&quot;)); String str13 = new String(new int[] {0x5b57, 0x7b26, 0x7f16, 0x7801}, 0, 4); // &quot;字符编码&quot;(\\u5b57是‘字’的unicode编码)。0表示起始位置，4表示长度。 String str14 = new String(new StringBuffer(&quot;StringBuffer&quot;)); String str15 = new String(new StringBuilder(&quot;StringBuilder&quot;)); System.out.printf(&quot; str01=%s \\n str02=%s \\n str03=%s \\n str04=%s \\n str05=%s \\n str06=%s \\n str07=%s \\n str08=%s\\n str09=%s\\n str10=%s\\n str11=%s\\n str12=%s\\n str13=%s\\n str14=%s\\n str15=%s\\n&quot;, str01, str02, str03, str04, str05, str06, str07, str08, str09, str10, str11, str12, str13, str14, str15); System.out.println(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } 运行结果： -------------------------------- testStringConstructors ----------------------- str01= str02=String02 str03=str03 str04=tr0 str05=abcde str06=bcd str07=abcde str08=bcd str09=字符编码 str10=字符编码 str11=字符编码 str12=字符编码 str13=字符编码 str14=StringBuffer str15=StringBuilder 3.3 String 将各种对象转换成String的API源码如下(StringValueTest.java): /** * String value相关示例 * * @author skywang */ import java.util.HashMap; public class StringValueTest { public static void main(String[] args) { testValueAPIs() ; } /** * String 的valueOf()演示程序 */ private static void testValueAPIs() { System.out.println(&quot;-------------------------------- testValueAPIs --------------------------------&quot;); // 1. String valueOf(Object obj) // 实际上，返回的是obj.toString(); HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(map)&quot;, String.valueOf(map)); // 2.String valueOf(boolean b) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(true)&quot;, String.valueOf(true)); // 3.String valueOf(char c) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(&apos;m&apos;)&quot;, String.valueOf(&apos;m&apos;)); // 4.String valueOf(int i) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(96)&quot;, String.valueOf(96)); // 5.String valueOf(long l) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(12345L)&quot;, String.valueOf(12345L)); // 6.String valueOf(float f) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(1.414f)&quot;, String.valueOf(1.414f)); // 7.String valueOf(double d) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(3.14159d)&quot;, String.valueOf(3.14159d)); // 8.String valueOf(char[] data) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;})&quot;, String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;})); // 9.String valueOf(char[] data, int offset, int count) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;}, 0, 2)&quot;, String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;}, 0, 2)); System.out.println(); } } 运行结果： -------------------------------- testValueAPIs -------------------------------- String.valueOf(map) = {3=three, 2=two, 1=one} String.valueOf(true) = true String.valueOf(&apos;m&apos;) = m String.valueOf(96) = 96 String.valueOf(12345L) = 12345 String.valueOf(1.414f) = 1.414 String.valueOf(3.14159d) = 3.14159 String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;}) = sky String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;}, 0, 2) = sk 3.4 String 中index相关的API源码如下(StringIndexTest.java): /** * String 中index相关API演示 * * @author skywang */ public class StringIndexTest { public static void main(String[] args) { testIndexAPIs() ; } /** * String 中index相关API演示 */ private static void testIndexAPIs() { System.out.println(&quot;-------------------------------- testIndexAPIs --------------------------------&quot;); String istr = &quot;abcAbcABCabCaBcAbCaBCabc&quot;; System.out.printf(&quot;istr=%s\\n&quot;, istr); // 1. 从前往后，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf((int)&apos;a&apos;)&quot;, istr.indexOf((int)&apos;a&apos;)); // 2. 从位置5开始，从前往后，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf((int)&apos;a&apos;, 5)&quot;, istr.indexOf((int)&apos;a&apos;, 5)); // 3. 从后往前，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf((int)&apos;a&apos;)&quot;, istr.lastIndexOf((int)&apos;a&apos;)); // 4. 从位置10开始，从后往前，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf((int)&apos;a&apos;, 10)&quot;, istr.lastIndexOf((int)&apos;a&apos;, 10)); // 5. 从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf(\\&quot;bc\\&quot;)&quot;, istr.indexOf(&quot;bc&quot;)); // 6. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf(\\&quot;bc\\&quot;, 5)&quot;, istr.indexOf(&quot;bc&quot;, 5)); // 7. 从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf(\\&quot;bc\\&quot;)&quot;, istr.lastIndexOf(&quot;bc&quot;)); // 8. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf(\\&quot;bc\\&quot;, 4)&quot;, istr.lastIndexOf(&quot;bc&quot;, 4)); System.out.println(); } } 运行结果： -------------------------------- testIndexAPIs -------------------------------- istr=abcAbcABCabCaBcAbCaBCabc istr.indexOf((int)&apos;a&apos;) = 0 istr.indexOf((int)&apos;a&apos;, 5) = 9 istr.lastIndexOf((int)&apos;a&apos;) = 21 istr.lastIndexOf((int)&apos;a&apos;, 10) = 9 istr.indexOf(&quot;bc&quot;) = 1 istr.indexOf(&quot;bc&quot;, 5) = 22 istr.lastIndexOf(&quot;bc&quot;) = 22 istr.lastIndexOf(&quot;bc&quot;, 4) = 4 3.5 String “比较”操作的API源码如下(StringCompareTest.java): /** * String 中比较相关API演示 * * @author skywang */ public class StringCompareTest { public static void main(String[] args) { testCompareAPIs() ; } /** * String 中比较相关API演示 */ private static void testCompareAPIs() { System.out.println(&quot;-------------------------------- testCompareAPIs ------------------------------&quot;); //String str = &quot;abcdefghijklmnopqrstuvwxyz&quot;; String str = &quot;abcAbcABCabCAbCabc&quot;; System.out.printf(&quot;str=%s\\n&quot;, str); // 1. 比较“2个String是否相等” System.out.printf(&quot;%-50s = %b\\n&quot;, &quot;str.equals(\\&quot;abcAbcABCabCAbCabc\\&quot;)&quot;, str.equals(&quot;abcAbcABCabCAbCabc&quot;)); // 2. 比较“2个String是否相等(忽略大小写)” System.out.printf(&quot;%-50s = %b\\n&quot;, &quot;str.equalsIgnoreCase(\\&quot;ABCABCABCABCABCABC\\&quot;)&quot;, str.equalsIgnoreCase(&quot;ABCABCABCABCABCABC&quot;)); // 3. 比较“2个String的大小” System.out.printf(&quot;%-40s = %d\\n&quot;, &quot;str.compareTo(\\&quot;abce\\&quot;)&quot;, str.compareTo(&quot;abce&quot;)); // 4. 比较“2个String的大小(忽略大小写)” System.out.printf(&quot;%-40s = %d\\n&quot;, &quot;str.compareToIgnoreCase(\\&quot;ABC\\&quot;)&quot;, str.compareToIgnoreCase(&quot;ABC&quot;)); // 5. 字符串的开头是不是&quot;ab&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.startsWith(\\&quot;ab\\&quot;)&quot;, str.startsWith(&quot;ab&quot;)); // 6. 字符串的从位置3开头是不是&quot;ab&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.startsWith(\\&quot;Ab\\&quot;)&quot;, str.startsWith(&quot;Ab&quot;, 3)); // 7. 字符串的结尾是不是&quot;bc&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.endsWith(\\&quot;bc\\&quot;)&quot;, str.endsWith(&quot;bc&quot;)); // 8. 字符串的是不是包含&quot;ABC&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.contains(\\&quot;ABC\\&quot;)&quot;, str.contains(&quot;ABC&quot;)); // 9. 比较2个字符串的部分内容 String region1 = str.substring(2, str.length()); // 获取str位置3(包括)到末尾(不包括)的子字符串 // 将“str中从位置2开始的字符串”和“region1中位置0开始的字符串”进行比较，比较长度是5。 System.out.printf(&quot;regionMatches(%s) = %b\\n&quot;, region1, str.regionMatches(2, region1, 0, 5)); // 10. 比较2个字符串的部分内容(忽略大小写) String region2 = region1.toUpperCase(); // 将region1转换为大写 String region3 = region1.toLowerCase(); // 将region1转换为小写 System.out.printf(&quot;regionMatches(%s) = %b\\n&quot;, region2, str.regionMatches(2, region2, 0, 5)); System.out.printf(&quot;regionMatches(%s) = %b\\n&quot;, region3, str.regionMatches(2, region3, 0, 5)); // 11. 比较“String”和“StringBuffer”的内容是否相等 System.out.printf(&quot;%-60s = %b\\n&quot;, &quot;str.contentEquals(new StringBuffer(\\&quot;abcAbcABCabCAbCabc\\&quot;))&quot;, str.contentEquals(new StringBuffer(&quot;abcAbcABCabCAbCabc&quot;))); // 12. 比较“String”和“StringBuilder”的内容是否相等 System.out.printf(&quot;%-60s = %b\\n&quot;, &quot;str.contentEquals(new StringBuilder(\\&quot;abcAbcABCabCAbCabc\\&quot;))&quot;, str.contentEquals(new StringBuilder(&quot;abcAbcABCabCAbCabc&quot;))); // 13. match()测试程序 // 正则表达式 xxx.xxx.xxx.xxx，其中xxx中x的取值可以是0～9，xxx中有1～3位。 String reg_ipv4 = &quot;[0-9]{3}(\\\\.[0-9]{1,3}){3}&quot;; String ipv4addr1 = &quot;192.168.1.102&quot;; String ipv4addr2 = &quot;192.168&quot;; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;ipv4addr1.matches()&quot;, ipv4addr1.matches(reg_ipv4)); System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;ipv4addr2.matches()&quot;, ipv4addr2.matches(reg_ipv4)); System.out.println(); } } 运行结果： -------------------------------- testCompareAPIs ------------------------------ str=abcAbcABCabCAbCabc str.equals(&quot;abcAbcABCabCAbCabc&quot;) = true str.equalsIgnoreCase(&quot;ABCABCABCABCABCABC&quot;) = true str.compareTo(&quot;abce&quot;) = -36 str.compareToIgnoreCase(&quot;ABC&quot;) = 15 str.startsWith(&quot;ab&quot;) = true str.startsWith(&quot;Ab&quot;) = true str.endsWith(&quot;bc&quot;) = true str.contains(&quot;ABC&quot;) = true regionMatches(cAbcABCabCAbCabc) = true regionMatches(CABCABCABCABCABC) = false regionMatches(cabcabcabcabcabc) = false str.contentEquals(new StringBuffer(&quot;abcAbcABCabCAbCabc&quot;)) = true str.contentEquals(new StringBuilder(&quot;abcAbcABCabCAbCabc&quot;)) = true ipv4addr1.matches() = true ipv4addr2.matches() = false 3.6 String “修改(追加/替换/截取/分割)”操作的API源码如下(StringModifyTest.java): /** * String 中 修改(追加/替换/截取/分割)字符串的相关API演示 * * @author skywang */ public class StringModifyTest { public static void main(String[] args) { testModifyAPIs() ; } /** * String 中 修改(追加/替换/截取/分割)字符串的相关API演示 */ private static void testModifyAPIs() { System.out.println(&quot;-------------------------------- testModifyAPIs -------------------------------&quot;); String str = &quot; abcAbcABCabCAbCabc &quot;; System.out.printf(&quot;str=%s, len=%d\\n&quot;, str, str.length()); // 1.追加 // 将&quot;123&quot;追加到str之后 System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.concat(\\&quot;123\\&quot;)&quot;, str.concat(&quot;123&quot;)); // 2.截取 // 截取str中从位置7(包括)开始的元素。 System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.substring(7)&quot;, str.substring(7)); // 截取str中从位置7(包括)到位置10(不包括)之间的元素。 System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.substring(7, 10)&quot;, str.substring(7, 10)); // 删除str中首位的空格，并返回。 System.out.printf(&quot;%-30s = %s, len=%d\\n&quot;, &quot;str.trim()&quot;, str.trim(), str.trim().length()); // 3.替换 // 将str中的 “字符‘a’” 全部替换为 “字符‘_’” System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.replace(&apos;a&apos;, &apos;M&apos;)&quot;, str.replace(&apos;a&apos;, &apos;_&apos;)); // 将str中的第一次出现的“字符串“a”” 替换为 “字符串“###”” System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.replaceFirst(\\&quot;a\\&quot;, \\&quot;###\\&quot;)&quot;, str.replaceFirst(&quot;a&quot;, &quot;###&quot;)); // 将str中的 “字符串“a”” 全部替换为 “字符串“$$$”” System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.replace(\\&quot;a\\&quot;, \\&quot;$$$\\&quot;)&quot;, str.replace(&quot;a&quot;, &quot;$$$&quot;)); // 4.分割 // 以“b”作为分隔符，对str进行分割 String[] splits = str.split(&quot;b&quot;); for (int i=0; i&lt;splits.length; i++) { System.out.printf(&quot;splits[%d]=%s\\n&quot;, i, splits[i]); } System.out.println(); } } 运行结果： -------------------------------- testModifyAPIs ------------------------------- str= abcAbcABCabCAbCabc , len=20 str.concat(&quot;123&quot;) = abcAbcABCabCAbCabc 123 str.substring(7) = ABCabCAbCabc str.substring(7, 10) = ABC str.trim() = abcAbcABCabCAbCabc, len=18 str.replace(&apos;a&apos;, &apos;M&apos;) = _bcAbcABC_bCAbC_bc str.replaceFirst(&quot;a&quot;, &quot;###&quot;) = ###bcAbcABCabCAbCabc str.replace(&quot;a&quot;, &quot;$$$&quot;) = $$$bcAbcABC$$$bCAbC$$$bc splits[0]= a splits[1]=cA splits[2]=cABCa splits[3]=CA splits[4]=Ca splits[5]=c 3.7 String 操作Unicode的API源码如下(StringUnicodeTest.java): /** * String 中与unicode相关的API * * @author skywang */ public class StringUnicodeTest { public static void main(String[] args) { testUnicodeAPIs() ; } /** * String 中与unicode相关的API */ private static void testUnicodeAPIs() { System.out.println(&quot;-------------------------------- testUnicodeAPIs ------------------------------&quot;); String ustr = new String(new int[] {0x5b57, 0x7b26, 0x7f16, 0x7801}, 0, 4); // &quot;字符编码&quot;(\\u5b57是‘字’的unicode编码)。0表示起始位置，4表示长度。 System.out.printf(&quot;ustr=%s\\n&quot;, ustr); // 获取位置0的元素对应的unciode编码 System.out.printf(&quot;%-30s = 0x%x\\n&quot;, &quot;ustr.codePointAt(0)&quot;, ustr.codePointAt(0)); // 获取位置2之前的元素对应的unciode编码 System.out.printf(&quot;%-30s = 0x%x\\n&quot;, &quot;ustr.codePointBefore(2)&quot;, ustr.codePointBefore(2)); // 获取位置1开始偏移2个代码点的索引 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;ustr.offsetByCodePoints(1, 2)&quot;, ustr.offsetByCodePoints(1, 2)); // 获取第0~3个元素之间的unciode编码的个数 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;ustr.codePointCount(0, 3)&quot;, ustr.codePointCount(0, 3)); System.out.println(); } } 运行结果： -------------------------------- testUnicodeAPIs ------------------------------ ustr=字符编码 ustr.codePointAt(0) = 0x5b57 ustr.codePointBefore(2) = 0x7b26 ustr.offsetByCodePoints(1, 2) = 3 ustr.codePointCount(0, 3) = 3 3.8 String 剩余的API源码如下(StringOtherTest.java): /** * String 中其它的API * * @author skywang */ public class StringOtherTest { public static void main(String[] args) { testOtherAPIs() ; } /** * String 中其它的API */ private static void testOtherAPIs() { System.out.println(&quot;-------------------------------- testOtherAPIs --------------------------------&quot;); String str = &quot;0123456789&quot;; System.out.printf(&quot;str=%s\\n&quot;, str); // 1. 字符串长度 System.out.printf(&quot;%s = %d\\n&quot;, &quot;str.length()&quot;, str.length()); // 2. 字符串是否为空 System.out.printf(&quot;%s = %b\\n&quot;, &quot;str.isEmpty()&quot;, str.isEmpty()); // 3. [字节] 获取字符串对应的字节数组 byte[] barr = str.getBytes(); for (int i=0; i&lt;barr.length; i++) { System.out.printf(&quot;barr[%d]=0x%x &quot;, i, barr[i]); } System.out.println(); // 4. [字符] 获取字符串位置4的字符 System.out.printf(&quot;%s = %c\\n&quot;, &quot;str.charAt(4)&quot;, str.charAt(4)); // 5. [字符] 获取字符串对应的字符数组 char[] carr = str.toCharArray(); for (int i=0; i&lt;carr.length; i++) { System.out.printf(&quot;carr[%d]=%c &quot;, i, carr[i]); } System.out.println(); // 6. [字符] 获取字符串中部分元素对应的字符数组 char[] carr2 = new char[3]; str.getChars(6, 9, carr2, 0); for (int i=0; i&lt;carr2.length; i++) { System.out.printf(&quot;carr2[%d]=%c &quot;, i, carr2[i]); } System.out.println(); // 7. [字符] 获取字符数组对应的字符串 System.out.printf(&quot;%s = %s\\n&quot;, &quot;str.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;})&quot;, String.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;})); // 8. [字符] 获取字符数组中部分元素对应的字符串 System.out.printf(&quot;%s = %s\\n&quot;, &quot;str.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}, 1, 4)&quot;, String.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}, 1, 4)); // 9. format()示例，将对象数组按指定格式转换为字符串 System.out.printf(&quot;%s = %s\\n&quot;, &quot;str.format()&quot;, String.format(&quot;%s-%d-%b&quot;, &quot;abc&quot;, 3, true)); System.out.println(); } } 运行结果： -------------------------------- testOtherAPIs -------------------------------- str=0123456789 str.length() = 10 str.isEmpty() = false barr[0]=0x30 barr[1]=0x31 barr[2]=0x32 barr[3]=0x33 barr[4]=0x34 barr[5]=0x35 barr[6]=0x36 barr[7]=0x37 barr[8]=0x38 barr[9]=0x39 str.charAt(4) = 4 carr[0]=0 carr[1]=1 carr[2]=2 carr[3]=3 carr[4]=4 carr[5]=5 carr[6]=6 carr[7]=7 carr[8]=8 carr[9]=9 carr2[0]=6 carr2[1]=7 carr2[2]=8 str.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}) = abcde str.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}, 1, 4) = bcde str.format() = abc-3-true 4. String 完整示例下面的示例是整合上面的几个示例的完整的String演示程序，源码如下(StringAPITest.java): /** * String 演示程序 * * @author skywang */ import java.util.HashMap; import java.nio.charset.Charset; import java.io.UnsupportedEncodingException; public class StringAPITest { public static void main(String[] args) { testStringConstructors() ; // String 构造函数测试程序 testValueAPIs() ; // String 的valueOf()演示程序 testIndexAPIs() ; // String 中index相关API演示 testCompareAPIs() ; // String 中比较相关API演示 testModifyAPIs() ; // String 中 修改(追加/替换/截取/分割)字符串的相关API演示 testUnicodeAPIs() ; // String 中与unicode相关的API testOtherAPIs() ; // String 中其它的API } /** * String 构造函数测试程序 */ private static void testStringConstructors() { try { System.out.println(&quot;-------------------------------- testStringConstructors -----------------------&quot;); String str01 = new String(); String str02 = new String(&quot;String02&quot;); String str03 = new String(new char[]{&apos;s&apos;,&apos;t&apos;,&apos;r&apos;,&apos;0&apos;,&apos;3&apos;}); String str04 = new String(new char[]{&apos;s&apos;,&apos;t&apos;,&apos;r&apos;,&apos;0&apos;,&apos;4&apos;}, 1, 3); // 1表示起始位置，3表示个数 String str05 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}); // 0x61在ASC表中，对应字符&quot;a&quot;; 1表示起始位置，3表示长度 String str06 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}, 1, 3); // 0x61在ASC表中，对应字符&quot;a&quot;; 1表示起始位置，3表示长度 String str07 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}, 0); // 0x61在ASC表中，对应字符&quot;a&quot;;0，表示“高字节” String str08 = new String(new byte[]{0x61, 0x62, 0x63, 0x64, 0x65}, 0, 1, 3); // 0x61在ASC表中，对应字符&quot;a&quot;; 0，表示“高字节”；1表示起始位置，3表示长度 String str09 = new String(new byte[]{(byte)0xe5, (byte)0xad, (byte)0x97, /* 字-对应的utf-8编码 */ (byte)0xe7, (byte)0xac, (byte)0xa6, /* 符-对应的utf-8编码 */ (byte)0xe7, (byte)0xbc, (byte)0x96, /* 编-对应的utf-8编码 */ (byte)0xe7, (byte)0xa0, (byte)0x81, /* 码-对应的utf-8编码 */ }, 0, 12, &quot;utf-8&quot;); // 0表示起始位置，12表示长度。 String str10 = new String(new byte[]{(byte)0x5b, (byte)0x57, /* 字-对应的utf-16编码 */ (byte)0x7b, (byte)0x26, /* 符-对应的utf-16编码 */ (byte)0x7f, (byte)0x16, /* 编-对应的utf-16编码 */ (byte)0x78, (byte)0x01, /* 码-对应的utf-16编码 */ }, 0, 8, &quot;utf-16&quot;); // 0表示起始位置，8表示长度。 String str11 = new String(new byte[]{(byte)0xd7, (byte)0xd6, /* 字-对应的gb2312编码 */ (byte)0xb7, (byte)0xfb, /* 符-对应的gb2312编码 */ (byte)0xb1, (byte)0xe0, /* 编-对应的gb2312编码 */ (byte)0xc2, (byte)0xeb, /* 码-对应的gb2312编码 */ }, Charset.forName(&quot;gb2312&quot;)); String str12 = new String(new byte[]{(byte)0xd7, (byte)0xd6, /* 字-对应的gbk编码 */ (byte)0xb7, (byte)0xfb, /* 符-对应的gbk编码 */ (byte)0xb1, (byte)0xe0, /* 编-对应的gbk编码 */ (byte)0xc2, (byte)0xeb, /* 码-对应的gbk编码 */ }, 0, 8, Charset.forName(&quot;gbk&quot;)); String str13 = new String(new int[] {0x5b57, 0x7b26, 0x7f16, 0x7801}, 0, 4); // &quot;字符编码&quot;(\\u5b57是‘字’的unicode编码)。0表示起始位置，4表示长度。 String str14 = new String(new StringBuffer(&quot;StringBuffer&quot;)); String str15 = new String(new StringBuilder(&quot;StringBuilder&quot;)); System.out.printf(&quot; str01=%s \\n str02=%s \\n str03=%s \\n str04=%s \\n str05=%s \\n str06=%s \\n str07=%s \\n str08=%s\\n str09=%s\\n str10=%s\\n str11=%s\\n str12=%s\\n str13=%s\\n str14=%s\\n str15=%s\\n&quot;, str01, str02, str03, str04, str05, str06, str07, str08, str09, str10, str11, str12, str13, str14, str15); System.out.println(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } /** * String 中其它的API */ private static void testOtherAPIs() { System.out.println(&quot;-------------------------------- testOtherAPIs --------------------------------&quot;); String str = &quot;0123456789&quot;; System.out.printf(&quot;str=%s\\n&quot;, str); // 1. 字符串长度 System.out.printf(&quot;%s = %d\\n&quot;, &quot;str.length()&quot;, str.length()); // 2. 字符串是否为空 System.out.printf(&quot;%s = %b\\n&quot;, &quot;str.isEmpty()&quot;, str.isEmpty()); // 3. [字节] 获取字符串对应的字节数组 byte[] barr = str.getBytes(); for (int i=0; i&lt;barr.length; i++) { System.out.printf(&quot;barr[%d]=0x%x &quot;, i, barr[i]); } System.out.println(); // 4. [字符] 获取字符串位置4的字符 System.out.printf(&quot;%s = %c\\n&quot;, &quot;str.charAt(4)&quot;, str.charAt(4)); // 5. [字符] 获取字符串对应的字符数组 char[] carr = str.toCharArray(); for (int i=0; i&lt;carr.length; i++) { System.out.printf(&quot;carr[%d]=%c &quot;, i, carr[i]); } System.out.println(); // 6. [字符] 获取字符串中部分元素对应的字符数组 char[] carr2 = new char[3]; str.getChars(6, 9, carr2, 0); for (int i=0; i&lt;carr2.length; i++) { System.out.printf(&quot;carr2[%d]=%c &quot;, i, carr2[i]); } System.out.println(); // 7. [字符] 获取字符数组对应的字符串 System.out.printf(&quot;%s = %s\\n&quot;, &quot;str.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;})&quot;, String.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;})); // 8. [字符] 获取字符数组中部分元素对应的字符串 System.out.printf(&quot;%s = %s\\n&quot;, &quot;str.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}, 1, 4)&quot;, String.copyValueOf(new char[]{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;}, 1, 4)); // 9. format()示例，将对象数组按指定格式转换为字符串 System.out.printf(&quot;%s = %s\\n&quot;, &quot;str.format()&quot;, String.format(&quot;%s-%d-%b&quot;, &quot;abc&quot;, 3, true)); System.out.println(); } /** * String 中 修改(追加/替换/截取/分割)字符串的相关API演示 */ private static void testModifyAPIs() { System.out.println(&quot;-------------------------------- testModifyAPIs -------------------------------&quot;); String str = &quot; abcAbcABCabCAbCabc &quot;; System.out.printf(&quot;%s, len=%d\\n&quot;, str, str.length()); // 1.追加 // 将&quot;123&quot;追加到str之后 System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.concat(\\&quot;123\\&quot;)&quot;, str.concat(&quot;123&quot;)); // 2.截取 // 截取str中从位置7(包括)开始的元素。 System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.substring(7)&quot;, str.substring(7)); // 截取str中从位置7(包括)到位置10(不包括)之间的元素。 System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.substring(7, 10)&quot;, str.substring(7, 10)); // 删除str中首位的空格，并返回。 System.out.printf(&quot;%-30s = %s, len=%d\\n&quot;, &quot;str.trim()&quot;, str.trim(), str.trim().length()); // 3.替换 // 将str中的 “字符‘a’” 全部替换为 “字符‘_’” System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.replace(&apos;a&apos;, &apos;M&apos;)&quot;, str.replace(&apos;a&apos;, &apos;_&apos;)); // 将str中的第一次出现的“字符串“a”” 替换为 “字符串“###”” System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.replaceFirst(\\&quot;a\\&quot;, \\&quot;###\\&quot;)&quot;, str.replaceFirst(&quot;a&quot;, &quot;###&quot;)); // 将str中的 “字符串“a”” 全部替换为 “字符串“$$$”” System.out.printf(&quot;%-30s = %s\\n&quot;, &quot;str.replace(\\&quot;a\\&quot;, \\&quot;$$$\\&quot;)&quot;, str.replace(&quot;a&quot;, &quot;$$$&quot;)); // 4.分割 // 以“b”作为分隔符，对str进行分割 String[] splits = str.split(&quot;b&quot;); for (int i=0; i&lt;splits.length; i++) { System.out.printf(&quot;splits[%d]=%s\\n&quot;, i, splits[i]); } System.out.println(); } /** * String 中比较相关API演示 */ private static void testCompareAPIs() { System.out.println(&quot;-------------------------------- testCompareAPIs ------------------------------&quot;); //String str = &quot;abcdefghijklmnopqrstuvwxyz&quot;; String str = &quot;abcAbcABCabCAbCabc&quot;; System.out.printf(&quot;%s\\n&quot;, str); // 1. 比较“2个String是否相等” System.out.printf(&quot;%-50s = %b\\n&quot;, &quot;str.equals(\\&quot;abcAbcABCabCAbCabc\\&quot;)&quot;, str.equals(&quot;abcAbcABCabCAbCabc&quot;)); // 2. 比较“2个String是否相等(忽略大小写)” System.out.printf(&quot;%-50s = %b\\n&quot;, &quot;str.equalsIgnoreCase(\\&quot;ABCABCABCABCABCABC\\&quot;)&quot;, str.equalsIgnoreCase(&quot;ABCABCABCABCABCABC&quot;)); // 3. 比较“2个String的大小” System.out.printf(&quot;%-40s = %d\\n&quot;, &quot;str.compareTo(\\&quot;abce\\&quot;)&quot;, str.compareTo(&quot;abce&quot;)); // 4. 比较“2个String的大小(忽略大小写)” System.out.printf(&quot;%-40s = %d\\n&quot;, &quot;str.compareToIgnoreCase(\\&quot;ABC\\&quot;)&quot;, str.compareToIgnoreCase(&quot;ABC&quot;)); // 5. 字符串的开头是不是&quot;ab&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.startsWith(\\&quot;ab\\&quot;)&quot;, str.startsWith(&quot;ab&quot;)); // 6. 字符串的从位置3开头是不是&quot;ab&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.startsWith(\\&quot;Ab\\&quot;)&quot;, str.startsWith(&quot;Ab&quot;, 3)); // 7. 字符串的结尾是不是&quot;bc&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.endsWith(\\&quot;bc\\&quot;)&quot;, str.endsWith(&quot;bc&quot;)); // 8. 字符串的是不是包含&quot;ABC&quot; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;str.contains(\\&quot;ABC\\&quot;)&quot;, str.contains(&quot;ABC&quot;)); // 9. 比较2个字符串的部分内容 String region1 = str.substring(2, str.length()); // 获取str位置3(包括)到末尾(不包括)的子字符串 // 将“str中从位置2开始的字符串”和“region1中位置0开始的字符串”进行比较，比较长度是5。 System.out.printf(&quot;regionMatches(%s) = %b\\n&quot;, region1, str.regionMatches(2, region1, 0, 5)); // 10. 比较2个字符串的部分内容(忽略大小写) String region2 = region1.toUpperCase(); // 将region1转换为大写 String region3 = region1.toLowerCase(); // 将region1转换为小写 System.out.printf(&quot;regionMatches(%s) = %b\\n&quot;, region2, str.regionMatches(2, region2, 0, 5)); System.out.printf(&quot;regionMatches(%s) = %b\\n&quot;, region3, str.regionMatches(2, region3, 0, 5)); // 11. 比较“String”和“StringBuffer”的内容是否相等 System.out.printf(&quot;%-60s = %b\\n&quot;, &quot;str.contentEquals(new StringBuffer(\\&quot;abcAbcABCabCAbCabc\\&quot;))&quot;, str.contentEquals(new StringBuffer(&quot;abcAbcABCabCAbCabc&quot;))); // 12. 比较“String”和“StringBuilder”的内容是否相等 System.out.printf(&quot;%-60s = %b\\n&quot;, &quot;str.contentEquals(new StringBuilder(\\&quot;abcAbcABCabCAbCabc\\&quot;))&quot;, str.contentEquals(new StringBuilder(&quot;abcAbcABCabCAbCabc&quot;))); // 13. match()测试程序 // 正则表达式 xxx.xxx.xxx.xxx，其中xxx中x的取值可以是0～9，xxx中有1～3位。 String reg_ipv4 = &quot;[0-9]{3}(\\\\.[0-9]{1,3}){3}&quot;; String ipv4addr1 = &quot;192.168.1.102&quot;; String ipv4addr2 = &quot;192.168&quot;; System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;ipv4addr1.matches()&quot;, ipv4addr1.matches(reg_ipv4)); System.out.printf(&quot;%-40s = %b\\n&quot;, &quot;ipv4addr2.matches()&quot;, ipv4addr2.matches(reg_ipv4)); System.out.println(); } /** * String 的valueOf()演示程序 */ private static void testValueAPIs() { System.out.println(&quot;-------------------------------- testValueAPIs --------------------------------&quot;); // 1. String valueOf(Object obj) // 实际上，返回的是obj.toString(); HashMap map = new HashMap(); map.put(&quot;1&quot;, &quot;one&quot;); map.put(&quot;2&quot;, &quot;two&quot;); map.put(&quot;3&quot;, &quot;three&quot;); System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(map)&quot;, String.valueOf(map)); // 2.String valueOf(boolean b) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(true)&quot;, String.valueOf(true)); // 3.String valueOf(char c) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(&apos;m&apos;)&quot;, String.valueOf(&apos;m&apos;)); // 4.String valueOf(int i) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(96)&quot;, String.valueOf(96)); // 5.String valueOf(long l) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(12345L)&quot;, String.valueOf(12345L)); // 6.String valueOf(float f) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(1.414f)&quot;, String.valueOf(1.414f)); // 7.String valueOf(double d) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(3.14159d)&quot;, String.valueOf(3.14159d)); // 8.String valueOf(char[] data) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;})&quot;, String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;})); // 9.String valueOf(char[] data, int offset, int count) System.out.printf(&quot;%-50s = %s\\n&quot;, &quot;String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;}, 0, 2)&quot;, String.valueOf(new char[]{&apos;s&apos;,&apos;k&apos;,&apos;y&apos;}, 0, 2)); System.out.println(); } /** * String 中index相关API演示 */ private static void testIndexAPIs() { System.out.println(&quot;-------------------------------- testIndexAPIs --------------------------------&quot;); String istr = &quot;abcAbcABCabCaBcAbCaBCabc&quot;; System.out.printf(&quot;istr=%s\\n&quot;, istr); // 1. 从前往后，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf((int)&apos;a&apos;)&quot;, istr.indexOf((int)&apos;a&apos;)); // 2. 从位置5开始，从前往后，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf((int)&apos;a&apos;, 5)&quot;, istr.indexOf((int)&apos;a&apos;, 5)); // 3. 从后往前，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf((int)&apos;a&apos;)&quot;, istr.lastIndexOf((int)&apos;a&apos;)); // 4. 从位置10开始，从后往前，找出‘a’第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf((int)&apos;a&apos;, 10)&quot;, istr.lastIndexOf((int)&apos;a&apos;, 10)); // 5. 从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf(\\&quot;bc\\&quot;)&quot;, istr.indexOf(&quot;bc&quot;)); // 6. 从位置5开始，从前往后，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.indexOf(\\&quot;bc\\&quot;, 5)&quot;, istr.indexOf(&quot;bc&quot;, 5)); // 7. 从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf(\\&quot;bc\\&quot;)&quot;, istr.lastIndexOf(&quot;bc&quot;)); // 8. 从位置4开始，从后往前，找出&quot;bc&quot;第一次出现的位置 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;istr.lastIndexOf(\\&quot;bc\\&quot;, 4)&quot;, istr.lastIndexOf(&quot;bc&quot;, 4)); System.out.println(); } /** * String 中与unicode相关的API */ private static void testUnicodeAPIs() { System.out.println(&quot;-------------------------------- testUnicodeAPIs ------------------------------&quot;); String ustr = new String(new int[] {0x5b57, 0x7b26, 0x7f16, 0x7801}, 0, 4); // &quot;字符编码&quot;(\\u5b57是‘字’的unicode编码)。0表示起始位置，4表示长度。 System.out.printf(&quot;ustr=%s\\n&quot;, ustr); // 获取位置0的元素对应的unciode编码 System.out.printf(&quot;%-30s = 0x%x\\n&quot;, &quot;ustr.codePointAt(0)&quot;, ustr.codePointAt(0)); // 获取位置2之前的元素对应的unciode编码 System.out.printf(&quot;%-30s = 0x%x\\n&quot;, &quot;ustr.codePointBefore(2)&quot;, ustr.codePointBefore(2)); // 获取位置1开始的元素对应的unciode编码 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;ustr.offsetByCodePoints(1, 2)&quot;, ustr.offsetByCodePoints(1, 2)); // 获取第0~3个元素之间的unciode编码的个数 System.out.printf(&quot;%-30s = %d\\n&quot;, &quot;ustr.codePointCount(0, 3)&quot;, ustr.codePointCount(0, 3)); System.out.println(); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 字符串系列","slug":"Java-字符串系列","permalink":"https://smuwjs.github.io/tags/Java-字符串系列/"}]},{"title":"Java异常(三) 《Java Puzzles》中关于异常的几个谜题","date":"2017-03-02T16:00:00.000Z","path":"2017/03/03/java-source-analysis-exception-series/Java异常(三) 《Java Puzzles》中关于异常的几个谜题/","text":"本章介绍《Java Puzzles》中关于异常的几个谜题。这一章都是以代码为例，相比上一章看起来更有意思。 目录谜题1: 优柔寡断谜题2: 极端不可思议谜题3: 不受欢迎的宾客谜题4: 您好,再见!谜题5: 不情愿的构造器谜题6: 域和流谜题7: 异常为循环而抛 谜题1: 优柔寡断看看下面的程序，它到底打印什么？ public class Indecisive { public static void main(String[] args) { System.out.println(decision()); } private static boolean decision() { try { return true; } finally { return false; } } } 运行结果： false 结果说明： 在一个 try-finally 语句中,finally 语句块总是在控制权离开 try 语句块时执行的。无论 try 语句块是正常结束的,还是意外结束的, 情况都是如此。 一条语句或一个语句块在它抛出了一个异常,或者对某个封闭型语句执行了一个 break 或 continue,或是象这个程序一样在方法中执行了一个return 时,将发生意外结束。它们之所以被称为意外结束,是因为它们阻止程序去按顺序执行下面的语句。当 try 语句块和 finally 语句块都意外结束时, try 语句块中引发意外结束的原因将被丢弃, 而整个 try-finally 语句意外结束的原因将于 finally 语句块意外结束的原因相同。在这个程序中,在 try 语句块中的 return 语句所引发的意外结束将被丢弃, try-finally 语句意外结束是由 finally 语句块中的 return 而造成的。 简单地讲, 程序尝试着 (try) (return) 返回 true, 但是它最终 (finally) 返回(return)的是 false。丢弃意外结束的原因几乎永远都不是你想要的行为, 因为意外结束的最初原因可能对程序的行为来说会显得更重要。对于那些在 try 语句块中执行 break、continue 或 return 语句,只是为了使其行为被 finally 语句块所否决掉的程序,要理解其行为是特别困难的。总之,每一个 finally 语句块都应该正常结束,除非抛出的是不受检查的异常。 千万不要用一个 return、break、continue 或 throw 来退出一个 finally 语句块,并且千万不要允许将一个受检查的异常传播到一个 finally 语句块之外去。对于语言设计者, 也许应该要求 finally 语句块在未出现不受检查的异常时必须正常结束。朝着这个目标,try-finally 结构将要求 finally 语句块可以正常结束。return、break 或 continue 语句把控制权传递到 finally 语句块之外应该是被禁止的, 任何可以引发将被检查异常传播到 finally 语句块之外的语句也同样应该是被禁止的。 谜题2: 极端不可思议下面的三个程序每一个都会打印些什么? 不要假设它们都可以通过编译。 第一个程序 import java.io.IOException; public class Arcane1 { public static void main(String[] args) { try { System.out.println(&quot;Hello world&quot;); } catch(IOException e) { System.out.println(&quot;I&apos;ve never seen println fail!&quot;); } } } 第二个程序 public class Arcane2 { public static void main(String[] args) { try { // If you have nothing nice to say, say nothing } catch(Exception e) { System.out.println(&quot;This can&apos;t happen&quot;); } } } 第三个程序 interface Type1 { void f() throws CloneNotSupportedException; } interface Type2 { void f() throws InterruptedException; } interface Type3 extends Type1, Type2 { } public class Arcane3 implements Type3 { public void f() { System.out.println(&quot;Hello world&quot;); } public static void main(String[] args) { Type3 t3 = new Arcane3(); t3.f(); } } 运行结果： (01) 第一个程序编译出错！ Arcane1.java:9: exception java.io.IOException is never thrown in body of corresponding try statement } catch(IOException e) { ^ 1 error (02) 第二个程序能正常编译和运行。 (03) 第三个程序能正常编译和运行。输出结果是: Hello world 结果说明： (01) Arcane1展示了被检查异常的一个基本原则。它看起来应该是可以编译的:try 子句执行 I/O,并且 catch 子句捕获 IOException 异常。但是这个程序不能编译,因为 println 方法没有声明会抛出任何被检查异常,而IOException 却正是一个被检查异常。语言规范中描述道:如果一个 catch 子句要捕获一个类型为 E 的被检查异常, 而其相对应的 try 子句不能抛出 E 的某种子类型的异常,那么这就是一个编译期错误。 (02) 基于同样的理由,第二个程序,Arcane2,看起来应该是不可以编译的,但是它却可以。它之所以可以编译,是因为它唯一的 catch 子句检查了 Exception。尽管在这一点上十分含混不清,但是捕获 Exception 或 Throwble 的 catch 子句是合法的,不管与其相对应的 try 子句的内容为何。尽管 Arcane2 是一个合法的程序,但是 catch 子句的内容永远的不会被执行,这个程序什么都不会打印。 (03) 第三个程序,Arcane3,看起来它也不能编译。方法 f 在 Type1 接口中声明要抛出被检查异常 CloneNotSupportedException,并且在 Type2 接口中声明要抛出被检查异常 InterruptedException。Type3 接口继承了 Type1 和 Type2,因此, 看起来在静态类型为 Type3 的对象上调用方法 f 时, 有潜在可能会抛出这些异常。一个方法必须要么捕获其方法体可以抛出的所有被检查异常, 要么声明它将抛出这些异常。Arcane3 的 main 方法在静态类型为 Type3 的对象上调用了方法 f,但它对 CloneNotSupportedException 和 InterruptedExceptioin 并没有作这些处理。那么,为什么这个程序可以编译呢? 上述分析的缺陷在于对“Type3.f 可以抛出在 Type1.f 上声明的异常和在 Type2.f 上声明的异常”所做的假设。这并不正确,因为每一个接口都限制了方法 f 可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适用的所有类型声明要抛出的被检查异常集合的交集,而不是合集。因此,静态类型为 Type3 的对象上的 f 方法根本就不能抛出任何被检查异常。因此,Arcane3可以毫无错误地通过编译,并且打印 Hello world。 谜题3: 不受欢迎的宾客下面的程序会打印出什么呢? public class UnwelcomeGuest { public static final long GUEST_USER_ID = -1; private static final long USER_ID; static { try { USER_ID = getUserIdFromEnvironment(); } catch (IdUnavailableException e) { USER_ID = GUEST_USER_ID; System.out.println(&quot;Logging in as guest&quot;); } } private static long getUserIdFromEnvironment() throws IdUnavailableException { throw new IdUnavailableException(); } public static void main(String[] args) { System.out.println(&quot;User ID: &quot; + USER_ID); } } class IdUnavailableException extends Exception { } 运行结果： UnwelcomeGuest.java:10: variable USER_ID might already have been assigned USER_ID = GUEST_USER_ID; ^ 1 error 结果说明： 该程序看起来很直观。对 getUserIdFromEnvironment 的调用将抛出一个异常, 从而使程序将 GUEST_USER_ID(-1L)赋值给 USER_ID, 并打印 Loggin in as guest。 然后 main 方法执行,使程序打印 User ID: -1。表象再次欺骗了我们,该程序并不能编译。如果你尝试着去编译它, 你将看到和一条错误信息。 问题出在哪里了?USER_ID 域是一个空 final(blank final),它是一个在声明中没有进行初始化操作的 final 域。很明显,只有在对 USER_ID 赋值失败时,才会在 try 语句块中抛出异常,因此,在 catch 语句块中赋值是相 当安全的。不管怎样执行静态初始化操作语句块,只会对 USER_ID 赋值一次,这正是空 final 所要求的。为什么编译器不知道这些呢? 要确定一个程序是否可以不止一次地对一个空 final 进行赋值是一个很困难的问题。事实上,这是不可能的。这等价于经典的停机问题,它通常被认为是不可能解决的。为了能够编写出一个编译器,语言规范在这一点上采用了保守的方式。在程序中,一个空 final 域只有在它是明确未赋过值的地方才可以被赋值。规范长篇大论,对此术语提供了一个准确的但保守的定义。 因为它是保守的,所以编译器必须拒绝某些可以证明是安全的程序。这个谜题就展示了这样的一个程序。幸运的是, 你不必为了编写 Java 程序而去学习那些骇人的用于明确赋值的细节。通常明确赋值规则不会有任何妨碍。如果碰巧你编写了一个真的可能会对一个空final 赋值超过一次的程序,编译器会帮你指出的。只有在极少的情况下,就像本谜题一样, 你才会编写出一个安全的程序, 但是它并不满足规范的形式化要求。编译器的抱怨就好像是你编写了一个不安全的程序一样,而且你必须修改你的程序以满足它。 解决这类问题的最好方式就是将这个烦人的域从空 final 类型改变为普通的final 类型,用一个静态域的初始化操作替换掉静态的初始化语句块。实现这一点的最佳方式是重构静态语句块中的代码为一个助手方法: public class UnwelcomeGuest { public static final long GUEST_USER_ID = -1; private static final long USER_ID = getUserIdOrGuest(); private static long getUserIdOrGuest() { try { return getUserIdFromEnvironment(); } catch (IdUnavailableException e) { System.out.println(&quot;Logging in as guest&quot;); return GUEST_USER_ID; } } private static long getUserIdFromEnvironment() throws IdUnavailableException { throw new IdUnavailableException(); } public static void main(String[] args) { System.out.println(&quot;User ID: &quot; + USER_ID); } } class IdUnavailableException extends Exception { } 程序的这个版本很显然是正确的,而且比最初的版本根据可读性,因为它为了域值的计算而增加了一个描述性的名字, 而最初的版本只有一个匿名的静态初始化操作语句块。将这样的修改作用于程序,它就可以如我们的期望来运行了。总之,大多数程序员都不需要学习明确赋值规则的细节。该规则的作为通常都是正确的。如果你必须重构一个程序,以消除由明确赋值规则所引发的错误,那么你应该考虑添加一个新方法。这样做除了可以解决明确赋值问题,还可以使程序的可读性提高。 谜题4: 您好,再见!下面的程序将会打印出什么呢? public class HelloGoodbye { public static void main(String[] args) { try { System.out.println(&quot;Hello world&quot;); System.exit(0); } finally { System.out.println(&quot;Goodbye world&quot;); } } } 运行结果: Hello world 结果说明： 这个程序包含两个 println 语句: 一个在 try 语句块中, 另一个在相应的 finally语句块中。try 语句块执行它的 println 语句,并且通过调用 System.exit 来提前结束执行。在此时,你可能希望控制权会转交给 finally 语句块。然而,如果你运行该程序,就会发现它永远不会说再见:它只打印了 Hello world。这是否违背了”Indecisive示例” 中所解释的原则呢? 不论 try 语句块的执行是正常地还是意外地结束, finally 语句块确实都会执行。然而在这个程序中,try 语句块根本就没有结束其执行过程。System.exit 方法将停止当前线程和所有其他当场死亡的线程。finally 子句的出现并不能给予线程继续去执行的特殊权限。 当 System.exit 被调用时,虚拟机在关闭前要执行两项清理工作。首先,它执行所有的关闭挂钩操作,这些挂钩已经注册到了 Runtime.addShutdownHook 上。这对于释放 VM 之外的资源将很有帮助。务必要为那些必须在 VM 退出之前发生的行为关闭挂钩。下面的程序版本示范了这种技术,它可以如我们所期望地打印出 Hello world 和 Goodbye world: public class HelloGoodbye1 { public static void main(String[] args) { System.out.println(&quot;Hello world&quot;); Runtime.getRuntime().addShutdownHook( new Thread() { public void run() { System.out.println(&quot;Goodbye world&quot;); } }); System.exit(0); } } VM 执行在 System.exit 被调用时执行的第二个清理任务与终结器有关。如果System.runFinalizerOnExit 或它的魔鬼双胞胎 Runtime.runFinalizersOnExit被调用了,那么 VM 将在所有还未终结的对象上面调用终结器。这些方法很久以前就已经过时了,而且其原因也很合理。无论什么原因,永远不要调用System.runFinalizersOnExit 和 Runtime.runFinalizersOnExit: 它们属于 Java类库中最危险的方法之一[ThreadStop]。调用这些方法导致的结果是,终结器会在那些其他线程正在并发操作的对象上面运行, 从而导致不确定的行为或导致死锁。 总之,System.exit 将立即停止所有的程序线程,它并不会使 finally 语句块得到调用,但是它在停止 VM 之前会执行关闭挂钩操作。当 VM 被关闭时,请使用关闭挂钩来终止外部资源。通过调用 System.halt 可以在不执行关闭挂钩的情况下停止 VM,但是这个方法很少使用。 谜题5: 不情愿的构造器下面的程序将打印出什么呢? public class Reluctant { private Reluctant internalInstance = new Reluctant(); public Reluctant() throws Exception { throw new Exception(&quot;I&apos;m not coming out&quot;); } public static void main(String[] args) { try { Reluctant b = new Reluctant(); System.out.println(&quot;Surprise!&quot;); } catch (Exception ex) { System.out.println(&quot;I told you so&quot;); } } } 运行结果： Exception in thread &quot;main&quot; java.lang.StackOverflowError at Reluctant.&lt;init&gt;(Reluctant.java:3) ... 结果说明： main 方法调用了 Reluctant 构造器,它将抛出一个异常。你可能期望 catch 子句能够捕获这个异常,并且打印 I told you so。凑近仔细看看这个程序就会发现,Reluctant 实例还包含第二个内部实例,它的构造器也会抛出一个异常。无论抛出哪一个异常,看起来 main 中的 catch 子句都应该捕获它,因此预测该程序将打印 I told you 应该是一个安全的赌注。但是当你尝试着去运行它时,就会发现它压根没有去做这类的事情:它抛出了 StackOverflowError 异常,为什么呢? 与大多数抛出 StackOverflowError 异常的程序一样,本程序也包含了一个无限递归。当你调用一个构造器时,实例变量的初始化操作将先于构造器的程序体而运行[JLS 12.5]。在本谜题中, internalInstance 变量的初始化操作递归调用了构造器,而该构造器通过再次调用 Reluctant 构造器而初始化该变量自己的 internalInstance 域,如此无限递归下去。这些递归调用在构造器程序体获得执行机会之前就会抛出 StackOverflowError 异常,因为 StackOverflowError 是 Error 的子类型而不是 Exception 的子类型,所以 catch 子句无法捕获它。对于一个对象包含与它自己类型相同的实例的情况,并不少见。例如,链接列表节点、树节点和图节点都属于这种情况。你必须非常小心地初始化这样的包含实例,以避免 StackOverflowError 异常。 至于本谜题名义上的题目:声明将抛出异常的构造器,你需要注意,构造器必须声明其实例初始化操作会抛出的所有被检查异常。 谜题6: 域和流下面的方法将一个文件拷贝到另一个文件,并且被设计为要关闭它所创建的每一个流,即使它碰到 I/O 错误也要如此。遗憾的是,它并非总是能够做到这一点。为什么不能呢,你如何才能订正它呢? static void copy(String src, String dest) throws IOException { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); byte[] buf = new byte[1024]; int n; while ((n = in.read(buf)) &gt; 0) out.write(buf, 0, n); } finally { if (in != null) in.close(); if (out != null) out.close(); } } 谜题分析： 这个程序看起来已经面面俱到了。其流域(in 和 out)被初始化为 null,并且新的流一旦被创建,它们马上就被设置为这些流域的新值。对于这些域所引用的流,如果不为空,则 finally 语句块会将其关闭。即便在拷贝操作引发了一个 IOException 的情况下,finally 语句块也会在方法返回之前执行。出什么错了呢? 问题在 finally 语句块自身中。close 方法也可能会抛出 IOException 异常。如果这正好发生在 in.close 被调用之时,那么这个异常就会阻止 out.close 被调用,从而使输出流仍保持在开放状态。请注意,该程序违反了”优柔寡断” 的建议:对 close 的调用可能会导致 finally 语句块意外结束。遗憾的是,编译器并不能帮助你发现此问题,因为 close 方法抛出的异常与 read 和 write 抛出的异常类型相同,而其外围方法(copy)声明将传播该异常。解决方式是将每一个 close 都包装在一个嵌套的 try 语句块中。 下面的 finally 语句块的版本可以保证在两个流上都会调用 close: try { // 和之前一样 } finally { if (in != null) { try { in.close(); } catch (IOException ex) { // There is nothing we can do if close fails } } if (out != null) { try { out.close(); } catch (IOException ex) { // There is nothing we can do if close fails } } } 总之,当你在 finally 语句块中调用 close 方法时,要用一个嵌套的 try-catch 语句来保护它,以防止 IOException 的传播。更一般地讲,对于任何在 finally 语句块中可能会抛出的被检查异常都要进行处理,而不是任其传播。 谜题7: 异常为循环而抛下面的程序会打印出什么呢? public class Loop { public static void main(String[] args) { int[][] tests = { { 6, 5, 4, 3, 2, 1 }, { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 } }; int successCount = 0; try { int i = 0; while (true) { if (thirdElementIsThree(tests[i++])) successCount ++; } } catch(ArrayIndexOutOfBoundsException e) { // No more tests to process } System.out.println(successCount); } private static boolean thirdElementIsThree(int[] a) { return a.length &gt;= 3 &amp; a[2] == 3; } } 运行结果： 0 结果说明： 该程序主要说明了两个问题。 第1个问题：不应该使用异常作为终止循环的手段！ 该程序用 thirdElementIsThree 方法测试了 tests 数组中的每一个元素。遍历这个数组的循环显然是非传统的循环:它不是在循环变量等于数组长度的时候终止,而是在它试图访问一个并不在数组中的元素时终止。尽管它是非传统的,但是这个循环应该可以工作。 如果传递给 thirdElementIsThree 的参数具有 3 个或更多的元素,并且其第三个元素等于 3,那么该方法将返回 true。对于 tests中的 5 个元素来说,有 2 个将返回 true,因此看起来该程序应该打印 2。如果你运行它,就会发现它打印的时 0。肯定是哪里出了问题,你能确定吗? 事实上,这个程序犯了两个错误。第一个错误是该程序使用了一种可怕的循环惯用法,该惯用法依赖的是对数组的访问会抛出异常。这种惯用法不仅难以阅读, 而且运行速度还非常地慢。不要使用异常来进行循环控制;应该只为异常条件而使用异常。为了纠正这个错误,可以将整个 try-finally 语句块替换为循环遍历数组的标准惯用法: for (int i = 0; i &lt; test.length; i++) if (thirdElementIsThree(tests[i])) successCount++; 如果你使用的是 5.0 或者是更新的版本,那么你可以用 for 循环结构来代替: for (int[] test : tests) if(thirdElementIsThree(test)) successCount++; 第2个问题: 主要比较”&amp;操作符” 和 “&amp;&amp;操作符”的区别。注意示例中的操作符是&amp;，这是按位进行”与”操作。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java异常系列","slug":"Java异常系列","permalink":"https://smuwjs.github.io/tags/Java异常系列/"}]},{"title":"Java异常(二) 《Effective Java》中关于异常处理的几条建议","date":"2017-03-01T16:00:00.000Z","path":"2017/03/02/java-source-analysis-exception-series/Java异常(二) 《Effective Java》中关于异常处理的几条建议/","text":"本章是从《Effective Java》摘录整理出来的关于异常处理的几条建议。 目录第1条: 只针对不正常的情况才使用异常第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常第3条: 避免不必要的使用被检查的异常第4条: 尽量使用标准的异常第5条: 抛出的异常要适合于相应的抽象第6条: 每个方法抛出的异常都要有文档第7条: 在细节消息中包含失败 – 捕获消息第8条: 努力使失败保持原子性第9条: 不要忽略异常 它们对应原书中”第8章 异常”部分的第39-47条。 第1条: 只针对不正常的情况才使用异常建议：异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。 通过比较下面的两份代码进行说明。 代码1 try { int i=0; while (true) { arr[i]=0; i++; } } catch (IndexOutOfBoundsException e) { } 代码2 for (int i=0; i&lt;arr.length; i++) { arr[i]=0; } 两份代码的作用都是遍历arr数组，并设置数组中每一个元素的值为0。代码1的是通过异常来终止，看起来非常难懂，代码2是通过数组边界来终止。我们应该避免使用代码1这种方式，主要原因有三点： 异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。 把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。 对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。 实际上，基于异常的模式比标准模式要慢得多。测试代码如下： public class Advice1 { private static int[] arr = new int[]{1,2,3,4,5}; private static int SIZE = 10000; public static void main(String[] args) { long s1 = System.currentTimeMillis(); for (int i=0; i&lt;SIZE; i++) endByRange(arr); long e1 = System.currentTimeMillis(); System.out.println(&quot;endByRange time:&quot;+(e1-s1)+&quot;ms&quot; ); long s2 = System.currentTimeMillis(); for (int i=0; i&lt;SIZE; i++) endByException(arr); long e2 = System.currentTimeMillis(); System.out.println(&quot;endByException time:&quot;+(e2-s2)+&quot;ms&quot; ); } // 遍历arr数组: 通过异常的方式 private static void endByException(int[] arr) { try { int i=0; while (true) { arr[i]=0; i++; //System.out.println(&quot;endByRange: arr[&quot;+i+&quot;]=&quot;+arr[i]); } } catch (IndexOutOfBoundsException e) { } } // 遍历arr数组: 通过边界的方式 private static void endByRange(int[] arr) { for (int i=0; i&lt;arr.length; i++) { arr[i]=0; //System.out.println(&quot;endByException: arr[&quot;+i+&quot;]=&quot;+arr[i]); } } } 运行结果： endByRange time:8ms endByException time:16ms 结果说明：通过异常遍历的速度比普通方式遍历数组慢很多！ 第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常 异常 说明 运行时异常 RuntimeException类及其子类都被称为运行时异常。 被检查的异常 Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常 它们的区别是：Java编译器会对”被检查的异常”进行检查，而对”运行时异常”不会检查。 也就是说，对于被检查的异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。而对于运行时异常，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。当然，虽说Java编译器不会检查运行时异常，但是，我们同样可以通过throws对该异常进行说明，或通过try-catch进行捕获。 rithmeticException(例如，除数为0)，IndexOutOfBoundsException(例如，数组越界)等都属于运行时异常。对于这种异常，我们应该通过修改代码进行避免它的产生。而对于被检查的异常，则可以通过处理让程序恢复运行。例如，假设因为一个用户没有存储足够数量的前，所以他在企图在一个收费电话上进行呼叫就会失败；于是就将一个被检查异常抛出。 第3条: 避免不必要的使用被检查的异常“被检查的异常”是Java语言的一个很好的特性。与返回代码不同，”被检查的异常”会强迫程序员处理例外的条件，大大提高了程序的可靠性。 但是，过分使用被检查异常会使API用起来非常不方便。如果一个方法抛出一个或多个被检查的异常，那么调用该方法的代码则必须在一个或多个catch语句块中处理这些异常，或者必须通过throws声明抛出这些异常。 无论是通过catch处理，还是通过throws声明抛出，都给程序员添加了不可忽略的负担。 适用于”被检查的异常”必须同时满足两个条件：第一，即使正确使用API并不能阻止异常条件的发生。第二，一旦产生了异常，使用API的程序员可以采取有用的动作对程序进行处理。 第4条: 尽量使用标准的异常代码重用是值得提倡的，这是一条通用规则，异常也不例外。重用现有的异常有几个好处：第一，它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。第二，对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。第三，异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。 Java标准异常中有几个是经常被使用的异常。如下表格： 异常 使用场合 IllegalArgumentException 参数的值不合适 IllegalStateException 参数的状态不合适 NullPointerException 在null被禁止的情况下参数值为null IndexOutOfBoundsException 下标越界 ConcurrentModificationException 在禁止并发修改的情况下，对象检测到并发修改 UnsupportedOperationException 对象不支持客户请求的方法 虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上！ 最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。 第5条: 抛出的异常要适合于相应的抽象如果一个方法抛出的异常与它执行的任务没有明显的关联关系，这种情形会让人不知所措。当一个方法传递一个由低层抽象抛出的异常时，往往会发生这种情况。这种情况发生时，不仅让人困惑，而且也”污染”了高层API。 为了避免这个问题，高层实现应该捕获低层的异常，同时抛出一个可以按照高层抽象进行介绍的异常。这种做法被称为”异常转译(exception translation)”。 例如，在Java的集合框架AbstractSequentialList的get()方法如下(基于JDK1.7.0_40)： public E get(int index) { try { return listIterator(index).next(); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); } } listIterator(index)会返回ListIterator对象，调用该对象的next()方法可能会抛出NoSuchElementException异常。而在get()方法中，抛出NoSuchElementException异常会让人感到困惑。所以，get()对NoSuchElementException进行了捕获，并抛出了IndexOutOfBoundsException异常。即，相当于将NoSuchElementException转译成了IndexOutOfBoundsException异常。 第6条: 每个方法抛出的异常都要有文档要单独的声明被检查的异常，并且利用Javadoc的@throws标记，准确地记录下每个异常被抛出的条件。 如果一个类中的许多方法处于同样的原因而抛出同一个异常，那么在该类的文档注释中对这个异常做文档，而不是为每个方法单独做文档，这是可以接受的。 第7条: 在细节消息中包含失败 – 捕获消息简而言之，当我们自定义异常或者抛出异常时，应该包含失败相关的信息。 当一个程序由于一个未被捕获的异常而失败的时候，系统会自动打印出该异常的栈轨迹。在栈轨迹中包含该异常的字符串表示。典型情况下它包含该异常类的类名，以及紧随其后的细节消息。 第8条: 努力使失败保持原子性当一个对象抛出一个异常之后，我们总期望这个对象仍然保持在一种定义良好的可用状态之中。对于被检查的异常而言，这尤为重要，因为调用者通常期望从被检查的异常中恢复过来。 一般而言，一个失败的方法调用应该保持使对象保持在”它在被调用之前的状态”。具有这种属性的方法被称为具有”失败原子性(failure atomic)”。可以理解为，失败了还保持着原子性。对象保持”失败原子性”的方式有几种： (01) 设计一个非可变对象。 (02) 对于在可变对象上执行操作的方法，获得”失败原子性”的最常见方法是，在执行操作之前检查参数的有效性。如下(Stack.java中的pop方法)： public Object pop() { if (size==0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; return result; } (03) 与上一种方法类似，可以对计算处理过程调整顺序，使得任何可能会失败的计算部分都发生在对象状态被修改之前。 (04) 编写一段恢复代码，由它来解释操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。 (05) 在对象的一份临时拷贝上执行操作，当操作完成之后再把临时拷贝中的结果复制给原来的对象。 虽然”保持对象的失败原子性”是期望目标，但它并不总是可以做得到。例如，如果多个线程企图在没有适当的同步机制的情况下，并发的访问一个对象，那么该对象就有可能被留在不一致的状态中。 即使在可以实现”失败原子性”的场合，它也不是总被期望的。对于某些操作，它会显著的增加开销或者复杂性。总的规则是：作为方法规范的一部分，任何一个异常都不应该改变对象调用该方法之前的状态，如果这条规则被违反，则API文档中应该清楚的指明对象将会处于什么样的状态。 第9条: 不要忽略异常当一个API的设计者声明一个方法会抛出某个异常的时候，他们正在试图说明某些事情。所以，请不要忽略它！忽略异常的代码如下： try { ... } catch (SomeException e) { } 空的catch块会使异常达不到应有的目的，异常的目的是强迫你处理不正常的条件。忽略一个异常，就如同忽略一个火警信号一样 – 若把火警信号器关闭了，那么当真正的火灾发生时，就没有人看到火警信号了。所以，至少catch块应该包含一条说明，用来解释为什么忽略这个异常是合适的。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java异常系列","slug":"Java异常系列","permalink":"https://smuwjs.github.io/tags/Java异常系列/"}]},{"title":"Java异常(一) Java异常简介及其架构","date":"2017-02-28T16:00:00.000Z","path":"2017/03/01/java-source-analysis-exception-series/Java异常(一) Java异常简介及其架构/","text":"本章对Java中的异常进行介绍。 目录第1部分 Java异常简介第2部分 Java异常框架 第1部分 Java异常简介Java异常是Java提供的一种识别及响应错误的一致性机制。 Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。 Java异常机制用到的几个关键字：try、catch、finally、throw、throws。 关键字 说明 try 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 catch 用于捕获异常。catch用来捕获try语句块中发生的异常。 finally finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 throw 用于抛出异常。 throws 用在方法签名中，用于声明该方法可能抛出的异常。 下面通过几个示例对这几个关键字进行简单了解。 示例一: 了解try和catch基本用法public class Demo1 { public static void main(String[] args) { try { int i = 10/0; System.out.println(&quot;i=&quot;+i); } catch (ArithmeticException e) { System.out.println(&quot;Caught Exception&quot;); System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); System.out.println(&quot;e.toString(): &quot; + e.toString()); System.out.println(&quot;e.printStackTrace():&quot;); e.printStackTrace(); } } } 运行结果： Caught Exception e.getMessage(): / by zero e.toString(): java.lang.ArithmeticException: / by zero e.printStackTrace(): java.lang.ArithmeticException: / by zero at Demo1.main(Demo1.java:6) 结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。观察结果我们发现，并没有执行System.out.println(“i=”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。 示例二: 了解finally的基本用法在”示例一”的基础上，我们添加finally语句。 public class Demo2 { public static void main(String[] args) { try { int i = 10/0; System.out.println(&quot;i=&quot;+i); } catch (ArithmeticException e) { System.out.println(&quot;Caught Exception&quot;); System.out.println(&quot;e.getMessage(): &quot; + e.getMessage()); System.out.println(&quot;e.toString(): &quot; + e.toString()); System.out.println(&quot;e.printStackTrace():&quot;); e.printStackTrace(); } finally { System.out.println(&quot;run finally&quot;); } } } 运行结果： Caught Exception e.getMessage(): / by zero e.toString(): java.lang.ArithmeticException: / by zero e.printStackTrace(): java.lang.ArithmeticException: / by zero at Demo2.main(Demo2.java:6) run finally 结果说明：最终执行了finally语句块。 示例三: 了解throws和throw的基本用法throws是用于声明抛出的异常，而throw是用于抛出异常。 class MyException extends Exception { public MyException() {} public MyException(String msg) { super(msg); } } public class Demo3 { public static void main(String[] args) { try { test(); } catch (MyException e) { System.out.println(&quot;Catch My Exception&quot;); e.printStackTrace(); } } public static void test() throws MyException{ try { int i = 10/0; System.out.println(&quot;i=&quot;+i); } catch (ArithmeticException e) { throw new MyException(&quot;This is MyException&quot;); } } } 运行结果： Catch My Exception MyException: This is MyException at Demo3.test(Demo3.java:24) at Demo3.main(Demo3.java:13) 结果说明：MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。 第2部分 Java异常框架Java异常架构图 img 1. ThrowableThrowable是 Java 语言中所有错误或异常的超类。Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。 2. ExceptionException及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。 3. RuntimeExceptionRuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 编译器不会检查RuntimeException异常。例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ 4. Error和Exception一样，Error也是Throwable的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。和RuntimeException一样，编译器也不会检查Error。 Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。 (01) 运行时异常 定义: RuntimeException及其子类都被称为运行时异常。特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。&nbsp;&nbsp;&nbsp;&nbsp; 虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。&nbsp;&nbsp;&nbsp;&nbsp; 如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ (02) 被检查的异常 定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。&nbsp;&nbsp;&nbsp;&nbsp; 被检查异常通常都是可以恢复的。 (03) 错误 定义: Error类及其子类。特点: 和运行时异常一样，编译器也不会对错误进行检查。&nbsp;&nbsp;&nbsp;&nbsp; 当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。&nbsp;&nbsp;&nbsp;&nbsp; 按照Java惯例，我们是不应该是实现任何新的Error子类的！ 对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是：对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java异常系列","slug":"Java异常系列","permalink":"https://smuwjs.github.io/tags/Java异常系列/"}]},{"title":"Java 时间相关内容07 TimeZone","date":"2017-02-06T16:00:00.000Z","path":"2017/02/07/java-source-analysis-time-series/Java 时间相关内容07 TimeZone/","text":"本章介绍TimeZone。 目录1. TimeZone 简介2. TimeZone示例 1. TimeZone 简介TimeZone 表示时区偏移量，也可以计算夏令时。在操作 Date, Calendar等表示日期/时间的对象时，经常会用到TimeZone；因为不同的时区，时间不同。 下面说说TimeZone对象的 2种常用创建方式。 (01) 获取默认的TimeZone对象 使用方法： TimeZone tz = TimeZone.getDefault() (02) 使用 getTimeZone(String id) 方法获取TimeZone对象 使用方法： // 获取 “GMT+08:00”对应的时区 TimeZone china = TimeZone.getTimeZone(&quot;GMT+:08:00&quot;); // 获取 “中国/重庆”对应的时区 TimeZone chongqing = TimeZone.getTimeZone(&quot;Asia/Chongqing&quot;); 关于 getTimeZone(String id) 这种方式支持的全部id参数的取值，可以通过以下方式查找： String[] ids = TimeZone.getAvailableIDs(); for (String id:ids) System.out.printf(id+&quot;, &quot;); 输出结果： Etc/GMT+12, Etc/GMT+11, Pacific/Midway, Pacific/Niue, Pacific/Pago_Pago, Pacific/Samoa, US/Samoa, America/Adak, America/Atka, Etc/GMT+10, HST, Pacific/Honolulu, Pacific/Johnston, Pacific/Rarotonga, Pacific/Tahiti, SystemV/HST10, US/Aleutian, US/Hawaii, Pacific/Marquesas, AST, America/Anchorage, America/Juneau, America/Nome, America/Sitka, America/Yakutat, Etc/GMT+9, Pacific/Gambier, SystemV/YST9, SystemV/YST9YDT, US/Alaska, America/Dawson, America/Ensenada, America/Los_Angeles, America/Metlakatla, America/Santa_Isabel, America/Tijuana, America/Vancouver, America/Whitehorse, Canada/Pacific, Canada/Yukon, Etc/GMT+8, Mexico/BajaNorte, PST, PST8PDT, Pacific/Pitcairn, SystemV/PST8, SystemV/PST8PDT, US/Pacific, US/Pacific-New, America/Boise, America/Cambridge_Bay, America/Chihuahua, America/Creston, America/Dawson_Creek, America/Denver, America/Edmonton, America/Hermosillo, America/Inuvik, America/Mazatlan, America/Ojinaga, America/Phoenix, America/Shiprock, America/Yellowknife, Canada/Mountain, Etc/GMT+7, MST, MST7MDT, Mexico/BajaSur, Navajo, PNT, SystemV/MST7, SystemV/MST7MDT, US/Arizona, US/Mountain, America/Bahia_Banderas, America/Belize, America/Cancun, America/Chicago, America/Costa_Rica, America/El_Salvador, America/Guatemala, America/Indiana/Knox, America/Indiana/Tell_City, America/Knox_IN, America/Managua, America/Matamoros, America/Menominee, America/Merida, America/Mexico_City, America/Monterrey, America/North_Dakota/Beulah, America/North_Dakota/Center, America/North_Dakota/New_Salem, America/Rainy_River, America/Rankin_Inlet, America/Regina, America/Resolute, America/Swift_Current, America/Tegucigalpa, America/Winnipeg, CST, CST6CDT, Canada/Central, Canada/East-Saskatchewan, Canada/Saskatchewan, Chile/EasterIsland, Etc/GMT+6, Mexico/General, Pacific/Easter, Pacific/Galapagos, SystemV/CST6, SystemV/CST6CDT, US/Central, US/Indiana-Starke, America/Atikokan, America/Bogota, America/Cayman, America/Coral_Harbour, America/Detroit, America/Fort_Wayne, America/Grand_Turk, America/Guayaquil, America/Havana, America/Indiana/Indianapolis, America/Indiana/Marengo, America/Indiana/Petersburg, America/Indiana/Vevay, America/Indiana/Vincennes, America/Indiana/Winamac, America/Indianapolis, America/Iqaluit, America/Jamaica, America/Kentucky/Louisville, America/Kentucky/Monticello, America/Lima, America/Louisville, America/Montreal, America/Nassau, America/New_York, America/Nipigon, America/Panama, America/Pangnirtung, America/Port-au-Prince, America/Thunder_Bay, America/Toronto, Canada/Eastern, Cuba, EST, EST5EDT, Etc/GMT+5, IET, Jamaica, SystemV/EST5, SystemV/EST5EDT, US/East-Indiana, US/Eastern, US/Michigan, America/Caracas, America/Anguilla, America/Antigua, America/Argentina/San_Luis, America/Aruba, America/Asuncion, America/Barbados, America/Blanc-Sablon, America/Boa_Vista, America/Campo_Grande, America/Cuiaba, America/Curacao, America/Dominica, America/Eirunepe, America/Glace_Bay, America/Goose_Bay, America/Grenada, America/Guadeloupe, America/Guyana, America/Halifax, America/Kralendijk, America/La_Paz, America/Lower_Princes, America/Manaus, America/Marigot, America/Martinique, America/Moncton, America/Montserrat, America/Port_of_Spain, America/Porto_Acre, America/Porto_Velho, America/Puerto_Rico, America/Rio_Branco, America/Santiago, America/Santo_Domingo, America/St_Barthelemy, America/St_Kitts, America/St_Lucia, America/St_Thomas, America/St_Vincent, America/Thule, America/Tortola, America/Virgin, Antarctica/Palmer, Atlantic/Bermuda, Brazil/Acre, Brazil/West, Canada/Atlantic, Chile/Continental, Etc/GMT+4, PRT, SystemV/AST4, SystemV/AST4ADT, America/St_Johns, CNT, Canada/Newfoundland, AGT, America/Araguaina, America/Argentina/Buenos_Aires, America/Argentina/Catamarca, America/Argentina/ComodRivadavia, America/Argentina/Cordoba, America/Argentina/Jujuy, America/Argentina/La_Rioja, America/Argentina/Mendoza, America/Argentina/Rio_Gallegos, America/Argentina/Salta, America/Argentina/San_Juan, America/Argentina/Tucuman, America/Argentina/Ushuaia, America/Bahia, America/Belem, America/Buenos_Aires, America/Catamarca, America/Cayenne, America/Cordoba, America/Fortaleza, America/Godthab, America/Jujuy, America/Maceio, America/Mendoza, America/Miquelon, America/Montevideo, America/Paramaribo, America/Recife, America/Rosario, America/Santarem, America/Sao_Paulo, Antarctica/Rothera, Atlantic/Stanley, BET, Brazil/East, Etc/GMT+3, America/Noronha, Atlantic/South_Georgia, Brazil/DeNoronha, Etc/GMT+2, America/Scoresbysund, Atlantic/Azores, Atlantic/Cape_Verde, Etc/GMT+1, Africa/Abidjan, Africa/Accra, Africa/Bamako, Africa/Banjul, Africa/Bissau, Africa/Casablanca, Africa/Conakry, Africa/Dakar, Africa/El_Aaiun, Africa/Freetown, Africa/Lome, Africa/Monrovia, Africa/Nouakchott, Africa/Ouagadougou, Africa/Sao_Tome, Africa/Timbuktu, America/Danmarkshavn, Atlantic/Canary, Atlantic/Faeroe, Atlantic/Faroe, Atlantic/Madeira, Atlantic/Reykjavik, Atlantic/St_Helena, Eire, Etc/GMT, Etc/GMT+0, Etc/GMT-0, Etc/GMT0, Etc/Greenwich, Etc/UCT, Etc/UTC, Etc/Universal, Etc/Zulu, Europe/Belfast, Europe/Dublin, Europe/Guernsey, Europe/Isle_of_Man, Europe/Jersey, Europe/Lisbon, Europe/London, GB, GB-Eire, GMT, GMT0, Greenwich, Iceland, Portugal, UCT, UTC, Universal, WET, Zulu, Africa/Algiers, Africa/Bangui, Africa/Brazzaville, Africa/Ceuta, Africa/Douala, Africa/Kinshasa, Africa/Lagos, Africa/Libreville, Africa/Luanda, Africa/Malabo, Africa/Ndjamena, Africa/Niamey, Africa/Porto-Novo, Africa/Tunis, Africa/Windhoek, Arctic/Longyearbyen, Atlantic/Jan_Mayen, CET, ECT, Etc/GMT-1, Europe/Amsterdam, Europe/Andorra, Europe/Belgrade, Europe/Berlin, Europe/Bratislava, Europe/Brussels, Europe/Budapest, Europe/Copenhagen, Europe/Gibraltar, Europe/Ljubljana, Europe/Luxembourg, Europe/Madrid, Europe/Malta, Europe/Monaco, Europe/Oslo, Europe/Paris, Europe/Podgorica, Europe/Prague, Europe/Rome, Europe/San_Marino, Europe/Sarajevo, Europe/Skopje, Europe/Stockholm, Europe/Tirane, Europe/Vaduz, Europe/Vatican, Europe/Vienna, Europe/Warsaw, Europe/Zagreb, Europe/Zurich, MET, Poland, ART, Africa/Blantyre, Africa/Bujumbura, Africa/Cairo, Africa/Gaborone, Africa/Harare, Africa/Johannesburg, Africa/Kigali, Africa/Lubumbashi, Africa/Lusaka, Africa/Maputo, Africa/Maseru, Africa/Mbabane, Africa/Tripoli, Asia/Amman, Asia/Beirut, Asia/Damascus, Asia/Gaza, Asia/Hebron, Asia/Istanbul, Asia/Jerusalem, Asia/Nicosia, Asia/Tel_Aviv, CAT, EET, Egypt, Etc/GMT-2, Europe/Athens, Europe/Bucharest, Europe/Chisinau, Europe/Helsinki, Europe/Istanbul, Europe/Kiev, Europe/Mariehamn, Europe/Nicosia, Europe/Riga, Europe/Simferopol, Europe/Sofia, Europe/Tallinn, Europe/Tiraspol, Europe/Uzhgorod, Europe/Vilnius, Europe/Zaporozhye, Israel, Libya, Turkey, Africa/Addis_Ababa, Africa/Asmara, Africa/Asmera, Africa/Dar_es_Salaam, Africa/Djibouti, Africa/Juba, Africa/Kampala, Africa/Khartoum, Africa/Mogadishu, Africa/Nairobi, Antarctica/Syowa, Asia/Aden, Asia/Baghdad, Asia/Bahrain, Asia/Kuwait, Asia/Qatar, Asia/Riyadh, EAT, Etc/GMT-3, Europe/Kaliningrad, Europe/Minsk, Indian/Antananarivo, Indian/Comoro, Indian/Mayotte, Asia/Riyadh87, Asia/Riyadh88, Asia/Riyadh89, Mideast/Riyadh87, Mideast/Riyadh88, Mideast/Riyadh89, Asia/Tehran, Iran, Asia/Baku, Asia/Dubai, Asia/Muscat, Asia/Tbilisi, Asia/Yerevan, Etc/GMT-4, Europe/Moscow, Europe/Samara, Europe/Volgograd, Indian/Mahe, Indian/Mauritius, Indian/Reunion, NET, W-SU, Asia/Kabul, Antarctica/Mawson, Asia/Aqtau, Asia/Aqtobe, Asia/Ashgabat, Asia/Ashkhabad, Asia/Dushanbe, Asia/Karachi, Asia/Oral, Asia/Samarkand, Asia/Tashkent, Etc/GMT-5, Indian/Kerguelen, Indian/Maldives, PLT, Asia/Calcutta, Asia/Colombo, Asia/Kolkata, IST, Asia/Kathmandu, Asia/Katmandu, Antarctica/Vostok, Asia/Almaty, Asia/Bishkek, Asia/Dacca, Asia/Dhaka, Asia/Qyzylorda, Asia/Thimbu, Asia/Thimphu, Asia/Yekaterinburg, BST, Etc/GMT-6, Indian/Chagos, Asia/Rangoon, Indian/Cocos, Antarctica/Davis, Asia/Bangkok, Asia/Ho_Chi_Minh, Asia/Hovd, Asia/Jakarta, Asia/Novokuznetsk, Asia/Novosibirsk, Asia/Omsk, Asia/Phnom_Penh, Asia/Pontianak, Asia/Saigon, Asia/Vientiane, Etc/GMT-7, Indian/Christmas, VST, Antarctica/Casey, Asia/Brunei, Asia/Choibalsan, Asia/Chongqing, Asia/Chungking, Asia/Harbin, Asia/Hong_Kong, Asia/Kashgar, Asia/Krasnoyarsk, Asia/Kuala_Lumpur, Asia/Kuching, Asia/Macao, Asia/Macau, Asia/Makassar, Asia/Manila, Asia/Shanghai, Asia/Singapore, Asia/Taipei, Asia/Ujung_Pandang, Asia/Ulaanbaatar, Asia/Ulan_Bator, Asia/Urumqi, Australia/Perth, Australia/West, CTT, Etc/GMT-8, Hongkong, PRC, Singapore, Australia/Eucla, Asia/Dili, Asia/Irkutsk, Asia/Jayapura, Asia/Pyongyang, Asia/Seoul, Asia/Tokyo, Etc/GMT-9, JST, Japan, Pacific/Palau, ROK, ACT, Australia/Adelaide, Australia/Broken_Hill, Australia/Darwin, Australia/North, Australia/South, Australia/Yancowinna, AET, Antarctica/DumontDUrville, Asia/Yakutsk, Australia/ACT, Australia/Brisbane, Australia/Canberra, Australia/Currie, Australia/Hobart, Australia/Lindeman, Australia/Melbourne, Australia/NSW, Australia/Queensland, Australia/Sydney, Australia/Tasmania, Australia/Victoria, Etc/GMT-10, Pacific/Chuuk, Pacific/Guam, Pacific/Port_Moresby, Pacific/Saipan, Pacific/Truk, Pacific/Yap, Australia/LHI, Australia/Lord_Howe, Antarctica/Macquarie, Asia/Sakhalin, Asia/Vladivostok, Etc/GMT-11, Pacific/Efate, Pacific/Guadalcanal, Pacific/Kosrae, Pacific/Noumea, Pacific/Pohnpei, Pacific/Ponape, SST, Pacific/Norfolk, Antarctica/McMurdo, Antarctica/South_Pole, Asia/Anadyr, Asia/Kamchatka, Asia/Magadan, Etc/GMT-12, Kwajalein, NST, NZ, Pacific/Auckland, Pacific/Fiji, Pacific/Funafuti, Pacific/Kwajalein, Pacific/Majuro, Pacific/Nauru, Pacific/Tarawa, Pacific/Wake, Pacific/Wallis, NZ-CHAT, Pacific/Chatham, Etc/GMT-13, MIT, Pacific/Apia, Pacific/Enderbury, Pacific/Fakaofo, Pacific/Tongatapu, Etc/GMT-14, Pacific/Kiritimati 例如，创建上面第2个打印值“Etc/GMT+11”对应的TimeZone。方法如下： TimeZone tz = TimeZone.getTimeZone(&quot;Etc/GMT+11&quot;); TimeZone的函数接口 // 构造函数 TimeZone() Object clone() synchronized static String[] getAvailableIDs() synchronized static String[] getAvailableIDs(int offsetMillis) int getDSTSavings() synchronized static TimeZone getDefault() final String getDisplayName(Locale locale) String getDisplayName(boolean daylightTime, int style, Locale locale) final String getDisplayName() final String getDisplayName(boolean daylightTime, int style) String getID() abstract int getOffset(int era, int year, int month, int day, int dayOfWeek, int timeOfDayMillis) int getOffset(long time) abstract int getRawOffset() synchronized static TimeZone getTimeZone(String id) boolean hasSameRules(TimeZone timeZone) abstract boolean inDaylightTime(Date time) synchronized static void setDefault(TimeZone timeZone) void setID(String id) abstract void setRawOffset(int offsetMillis) abstract boolean useDaylightTime() 2. TimeZone示例下面通过示例演示在Date中使用TimeZone。 参考代码如下(TimeZoneTest.java)： import java.text.DateFormat; import java.util.Date; import java.util.TimeZone; /** * TimeZone的测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class TimeZoneTest { public static void main(String[] args) { // 测试创建TimeZone对象的3种方法 showUsageOfTimeZones() ; // 测试TimeZone的其它API testOtherAPIs() ; // 打印getTimeZone(String id)支持的所有id //printAllTimeZones() ; } /** * 测试创建TimeZone对象的3种方法 */ public static void showUsageOfTimeZones() { TimeZone tz; // (01) 默认时区 tz = TimeZone.getDefault(); printDateIn(tz) ; // (02) 设置时区为&quot;GMT+08:00&quot; tz = TimeZone.getTimeZone(&quot;GMT+08:00&quot;); printDateIn(tz) ; // (03) 设置时区为&quot;&quot; tz = TimeZone.getTimeZone(&quot;Asia/Chongqing&quot;); printDateIn(tz) ; } /** * 打印 tz对应的日期/时间 */ private static void printDateIn(TimeZone tz) { // date为2013-09-19 14:22:30 Date date = new Date(113, 8, 19, 14, 22, 30); // 获取默认的DateFormat，用于格式化Date DateFormat df = DateFormat.getInstance(); // 设置时区为tz df.setTimeZone(tz); // 获取格式化后的字符串 String str = df.format(date); System.out.println(tz.getID()+&quot; :&quot;+str); } /** * 测试TimeZone的其它API */ public static void testOtherAPIs() { // 默认时区 TimeZone tz = TimeZone.getDefault(); // 获取“id” String id = tz.getID(); // 获取“显示名称” String name = tz.getDisplayName(); // 获取“时间偏移”。相对于“本初子午线”的偏移，单位是ms。 int offset = tz.getRawOffset(); // 获取“时间偏移” 对应的小时 int gmt = offset/(3600*1000); System.out.printf(&quot;id=%s, name=%s, offset=%s(ms), gmt=%s\\n&quot;, id, name, offset, gmt); } /** * 打印getTimeZone(String id)支持的所有id */ public static void printAllTimeZones() { String[] ids = TimeZone.getAvailableIDs(); for (String id:ids) { //int offset = TimeZone.getTimeZone(avaIds[i]).getRawOffset(); //System.out.println(i+&quot; &quot;+avaIds[i]+&quot; &quot;+offset / (3600 * 1000) + &quot;\\t&quot;); System.out.printf(id+&quot;, &quot;); } System.out.println(); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"Java 时间相关内容06 Locale","date":"2017-02-05T16:00:00.000Z","path":"2017/02/06/java-source-analysis-time-series/Java 时间相关内容06 Locale/","text":"本章介绍Locale。 目录1. Locale 介绍2. Locale示例 1. Locale 介绍Locale 表示地区。每一个Locale对象都代表了一个特定的地理、政治和文化地区。 在操作 Date, Calendar等表示日期/时间的对象时，经常会用到；因为不同的区域，时间表示方式都不同。 下面说说Locale对象的3种常用创建方式。 (01) 获取默认的Locale 使用方法： Locale locale = Locale.getDefault() (02) 直接使用Locale的静态对象 Locale.java中提供了以下静态对象 public static final Locale CANADA public static final Locale CANADA_FRENCH public static final Locale CHINA public static final Locale CHINESE public static final Locale ENGLISH public static final Locale FRANCE public static final Locale FRENCH public static final Locale GERMAN public static final Locale GERMANY public static final Locale ITALIAN public static final Locale ITALY public static final Locale JAPAN public static final Locale JAPANESE public static final Locale KOREA public static final Locale KOREAN public static final Locale PRC public static final Locale ROOT public static final Locale SIMPLIFIED_CHINESE public static final Locale TAIWAN public static final Locale TRADITIONAL_CHINESE public static final Locale UK public static final Locale US 使用方法：下面的Locale对象是对应 “中国(大陆)”的 Locale locale = Locale.SIMPLIFIED_CHINESE (03) 通过Locale的构造函数创建Locale对象 Locale的构造函数共有3个。如下： Locale(String language) Locale(String language, String country) Locale(String language, String country, String variant) 使用方法： Locale local = new Locale(&quot;zh&quot;, &quot;CN&quot;); Locale类支持非常多的国家和地区。我们可以通过以下方法，查看Locale支持的全部区域： Locale[] ls = Locale.getAvailableLocales(); for (Locale locale:ls) { System.out.println(&quot;locale :&quot;+locale); } 输入结果如下： All Locales: ja_JP, es_PE, en, ja_JP_JP, es_PA, sr_BA, mk, es_GT, ar_AE, no_NO, sq_AL, bg, ar_IQ, ar_YE, hu, pt_PT, el_CY, ar_QA, mk_MK, sv, de_CH, en_US, fi_FI, is, cs, en_MT, sl_SI, sk_SK, it, tr_TR, zh, th, ar_SA, no, en_GB, sr_CS, lt, ro, en_NZ, no_NO_NY, lt_LT, es_NI, nl, ga_IE, fr_BE, es_ES, ar_LB, ko, fr_CA, et_EE, ar_KW, sr_RS, es_US, es_MX, ar_SD, in_ID, ru, lv, es_UY, lv_LV, iw, pt_BR, ar_SY, hr, et, es_DO, fr_CH, hi_IN, es_VE, ar_BH, en_PH, ar_TN, fi, de_AT, es, nl_NL, es_EC, zh_TW, ar_JO, be, is_IS, es_CO, es_CR, es_CL, ar_EG, en_ZA, th_TH, el_GR, it_IT, ca, hu_HU, fr, en_IE, uk_UA, pl_PL, fr_LU, nl_BE, en_IN, ca_ES, ar_MA, es_BO, en_AU, sr, zh_SG, pt, uk, es_SV, ru_RU, ko_KR, vi, ar_DZ, vi_VN, sr_ME, sq, ar_LY, ar, zh_CN, be_BY, zh_HK, ja, iw_IL, bg_BG, in, mt_MT, es_PY, sl, fr_FR, cs_CZ, it_CH, ro_RO, es_PR, en_CA, de_DE, ga, de_LU, de, es_AR, sk, ms_MY, hr_HR, en_SG, da, mt, pl, ar_OM, tr, th_TH_TH, el, ms, sv_SE, da_DK, es_HN 下面选择其中的两个进行说明，如何利用它们来创建Locale对象：例如，第一个输出是“ja_JP”。 其中，ja代表“语言”，这里指日语；“JP”代表国家，这里指日本。我们可以通过如下方法，创建“语言是日语，国家是日本的Locale对象”。 Locale locale = new Locale(&quot;ja&quot;, &quot;JP&quot;); 例如，第三个输出是“en”。 其中，en代表“语言”，这里指英语。我们可以通过如下方法，创建“语言是英文的Locale对象”。 Locale locale = new Locale(&quot;en&quot;); Locale 函数列表 // Locale的构造函数 Locale(String language) Locale(String language, String country) Locale(String language, String country, String variant) Object clone() boolean equals(Object object) static Locale[] getAvailableLocales() String getCountry() static Locale getDefault() String getDisplayCountry(Locale locale) final String getDisplayCountry() final String getDisplayLanguage() String getDisplayLanguage(Locale locale) String getDisplayName(Locale locale) final String getDisplayName() final String getDisplayVariant() String getDisplayVariant(Locale locale) String getISO3Country() String getISO3Language() static String[] getISOCountries() static String[] getISOLanguages() String getLanguage() String getVariant() synchronized int hashCode() synchronized static void setDefault(Locale locale) final String toString() 2. Locale示例下面通过示例演示在Date中使用Locale的。参考代码如下(LocaleTest.java)： import java.util.Locale; import java.util.Date; import java.util.Calendar; import java.text.SimpleDateFormat; import java.text.DateFormat; /** * Locale 的测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class LocaleTest { public static void main(String[] args) { // 2种不同的Locale的创建方法 testDiffDateLocales(); // 显示所有的Locales testAllLocales(); } /** * 2种不同的Locale的创建方法 */ private static void testDiffDateLocales() { // date为2013-09-19 14:22:30 Date date = new Date(113, 8, 19, 14, 22, 30); // 创建“简体中文”的Locale Locale localeCN = Locale.SIMPLIFIED_CHINESE; // 创建“英文/美国”的Locale Locale localeUS = new Locale(&quot;en&quot;, &quot;US&quot;); // 获取“简体中文”对应的date字符串 String cn = DateFormat.getDateInstance(DateFormat.MEDIUM, localeCN).format(date); // 获取“英文/美国”对应的date字符串 String us = DateFormat.getDateInstance(DateFormat.MEDIUM, localeUS).format(date); System.out.printf(&quot;cn=%s\\nus=%s\\n&quot;, cn, us); } /** * 显示所有的Locales */ private static void testAllLocales() { Locale[] ls = Locale.getAvailableLocales(); System.out.print(&quot;All Locales: &quot;); for (Locale locale:ls) { System.out.printf(locale+&quot;, &quot;); } System.out.println(); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"Java 时间相关内容05 SimpleDateFormat","date":"2017-02-04T16:00:00.000Z","path":"2017/02/05/java-source-analysis-time-series/Java 时间相关内容05 SimpleDateFormat/","text":"本章介绍SimpleDateFormat 目录1. SimpleDateFormat 介绍2. SimpleDateFormat 相关格式说明3. SimpleDateFormat 示例 1. SimpleDateFormat 介绍SimpleDateFormat 是一个格式化Date 以及 解析日期字符串 的工具。它的最常用途是，能够按照指定的格式来对Date进行格式化，然后我们使用可以格式化Date后得到的字符串。 更严格的说，SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 SimpleDateFormat的构造函数： // 构造函数 SimpleDateFormat() SimpleDateFormat(String pattern) SimpleDateFormat(String template, DateFormatSymbols value) SimpleDateFormat(String template, Locale locale) 非构造函数 void applyLocalizedPattern(String template) void applyPattern(String template) Object clone() boolean equals(Object object) StringBuffer format(Date date, StringBuffer buffer, FieldPosition fieldPos) AttributedCharacterIterator formatToCharacterIterator(Object object) Date get2DigitYearStart() DateFormatSymbols getDateFormatSymbols() int hashCode() Date parse(String string, ParsePosition position) void set2DigitYearStart(Date date) void setDateFormatSymbols(DateFormatSymbols value) String toLocalizedPattern() String toPattern() SimpleDateFormat 简单示范： // 新建date对象，时间是2013-09-19 Date date = new Date(113,8,19); // 新建“SimpleDateFormat对象”，并设置 sdf 的“格式化模式” SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); // 用 sdf 格式化 date，并返回字符串。 String str = sdf.format(date); 2. SimpleDateFormat 相关格式说明2.1 日期和时间模式日期和时间格式由日期和时间模式 字符串指定。在日期和时间模式字符串中，未加引号的字母 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’ 被解释为模式字母，用来表示日期或时间字符串元素。文本可以使用单引号 (‘) 引起来，以免进行解释。”‘’” 表示单引号。所有其他字符均不解释；只是在格式化时将它们简单复制到输出字符串，或者在解析时与输入字符串进行匹配。 定义了以下模式字母（所有其他字符 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’ 都被保留）： 字母 日期或时间元素 表示 示例 G Era 标志符 Text AD y 年 Year 1996; 96 M 年中的月份 Month July; Jul; 07 w 年中的周数 Number 27 W 月份中的周数 Number 2 D 年中的天数 Number 189 d 月份中的天数 Number 10 F 月份中的星期 Number 2 E 星期中的天数 Text Tuesday; Tue a Am/pm 标记 Text PM H 一天中的小时数（0-23） Number 0 k 一天中的小时数（1-24） Number 24 K am/pm 中的小时数（0-11） Number 0 h am/pm 中的小时数（1-12） Number 12 m 小时中的分钟数 Number 30 s 分钟中的秒数 Number 55 S 毫秒数 Number 978 z 时区 General time zone Pacific Standard Time; PST; GMT-08:00 Z 时区 RFC 822 time zone -0800 模式字母通常是重复的，其数量确定其精确表示： Text: 对于格式化来说，如果模式字母的数量大于等于 4，则使用完全形式；否则，在可用的情况下使用短形式或缩写形式。对于解析来说，两种形式都是可接受的，与模式字母的数量无关。Number: 对于格式化来说，模式字母的数量是最小的数位，如果数位不够，则用 0 填充以达到此数量。对于解析来说，模式字母的数量被忽略，除非必须分开两个相邻字段。Year: 如果格式器的 Calendar 是格里高利历，则应用以下规则。Month: 如果模式字母的数量为 3 或大于 3，则将月份解释为 text；否则解释为 number。 &nbsp;&nbsp;&nbsp;&nbsp; 对于格式化来说，如果模式字母的数量为 2，则年份截取为 2 位数,否则将年份解释为 number。 &nbsp;&nbsp;&nbsp;&nbsp; 对于解析来说，如果模式字母的数量大于 2，则年份照字面意义进行解释，而不管数位是多少。因此使用模式 “MM/dd/yyyy”，将 “01/11/12” 解析为公元 12 年 1 月 11 日。 &nbsp;&nbsp;&nbsp;&nbsp; 在解析缩写年份模式（”y” 或 “yy”）时，SimpleDateFormat 必须相对于某个世纪来解释缩写的年份。这通过将日期调整为 SimpleDateFormat 实例创建之前的 80 年和之后 20 年范围内来完成。例如，在 “MM/dd/yy” 模式下，如果 SimpleDateFormat 实例是在 1997 年 1 月 1 日创建的，则字符串 “01/11/12” 将被解释为 2012 年 1 月 11 日，而字符串 “05/04/64” 将被解释为 1964 年 5 月 4 日。在解析时，只有恰好由两位数字组成的字符串（如 Character#isDigit(char) 所定义的）被解析为默认的世纪。其他任何数字字符串将照字面意义进行解释，例如单数字字符串，3 个或更多数字组成的字符串，或者不都是数字的两位数字字符串（例如”-1”）。因此，在相同的模式下， “01/02/3” 或 “01/02/003” 解释为公元 3 年 1 月 2 日。同样，”01/02/-3” 解析为公元前 4 年 1 月 2 日。否则，则应用日历系统特定的形式。对于格式化和解析，如果模式字母的数量为 4 或大于 4，则使用日历特定的 long form。否则，则使用日历特定的 short or abbreviated form。 SimpleDateFormat 还支持本地化日期和时间模式 字符串。在这些字符串中，以上所述的模式字母可以用其他与语言环境有关的模式字母来替换。SimpleDateFormat 不处理除模式字母之外的文本本地化；而由类的客户端来处理。 示例 以下示例显示了如何在美国语言环境中解释日期和时间模式。给定的日期和时间为美国太平洋时区的本地时间 2001-07-04 12:08:56。 日期和时间模式 结果 “yyyy.MM.dd G ‘at’ HH:mm:ss z” 2001.07.04 AD at 12:08:56 PDT “EEE, MMM d, ‘’yy” Wed, Jul 4, ‘01 “h:mm a” 12:08 PM “hh ‘o’’clock’ a, zzzz” 12 o’clock PM, Pacific Daylight Time “K:mm a, z” 0:08 PM, PDT “yyyyy.MMMMM.dd GGG hh:mm aaa” 02001.July.04 AD 12:08 PM “EEE, d MMM yyyy HH:mm:ss Z” Wed, 4 Jul 2001 12:08:56 -0700 “yyMMddHHmmssZ” 010704120856-0700 “yyyy-MM-dd’T’HH:mm:ss.SSSZ” 2001-07-04T12:08:56.235-0700 日期格式是不同步的。建议为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须是外部同步的。 3. SimpleDateFormat 示例下面，我们通过实例学习如何使用SimpleDateFormat。 源码如下(SimpleDateFormatTest.java)： import java.util.Date; import java.util.Locale; import java.util.Calendar; import java.text.DateFormat; import java.text.SimpleDateFormat; /** * SimpleDateFormat 的API测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class SimpleDateFormatTest { public static void main(String[] args) { // 通过SimpleDateFormat 获取日期/时间：有多种格式 testSimpleDateFormats() ; // 通过DateFormat 获取日期/时间 superTest() ; } /** * 通过SimpleDateFormat 获取日期/时间。有多种格式可以选择 */ private static void testSimpleDateFormats() { String[] formats = new String[] { &quot;HH:mm&quot;, // 14:22 &quot;h:mm a&quot;, // 2:22 下午 &quot;HH:mm z&quot;, // 14:22 CST &quot;HH:mm Z&quot;, // 14:22 +0800 &quot;HH:mm zzzz&quot;, // 14:22 中国标准时间 &quot;HH:mm:ss&quot;, // 14:22:30 &quot;yyyy-MM-dd&quot;, // 2013-09-19 &quot;yyyy-MM-dd HH:mm&quot;, // 2013-09-19 14:22 &quot;yyyy-MM-dd HH:mm:ss&quot;, // 2013-09-19 14:22:30 &quot;yyyy-MM-dd HH:mm:ss zzzz&quot;, // 2013-09-19 14:22:30 中国标准时间 &quot;EEEE yyyy-MM-dd HH:mm:ss zzzz&quot;, // 星期四 2013-09-19 14:22:30 中国标准时间 &quot;yyyy-MM-dd HH:mm:ss.SSSZ&quot;, // 2013-09-19 14:22:30.000+0800 &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot;, // 2013-09-19T14:22:30.000+0800 &quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot;, // 2013.09.19 公元 at 14:22:30 CST &quot;K:mm a&quot;, // 2:22 下午, CST &quot;EEE, MMM d, &apos;&apos;yy&quot;, // 星期四, 九月 19, &apos;13 &quot;hh &apos;o&apos;&apos;clock&apos; a, zzzz&quot;, // 02 o&apos;clock 下午, 中国标准时间 &quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;, // 02013.九月.19 公元 02:22 下午 &quot;EEE, d MMM yyyy HH:mm:ss Z&quot;, // 星期四, 19 九月 2013 14:22:30 +0800 &quot;yyMMddHHmmssZ&quot;, // 130919142230+0800 &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot;, // 2013-09-19T14:22:30.000+0800 &quot;EEEE &apos;DATE(&apos;yyyy-MM-dd&apos;)&apos; &apos;TIME(&apos;HH:mm:ss&apos;)&apos; zzzz&quot;, // 星期四 2013-09-19 14:22:30 中国标准时间 }; //Date date = (new Date(0)); // date为1970-01-01 07:00:00 //Date date = Calendar.getInstance().getTime(); // date为当前时间 Date date = new Date(113, 8, 19, 14, 22, 30); // date为2013-09-19 14:22:30 for (String format : formats) { SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.SIMPLIFIED_CHINESE); //SimpleDateFormat sdf = new SimpleDateFormat(format); System.out.format(&quot;%30s %s\\n&quot;, format, sdf.format(date)); } } /** * 通过DateFormat 获取日期/时间 */ private static void superTest() { // 新建date对象，时间是2013-09-19 14:22:30 // (01) 年=“‘目标年’ - 1900”， // (02) 月。 0是一月，1是二月，依次类推。 // (03) 日。 1-31之间的数 Date mDate = new Date(113, 8, 19, 14, 22, 30); Locale locale = new Locale(&quot;zh&quot;, &quot;CN&quot;); // 14:22:30 String time = DateFormat.getTimeInstance( DateFormat.MEDIUM, Locale.SIMPLIFIED_CHINESE).format(mDate); // 2013-09-19 String date = DateFormat.getDateInstance( DateFormat.MEDIUM, Locale.SIMPLIFIED_CHINESE).format(mDate); // 2013-09-19 14:22:30 String datetime = DateFormat.getDateTimeInstance( DateFormat.MEDIUM, DateFormat.MEDIUM, Locale.SIMPLIFIED_CHINESE).format(mDate); System.out.printf(&quot;\\ntime=%s\\ndate=%s\\ndatetime=%s\\n&quot;,time,date,datetime); } } 运行结果： HH:mm 14:22 h:mm a 2:22 下午 HH:mm z 14:22 CST HH:mm Z 14:22 +0800 HH:mm zzzz 14:22 中国标准时间 HH:mm:ss 14:22:30 yyyy-MM-dd 2013-09-19 yyyy-MM-dd HH:mm 2013-09-19 14:22 yyyy-MM-dd HH:mm:ss 2013-09-19 14:22:30 yyyy-MM-dd HH:mm:ss zzzz 2013-09-19 14:22:30 中国标准时间 EEEE yyyy-MM-dd HH:mm:ss zzzz 星期四 2013-09-19 14:22:30 中国标准时间 yyyy-MM-dd HH:mm:ss.SSSZ 2013-09-19 14:22:30.000+0800 yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ 2013-09-19T14:22:30.000+0800 yyyy.MM.dd G &apos;at&apos; HH:mm:ss z 2013.09.19 公元 at 14:22:30 CST K:mm a 2:22 下午 EEE, MMM d, &apos;&apos;yy 星期四, 九月 19, &apos;13 hh &apos;o&apos;&apos;clock&apos; a, zzzz 02 o&apos;clock 下午, 中国标准时间 yyyyy.MMMMM.dd GGG hh:mm aaa 02013.九月.19 公元 02:22 下午 EEE, d MMM yyyy HH:mm:ss Z 星期四, 19 九月 2013 14:22:30 +0800 yyMMddHHmmssZ 130919142230+0800 yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ 2013-09-19T14:22:30.000+0800 EEEE &apos;DATE(&apos;yyyy-MM-dd&apos;)&apos; &apos;TIME(&apos;HH:mm:ss&apos;)&apos; zzzz 星期四 DATE(2013-09-19) TIME(14:22:30) 中国标准时间 time=14:22:30 date=2013-9-19 datetime=2013-9-19 14:22:30","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"Java 时间相关内容04 DateFormat","date":"2017-02-03T16:00:00.000Z","path":"2017/02/04/java-source-analysis-time-series/Java 时间相关内容04 DateFormat/","text":"本章主要介绍DateFormat。 目录1. DateFormat 介绍2. DateFormat 实例 1. DateFormat 介绍DateFormat 的作用是 格式化并解析“日期/时间”。实际上，它是Date的格式化工具，它能帮助我们格式化Date，进而将Date转换成我们想要的String字符串供我们使用 不过DateFormat的格式化Date的功能有限，没有SimpleDateFormat强大；但DateFormat是SimpleDateFormat的父类。所以，我们先对DateFormat有个整体了解，然后再学习SimpleDateFormat。 DateFormat 的作用是格式化Date。它支持格式化风格包括 FULL、LONG、MEDIUM 和 SHORT 共4种：(01) DateFormat.SHORT&nbsp;&nbsp;&nbsp;&nbsp; 完全为数字，如 12.13.52 或 3:30pm(02) DateFormat.MEDIUM&nbsp;&nbsp;&nbsp;&nbsp; 较长，如 Jan 12, 1952(03) DateFormat.LONG&nbsp;&nbsp;&nbsp;&nbsp; 更长，如 January 12, 1952 或 3:30:32pm(04) DateFormat.FULL&nbsp;&nbsp;&nbsp;&nbsp; 是完全指定，如 Tuesday、April 12、1952 AD 或 3:30:42pm PST。 DateFormat 的定义如下 public abstract class NumberFormat extends Format {} DateFormat 的函数接口 // 默认构造函数 DateFormat() // 非构造函数 Object clone() boolean equals(Object object) abstract StringBuffer format(Date date, StringBuffer buffer, FieldPosition field) final StringBuffer format(Object object, StringBuffer buffer, FieldPosition field) final String format(Date date) static Locale[] getAvailableLocales() Calendar getCalendar() final static DateFormat getInstance() final static DateFormat getDateInstance() final static DateFormat getDateInstance(int style) final static DateFormat getDateInstance(int style, Locale locale) final static DateFormat getTimeInstance() final static DateFormat getTimeInstance(int style) final static DateFormat getTimeInstance(int style, Locale locale) final static DateFormat getDateTimeInstance() final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle) final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) NumberFormat getNumberFormat() TimeZone getTimeZone() int hashCode() boolean isLenient() Date parse(String string) abstract Date parse(String string, ParsePosition position) Object parseObject(String string, ParsePosition position) void setCalendar(Calendar cal) void setLenient(boolean value) void setNumberFormat(NumberFormat format) void setTimeZone(TimeZone timezone) 注意：DateFormat是一个抽象类。 当我们通过DateFormat的 getInstance(), getDateInstance()和getDateTimeInstance() 获取DateFormat实例时；实际上是返回的SimpleDateFormat对象。下面的函数实际上都是返回的SimpleDateFormat对象。 final static DateFormat getInstance() final static DateFormat getTimeInstance() final static DateFormat getTimeInstance(int style) final static DateFormat getTimeInstance(int style, Locale locale) final static DateFormat getDateInstance() final static DateFormat getDateInstance(int style) final static DateFormat getDateInstance(int style, Locale locale) final static DateFormat getDateTimeInstance() final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle) final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) 这些函数在SimpleDateFormat.java中的定义如下： public static final int FULL = 0; public static final int LONG = 1; public static final int MEDIUM = 2; public static final int SHORT = 3; public static final int DEFAULT = MEDIUM; public final static DateFormat getInstance() { return getDateTimeInstance(SHORT, SHORT); } public final static DateFormat getTimeInstance() { return get(DEFAULT, 0, 1, Locale.getDefault()); } public final static DateFormat getTimeInstance(int style) { return get(style, 0, 1, Locale.getDefault()); } public final static DateFormat getTimeInstance(int style, Locale aLocale) { return get(style, 0, 1, aLocale); } public final static DateFormat getDateInstance() { return get(0, DEFAULT, 2, Locale.getDefault()); } public final static DateFormat getDateInstance(int style) { return get(0, style, 2, Locale.getDefault()); } public final static DateFormat getDateInstance(int style, Locale aLocale) { return get(0, style, 2, aLocale); } public final static DateFormat getDateTimeInstance() { return get(DEFAULT, DEFAULT, 3, Locale.getDefault()); } public final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle) { return get(timeStyle, dateStyle, 3, Locale.getDefault()); } public final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale) { return get(timeStyle, dateStyle, 3, aLocale); } /** * 获取DateFormat实例，实际上是返回SimpleDateFormat对象。 * * timeStyle -- 值可以为“FULL”或“LONG”或“MEDIUM”或“SHORT” * dateStyle -- 值可以为“FULL”或“LONG”或“MEDIUM”或“SHORT” * flags -- 值可以为“1”或“2”或“3”。 * 1 表示获取“时间样式” * 2 表示获取“日期样式” * 3 表示获取“时间和日期样式” * loc -- locale对象，表示“区域” */ private static DateFormat get(int timeStyle, int dateStyle, int flags, Locale loc) { if ((flags &amp; 1) != 0) { if (timeStyle &lt; 0 || timeStyle &gt; 3) { throw new IllegalArgumentException(&quot;Illegal time style &quot; + timeStyle); } } else { timeStyle = -1; } if ((flags &amp; 2) != 0) { if (dateStyle &lt; 0 || dateStyle &gt; 3) { throw new IllegalArgumentException(&quot;Illegal date style &quot; + dateStyle); } } else { dateStyle = -1; } try { // Check whether a provider can provide an implementation that&apos;s closer // to the requested locale than what the Java runtime itself can provide. LocaleServiceProviderPool pool = LocaleServiceProviderPool.getPool(DateFormatProvider.class); if (pool.hasProviders()) { DateFormat providersInstance = pool.getLocalizedObject( DateFormatGetter.INSTANCE, loc, timeStyle, dateStyle, flags); if (providersInstance != null) { return providersInstance; } } return new SimpleDateFormat(timeStyle, dateStyle, loc); } catch (MissingResourceException e) { return new SimpleDateFormat(&quot;M/d/yy h:mm a&quot;); } } 通过上面的代码，我们能够进一步的认识到：DateFormat的作用是格式化Date；帮助我们将Date转换成我们需要的String字符串。DateFormat提供的功能非常有限，它只能支持FULL、LONG、MEDIUM 和 SHORT 这4种格式。而且，我们获取DateFormat实例时，实际上是返回的SimpleDateFormat对象。 2. DateFormat 实例下面，我们通过实例学习使用DateFormat的常用API。 源码如下(DateFormatTest.java): import java.util.Date; import java.util.Locale; import java.text.DateFormat; import java.text.FieldPosition; /** * DateFormat 的API测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class DateFormatTest { public static void main(String[] args) { // 只显示“时间”：调用getTimeInstance()函数 testGetTimeInstance() ; // 只显示“日期”：调用getDateInstance()函数 testGetDateInstance() ; // 显示“日期”+“时间”：调用getDateTimeInstance()函数 testGetDateTimeInstance() ; // 测试format()函数 testFormat(); } /** * 测试DateFormat的getTimeInstance()函数 * 它共有3种重载形式： * (01) getTimeInstance() * (02) getTimeInstance(int style) * (03) getTimeInstance(int style, Locale locale) * * @author skywang */ private static void testGetTimeInstance() { Date date = new Date(); //Locale locale = new Locale(&quot;fr&quot;, &quot;FR&quot;); Locale locale = new Locale(&quot;zh&quot;, &quot;CN&quot;); // 等价于 DateFormat.getTimeInstance( DateFormat.MEDIUM); DateFormat short0 = DateFormat.getTimeInstance( ); // 参数是：“时间的显示样式” DateFormat short1 = DateFormat.getTimeInstance( DateFormat.SHORT); DateFormat medium1 = DateFormat.getTimeInstance( DateFormat.MEDIUM); DateFormat long1 = DateFormat.getTimeInstance( DateFormat.LONG); DateFormat full1 = DateFormat.getTimeInstance( DateFormat.FULL); // 参数是：“时间的显示样式” 和 “地区” DateFormat short2 = DateFormat.getTimeInstance( DateFormat.SHORT, locale); DateFormat medium2 = DateFormat.getTimeInstance( DateFormat.MEDIUM, locale); DateFormat long2 = DateFormat.getTimeInstance( DateFormat.LONG, locale); DateFormat full2 = DateFormat.getTimeInstance( DateFormat.FULL, locale); System.out.println(&quot;\\n----getTimeInstance ----\\n&quot; + &quot;(1.0) Empty Param : &quot; + short0.format(date) +&quot;\\n&quot; + &quot;(2.1) One Param(s) : &quot; + short1.format(date) +&quot;\\n&quot; + &quot;(2.2) One Param(m) : &quot; + medium1.format(date) +&quot;\\n&quot; + &quot;(2.3) One Param(l) : &quot; + long1.format(date) +&quot;\\n&quot; + &quot;(2.4) One Param(f) : &quot; + full1.format(date) +&quot;\\n&quot; + &quot;(3.1) One Param(s,l): &quot; + short2.format(date) +&quot;\\n&quot; + &quot;(3.2) One Param(m,l): &quot; + medium2.format(date) +&quot;\\n&quot; + &quot;(3.3) One Param(l,l): &quot; + long2.format(date) +&quot;\\n&quot; + &quot;(3.4) One Param(f,l): &quot; + full2.format(date) +&quot;\\n&quot; ); } /** * 测试DateFormat的getDateTimeInstance()函数 * 它共有3种重载形式： * (01) getDateInstance() * (02) getDateInstance(int style) * (03) getDateInstance(int style, Locale locale) */ public static void testGetDateTimeInstance() { Date date = new Date(); Locale locale = new Locale(&quot;zh&quot;, &quot;CN&quot;); // 等价于 DateFormat.getDateTimeInstance( DateFormat.MEDIUM); DateFormat short0 = DateFormat.getDateTimeInstance( ); DateFormat short1 = DateFormat.getDateTimeInstance( DateFormat.SHORT, DateFormat.SHORT); DateFormat medium1 = DateFormat.getDateTimeInstance( DateFormat.MEDIUM, DateFormat.MEDIUM); DateFormat long1 = DateFormat.getDateTimeInstance( DateFormat.LONG, DateFormat.LONG); DateFormat full1 = DateFormat.getDateTimeInstance( DateFormat.FULL, DateFormat.FULL); DateFormat short2 = DateFormat.getDateTimeInstance( DateFormat.SHORT, DateFormat.SHORT, locale); DateFormat medium2 = DateFormat.getDateTimeInstance( DateFormat.MEDIUM, DateFormat.MEDIUM, locale); DateFormat long2 = DateFormat.getDateTimeInstance( DateFormat.LONG, DateFormat.LONG, locale); DateFormat full2 = DateFormat.getDateTimeInstance( DateFormat.FULL, DateFormat.FULL, locale); System.out.println(&quot;\\n----getDateTimeInstance ----\\n&quot; + &quot;(1.0) Empty Param : &quot; + short0.format(date) +&quot;\\n&quot; + &quot;(2.1) One Param(s) : &quot; + short1.format(date) +&quot;\\n&quot; + &quot;(2.2) One Param(m) : &quot; + medium1.format(date) +&quot;\\n&quot; + &quot;(2.3) One Param(l) : &quot; + long1.format(date) +&quot;\\n&quot; + &quot;(2.4) One Param(f) : &quot; + full1.format(date) +&quot;\\n&quot; + &quot;(3.1) One Param(s,l): &quot; + short2.format(date) +&quot;\\n&quot; + &quot;(3.2) One Param(m,l): &quot; + medium2.format(date) +&quot;\\n&quot; + &quot;(3.3) One Param(l,l): &quot; + long2.format(date) +&quot;\\n&quot; + &quot;(3.4) One Param(f,l): &quot; + full2.format(date) +&quot;\\n&quot; ); } /** * 测试DateFormat的getDateInstance()函数 * 它共有3种重载形式： * (01) getDateTimeInstance() * (02) getDateTimeInstance(int dateStyle, int timeStyle) * (03) getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) */ public static void testGetDateInstance() { Date date = new Date(); //Locale locale = new Locale(&quot;en&quot;, &quot;US&quot;); Locale locale = new Locale(&quot;zh&quot;, &quot;CN&quot;); // 等价于 DateFormat.getDateInstance( DateFormat.MEDIUM); DateFormat short0 = DateFormat.getDateInstance( ); DateFormat short1 = DateFormat.getDateInstance( DateFormat.SHORT); DateFormat medium1 = DateFormat.getDateInstance( DateFormat.MEDIUM); DateFormat long1 = DateFormat.getDateInstance( DateFormat.LONG); DateFormat full1 = DateFormat.getDateInstance( DateFormat.FULL); DateFormat short2 = DateFormat.getDateInstance( DateFormat.SHORT, locale); DateFormat medium2 = DateFormat.getDateInstance( DateFormat.MEDIUM, locale); DateFormat long2 = DateFormat.getDateInstance( DateFormat.LONG, locale); DateFormat full2 = DateFormat.getDateInstance( DateFormat.FULL, locale); System.out.println(&quot;\\n----getDateInstance ----\\n&quot; + &quot;(1.0) Empty Param : &quot; + short0.format(date) +&quot;\\n&quot; + &quot;(2.1) One Param(s) : &quot; + short1.format(date) +&quot;\\n&quot; + &quot;(2.2) One Param(m) : &quot; + medium1.format(date) +&quot;\\n&quot; + &quot;(2.3) One Param(l) : &quot; + long1.format(date) +&quot;\\n&quot; + &quot;(2.4) One Param(f) : &quot; + full1.format(date) +&quot;\\n&quot; + &quot;(3.1) One Param(s,l): &quot; + short2.format(date) +&quot;\\n&quot; + &quot;(3.2) One Param(m,l): &quot; + medium2.format(date) +&quot;\\n&quot; + &quot;(3.3) One Param(l,l): &quot; + long2.format(date) +&quot;\\n&quot; + &quot;(3.4) One Param(f,l): &quot; + full2.format(date) +&quot;\\n&quot; ); } /** * 测试DateFormat的format()函数 */ public static void testFormat() { Date date = new Date(); StringBuffer sb = new StringBuffer(); FieldPosition field = new FieldPosition(DateFormat.YEAR_FIELD); DateFormat format = DateFormat.getDateTimeInstance(); sb = format.format(date, sb, field); System.out.println(&quot;\\ntestFormat&quot;); System.out.printf(&quot;sb=%s\\n&quot;, sb); } } 运行结果： ----getTimeInstance ---- (1.0) Empty Param : 4:54:22 PM (2.1) One Param(s) : 4:54 PM (2.2) One Param(m) : 4:54:22 PM (2.3) One Param(l) : 4:54:22 PM CST (2.4) One Param(f) : 4:54:22 PM CST (3.1) One Param(s,l): 下午4:54 (3.2) One Param(m,l): 16:54:22 (3.3) One Param(l,l): 下午04时54分22秒 (3.4) One Param(f,l): 下午04时54分22秒 CST ----getDateInstance ---- (1.0) Empty Param : Jan 23, 2014 (2.1) One Param(s) : 1/23/14 (2.2) One Param(m) : Jan 23, 2014 (2.3) One Param(l) : January 23, 2014 (2.4) One Param(f) : Thursday, January 23, 2014 (3.1) One Param(s,l): 14-1-23 (3.2) One Param(m,l): 2014-1-23 (3.3) One Param(l,l): 2014年1月23日 (3.4) One Param(f,l): 2014年1月23日 星期四 ----getDateTimeInstance ---- (1.0) Empty Param : Jan 23, 2014 4:54:23 PM (2.1) One Param(s) : 1/23/14 4:54 PM (2.2) One Param(m) : Jan 23, 2014 4:54:23 PM (2.3) One Param(l) : January 23, 2014 4:54:23 PM CST (2.4) One Param(f) : Thursday, January 23, 2014 4:54:23 PM CST (3.1) One Param(s,l): 14-1-23 下午4:54 (3.2) One Param(m,l): 2014-1-23 16:54:23 (3.3) One Param(l,l): 2014年1月23日 下午04时54分23秒 (3.4) One Param(f,l): 2014年1月23日 星期四 下午04时54分23秒 CST testFormat sb=Jan 23, 2014 4:54:23 PM OK。至此，对DateFormat的学习到此为止。接下来，我们开始学习SimpleDateFormat，它才是格式化Date需要重点了解的。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"Java 时间相关内容03 Date","date":"2017-02-02T16:00:00.000Z","path":"2017/02/03/java-source-analysis-time-series/Java 时间相关内容03 Date/","text":"本章主要介绍Date类，并通过示例学习如何使用它。最后，讲解一下UTC、GMT和时区的关系。 目录第1部分 Date介绍第2部分 Date示例第3部分 GMT、UTC、时区的关系 第1部分 Date介绍1. Date 定义public class Date implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt; {} Date 是表示时间的类。一个Date对象表示一个特定的瞬间，能精确到毫秒。我们可以通过这个特定的瞬间，来获取到Date对应的“年、月、日、时、分、秒”。反之亦然，我们也可以通过设置Date的“年、月、日、时、分、秒”等信息，来改变Date所指定的特定瞬间。除了“年月日时分秒”等信息之外，Data也允许格式化和解析日期字符串。即，我们可以定义一个字符串，这个字符串包含时间信息，然后将字符串通过Date来解析，从而得到相应的Date对象。 在 JDK 1.1 之前，通常是通过Data操作“年月日时分秒”。不过，由于Date的相关 API 不易于实现国际化。从 JDK 1.1 开始，应该使用 Calendar 类来操作“年月日时分秒”，同时可以通过 DateFormat 类来格式化和解析日期字符串。Date 中的相应方法已废弃。 2. Date和Calendar相互转换(01) Date转换为Calendar // 新建date，且日期/时间为2013-09-19 14:22:30 Date date = new Date(113, 8, 19, 14, 22, 30); // 新建Calendar对象，并设置日期为date Calendar cal = Calendar.getInstance(); cal.setTime(date); (02) Calendar换为Date // 新建Calendar对象 Calendar cal = Calendar.getInstance(); // 获取Calendar对应的Date Date date = cal.getTime(); 3. Date函数列表Date 共包含下面5个构造函数 // Date构造函数一：传入“年、月、日” // (01) 年 -- 减 1900 的年份。若要设为1988，则“年”应该是88。 // (02) 月 -- 0-11 的月份。0是一月,1是二月,依次类推。 // (03) 日 -- 1-31 之间的某一天。 Date(int year, int month, int day) // Date构造函数二：传入“年、月、日、时、分” // (01) 年 -- 减 1900 的年份。若要设为1988，则“年”应该是88。 // (02) 月 -- 0-11 的月份。0是一月,1是二月,依次类推。 // (03) 日 -- 1-31 之间的某一天。 // (04) 时 -- 0-23 之间的小时数。 // (05) 分 -- 0-59 之间的分钟数。 Date(int year, int month, int day, int hour, int minute) // Date构造函数三：传入“年、月、日、时、分、秒” // (01) 年 -- 减 1900 的年份。若要设为1988，则“年”应该是88。 // (02) 月 -- 0-11 的月份。0是一月,1是二月,依次类推。 // (03) 日 -- 1-31 之间的某一天。 // (04) 时 -- 0-23 之间的小时数。 // (05) 分 -- 0-59 之间的分钟数。 // (06) 秒 -- 0-59 之间的秒钟数。 Date(int year, int month, int day, int hour, int minute, int second) // Date构造函数四：传入“毫秒”。 毫秒 = “目标时间” - “1970-01-01 00:00:00 GMT” Date(long milliseconds) // Date构造函数五：传入“字符串”。 Date(String string) Date的操作API // 根据参数确定日期和时间。这些参数被解释为年份、月份、月中某一天、一天中的某一小时、小时中某一分钟和分钟中的某一秒。 static long UTC(int year, int month, int day, int hour, int minute, int second) // 此日期是否在指定日期之后。 boolean after(Date date) // 此日期是否在指定日期之前 boolean before(Date date) // 返回此对象的副本。 Object clone() // 比较两个日期的顺序。 int compareTo(Date date) // 比较两个日期是否相等。 boolean equals(Object object) // 返回此 Date 对象表示的月份中的某一天。返回的值在 1 和 31 之间，表示包含或开始于此 Date 对象表示的时间的月份中的某一天（用本地时区进行解释）。 int getDate() // 返回此日期表示的周中的某一天。返回值 (0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday) 表示一周中的某一天 int getDay() // 返回此 Date 对象表示的小时。返回值是一个数字（0 至 23） int getHours() // 返回此日期所表示的小时已经过去的分钟数（用本地时区进行解释）。返回值在 0 和 59 之间。 int getMinutes() // 返回表示月份的数字，该月份包含或开始于此 Date 对象所表示的瞬间。返回的值在 0 和 11 之间。0为一月，1为二月，依次类推。 int getMonth() // 返回此日期所表示的分钟已经过去的秒数。返回的值在 0 和 61 之间。值 60 和 61 只可能发生在考虑了闰秒的 Java 虚拟机上。 int getSeconds() // 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 long getTime() // 返回相对于 UTC（相应于此 Date 对象表示的时间）的本地时区的偏移量（以分钟为单位）。 int getTimezoneOffset() // 返回一个值，此值是从包含或开始于此 Date 对象表示的瞬间的年份减去 1900 的结果（用本地时区进行解释）。 int getYear() // 哈希值 int hashCode() // 把字符串 s 解释为日期和时间的表示形式。 static long parse(String string) // 把此 Date 对象的月份中的某一天设置为指定值。 void setDate(int day) // 把此 Date 对象的小时设置为指定值。 void setHours(int hour) // 把此 Date 对象的分钟数设置为指定值。 void setMinutes(int minute) // 把此日期的月份设置为指定值。0为一月，1为二月，依次类推。 void setMonth(int month) // 把此 Date 的秒数设置为指定值。 void setSeconds(int second) // 设置此 Date 对象，以表示 1970 年 1 月 1 日 00:00:00 GMT 以后 time 毫秒的时间点。 void setTime(long milliseconds) // 把此 Date 对象的年份设置为指定的值加 1900。 void setYear(int year) // 返回GMT字符串 String toGMTString() // 返回本地字符串 String toLocaleString() // 返回字符串 String toString() 第2部分 Date示例下面我们通过示例学习使用Date的API。 源码如下(DateTest.java)： import java.util.Date; import java.util.Calendar; /** * java Date类的测试程序 * * 注意几点： * (01) Date中的“年” -- 读取/设置 到的年份值=“‘时间年份’ - 1900年” * (02) Date中的“月” -- 0是一月,1是二月,2是三月,依次类推。 * (03) Date中的“星期几” -- 1是周日,2是周一,3是周二,依次类推。 * * @author skywang */ public class DateTest { public static void main(String[] args) { // 测试Date的构造函数：Date共有5类构造函数 testDateConstructor(); // 测试Date类的“设置”、“读取”函数 testDateSet(); // 测试Date类的before(), after(), compareTo(), equals(), clone(), parse()等接口 testOtherDateAPIs(); } /** * 测试Date的构造函数：Date共有5类构造函数 */ private static void testDateConstructor() { Date date; // Date构造函数一：传入“年、月、日”。 // 参数说明 // (01) 年 -- 减 1900 的年份。若要设为1988，则“年”应该是88。 // (02) 月 -- 0-11 的月份。0是一月,1是二月,依次类推。 // (03) 日 -- 1-31 之间的某一天。 // 设置时间为“1988-08-08” date = new Date(88,7,8); System.out.printf(&quot;Constructor-1 : %s\\n&quot;, tostring(date)); // Date构造函数二：传入“年、月、日、时、分” // (01) 年 -- 减 1900 的年份。若要设为1988，则“年”应该是88。 // (02) 月 -- 0-11 的月份。0是一月,1是二月,依次类推。 // (03) 日 -- 1-31 之间的某一天。 // (04) 时 -- 0-23 之间的小时数。 // (05) 分 -- 0-59 之间的分钟数。 // 设置时间为“1999-09-09 19:19” date = new Date(99,8,9,19,19); System.out.printf(&quot;Constructor-2 : %s\\n&quot;, tostring(date)); // Date构造函数三：传入“年、月、日、时、分、秒” // (01) 年 -- 减 1900 的年份。若要设为1988，则“年”应该是88。 // (02) 月 -- 0-11 的月份。0是一月,1是二月,依次类推。 // (03) 日 -- 1-31 之间的某一天。 // (04) 时 -- 0-23 之间的小时数。 // (05) 分 -- 0-59 之间的分钟数。 // (06) 秒 -- 0-59 之间的秒钟数。 date = new Date(100,10,10,20,10,10); System.out.printf(&quot;Constructor-3 : %s\\n&quot;, tostring(date)); // Date构造函数四：传入“毫秒”。 毫秒 = “目标时间” - “1970-01-01 00:00:00 GMT” // 973858210000(ms) 对应时间 2000-10-10 8:10:10 date = new Date(973858210000l); System.out.printf(&quot;Constructor-4 : %s\\n&quot;, tostring(date)); // Date构造函数五：传入“字符串”。可以为以下几种格式： // (注意，year值 = “实际年份-1900”) // 1955-08-12 13:30:00 date = new Date(&quot;Sat, 12 Aug 95 13:30:00 GMT&quot;); System.out.printf(&quot;Constructor-5.1: %s\\n&quot;, tostring(date)); // 1955-08-12 13:30:00 date = new Date(&quot;12 Aug 95 13:30:00&quot;); System.out.printf(&quot;Constructor-5.2: %s\\n&quot;, tostring(date)); // 1955-08-12 date = new Date(&quot;12 Aug 95&quot;); System.out.printf(&quot;Constructor-5.3: %s\\n&quot;, tostring(date)); } /** * 测试Date类的“读取”函数 */ private static void testGet(Date date) { // “年”。减 1900 的年份。若为1988，则“年”是88。 int year = date.getYear(); // “月”。 0-11 的月份。0是一月,1是二月,依次类推。 int month = date.getMonth(); // “日” int day = date.getDate(); // “时” int hour = date.getHours(); // “分” int minute = date.getMinutes(); // “秒” int second = date.getSeconds(); // “星期(几)”。 周日是1,周一是2,周二是3,依次类推。 int weekday = date.getDay(); // “毫秒”。毫秒 = “目标时间” - “1970-01-01 00:00:00 GMT” long millis = date.getTime(); // “时区偏移”。相对于 UTC 的本地时区的偏移量（以分钟为单位）。 int timezoneoffset = date.getTimezoneOffset(); //System.out.printf(&quot;\\t!!!date get is: %s\\n&quot;, tostring(date)); System.out.println(&quot;\\t!!!get date: &quot;+year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second+&quot;\\t&quot;+millis+&quot;(ms)&quot;); } /** * 测试Date类的“设置”函数 */ private static void testDateSet() { // 新建date Date date = new Date(99,8,9); // 设置Date为“2013-09-19 15:28:30” // 设为“2013年”。传入值是“‘目标年份’ - ‘1900 的年份’” date.setYear(113); // 设为“8月”，传入的参数应该是8。因为，一月是0,二月是1,依次类推。 date.setMonth(8); // 设为“19日” date.setDate(19); // 设为“15”(上午)。采用的24时制；因此，若要设为上午3点，应该传入参数3。 date.setHours(11); // 设为“28分” date.setMinutes(28); // 设为“30秒” date.setSeconds(30); System.out.printf(&quot;new date-01 is: %s\\n&quot;, tostring(date)); // 测试Date的获取函数 testGet(date); // 设为“毫秒”，1379561310000(ms) 对应的时间是“2013-09-19 15:28:30” date.setTime(1379561310000l); System.out.printf(&quot;new date-02 is: %s\\n&quot;, tostring(date)); } /** * 测试Date类的before(), after(), compareTo(), equals(), clone(), parse()等接口 */ private static void testOtherDateAPIs() { // 初始化d1=2008-05-12, d2=2009-03-15。 Date d1 = new Date(108,4,12); System.out.printf(&quot;\\nd1 is: %s\\n&quot;, tostring(d1)); Date d2 = new Date(109,2,15); System.out.printf(&quot;d2 is: %s\\n&quot;, tostring(d2)); // 克隆 Date d3 = (Date) d1.clone(); System.out.printf(&quot;clone of d1 is: %s\\n&quot;, tostring(d3)); // d1 是否早于 d2 boolean isBefore = d1.before(d2); // d1 是否晚于 d2 boolean isAfter = d1.after(d2); // d1 是否等于 d2 boolean isEquals = d1.after(d2); // d1 和 d2 比较。 // 若d1 早于 d2，返回 -1 // 若d1 晚于 d2，返回 1 // 若d1 等于 d2，返回 0 int comp = d1.compareTo(d2); System.out.printf(&quot;isBefore=%s, isAfter=%s, isEquals=%s, comp=%s\\n&quot;, isBefore, isAfter, isEquals, comp); // parse接口 long millis = Date.parse(&quot;13 Mar 2009&quot;); // (注意，通过这种方式设置Date，获取的Year值是“实际年份-1900”) Date d4 = new Date(millis); System.out.printf(&quot;millis=%s, d4=%s\\n&quot;, millis, tostring(d4)); System.out.printf(&quot;d1.toGMTString()%s\\n&quot;, d1.toGMTString()); System.out.printf(&quot;d1.toLocaleString()%s\\n&quot;, d1.toLocaleString()); System.out.printf(&quot;d1.toString()%s\\n&quot;, d1.toString()); } /** * 将date转换Calendar对象，并返回实际的年月日。 */ private static String tostring(Date date) { // 获取Date对应的Calendar Calendar cal = Calendar.getInstance(); cal.setTime(date); int year = cal.get(Calendar.YEAR); int month = cal.get(Calendar.MONTH)+1; int day = cal.get(Calendar.DATE); int hour = cal.get(Calendar.HOUR); int minute = cal.get(Calendar.MINUTE); int second = cal.get(Calendar.SECOND); long millis = cal.getTimeInMillis(); return year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second+&quot;\\t&quot;+millis+&quot;(ms)&quot;; } } 第3部分 GMT、UTC、时区的关系许多人都知道两地时间表简称为GMT或UTC，而世界时区表则通称为World Time，那么GMT与UTC的实质原意又是为何？世界时区又是怎么区分的？面盘上密密麻麻的英文单字代表着什么意义与作用呢？这些都是新手在接触两地时间表或世界时区表时，脑海中所不断浮现的种种疑问，以下将带您一探时区奥妙的究竟。 世界时区及国际换日线示意图 全球24个时区的划分 相较于两地时间表，可以显示世界各时区时间和地名的世界时区表（World Time），就显得精密与复杂多了，通常世界时区表的表盘上会标示着全球24个时区的城市名称，但究竟这24个时区是如何产生的？过去世界各地原本各自订定当地时间，但随着交通和电讯的发达，各地交流日益频繁，不同的地方时间，造成许多困扰，于是在西元1884年的国际会议上制定了全球性的标准时，明定以英国伦敦格林威治这个地方为零度经线的起点（亦称为本初子午线），并以地球由西向东每24小时自转一周360°，订定每隔经度15°，时差1小时。而每15°的经线则称为该时区的中央经线，将全球划分为24个时区，其中包含23个整时区及180°经线左右两侧的2个半时区。就全球的时间来看，东经的时间比西经要早，也就是如果格林威治时间是中午12时，则中央经线15°E的时区为下午1时，中央经线30°E时区的时间为下午2时；反之，中央经线15°W的时区时间为上午11时，中央经线30°W时区的时间为上午10时。以台湾为例，台湾位于东经121°，换算后与格林威治就有8小时的时差。如果两人同时从格林威治的0°各往东、西方前进，当他们在经线180°时，就会相差24小时，所以经线180°被定为国际换日线，由西向东通过此线时日期要减去一日，反之，若由东向西则要增加一日。 格林威治标准时间GMT 十七世纪，格林威治皇家天文台为了海上霸权的扩张计画而进行天体观测。1675年旧皇家观测所(Old Royal Observatory) 正式成立，到了1884年决定以通过格林威治的子午线作为划分地球东西两半球的经度零度。观测所门口墙上有一个标志24小时的时钟，显示当下的时间，对全球而言，这里所设定的时间是世界时间参考点，全球都以格林威治的时间作为标准来设定时间，这就是我们耳熟能详的「格林威治标准时间」(Greenwich Mean Time，简称G.M.T.)的由来，标示在手表上，则代表此表具有两地时间功能，也就是同时可以显示原居地和另一个国度的时间。 世界协调时间UTC 多数的两地时间表都以GMT来表示，但也有些两地时间表上看不到GMT字样，出现的反而是UTC这3个英文字母，究竟何谓UTC？事实上，UTC指的是Coordinated Universal Time－ 世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。所以基本上UTC的本质强调的是比GMT更为精确的世界时间标准，不过对于现行表款来说，GMT与UTC的功能与精确度是没有差别的。 夏日节约时间DST 所谓「夏日节约时间」Daylight Saving Time（简称D.S.T.），是指在夏天太阳升起的比较早时，将时钟拨快一小时，以提早日光的使用，在英国则称为夏令时间(Summer Time)。这个构想于1784年由美国班杰明·富兰克林提出来，1915年德国成为第一个正式实施夏令日光节约时间的国家，以削减灯光照明和耗电开支。自此以后，全球以欧洲和北美为主的约70个国家都引用这个做法。目前被划分成两个时区的印度也正在商讨是否全国该统一实行夏令日光节约时间。欧洲手机上也有很多GSM系统的基地台，除了会传送当地时间外也包括夏令日光节约时间，做为手机的时间标准，使用者可以自行决定要开启或关闭。值得注意的是，某些国家有实施「夏日节约时间」的制度，出国时别忘了跟随当地习惯在表上调整一下，这可是机械表没有的功能设计哦！","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"Java 时间相关内容02 万年历和自定义Calendar接口","date":"2017-02-01T16:00:00.000Z","path":"2017/02/02/java-source-analysis-time-series/Java 时间相关内容02 万年历和自定义Calendar接口/","text":"本章主要是收藏一些常用的类和接口，包括：万年历(农历、阳历节日、阴历节日)、自定义的Calendar接口。 目录1. 万年历2. 自定义的Calendar接口 1. 万年历源码如下(ChineseCalendar.java)： package com.via.mce.monthcalendar.utils; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashMap; /** * 农历日历。&lt;br&gt; * 将农历从1901年到2100年之间各年、月的大小以及历年节气保存，然后基于这些数据进行计算。&lt;br&gt; * &lt;br&gt; * 新增了几个用于农历的常量属性字段，可以使用get()方法获取日历对应的值；&lt;br&gt; * 农历年、月、日还可以使用set()/add()/roll()方法设置，其他农历属性自动计算；&lt;br&gt; * 另外，还提供了getChinese(int field)方法用于获得农历的中文文字（仅适用于农历属性和星期）。&lt;br&gt; * &lt;ul&gt; * &lt;li&gt;CHINESE_YEAR - 农历年&lt;/li&gt; * &lt;li&gt;CHINESE_MONTH - 农历月&lt;/li&gt; * &lt;li&gt;CHINESE_DATE - 农历日&lt;/li&gt; * &lt;li&gt;CHINESE_SECTIONAL_TERM - 当月的节气&lt;/li&gt; * &lt;li&gt;CHINESE_PRINCIPLE_TERM - 当月的中气&lt;/li&gt; * &lt;li&gt;CHINESE_HEAVENLY_STEM - 农历年的天干&lt;/li&gt; * &lt;li&gt;CHINESE_EARTHLY_BRANCH - 农历年的地支&lt;/li&gt; * &lt;li&gt;CHINESE_ZODIAC - 农历年的属相&lt;/li&gt; * &lt;li&gt;CHINESE_TERM_OR_DATE - 如果当天存在一个节气则指示节气，否则如果当天是初一则指示农历月，否则指示农历日&lt;/li&gt; * &lt;/ul&gt; * 注意：&lt;br&gt; * 由于Calendar类的设定，公历月份从0起始。所有方法都遵循了这一约定。&lt;br&gt; * 但所有的农历属性从1起始。即使是在Calendar提供的方法中，农历月也是从1起始的，并以负数表示闰月。&lt;br&gt; * clear()方法在某些情况下会导致农历和公历日期不对应或是不能达到预期的重置效果，应尽量避免使用。&lt;br&gt; * 使用getSimpleDateString()获得公历日期字符串时，公历月已经修正；&lt;br&gt; * 使用getSimpleChineseDateString()获得农历日期字符串时，农历闰月以*表示。&lt;br&gt; * * @version 0.12 2011-9-5 &lt;br&gt; * &lt;blockquote&gt;修复一个当使用农历正月日期初始化日历时陷入死循环的问题。&lt;/blockquote&gt; * @version 0.11 2009-12-27 &lt;br&gt; * &lt;blockquote&gt;修复了获取中文农历时未计算农历日期的问题；&lt;br&gt; * 加入一个字段CHINESE_TERM_OR_DATE用于模仿台历的显示方式：如果当天有节气则指示节气，如果是初一指示农历月， * 否则指示农历日。&lt;/blockquote&gt; * @version 0.10 2009-12-22 */ public final class ChineseCalendar extends GregorianCalendar { private static final long serialVersionUID = 8L; /** 农历年 */ public static final int CHINESE_YEAR = 801; /** 农历月 */ public static final int CHINESE_MONTH = 802; /** 农历日 */ public static final int CHINESE_DATE = 803; /** 当月的节气对应的公历日(前一个节气) */ public static final int CHINESE_SECTIONAL_TERM = 804; /** 当月的中气对应的公历日(后一个节气) */ public static final int CHINESE_PRINCIPLE_TERM = 805; /** 天干 */ public static final int CHINESE_HEAVENLY_STEM = 806; /** 地支 */ public static final int CHINESE_EARTHLY_BRANCH = 807; /** 农历年的属相(生肖) */ public static final int CHINESE_ZODIAC = 808; /** 节气或者农历日 */ public static final int CHINESE_TERM_OR_DATE = 888; // add by skywang /** 农历节日 */ public static final int LUNAR_FESTIVAL = 809; /** 阳历节日 */ public static final int SOLAR_FESTIVAL = 810; /** 节气 */ public static final int CHINESE_TERM = 811; /** 月或者农历日 */ public static final int CHINESE_MONTH_OR_DATE = 812; /** 节日 或 节气 或 农历日 */ public static final int FESTIVAL_OR_TERM_OR_DATE = 813; private int chineseYear; private int chineseMonth; // 1起始，负数表示闰月 private int chineseDate; private int sectionalTerm; // 当月节气的公历日 private int principleTerm; // 当月中气的公历日 private boolean areChineseFieldsComputed; // 农历日期是否已经经过计算确认 private boolean areSolarTermsComputed; // 节气是否已经经过计算确认 private boolean lastSetChinese; // 最后设置的是不是农历属性 /** 使用当前时间构造一个实例。 */ public ChineseCalendar() { super(); } /** 使用指定时间构造一个实例。 */ public ChineseCalendar(Date d) { super.setTime(d); } /** 使用指定时间构造一个实例。 */ public ChineseCalendar(Calendar c) { this(c.getTime()); } /** 使用指定公历日期构造一个实例。 */ public ChineseCalendar(int y, int m, int d) { super(y, m, d); } /** * 使用指定日期构造一个实例。 * * @param isChinese * 是否为农历日期 * @param y * @param m * @param d */ public ChineseCalendar(boolean isChinese, int y, int m, int d) { if (isChinese) { set(CHINESE_YEAR, y); set(CHINESE_MONTH, m); set(CHINESE_DATE, d); } else { set(y, m, d); } } public void set(int field, int value) { computeIfNeed(field); if (isChineseField(field)) { // 农历属性 switch (field) { case CHINESE_YEAR: chineseYear = value; break; case CHINESE_MONTH: chineseMonth = value; break; case CHINESE_DATE: chineseDate = value; break; default: throw new IllegalArgumentException(&quot;不支持的field设置：&quot; + field); } lastSetChinese = true; } else { // 非农历属性 super.set(field, value); lastSetChinese = false; } areFieldsSet = false; areChineseFieldsComputed = false; areSolarTermsComputed = false; } public int get(int field) { computeIfNeed(field); if (!isChineseField(field)) { return super.get(field); } switch (field) { case CHINESE_YEAR: return chineseYear; case CHINESE_MONTH: return chineseMonth; case CHINESE_DATE: return chineseDate; case CHINESE_SECTIONAL_TERM: return sectionalTerm; case CHINESE_PRINCIPLE_TERM: return principleTerm; case CHINESE_HEAVENLY_STEM: return (chineseYear - 4) % 10 + 1; case CHINESE_EARTHLY_BRANCH: case CHINESE_ZODIAC: return (chineseYear - 4) % 12 + 1; case CHINESE_MONTH_OR_DATE: if (get(CHINESE_DATE) == 1) { return CHINESE_MONTH; } else { return CHINESE_DATE; } case CHINESE_TERM_OR_DATE: int option; if (get(Calendar.DATE) == get(CHINESE_SECTIONAL_TERM)) { option = CHINESE_SECTIONAL_TERM; } else if (get(Calendar.DATE) == get(CHINESE_PRINCIPLE_TERM)) { option = CHINESE_PRINCIPLE_TERM; } else if (get(CHINESE_DATE) == 1) { option = CHINESE_MONTH; } else { option = CHINESE_DATE; } return option; default: throw new IllegalArgumentException(&quot;不支持的field获取：&quot; + field); } } public void add(int field, int amount) { computeIfNeed(field); if (!isChineseField(field)) { super.add(field, amount); lastSetChinese = false; areChineseFieldsComputed = false; areSolarTermsComputed = false; return; } switch (field) { case CHINESE_YEAR: chineseYear += amount; break; case CHINESE_MONTH: for (int i = 0; i &lt; amount; i++) { chineseMonth = nextChineseMonth(chineseYear, chineseMonth); if (chineseMonth == 1) { chineseYear++; } } break; case CHINESE_DATE: int maxDate = daysInChineseMonth(chineseYear, chineseMonth); for (int i = 0; i &lt; amount; i++) { chineseDate++; if (chineseDate &gt; maxDate) { chineseDate = 1; chineseMonth = nextChineseMonth(chineseYear, chineseMonth); if (chineseMonth == 1) { chineseYear++; } maxDate = daysInChineseMonth(chineseYear, chineseMonth); } } default: throw new IllegalArgumentException(&quot;不支持的field：&quot; + field); } lastSetChinese = true; areFieldsSet = false; areChineseFieldsComputed = false; areSolarTermsComputed = false; } public void roll(int field, int amount) { computeIfNeed(field); if (!isChineseField(field)) { super.roll(field, amount); lastSetChinese = false; areChineseFieldsComputed = false; areSolarTermsComputed = false; return; } switch (field) { case CHINESE_YEAR: chineseYear += amount; break; case CHINESE_MONTH: for (int i = 0; i &lt; amount; i++) { chineseMonth = nextChineseMonth(chineseYear, chineseMonth); } break; case CHINESE_DATE: int maxDate = daysInChineseMonth(chineseYear, chineseMonth); for (int i = 0; i &lt; amount; i++) { chineseDate++; if (chineseDate &gt; maxDate) { chineseDate = 1; } } default: throw new IllegalArgumentException(&quot;不支持的field：&quot; + field); } lastSetChinese = true; areFieldsSet = false; areChineseFieldsComputed = false; areSolarTermsComputed = false; } /** * 获得属性的中文，可以使用的属性字段为DAY_OF_WEEK以及所有农历属性字段。 * * @param field * @return */ public String getChinese(int field) { computeIfNeed(field); switch (field) { case CHINESE_YEAR: return getChinese(CHINESE_HEAVENLY_STEM) + getChinese(CHINESE_EARTHLY_BRANCH) + &quot;年&quot;; case CHINESE_MONTH: if (chineseMonth &gt; 0) return chineseMonthNames[chineseMonth] + &quot;月&quot;; else return &quot;闰&quot; + chineseMonthNames[-chineseMonth] + &quot;月&quot;; case CHINESE_DATE: return chineseDateNames[chineseDate]; case CHINESE_SECTIONAL_TERM: return sectionalTermNames[get(Calendar.MONTH)]; case CHINESE_PRINCIPLE_TERM: return principleTermNames[get(Calendar.MONTH)]; case CHINESE_HEAVENLY_STEM: return stemNames[get(field)]; case CHINESE_EARTHLY_BRANCH: return branchNames[get(field)]; case CHINESE_ZODIAC: return animalNames[get(field)]; case Calendar.DAY_OF_WEEK: return chineseWeekNames[get(field)]; case CHINESE_TERM_OR_DATE: return getChinese(get(CHINESE_TERM_OR_DATE)); case LUNAR_FESTIVAL: return getLunarFestival(); case SOLAR_FESTIVAL: return getSolarFestival(); case FESTIVAL_OR_TERM_OR_DATE: return getFestivalOrTermOrDate(); // TODO CHECK case CHINESE_MONTH_OR_DATE: return getChinese(get(CHINESE_MONTH_OR_DATE)); case CHINESE_TERM: return getChineseTerm(); default: throw new IllegalArgumentException(&quot;不支持的field中文获取：&quot; + field); } } public String getSimpleGregorianDateString() { return new StringBuffer().append(get(YEAR)).append(&quot;-&quot;) .append(get(MONTH) + 1).append(&quot;-&quot;).append(get(DATE)) .toString(); } public String getSimpleChineseDateString() { return new StringBuffer() .append(get(CHINESE_YEAR)) .append(&quot;-&quot;) .append(get(CHINESE_MONTH) &gt; 0 ? &quot;&quot; + get(CHINESE_MONTH) : &quot;*&quot; + (-get(CHINESE_MONTH))).append(&quot;-&quot;) .append(get(CHINESE_DATE)).toString(); } public String getChineseDateString() { return new StringBuffer().append(getChinese(CHINESE_YEAR)) .append(getChinese(CHINESE_MONTH)) .append(getChinese(CHINESE_DATE)).toString(); } public String toString() { StringBuffer buf = new StringBuffer(); buf.append(getSimpleGregorianDateString()).append(&quot; | &quot;) .append(getChinese(DAY_OF_WEEK)).append(&quot; | [农历]&quot;) .append(getChineseDateString()).append(&quot; &quot;) .append(getChinese(CHINESE_ZODIAC)).append(&quot;年 &quot;) .append(get(CHINESE_SECTIONAL_TERM)).append(&quot;日&quot;) .append(getChinese(CHINESE_SECTIONAL_TERM)).append(&quot; &quot;) .append(get(CHINESE_PRINCIPLE_TERM)).append(&quot;日&quot;) .append(getChinese(CHINESE_PRINCIPLE_TERM)); return buf.toString(); } /** * 判断是不是农历属性 * * @param field * @return */ private boolean isChineseField(int field) { switch (field) { case CHINESE_YEAR: case CHINESE_MONTH: case CHINESE_DATE: case CHINESE_SECTIONAL_TERM: case CHINESE_PRINCIPLE_TERM: case CHINESE_HEAVENLY_STEM: case CHINESE_EARTHLY_BRANCH: case CHINESE_ZODIAC: case CHINESE_TERM_OR_DATE: case CHINESE_MONTH_OR_DATE: return true; default: return false; } } /** * 判断是不是与节气有关的属性 * * @param field * @return */ private boolean isChineseTermsField(int field) { switch (field) { case CHINESE_SECTIONAL_TERM: case CHINESE_PRINCIPLE_TERM: case CHINESE_TERM_OR_DATE: return true; default: return false; } } /** * 如果上一次设置的与这次将要设置或获取的属性不是同一类（农历/公历），&lt;br&gt; * 例如上一次设置的是农历而现在要设置或获取公历，&lt;br&gt; * 则需要先根据之前设置的农历日期计算出公历日期。 * * @param field */ private void computeIfNeed(int field) { if (isChineseField(field)) { if (!lastSetChinese &amp;&amp; !areChineseFieldsComputed) { super.complete(); computeChineseFields(); areFieldsSet = true; areChineseFieldsComputed = true; areSolarTermsComputed = false; } if (isChineseTermsField(field) &amp;&amp; !areSolarTermsComputed) { computeSolarTerms(); areSolarTermsComputed = true; } } else { if (lastSetChinese &amp;&amp; !areFieldsSet) { computeGregorianFields(); super.complete(); areFieldsSet = true; areChineseFieldsComputed = true; areSolarTermsComputed = false; } } } /** * 使用农历日期计算出公历日期 */ private void computeGregorianFields() { int y = chineseYear; int m = chineseMonth; int d = chineseDate; areChineseFieldsComputed = true; areFieldsSet = true; lastSetChinese = false; // 调整日期范围 if (y &lt; 1900) y = 1899; else if (y &gt; 2100) y = 2101; if (m &lt; -12) m = -12; else if (m &gt; 12) m = 12; if (d &lt; 1) d = 1; else if (d &gt; 30) d = 30; int dateint = y * 10000 + Math.abs(m) * 100 + d; if (dateint &lt; 19001111) { // 太小 set(1901, Calendar.JANUARY, 1); super.complete(); } else if (dateint &gt; 21001201) { // 太大 set(2100, Calendar.DECEMBER, 31); super.complete(); } else { if (Math.abs(m) &gt; 12) { m = 12; } int days = ChineseCalendar.daysInChineseMonth(y, m); if (days == 0) { m = -m; days = ChineseCalendar.daysInChineseMonth(y, m); } if (d &gt; days) { d = days; } set(y, Math.abs(m) - 1, d); computeChineseFields(); int amount = 0; while (chineseYear != y || chineseMonth != m) { amount += daysInChineseMonth(chineseYear, chineseMonth); chineseMonth = nextChineseMonth(chineseYear, chineseMonth); if (chineseMonth == 1) { chineseYear++; } } amount += d - chineseDate; super.add(Calendar.DATE, amount); } computeChineseFields(); } /** * 使用公历日期计算出农历日期 */ private void computeChineseFields() { int gregorianYear = internalGet(Calendar.YEAR); int gregorianMonth = internalGet(Calendar.MONTH) + 1; int gregorianDate = internalGet(Calendar.DATE); if (gregorianYear &lt; 1901 || gregorianYear &gt; 2100) { return; } int startYear, startMonth, startDate; if (gregorianYear &lt; 2000) { startYear = baseYear; startMonth = baseMonth; startDate = baseDate; chineseYear = baseChineseYear; chineseMonth = baseChineseMonth; chineseDate = baseChineseDate; } else { // 第二个对应日，用以提高计算效率 // 公历 2000 年 1 月 1 日，对应农历 4697(1999) 年 11 月 25 日 startYear = baseYear + 99; startMonth = 1; startDate = 1; chineseYear = baseChineseYear + 99; chineseMonth = 11; chineseDate = 25; } int daysDiff = 0; // 年 for (int i = startYear; i &lt; gregorianYear; i++) { if (isGregorianLeapYear(i)) { daysDiff += 366; // leap year } else { daysDiff += 365; } } // 月 for (int i = startMonth; i &lt; gregorianMonth; i++) { daysDiff += daysInGregorianMonth(gregorianYear, i - 1); } // 日 daysDiff += gregorianDate - startDate; chineseDate += daysDiff; int lastDate = daysInChineseMonth(chineseYear, chineseMonth); while (chineseDate &gt; lastDate) { chineseDate -= lastDate; chineseMonth = nextChineseMonth(chineseYear, chineseMonth); if (chineseMonth == 1) { chineseYear++; } lastDate = daysInChineseMonth(chineseYear, chineseMonth); } } /** * 计算节气 */ private void computeSolarTerms() { int gregorianYear = internalGet(Calendar.YEAR); int gregorianMonth = internalGet(Calendar.MONTH); if (gregorianYear &lt; 1901 || gregorianYear &gt; 2100) { return; } sectionalTerm = sectionalTerm(gregorianYear, gregorianMonth); principleTerm = principleTerm(gregorianYear, gregorianMonth); } /* 接下来是静态方法~ */ /** * 是否为公历闰年 * * @param year * @return */ public static boolean isGregorianLeapYear(int year) { boolean isLeap = false; if (year % 4 == 0) { isLeap = true; } if (year % 100 == 0) { isLeap = false; } if (year % 400 == 0) { isLeap = true; } return isLeap; } /** * 计算公历年的当月天数，公历月从0起始！ * * @param y * @param m * @return */ public static int daysInGregorianMonth(int y, int m) { int d = daysInGregorianMonth[m]; if (m == Calendar.FEBRUARY &amp;&amp; isGregorianLeapYear(y)) { d++; // 公历闰年二月多一天 } return d; } /** * 计算公历年当月的节气，公历月从0起始！ * * @param y * @param m * @return */ public static int sectionalTerm(int y, int m) { m++; if (y &lt; 1901 || y &gt; 2100) { return 0; } int index = 0; int ry = y - baseYear + 1; while (ry &gt;= sectionalTermYear[m - 1][index]) { index++; } int term = sectionalTermMap[m - 1][4 * index + ry % 4]; if ((ry == 121) &amp;&amp; (m == 4)) { term = 5; } if ((ry == 132) &amp;&amp; (m == 4)) { term = 5; } if ((ry == 194) &amp;&amp; (m == 6)) { term = 6; } return term; } /** * 计算公历年当月的中气，公历月从0起始！ * * @param y * @param m * @return */ public static int principleTerm(int y, int m) { m++; if (y &lt; 1901 || y &gt; 2100) { return 0; } int index = 0; int ry = y - baseYear + 1; while (ry &gt;= principleTermYear[m - 1][index]) { index++; } int term = principleTermMap[m - 1][4 * index + ry % 4]; if ((ry == 171) &amp;&amp; (m == 3)) { term = 21; } if ((ry == 181) &amp;&amp; (m == 5)) { term = 21; } return term; } /** * 计算农历年的天数 * * @param y * @param m * @return */ public static int daysInChineseMonth(int y, int m) { // 注意：闰月 m &lt; 0 int index = y - baseChineseYear + baseIndex; int v = 0; int l = 0; int d = 30; if (1 &lt;= m &amp;&amp; m &lt;= 8) { v = chineseMonths[2 * index]; l = m - 1; if (((v &gt;&gt; l) &amp; 0x01) == 1) { d = 29; } } else if (9 &lt;= m &amp;&amp; m &lt;= 12) { v = chineseMonths[2 * index + 1]; l = m - 9; if (((v &gt;&gt; l) &amp; 0x01) == 1) { d = 29; } } else { v = chineseMonths[2 * index + 1]; v = (v &gt;&gt; 4) &amp; 0x0F; if (v != Math.abs(m)) { d = 0; } else { d = 29; for (int i = 0; i &lt; bigLeapMonthYears.length; i++) { if (bigLeapMonthYears[i] == index) { d = 30; break; } } } } return d; } /** * 计算农历的下个月 * * @param y * @param m * @return */ public static int nextChineseMonth(int y, int m) { int n = Math.abs(m) + 1; if (m &gt; 0) { int index = y - baseChineseYear + baseIndex; int v = chineseMonths[2 * index + 1]; v = (v &gt;&gt; 4) &amp; 0x0F; if (v == m) { n = -m; } } if (n == 13) { n = 1; } return n; } /* 日历第一天的日期 */ private static final int baseYear = 1901; private static final int baseMonth = 1; private static final int baseDate = 1; private static final int baseIndex = 0; private static final int baseChineseYear = 1900; private static final int baseChineseMonth = 11; private static final int baseChineseDate = 11; /* 中文字符串 */ private static final String[] chineseWeekNames = { &quot;&quot;, &quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot; }; private static final String[] chineseMonthNames = { &quot;&quot;, &quot;正&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;, &quot;十一&quot;, &quot;十二&quot; }; private static final String[] chineseDateNames = { &quot;&quot;, &quot;初一&quot;, &quot;初二&quot;, &quot;初三&quot;, &quot;初四&quot;, &quot;初五&quot;, &quot;初六&quot;, &quot;初七&quot;, &quot;初八&quot;, &quot;初九&quot;, &quot;初十&quot;, &quot;十一&quot;, &quot;十二&quot;, &quot;十三&quot;, &quot;十四&quot;, &quot;十五&quot;, &quot;十六&quot;, &quot;十七&quot;, &quot;十八&quot;, &quot;十九&quot;, &quot;二十&quot;, &quot;廿一&quot;, &quot;廿二&quot;, &quot;廿三&quot;, &quot;廿四&quot;, &quot;廿五&quot;, &quot;廿六&quot;, &quot;廿七&quot;, &quot;廿八&quot;, &quot;廿九&quot;, &quot;三十&quot; }; private static final String[] principleTermNames = { &quot;大寒&quot;, &quot;雨水&quot;, &quot;春分&quot;, &quot;谷雨&quot;, &quot;夏满&quot;, &quot;夏至&quot;, &quot;大暑&quot;, &quot;处暑&quot;, &quot;秋分&quot;, &quot;霜降&quot;, &quot;小雪&quot;, &quot;冬至&quot; }; private static final String[] sectionalTermNames = { &quot;小寒&quot;, &quot;立春&quot;, &quot;惊蛰&quot;, &quot;清明&quot;, &quot;立夏&quot;, &quot;芒种&quot;, &quot;小暑&quot;, &quot;立秋&quot;, &quot;白露&quot;, &quot;寒露&quot;, &quot;立冬&quot;, &quot;大雪&quot; }; private static final String[] stemNames = { &quot;&quot;, &quot;甲&quot;, &quot;乙&quot;, &quot;丙&quot;, &quot;丁&quot;, &quot;戊&quot;, &quot;己&quot;, &quot;庚&quot;, &quot;辛&quot;, &quot;壬&quot;, &quot;癸&quot; }; private static final String[] branchNames = { &quot;&quot;, &quot;子&quot;, &quot;丑&quot;, &quot;寅&quot;, &quot;卯&quot;, &quot;辰&quot;, &quot;巳&quot;, &quot;午&quot;, &quot;未&quot;, &quot;申&quot;, &quot;酉&quot;, &quot;戌&quot;, &quot;亥&quot; }; private static final String[] animalNames = { &quot;&quot;, &quot;鼠&quot;, &quot;牛&quot;, &quot;虎&quot;, &quot;兔&quot;, &quot;龙&quot;, &quot;蛇&quot;, &quot;马&quot;, &quot;羊&quot;, &quot;猴&quot;, &quot;鸡&quot;, &quot;狗&quot;, &quot;猪&quot; }; /* 接下来是数据压缩表~ */ private static final int[] bigLeapMonthYears = { 6, 14, 19, 25, 33, 36, 38, 41, 44, 52, 55, 79, 117, 136, 147, 150, 155, 158, 185, 193 }; private static final char[][] sectionalTermMap = { { 7, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5 }, { 5, 4, 5, 5, 5, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 3, 3, 4, 4, 3, 3, 3 }, { 6, 6, 6, 7, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5, 5 }, { 5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5, 4, 4, 5, 5, 4, 4, 4, 5, 4, 4, 4, 4, 5 }, { 6, 6, 6, 7, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5, 5 }, { 6, 6, 7, 7, 6, 6, 6, 7, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5, 5 }, { 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 6, 6, 7, 7, 6, 6, 6, 7, 7 }, { 8, 8, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 6, 6, 7, 7, 7 }, { 8, 8, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 7 }, { 9, 9, 9, 9, 8, 9, 9, 9, 8, 8, 9, 9, 8, 8, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8, 8 }, { 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 6, 6, 7, 7, 7 }, { 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 6, 6, 7, 7, 6, 6, 6, 7, 7 } }; private static final char[][] sectionalTermYear = { { 13, 49, 85, 117, 149, 185, 201, 250, 250 }, { 13, 45, 81, 117, 149, 185, 201, 250, 250 }, { 13, 48, 84, 112, 148, 184, 200, 201, 250 }, { 13, 45, 76, 108, 140, 172, 200, 201, 250 }, { 13, 44, 72, 104, 132, 168, 200, 201, 250 }, { 5, 33, 68, 96, 124, 152, 188, 200, 201 }, { 29, 57, 85, 120, 148, 176, 200, 201, 250 }, { 13, 48, 76, 104, 132, 168, 196, 200, 201 }, { 25, 60, 88, 120, 148, 184, 200, 201, 250 }, { 16, 44, 76, 108, 144, 172, 200, 201, 250 }, { 28, 60, 92, 124, 160, 192, 200, 201, 250 }, { 17, 53, 85, 124, 156, 188, 200, 201, 250 } }; private static final char[][] principleTermMap = { { 21, 21, 21, 21, 21, 20, 21, 21, 21, 20, 20, 21, 21, 20, 20, 20, 20, 20, 20, 20, 20, 19, 20, 20, 20, 19, 19, 20 }, { 20, 19, 19, 20, 20, 19, 19, 19, 19, 19, 19, 19, 19, 18, 19, 19, 19, 18, 18, 19, 19, 18, 18, 18, 18, 18, 18, 18 }, { 21, 21, 21, 22, 21, 21, 21, 21, 20, 21, 21, 21, 20, 20, 21, 21, 20, 20, 20, 21, 20, 20, 20, 20, 19, 20, 20, 20, 20 }, { 20, 21, 21, 21, 20, 20, 21, 21, 20, 20, 20, 21, 20, 20, 20, 20, 19, 20, 20, 20, 19, 19, 20, 20, 19, 19, 19, 20, 20 }, { 21, 22, 22, 22, 21, 21, 22, 22, 21, 21, 21, 22, 21, 21, 21, 21, 20, 21, 21, 21, 20, 20, 21, 21, 20, 20, 20, 21, 21 }, { 22, 22, 22, 22, 21, 22, 22, 22, 21, 21, 22, 22, 21, 21, 21, 22, 21, 21, 21, 21, 20, 21, 21, 21, 20, 20, 21, 21, 21 }, { 23, 23, 24, 24, 23, 23, 23, 24, 23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23, 22, 22, 22, 23, 22, 22, 22, 22, 23 }, { 23, 24, 24, 24, 23, 23, 24, 24, 23, 23, 23, 24, 23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23, 22, 22, 22, 23, 23 }, { 23, 24, 24, 24, 23, 23, 24, 24, 23, 23, 23, 24, 23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23, 22, 22, 22, 23, 23 }, { 24, 24, 24, 24, 23, 24, 24, 24, 23, 23, 24, 24, 23, 23, 23, 24, 23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23, 23 }, { 23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23, 22, 22, 22, 23, 22, 22, 22, 22, 21, 22, 22, 22, 21, 21, 22, 22, 22 }, { 22, 22, 23, 23, 22, 22, 22, 23, 22, 22, 22, 22, 21, 22, 22, 22, 21, 21, 22, 22, 21, 21, 21, 22, 21, 21, 21, 21, 22 } }; private static final char[][] principleTermYear = { { 13, 45, 81, 113, 149, 185, 201 }, { 21, 57, 93, 125, 161, 193, 201 }, { 21, 56, 88, 120, 152, 188, 200, 201 }, { 21, 49, 81, 116, 144, 176, 200, 201 }, { 17, 49, 77, 112, 140, 168, 200, 201 }, { 28, 60, 88, 116, 148, 180, 200, 201 }, { 25, 53, 84, 112, 144, 172, 200, 201 }, { 29, 57, 89, 120, 148, 180, 200, 201 }, { 17, 45, 73, 108, 140, 168, 200, 201 }, { 28, 60, 92, 124, 160, 192, 200, 201 }, { 16, 44, 80, 112, 148, 180, 200, 201 }, { 17, 53, 88, 120, 156, 188, 200, 201 } }; private static final char[] daysInGregorianMonth = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; private static final char[] chineseMonths = { 0x00, 0x04, 0xad, 0x08, 0x5a, 0x01, 0xd5, 0x54, 0xb4, 0x09, 0x64, 0x05, 0x59, 0x45, 0x95, 0x0a, 0xa6, 0x04, 0x55, 0x24, 0xad, 0x08, 0x5a, 0x62, 0xda, 0x04, 0xb4, 0x05, 0xb4, 0x55, 0x52, 0x0d, 0x94, 0x0a, 0x4a, 0x2a, 0x56, 0x02, 0x6d, 0x71, 0x6d, 0x01, 0xda, 0x02, 0xd2, 0x52, 0xa9, 0x05, 0x49, 0x0d, 0x2a, 0x45, 0x2b, 0x09, 0x56, 0x01, 0xb5, 0x20, 0x6d, 0x01, 0x59, 0x69, 0xd4, 0x0a, 0xa8, 0x05, 0xa9, 0x56, 0xa5, 0x04, 0x2b, 0x09, 0x9e, 0x38, 0xb6, 0x08, 0xec, 0x74, 0x6c, 0x05, 0xd4, 0x0a, 0xe4, 0x6a, 0x52, 0x05, 0x95, 0x0a, 0x5a, 0x42, 0x5b, 0x04, 0xb6, 0x04, 0xb4, 0x22, 0x6a, 0x05, 0x52, 0x75, 0xc9, 0x0a, 0x52, 0x05, 0x35, 0x55, 0x4d, 0x0a, 0x5a, 0x02, 0x5d, 0x31, 0xb5, 0x02, 0x6a, 0x8a, 0x68, 0x05, 0xa9, 0x0a, 0x8a, 0x6a, 0x2a, 0x05, 0x2d, 0x09, 0xaa, 0x48, 0x5a, 0x01, 0xb5, 0x09, 0xb0, 0x39, 0x64, 0x05, 0x25, 0x75, 0x95, 0x0a, 0x96, 0x04, 0x4d, 0x54, 0xad, 0x04, 0xda, 0x04, 0xd4, 0x44, 0xb4, 0x05, 0x54, 0x85, 0x52, 0x0d, 0x92, 0x0a, 0x56, 0x6a, 0x56, 0x02, 0x6d, 0x02, 0x6a, 0x41, 0xda, 0x02, 0xb2, 0xa1, 0xa9, 0x05, 0x49, 0x0d, 0x0a, 0x6d, 0x2a, 0x09, 0x56, 0x01, 0xad, 0x50, 0x6d, 0x01, 0xd9, 0x02, 0xd1, 0x3a, 0xa8, 0x05, 0x29, 0x85, 0xa5, 0x0c, 0x2a, 0x09, 0x96, 0x54, 0xb6, 0x08, 0x6c, 0x09, 0x64, 0x45, 0xd4, 0x0a, 0xa4, 0x05, 0x51, 0x25, 0x95, 0x0a, 0x2a, 0x72, 0x5b, 0x04, 0xb6, 0x04, 0xac, 0x52, 0x6a, 0x05, 0xd2, 0x0a, 0xa2, 0x4a, 0x4a, 0x05, 0x55, 0x94, 0x2d, 0x0a, 0x5a, 0x02, 0x75, 0x61, 0xb5, 0x02, 0x6a, 0x03, 0x61, 0x45, 0xa9, 0x0a, 0x4a, 0x05, 0x25, 0x25, 0x2d, 0x09, 0x9a, 0x68, 0xda, 0x08, 0xb4, 0x09, 0xa8, 0x59, 0x54, 0x03, 0xa5, 0x0a, 0x91, 0x3a, 0x96, 0x04, 0xad, 0xb0, 0xad, 0x04, 0xda, 0x04, 0xf4, 0x62, 0xb4, 0x05, 0x54, 0x0b, 0x44, 0x5d, 0x52, 0x0a, 0x95, 0x04, 0x55, 0x22, 0x6d, 0x02, 0x5a, 0x71, 0xda, 0x02, 0xaa, 0x05, 0xb2, 0x55, 0x49, 0x0b, 0x4a, 0x0a, 0x2d, 0x39, 0x36, 0x01, 0x6d, 0x80, 0x6d, 0x01, 0xd9, 0x02, 0xe9, 0x6a, 0xa8, 0x05, 0x29, 0x0b, 0x9a, 0x4c, 0xaa, 0x08, 0xb6, 0x08, 0xb4, 0x38, 0x6c, 0x09, 0x54, 0x75, 0xd4, 0x0a, 0xa4, 0x05, 0x45, 0x55, 0x95, 0x0a, 0x9a, 0x04, 0x55, 0x44, 0xb5, 0x04, 0x6a, 0x82, 0x6a, 0x05, 0xd2, 0x0a, 0x92, 0x6a, 0x4a, 0x05, 0x55, 0x0a, 0x2a, 0x4a, 0x5a, 0x02, 0xb5, 0x02, 0xb2, 0x31, 0x69, 0x03, 0x31, 0x73, 0xa9, 0x0a, 0x4a, 0x05, 0x2d, 0x55, 0x2d, 0x09, 0x5a, 0x01, 0xd5, 0x48, 0xb4, 0x09, 0x68, 0x89, 0x54, 0x0b, 0xa4, 0x0a, 0xa5, 0x6a, 0x95, 0x04, 0xad, 0x08, 0x6a, 0x44, 0xda, 0x04, 0x74, 0x05, 0xb0, 0x25, 0x54, 0x03 }; private String getChineseTerm() { if (get(Calendar.DATE) == get(CHINESE_SECTIONAL_TERM)) { return sectionalTermNames[get(Calendar.MONTH)]; } else if (get(Calendar.DATE) == get(CHINESE_PRINCIPLE_TERM)) { return principleTermNames[get(Calendar.MONTH)]; } else return null; } // add by skywang private String getLunarFestival() { int day = get(CHINESE_DATE); int month = get(CHINESE_MONTH); String sToday = day &lt; 10 ? &quot;0&quot; + day:&quot;&quot; + day; String sMonth = month&lt;10 ? &quot;0&quot; +(month):&quot;&quot;+(month); return lFestival.get(sMonth+sToday); } private String getSolarFestival() { int day = get(Calendar.DATE); int month = get(Calendar.MONTH); String sToday = day &lt; 10 ? &quot;0&quot; + day:&quot;&quot; + day; String sMonth = month&lt;10 ? &quot;0&quot; +(month+1):&quot;&quot;+(month+1); return sFestival.get(sMonth+sToday); } private String getFestivalOrTermOrDate() { String ret; if ((ret = getSolarFestival()) != null) return ret; if ((ret = getLunarFestival()) != null) return ret; return getChinese(get(CHINESE_TERM_OR_DATE)); } //公历节日 private static HashMap&lt;String,String&gt; sFestival =new HashMap&lt;String,String&gt;(); // 农历介入 private static HashMap&lt;String,String&gt; lFestival =new HashMap&lt;String,String&gt;(); static { sFestival.put(&quot;0101&quot;,&quot;元旦&quot;); sFestival.put(&quot;0214&quot;,&quot;情人节&quot;); sFestival.put(&quot;0308&quot;,&quot;妇女节&quot;); sFestival.put(&quot;0312&quot;,&quot;植树节&quot;); sFestival.put(&quot;0401&quot;,&quot;愚人节&quot;); sFestival.put(&quot;0501&quot;,&quot;劳动节&quot;); sFestival.put(&quot;0504&quot;,&quot;青年节&quot;); sFestival.put(&quot;0601&quot;,&quot;儿童节&quot;); sFestival.put(&quot;0701&quot;,&quot;建党节&quot;); sFestival.put(&quot;0801&quot;,&quot;建军节&quot;); sFestival.put(&quot;0910&quot;,&quot;教师节&quot;); sFestival.put(&quot;1001&quot;,&quot;国庆节&quot;); sFestival.put(&quot;1031&quot;,&quot;万圣节&quot;); // sFestival.put(&quot;1112&quot;,&quot;孙中山诞辰&quot;); sFestival.put(&quot;1225&quot;,&quot;圣诞节&quot;); lFestival.put(&quot;0101&quot;,&quot;春节&quot;); // lFestival.put(&quot;0102&quot;,&quot;大年初二&quot;); // lFestival.put(&quot;0103&quot;,&quot;大年初三&quot;); lFestival.put(&quot;0115&quot;,&quot;元宵节&quot;); lFestival.put(&quot;0505&quot;,&quot;端午节&quot;); lFestival.put(&quot;0707&quot;,&quot;七夕&quot;); lFestival.put(&quot;0815&quot;,&quot;中秋节&quot;); lFestival.put(&quot;0909&quot;,&quot;重阳节&quot;); lFestival.put(&quot;1208&quot;,&quot;腊八节&quot;); // lFestival.put(&quot;1299&quot;,&quot;除夕&quot;); } } 2. 自定义的Calendar接口这些接口在写日历程序时可能会用到。 源代码如下(CalendarSelfDefineTest.java)： import java.util.Calendar; /** * 根据Calendar的API封装的一些常用函数 * * @author skywang * @email kuiwu-wang@163.com */ public class CalendarSelfDefineTest { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); // 设置日期为“2013-09-18” cal.set(2013, Calendar.SEPTEMBER, 18); // 获取“年” System.out.printf(&quot;year: %s\\n&quot;, getYear(cal) ); // 获取“月” System.out.printf(&quot;month: %s\\n&quot;, getMonth(cal) ); // 获取“上月” System.out.printf(&quot;previcou month: %s\\n&quot;, getLastMonth(cal) ); // 获取“下月” System.out.printf(&quot;next month: %s\\n&quot;, getNextMonth(cal) ); // 获取“日” System.out.printf(&quot;day: %s\\n&quot;, getDay(cal) ); // 获取Cal对应星期几 System.out.printf(&quot;weekday: %s\\n&quot;, getWeekDay(cal) ); // 本月天数 System.out.printf(&quot;Current Month days: %s\\n&quot;, getMonthDays(cal) ); // 上月天数 System.out.printf(&quot;Previcous Month days: %s\\n&quot;, getPrevMonthDays(cal) ); // 下月天数 System.out.printf(&quot;Next Month days: %s\\n&quot;, getNextMonthDays(cal) ); // 获取当月第一天的星期几 System.out.printf(&quot;First day&apos; weekday : %s\\n&quot;, getFirstDayWeekday(cal) ); // 获取当前月最后一天的星期几 System.out.printf(&quot;Last day&apos; weekday : %s\\n&quot;, getLastDayWeekday(cal) ); // 获取上月最后一天的星期几 System.out.printf(&quot;PrevMonth Last day&apos; weekday: %s\\n&quot;, getLastDayWeekdayOfPrevMonth(cal) ); // 获取下月第一天的星期几 System.out.printf(&quot;NextMonth First day&apos; weekday: %s\\n&quot;, getFirstDayWeekdayOfNextMonth(cal) ); } /** * 获取“年” * * @return 例如，2013-09-18，则返回2013 */ public static int getYear(Calendar cal) { return cal.get(Calendar.YEAR); } /** * 获取“月” * * @return 返回值可以为以下值： * JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER, UNDECIMBER。 * 其中第一个月是 JANUARY，它为 0。 * * 例如，2013-09-18，则返回8 */ public static int getMonth(Calendar cal) { return cal.get(Calendar.MONTH); } /** * 获取“上一个月” * * @return 返回值可以为以下值： * JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER, UNDECIMBER。 * 其中第一个月是 JANUARY，它为 0。 * * 例如，2012-01-12的上一个月是“11”(即DECEMBER)。 */ public static int getLastMonth(Calendar cal) { return (cal.get(Calendar.MONTH) + 11) % 12; } /** * 获取“下一个月” * * @return 返回值可以为以下值： * JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER, UNDECIMBER。 * 其中第一个月是 JANUARY，它为 0。 * * 例如，2013-12-12的下一个月是“1”(即DECEMBER)。 */ public static int getNextMonth(Calendar cal) { return (cal.get(Calendar.MONTH) + 13) % 12; } /** * 获取“日” * * @return 例如，2013-09-18，则返回18 * */ public static int getDay(Calendar cal) { return cal.get(Calendar.DATE); } /** * 获取“本月的天数” * * @return 例如，2013-09-18，则返回30 * */ public static int getMonthDays(Calendar cal) { return cal.getActualMaximum(Calendar.DATE); } /** * 获取“上一个月的天数” * * @return 例如，2013-01-18，则返回31 (因为2012-12有31天) * */ public static int getPrevMonthDays(Calendar cal) { Calendar tmpCal = (Calendar)cal.clone(); // 克隆cal。后面对tmpCal操作，就不会改变cal tmpCal.add(Calendar.MONTH, -1); // 设为“上一个月” return tmpCal.getActualMaximum(Calendar.DATE); } /** * 获取“下一个月的天数” * * @return 例如，2013-12-18，则返回31 (因为2014-01有31天) * */ public static int getNextMonthDays(Calendar cal) { Calendar tmpCal = (Calendar)cal.clone(); // 克隆cal。后面对tmpCal操作，就不会改变cal tmpCal.add(Calendar.MONTH, 1); // 设为“下一个月” return tmpCal.getActualMaximum(Calendar.DATE); } /** * 获取Cal对应星期几 * * @return 返回“星期几”，可以为以下值： * SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY 和 SATURDAY。 * SUNDAY为1，MONDAY为2，依次类推。 * 例如，2013-09-18(星期三)，则返回4 */ public static int getWeekDay(Calendar cal) { return cal.get(Calendar.DAY_OF_WEEK); } /** * 获取当月第一天对应星期几 * * @return SUNDAY为1，MONDAY为2，依次类推。 */ public static int getFirstDayWeekday(Calendar cal) { Calendar tmpCal = (Calendar)cal.clone(); // 克隆cal。后面对tmpCal操作，就不会改变cal tmpCal.set(Calendar.DATE, 1); // 把日期设置为当月第一天 return tmpCal.get(Calendar.DAY_OF_WEEK); } /** * 获取当前月最后一天对应星期几 * * @return SUNDAY为1，MONDAY为2，依次类推。 */ public static int getLastDayWeekday(Calendar cal) { Calendar tmpCal = (Calendar)cal.clone(); // 克隆cal。后面对tmpCal操作，就不会改变cal tmpCal.set(Calendar.DATE, 1); // 把日期设置为当月第一天 tmpCal.roll(Calendar.DATE, -1); // 把日期设置为当月最后一天 return tmpCal.get(Calendar.DAY_OF_WEEK); } /** * 获取上月最后一天的星期几 * * @return SUNDAY为1，MONDAY为2，依次类推。 */ public static int getLastDayWeekdayOfPrevMonth(Calendar cal) { Calendar tmpCal = (Calendar)cal.clone(); // 克隆cal。后面对tmpCal操作，就不会改变cal tmpCal.set(Calendar.DATE, 1); // 把日期设置为当月第一天 tmpCal.add(Calendar.DATE, -1); // 把日期设置为上一个月最后一天 return tmpCal.get(Calendar.DAY_OF_WEEK); } /** * 获取下月第一天的星期偏移 * * @return SUNDAY为1，MONDAY为2，依次类推。 */ public static int getFirstDayWeekdayOfNextMonth(Calendar cal) { Calendar tmpCal = (Calendar)cal.clone(); // 克隆cal。后面对tmpCal操作，就不会改变cal tmpCal.add(Calendar.MONTH, 1); // 设为“下一个月” tmpCal.set(Calendar.DATE, 1); // 设为“第一天” return tmpCal.get(Calendar.DAY_OF_WEEK); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"Java 时间相关内容01 Calendar","date":"2017-01-31T16:00:00.000Z","path":"2017/02/01/java-source-analysis-time-series/Java 时间相关内容01 Calendar/","text":"Java 操作日期/时间，往往会涉及到Calendar，Date，DateFormat这些类。最近决定把这些内容系统的整理一下，这样以后使用的时候，会更得心应手。本章的内容是主要讲解“Java时间框架”以及“类Calendar”。在学习Calendar类时，我们先对它有个整体认识，心中建立一个框架，然后再通过示例学习如何使用它。 目录第一部分 Java时间架构第二部分 Calendar介绍 第3部分 Calendar的原理和思想第4部分 Calendar函数接口第5部分 Calendar示例 第一部分 Java时间架构Java 的Calendar, Date和DateFormat的关系图如下： img 说明：(01) milliseconds 表示毫秒。&nbsp;&nbsp;&nbsp;&nbsp; milliseconds = “实际时间” - “1970-01-01 00:00:00”。Calendar 和 Date依赖于 milliseconds，从而表示时间。(02) Calendar表示日期/时间。&nbsp;&nbsp;&nbsp;&nbsp; 它是一个抽象类，依赖于milliseconds。GregorianCalendar是Calendar的子类，通常我们通过Calendar.getInstance() 获取Calendar实例时，实际上返回的是 GregorianCalendar 对象。&nbsp;&nbsp;&nbsp;&nbsp; Calendar和Locale关联，而Locale代表区域；Locale的值不同时，Calendar的日期/时间也不同。&nbsp;&nbsp;&nbsp;&nbsp; Calendar和TimeZone关联，而TimeZone代表时区；不同的时区，Calendar的日期/时间也不同。(03) Date 表示日期/时间。&nbsp;&nbsp;&nbsp;&nbsp; 它也依赖于 milliseconds实现。&nbsp;&nbsp;&nbsp;&nbsp; 在 JDK 1.1 之前，通常是通过Data操作“年月日时分秒”。不过，由于Date的相关 API 不易于实现国际化。从 JDK 1.1 开始，应该使用 Calendar 类来操作“年月日时分秒”，同时可以通过 DateFormat 类来格式化和解析日期字符串。Date 中的相应方法已废弃。(04) DateFormat是格式化/解析“日期/时间”的工具类。&nbsp;&nbsp;&nbsp;&nbsp; 它是Date的格式化工具，它能帮助我们格式化Date，进而将Date转换成我们想要的String字符串供我们使用。&nbsp;&nbsp;&nbsp;&nbsp; 它是一个抽象类。通常，我们通过getInstance(), getDateInstance()和getDateTimeInstance() 等获取DateFormat实例时；实际上是返回的SimpleDateFormat对象。 第二部分 Calendar介绍Calendar 定义 public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {} Calendar 是一个抽象类。 它的实现，采用了设计模式中的工厂方法。表现在：当我们获取Calendar实例时，Calendar会根据传入的参数来返回相应的Calendar对象。获取Calendar实例，有以下两种方式：1) 当我们通过 Calendar.getInstance() 获取日历时，默认的是返回的一个GregorianCalendar对象。&nbsp;&nbsp;&nbsp;&nbsp; GregorianCalendar是Calendar的一个实现类，它提供了世界上大多数国家/地区使用的标准日历系统。2) 当我们通过 Calendar.getInstance(TimeZone timezone, Locale locale) 或 Calendar.getInstance(TimeZone timezone) 或 Calendar.getInstance(Locale locale)获取日历时，是返回“对应时区(zone) 或 地区(local)等所使用的日历”。&nbsp;&nbsp;&nbsp;&nbsp; 例如，若是日本，则返回JapaneseImperialCalendar对象。 参考如下代码： public static Calendar getInstance() { // 调用createCalendar()创建日历 Calendar cal = createCalendar(TimeZone.getDefaultRef(), Locale.getDefault()); cal.sharedZone = true; return cal; } public static Calendar getInstance(TimeZone zone) { // 调用createCalendar()创建日历 return createCalendar(zone, Locale.getDefault()); } public static Calendar getInstance(Locale aLocale) { // 调用createCalendar()创建日历 Calendar cal = createCalendar(TimeZone.getDefaultRef(), aLocale); cal.sharedZone = true; return cal; } public static Calendar getInstance(TimeZone zone, Locale aLocale) { // 调用createCalendar()创建日历 return createCalendar(zone, aLocale); } private static Calendar createCalendar(TimeZone zone, Locale aLocale) { // (01) 若地区是“th”，则返回BuddhistCalendar对象 // (02) 若地区是“JP”，则返回JapaneseImperialCalendar对象 if (&quot;th&quot;.equals(aLocale.getLanguage()) &amp;&amp; (&quot;TH&quot;.equals(aLocale.getCountry()))) { return new sun.util.BuddhistCalendar(zone, aLocale); } else if (&quot;JP&quot;.equals(aLocale.getVariant()) &amp;&amp; &quot;JP&quot;.equals(aLocale.getCountry()) &amp;&amp; &quot;ja&quot;.equals(aLocale.getLanguage())) { return new JapaneseImperialCalendar(zone, aLocale); } // (03) 否则，返回GregorianCalendar对象 return new GregorianCalendar(zone, aLocale); } 当我们获取Calendar实例之后，就可以通过Calendar提供的一些列方法来操作日历。 第3部分 Calendar的原理和思想我们使用Calendar，无非是操作Calendar的“年、月、日、星期、时、分、秒”这些字段。下面，我们对这些字段的的来源、定义以及计算方法进行学习。 1. Calendar 各个字段值的来源我们使用Calendar，无非是使用“年、月、日、星期、时、分、秒”等信息。那么它是如何做到的呢？本质上，Calendar就是保存了一个时间。如下定义： // time 是当前时间，单位是毫秒。 // 它是当前时间距离“January 1, 1970, 0:00:00 GMT”的差值。 protected long time; Calendar就是根据 time 计算出 “Calendar的年、月、日、星期、时、分、秒”等等信息。 2. Calendar 各个字段的定义和初始化Calendar 的“年、月、日、星期、时、分、秒”这些信息，一共是17个字段。我们使用Calendar，无非是就是使用这17个字段。它们的定义如下： (字段0) public final static int ERA = 0;说明：纪元。取值：只能为0 或 1。0表示BC(“before Christ”,即公元前)，1表示AD(拉丁语“Anno Domini”,即公元)。 (字段1) public final static int YEAR = 1;说明：年。 (字段2) public final static int MONTH = 2;说明：月取值：可以为，JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER, UNDECIMBER。&nbsp;&nbsp;&nbsp;&nbsp; 其中第一个月是 JANUARY，它为 0。 (字段3) public final static int WEEK_OF_YEAR = 3;说明：当前日期在本年中对应第几个星期。一年中第一个星期的值为 1。 (字段4) public final static int WEEK_OF_MONTH = 4;说明：当前日期在本月中对应第几个星期。一个月中第一个星期的值为 1。 (字段5) public final static int DATE = 5;说明：日。一个月中第一天的值为 1。 (字段5) public final static int DAY_OF_MONTH = 5;说明：同“DATE”，表示“日”。 (字段6) public final static int DAY_OF_YEAR = 6;说明：当前日期在本年中对应第几天。一年中第一天的值为 1。 (字段7) public final static int DAY_OF_WEEK = 7;说明：星期几。取值：可以为，SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY 和 SATURDAY。&nbsp;&nbsp;&nbsp;&nbsp; 其中，SUNDAY为1，MONDAY为2，依次类推。 (字段8) public final static int DAY_OF_WEEK_IN_MONTH = 8;说明：当前月中的第几个星期。取值：DAY_OF_MONTH 1 到 7 总是对应于 DAY_OF_WEEK_IN_MONTH 1；8 到 14 总是对应于 DAY_OF_WEEK_IN_MONTH 2，依此类推。 (字段9) public final static int AM_PM = 9;说明：上午 还是 下午取值：可以是AM 或 PM。AM为0,表示上午；PM为1,表示下午。 (字段10) public final static int HOUR = 10;说明：指示一天中的第几小时。&nbsp;&nbsp;&nbsp;&nbsp; HOUR 用于 12 小时制时钟 (0 - 11)。中午和午夜用 0 表示，不用 12 表示。 (字段11) public final static int HOUR_OF_DAY = 11;说明：指示一天中的第几小时。 &nbsp;&nbsp;&nbsp;&nbsp; HOUR_OF_DAY 用于 24 小时制时钟。例如，在 10:04:15.250 PM 这一时刻，HOUR_OF_DAY 为 22。 (字段12) public final static int MINUTE = 12;说明：一小时中的第几分钟。例如，在 10:04:15.250 PM这一时刻，MINUTE 为 4。 (字段13) public final static int SECOND = 13;说明：一分钟中的第几秒。例如，在 10:04:15.250 PM 这一时刻，SECOND 为 15。 (字段14) public final static int MILLISECOND = 14;说明：一秒中的第几毫秒。例如，在 10:04:15.250 PM 这一时刻，MILLISECOND 为 250。 (字段15) public final static int ZONE_OFFSET = 15;说明：毫秒为单位指示距 GMT 的大致偏移量。 (字段16) public final static int DST_OFFSET = 16;说明：毫秒为单位指示夏令时的偏移量。 public final static int FIELD_COUNT = 17; 这17个字段是保存在int数组中。定义如下： // 保存这17个字段的数组 protected int fields[]; // 数组的定义函数 protected Calendar(TimeZone zone, Locale aLocale) { // 初始化“fields数组” fields = new int[FIELD_COUNT]; isSet = new boolean[FIELD_COUNT]; stamp = new int[FIELD_COUNT]; this.zone = zone; setWeekCountData(aLocale); } protected Calendar(TimeZone zone, Locale aLocale) 这是Calendar的构造函数。它会被它的子类的构造函数调用到，从而新建“保存Calendar的17个字段数据”的数组。 3. Calendar 各个字段值的计算下面以get(int field)为例，简要的说明Calendar的17个字段的计算和操作。get(int field)是获取“field”字段的值。它的定义如下： public int get(int field) { // 计算各个字段的值 complete(); // 返回field字段的值 return internalGet(field); } 说明：get(int field)的代码很简单。先通过 complete() 计算各个字段的值，然后在通过 internalGet(field) 返回“field字段的值”。 complete() 的作用就是计算Calendar各个字段的值。它定义在Calendar.java中，代码如下： protected void complete() { if (!isTimeSet) updateTime(); if (!areFieldsSet || !areAllFieldsSet) { computeFields(); // fills in unset fields areAllFieldsSet = areFieldsSet = true; } } private void updateTime() { computeTime(); isTimeSet = true; } updateTime() 调用到的 computeTime() 定义在 Calendar.java的实现类中。下面，我列出GregorianCalendar.java中computeTime()的实现： protected void computeTime() { // In non-lenient mode, perform brief checking of calendar // fields which have been set externally. Through this // checking, the field values are stored in originalFields[] // to see if any of them are normalized later. if (!isLenient()) { if (originalFields == null) { originalFields = new int[FIELD_COUNT]; } for (int field = 0; field &lt; FIELD_COUNT; field++) { int value = internalGet(field); if (isExternallySet(field)) { // Quick validation for any out of range values if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) { throw new IllegalArgumentException(getFieldName(field)); } } originalFields[field] = value; } } // Let the super class determine which calendar fields to be // used to calculate the time. int fieldMask = selectFields(); // The year defaults to the epoch start. We don&apos;t check // fieldMask for YEAR because YEAR is a mandatory field to // determine the date. int year = isSet(YEAR) ? internalGet(YEAR) : EPOCH_YEAR; int era = internalGetEra(); if (era == BCE) { year = 1 - year; } else if (era != CE) { // Even in lenient mode we disallow ERA values other than CE &amp; BCE. // (The same normalization rule as add()/roll() could be // applied here in lenient mode. But this checking is kept // unchanged for compatibility as of 1.5.) throw new IllegalArgumentException(&quot;Invalid era&quot;); } // If year is 0 or negative, we need to set the ERA value later. if (year &lt;= 0 &amp;&amp; !isSet(ERA)) { fieldMask |= ERA_MASK; setFieldsComputed(ERA_MASK); } // Calculate the time of day. We rely on the convention that // an UNSET field has 0. long timeOfDay = 0; if (isFieldSet(fieldMask, HOUR_OF_DAY)) { timeOfDay += (long) internalGet(HOUR_OF_DAY); } else { timeOfDay += internalGet(HOUR); // The default value of AM_PM is 0 which designates AM. if (isFieldSet(fieldMask, AM_PM)) { timeOfDay += 12 * internalGet(AM_PM); } } timeOfDay *= 60; timeOfDay += internalGet(MINUTE); timeOfDay *= 60; timeOfDay += internalGet(SECOND); timeOfDay *= 1000; timeOfDay += internalGet(MILLISECOND); // Convert the time of day to the number of days and the // millisecond offset from midnight. long fixedDate = timeOfDay / ONE_DAY; timeOfDay %= ONE_DAY; while (timeOfDay &lt; 0) { timeOfDay += ONE_DAY; --fixedDate; } // Calculate the fixed date since January 1, 1 (Gregorian). calculateFixedDate: { long gfd, jfd; if (year &gt; gregorianCutoverYear &amp;&amp; year &gt; gregorianCutoverYearJulian) { gfd = fixedDate + getFixedDate(gcal, year, fieldMask); if (gfd &gt;= gregorianCutoverDate) { fixedDate = gfd; break calculateFixedDate; } jfd = fixedDate + getFixedDate(getJulianCalendarSystem(), year, fieldMask); } else if (year &lt; gregorianCutoverYear &amp;&amp; year &lt; gregorianCutoverYearJulian) { jfd = fixedDate + getFixedDate(getJulianCalendarSystem(), year, fieldMask); if (jfd &lt; gregorianCutoverDate) { fixedDate = jfd; break calculateFixedDate; } gfd = fixedDate + getFixedDate(gcal, year, fieldMask); } else { gfd = fixedDate + getFixedDate(gcal, year, fieldMask); jfd = fixedDate + getFixedDate(getJulianCalendarSystem(), year, fieldMask); } // Now we have to determine which calendar date it is. if (gfd &gt;= gregorianCutoverDate) { if (jfd &gt;= gregorianCutoverDate) { fixedDate = gfd; } else { // The date is in an &quot;overlapping&quot; period. No way // to disambiguate it. Determine it using the // previous date calculation. if (calsys == gcal || calsys == null) { fixedDate = gfd; } else { fixedDate = jfd; } } } else { if (jfd &lt; gregorianCutoverDate) { fixedDate = jfd; } else { // The date is in a &quot;missing&quot; period. if (!isLenient()) { throw new IllegalArgumentException(&quot;the specified date doesn&apos;t exist&quot;); } // Take the Julian date for compatibility, which // will produce a Gregorian date. fixedDate = jfd; } } } // millis represents local wall-clock time in milliseconds. long millis = (fixedDate - EPOCH_OFFSET) * ONE_DAY + timeOfDay; // Compute the time zone offset and DST offset. There are two potential // ambiguities here. We&apos;ll assume a 2:00 am (wall time) switchover time // for discussion purposes here. // 1. The transition into DST. Here, a designated time of 2:00 am - 2:59 am // can be in standard or in DST depending. However, 2:00 am is an invalid // representation (the representation jumps from 1:59:59 am Std to 3:00:00 am DST). // We assume standard time. // 2. The transition out of DST. Here, a designated time of 1:00 am - 1:59 am // can be in standard or DST. Both are valid representations (the rep // jumps from 1:59:59 DST to 1:00:00 Std). // Again, we assume standard time. // We use the TimeZone object, unless the user has explicitly set the ZONE_OFFSET // or DST_OFFSET fields; then we use those fields. TimeZone zone = getZone(); if (zoneOffsets == null) { zoneOffsets = new int[2]; } int tzMask = fieldMask &amp; (ZONE_OFFSET_MASK|DST_OFFSET_MASK); if (tzMask != (ZONE_OFFSET_MASK|DST_OFFSET_MASK)) { if (zone instanceof ZoneInfo) { ((ZoneInfo)zone).getOffsetsByWall(millis, zoneOffsets); } else { int gmtOffset = isFieldSet(fieldMask, ZONE_OFFSET) ? internalGet(ZONE_OFFSET) : zone.getRawOffset(); zone.getOffsets(millis - gmtOffset, zoneOffsets); } } if (tzMask != 0) { if (isFieldSet(tzMask, ZONE_OFFSET)) { zoneOffsets[0] = internalGet(ZONE_OFFSET); } if (isFieldSet(tzMask, DST_OFFSET)) { zoneOffsets[1] = internalGet(DST_OFFSET); } } // Adjust the time zone offset values to get the UTC time. millis -= zoneOffsets[0] + zoneOffsets[1]; // Set this calendar&apos;s time in milliseconds time = millis; int mask = computeFields(fieldMask | getSetStateFields(), tzMask); if (!isLenient()) { for (int field = 0; field &lt; FIELD_COUNT; field++) { if (!isExternallySet(field)) { continue; } if (originalFields[field] != internalGet(field)) { // Restore the original field values System.arraycopy(originalFields, 0, fields, 0, fields.length); throw new IllegalArgumentException(getFieldName(field)); } } } setFieldsNormalized(mask); } 下面，我们看看internalGet(field)的定义。如下： protected final int internalGet(int field) { return fields[field]; } 从中，我们就看出，get(int field) 最终是通过 internalGet(int field)来返回值的。而 internalGet(int field) ，实际上返回的是field数组中的第field个元素。这就正好和Calendar的17个元素所对应了！ 总之，我们需要了解的就是：Calendar就是以一个time(毫秒)为基数，而计算出“年月日时分秒”等，从而方便我们对“年月日时分秒”等进行操作。下面，介绍以下Calendar提供的相关操作函数。 第4部分 Calendar函数接口1. Calendar的17个字段的公共接口Calendar的这17个字段，都支持下面的公共函数接口。这些公共接口的使用示例，请参考CalendarTest.java 示例中的 testAllCalendarSections() 函数。 1) getMaximum(int field) 作用：获取“字段的最大值”。注意“对比它和 getActualMaximum() 的区别”。示例：以“MONTH”字段来说。使用方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 获取MONTH的最大值 int max = cal.getMaximum(Calendar.MONTH); 若要获取其它字段的最大值，只需要将示例中的MONTH相应的替换成其它字段名即可。 2) getActualMaximum(int field) 作用：获取“当前日期下，该字段的最大值”。示例：以“MONTH”字段来说。使用方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 获取当前MONTH的最大值 int max = cal.getActualMaximum(Calendar.MONTH); 若要获取其它字段的最大值，只需要将示例中的MONTH相应的替换成其它字段名即可。 注意：对比getActualMaximum() 和 getMaximum() 的区别。参考下面的对比示例， (01) getMaximum() 获取的“字段最大值”，是指在综合所有的日期，在所有这些日期中得出的“字段最大值”。&nbsp;&nbsp;&nbsp;&nbsp; 例如，getMaximum(Calendar.DATE)的目的是“获取‘日的最大值’”。综合所有的日期，得出一个月最多有31天。因此，getMaximum(Calendar.DATE)的返回值是“31”！(02) getActualMaximum() 获取的“当前日期时，该字段的最大值”。&nbsp;&nbsp;&nbsp;&nbsp; 例如，当日期为2013-09-01时，getActualMaximum(Calendar.DATE)是获取“日的最大值”是“30”。当前日期是9月份，而9月只有30天。因此，getActualMaximum(Calendar.DATE)的返回值是“30”！ 3) getMinimum(int field) 作用：获取“字段的最小值”。注意“对比它和 getActualMinimum() 的区别”。示例：以“MONTH”字段来说。使用方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 获取MONTH的最小值 int min = cal.getMinimum(Calendar.MONTH); 若要获取其它字段的最小值，只需要将示例中的MONTH相应的替换成其它字段名即可。 4) getActualMinimum(int field) 作用：获取“当前日期下，该字段的最小值”。示例：以“MONTH”字段来说。使用方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 获取MONTH的最小值 int min = cal.getMinimum(Calendar.MONTH); 若要获取其它字段的最小值，只需要将示例中的MONTH相应的替换成其它字段名即可。 注意：在Java默认的Calendar中，虽然 getMinimum() 和 getActualMinimum() 的含义不同；但是，它们的返回值是一样的。因为Calendar的默认是返回GregorianCalendar对象，而在GregorianCalendar.java中，getMinimum() 和 getActualMinimum() 返回值一样。 5) get(int field) 作用：获取“字段的当前值”。获取field字段的当前值。示例：以“MONTH”字段来说。“获取MONTH的当前值”的方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 获取“cal日历”的当前MONTH值 int MONTH = cal.get(Calendar.MONTH); 若要获取其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。 6) set(int field, int value) 作用：设置“字段的当前值”。设置field字段的当前值为value示例：以“MONTH”字段来说。“设置MONTH的当前值”的方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 设置“cal日历”的当前MONTH值为 1988年 cal.set(Calendar.MONTH, 1988); 说明：(01) 1988 是想要设置的MONTH的当前值。这个设置值必须是整数。(02) 若要设置其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。 7) add(int field, int value) 作用：给“字段的当前值”添加值。给field字段的当前值添加value。示例：以“MONTH”字段来说。方法如下： // 获取Calendar实例，并设置日期为“2013-09-01” Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2013); cal.set(Calendar.MONTH, 8); cal.set(Calendar.DATE, 1); // 给“cal日历”的当前MONTH值 “添加-10” cal.add(Calendar.MONTH, -10); 说明：(01) -10 是添加值。&nbsp;&nbsp;&nbsp;&nbsp; 添加值可以为正数，也可以是负数。&nbsp;&nbsp;&nbsp;&nbsp; 正数表示将日期增加，负数表示将日期减少。&nbsp;&nbsp;&nbsp;&nbsp; 假设：现在cal的值是“2013-09-01”，现在我们将MONTH字段值增加-10。得到的结果是：“2012-10-01”。&nbsp;&nbsp;&nbsp;&nbsp; 为什么会这样呢？“2013-09-01”增加-10，也就是将日期向前减少10个月；得到的结果就是“2012-10-01”。(02) Calendar的17个字段中：除了回滚Calendar.ZONE_OFFSET时，会抛出IllegalArgumentException异常；其它的字段都支持该操作。(03) 若要设置其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。 8) roll(int field, int value) 作用：回滚“字段的当前值”示例：以“MONTH”字段来说。“回滚MONTH的当前值”的方法为： // 获取Calendar实例，并设置日期为“2013-09-01” Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2013); cal.set(Calendar.MONTH, 8); cal.set(Calendar.DATE, 1); // 将“cal日历”的当前MONTH值 “向前滚动10” cal.roll(Calendar.MONTH, -10); 说明：(01) -10 是回滚值。&nbsp;&nbsp;&nbsp;&nbsp; 当回滚值是负数时，表示将当前字段向前滚；&nbsp;&nbsp;&nbsp;&nbsp; 当回滚值是正数时，表示将当前字段向后滚。 &nbsp;&nbsp;&nbsp;&nbsp; 回滚Calendar中某一字段时，不更改更大的字段！&nbsp;&nbsp;&nbsp;&nbsp; 这是roll()与add()的根据区别！add()可能会更改更大字段，比如“使用add()修改‘MONTH’字段，可能会引起‘YEAR’字段的改变”；但是roll()不会更改更大的字段，例如“使用roll()修改‘MONTH’字段，不回引起‘YEAR’字段的改变。” &nbsp;&nbsp;&nbsp;&nbsp; 假设：现在cal的值是“2013-09-01”，现在我们将MONTH字段值增加-10。得到的结果是：“2013-10-01”。&nbsp;&nbsp;&nbsp;&nbsp; 为什么会这样呢？这就是因为“回滚”就是“在最小值和最大值之间来回滚动”。本例中，MONTH是9月，前回滚10，得到的值是10月，但是roll()不会改变“比MONTH”更大的字段，所以YEAR字段不会改变。所以结果是“2013-10-01”。(02) Calendar的17个字段中：除了回滚Calendar.ZONE_OFFSET时，会抛出IllegalArgumentException异常；其它的字段都支持该操作。(03) 若要设置其它字段的当前值，只需要将示例中的MONTH相应的替换成其它字段名即可。 9) clear(int field) 作用：清空“字段的当前值”。所谓清空，实际上是将“field”的值设置为0；若field最小值为1,则设置为1。示例：以“MONTH”字段来说。“清空MONTH”的方法为： // 获取Calendar实例，并设置日期为“9月” Calendar cal = Calendar.getInstance(); cal.set(Calendar.MONTH, 9); // 清空MONTH cal.clear(Calendar.MONTH); 若要清空其它字段，只需要将示例中的MONTH相应的替换成其它字段名即可。 10) isSet(int field) 作用：判断“字段field”是否被设置。若调用clear()清空之后，则field变为“没有设置状态”。示例：以“MONTH”字段来说。“判断MONTH是否被设置”的方法为： // 获取Calendar实例 Calendar cal = Calendar.getInstance(); // 判断MONTH是否被设置 boolean bset = cal.isSet(Calendar.MONTH); 若要判断其它字段，只需要将示例中的MONTH相应的替换成其它字段名即可。 2. Calendar的其它函数1) 日期比较函数 Calendar的比较函数，主要有以下几个： // 比较“当前Calendar对象”和“calendar” 的日期、时区等内容是否相等。 boolean equals(Object object) // 当前Calendar对象 是否 早于calendar boolean before(Object calendar) // 当前Calendar对象 是否 晚于calendar boolean after(Object calendar) // 比较“当前Calendar对象”和“calendar”。 // 若 早于 “calendar” 则，返回-1 // 若 相等， 则，返回0 // 若 晚于 “calendar” 则，返回1 int compareTo(Calendar anotherCalendar) 这些函数的使用示例，请参考CalendarTest.java示例中的 testComparatorAPIs() 函数。 示例：假设cal1 和 cal2 都是Calendar的两个对象。 // 它们的使用方法如下 boolean isEqual = cal1.equals(cal2); boolean isBefore = cal1.before(cal2); boolean isAfter = cal1.after(cal2); int icompare = cal1.compareTo(cal2); 2) “宽容”函数 // 设置“Calendar的宽容度” void setLenient(boolean value) // 获取“Calendar的宽容度” boolean isLenient() 这些函数的使用示例，请参考CalendarTest.java示例中的 testLenientAPIs() 函数。 说明：Calendar 有两种解释日历字段的模式，即 lenient 和 non-lenient。(01) 当 Calendar 处于 lenient 模式时，它可接受比它所生成的日历字段范围更大范围内的值。当 Calendar 重新计算日历字段值，以便由 get() 返回这些值时，所有日历字段都被标准化。&nbsp;&nbsp;&nbsp;&nbsp; 例如，lenient 模式下的 GregorianCalendar 将 MONTH == JANUARY、DAY_OF_MONTH == 32 解释为 February 1。(02) 当 Calendar 处于 non-lenient 模式时，如果其日历字段中存在任何不一致性，它都会抛出一个异常。&nbsp;&nbsp;&nbsp;&nbsp; 例如，GregorianCalendar 总是在 1 与月份的长度之间生成 DAY_OF_MONTH 值。如果已经设置了任何超出范围的字段值，那么在计算时间或日历字段值时，处于 non-lenient 模式下的 GregorianCalendar 会抛出一个异常。注意：在(02)步骤中的异常，在使用set()时不会抛出，而需要在使用get()、getTimeInMillis()、getTime()、add() 和 roll() 等函数中才抛出。因为set()只是设置了一个修改标志，而get()等方法才会引起时间的重新计算，此时才会抛出异常！ 3) “年月日(时分秒)”、Date、TimeZone、MilliSecond函数 // 设置“年月日” final void set(int year, int month, int day) // 设置“年月日时分” final void set(int year, int month, int day, int hourOfDay, int minute, int second) // 设置“年月日时分秒” final void set(int year, int month, int day, int hourOfDay, int minute) // 获取Calendar对应的日期 final Date getTime() // 设置Calendar为date final void setTime(Date date) // 获取Calendar对应的时区 TimeZone getTimeZone() // 设置Calendar对应的时区 void setTimeZone(TimeZone timezone) // 获取Calendar对应的milliscondes值，就是“Calendar当前日期”距离“1970-01-01 0:00:00 GMT”的毫秒数 long getTimeInMillis() // 设置Calendar对应的milliscondes值 void setTimeInMillis(long milliseconds) 这些函数的使用示例，请参考CalendarTest.java示例中的 testTimeAPIs() 函数。 4) 其它操作 // 克隆Calendar Object clone() // 获取“每周的第一天是星期几”。例如，在美国，这一天是 SUNDAY，而在法国，这一天是 MONDAY。 int getFirstDayOfWeek() // 设置“每周的第一天是星期几”。例如，在美国，这一天是 SUNDAY，而在法国，这一天是 MONDAY。 void setFirstDayOfWeek(int value) // 获取一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则此方法将返回 1。如果最少天数必须是一整个星期，则此方法将返回 7。 int getMinimalDaysInFirstWeek() // 设置一年中第一个星期所需的最少天数，例如，如果定义第一个星期包含一年第一个月的第一天，则使用值 1 调用此方法。如果最少天数必须是一整个星期，则使用值 7 调用此方法。 void setMinimalDaysInFirstWeek(int value) 这些函数的使用示例，请参考CalendarTest.java示例中的 testOtherAPIs() 函数。 第5部分 Calendar示例下面，我们通过示例学习使用Calendar的API。CalendarTest.java的源码如下： import java.util.Date; import java.util.Calendar; import java.util.TimeZone; import java.util.Random; /** * Calendar的API测试程序 * * @author skywang * @email kuiwu-wang@163.com */ public class CalendarTest { public static void main(String[] args) { // 测试Calendar的“17个字段的公共函数接口” testAllCalendarSections() ; // 测试Calendar的“比较接口” testComparatorAPIs() ; // 测试Calendar的“比较接口” testLenientAPIs() ; // 测试Calendar的Date、TimeZone、MilliSecond等相关函数 testTimeAPIs() ; // 测试Calendar的clone()，getFirstDayOfWeek()等接口 testOtherAPIs() ; } /** * 测试“Calendar的字段” * * @param cal -- Calendar对象 * @param field -- 要测试的“Calendar字段”。可以为以下值： * Calendar.YEAR, Calendar.MONTH, Calendar.DATE, ... 等等 * @param title -- 标题 * @author skywang (kuiwu-wang@163.com) */ private static void testSection(Calendar cal, int field, String title) { final Random random = new Random(); final Date date = cal.getTime(); final int min = cal.getMinimum(field); // 获取&quot;字段最小值&quot; final int max = cal.getMaximum(field); // 获取“字段最大值” final int actualMin = cal.getActualMinimum(field); // 获取&quot;当前日期下，该字段最小值&quot; final int actualMax = cal.getActualMaximum(field); // 获取“当前日期下，该字段的最大值” // 获取“字段的当前值” final int ori = cal.get(field); // 设置“字段的当前值”, 并获取“设置之后的值” final int r1 = random.nextInt(max); cal.set(field, r1); final int set = cal.get(field); try { // 回滚“字段的当前值”：在“字段最小值”和“字段最大值”之间回滚。 // “回滚值”可以为正，也可以为负。 cal.roll(field, -max); } catch (IllegalArgumentException e) { // 当field == Calendar.ZONE_OFFSET时，会抛出该异常！ e.printStackTrace(); } final int roll = cal.get(field); // 获取一个随机值 final int sign = ( random.nextInt(2) == 1) ? 1 : -1; final int r2 = sign * random.nextInt(max); try { // 增加“字段的当前值” ，并获取“新的当前字段值” // add的“参数值”可以为正，也可以为负。 cal.add(field, r2); } catch (IllegalArgumentException e) { // 当field == Calendar.ZONE_OFFSET时，会抛出该异常！ e.printStackTrace(); } final int add = cal.get(field); // 打印字段信息 System.out.printf(&quot;%s:\\n\\trange is [%d - %d] actualRange is [%d - %d]. original=%d, set(%d)=%d, roll(%d)=%d, add(%d)=%d\\n&quot;, title, min, max, actualMin, actualMax, ori, r1, set, -max, roll, r2, add); } /** * 测试Calendar的“17个字段的公共函数接口” * * @author skywang (kuiwu-wang@163.com) */ private static void testAllCalendarSections() { // 00. ERA 字段 testSection(Calendar.getInstance(), Calendar.ERA, &quot;Calendar.ERA&quot;); // 01. YEAR 字段 testSection(Calendar.getInstance(), Calendar.YEAR, &quot;Calendar.YEAR&quot;); // 02. MONTH 字段 testSection(Calendar.getInstance(), Calendar.MONTH, &quot;Calendar.MONTH&quot;); // 03. WEEK_OF_YEAR 字段 testSection(Calendar.getInstance(), Calendar.WEEK_OF_YEAR, &quot;Calendar.WEEK_OF_YEAR&quot;); // 04. WEEK_OF_MONTH 字段 testSection(Calendar.getInstance(), Calendar.WEEK_OF_MONTH, &quot;Calendar.WEEK_OF_MONTH&quot;); // 05. DATE 字段 testSection(Calendar.getInstance(), Calendar.DATE, &quot;Calendar.DATE&quot;); // 06. DAY_OF_MONTH 字段 testSection(Calendar.getInstance(), Calendar.DAY_OF_MONTH, &quot;Calendar.DAY_OF_MONTH&quot;); // 07. DAY_OF_YEAR 字段 testSection(Calendar.getInstance(), Calendar.DAY_OF_YEAR, &quot;Calendar.DAY_OF_YEAR&quot;); // 08. DAY_OF_WEEK 字段 testSection(Calendar.getInstance(), Calendar.DAY_OF_WEEK, &quot;Calendar.DAY_OF_WEEK&quot;); // 09. DAY_OF_WEEK_IN_MONTH 字段 testSection(Calendar.getInstance(), Calendar.DAY_OF_WEEK_IN_MONTH, &quot;Calendar.DAY_OF_WEEK_IN_MONTH&quot;); // 10. AM_PM 字段 testSection(Calendar.getInstance(), Calendar.AM_PM, &quot;Calendar.AM_PM&quot;); // 11. HOUR 字段 testSection(Calendar.getInstance(), Calendar.HOUR, &quot;Calendar.HOUR&quot;); // 12. HOUR_OF_DAY 字段 testSection(Calendar.getInstance(), Calendar.HOUR_OF_DAY, &quot;Calendar.HOUR_OF_DAY&quot;); // 13. MINUTE 字段 testSection(Calendar.getInstance(), Calendar.MINUTE, &quot;Calendar.MINUTE&quot;); // 14. SECOND 字段 testSection(Calendar.getInstance(), Calendar.SECOND, &quot;Calendar.SECOND&quot;); // 15. MILLISECOND 字段 testSection(Calendar.getInstance(), Calendar.MILLISECOND, &quot;Calendar.MILLISECOND&quot;); // 16. ZONE_OFFSET 字段 testSection(Calendar.getInstance(), Calendar.ZONE_OFFSET, &quot;Calendar.ZONE_OFFSET&quot;); } /** * 测试Calendar的“比较接口” * * @author skywang (kuiwu-wang@163.com) */ private static void testComparatorAPIs() { // 新建cal1 ，且时间为1988年 Calendar cal1 = Calendar.getInstance(); cal1.set(Calendar.YEAR, 1988); // 新建cal2 ，且时间为2000年 Calendar cal2 = Calendar.getInstance(); cal2.set(Calendar.YEAR, 2000); // 新建cal3, 为cal1的克隆对象 Calendar cal3 = (Calendar)cal1.clone(); // equals 判断 cal1和cal2的“时间、时区等”内容是否相等 boolean isEqual12 = cal1.equals(cal2); // equals 判断 cal1和cal3的“时间、时区等”内容是否相等 boolean isEqual13 = cal1.equals(cal3); // cal1是否比cal2早 boolean isBefore = cal1.before(cal2); // cal1是否比cal2晚 boolean isAfter = cal1.after(cal2); // 比较cal1和cal2 // (01) 若cal1 早于 cal2，返回-1 // (02) 若cal1 等于 cal2，返回0 // (03) 若cal1 晚于 cal2，返回1 int icompare = cal1.compareTo(cal2); System.out.printf(&quot;\\ntestComparatorAPIs: isEuqal12=%s, isEqual13=%s, isBefore=%s, isAfter=%s, icompare=%s\\n&quot;, isEqual12, isEqual13, isBefore, isAfter, icompare); } /** * 测试Calendar的“比较接口” * * @author skywang (kuiwu-wang@163.com) */ private static void testLenientAPIs() { Calendar cal = Calendar.getInstance(); // 获取默认的“宽容度”。返回true boolean oriLenient = cal.isLenient(); // MONTH值只能是“0-11”，这里越界。但是由于当前cal是宽容的，所以不会抛出异常 cal.set(Calendar.MONTH, 50); // 设置“宽容度”为false。 cal.setLenient(false); // 获取设置后的“宽容度” boolean curLenient = cal.isLenient(); try { // MONTH值只能是“0-11”，这里越界。而且当前cal是不宽容的，所以会产生异常。 // 但是，异常到下次计算日期时才会抛出。即，set()中不回抛出异常，而要等到get()中才会抛出异常 cal.set(Calendar.MONTH, 50); // 此时，对cal进行读取。读取会导致重新计算cal的值，所以此时抛出异常！ int m2 = cal.get(Calendar.MONTH); } catch (IllegalArgumentException e) { e.printStackTrace(); } System.out.printf(&quot;\\ntestLenientAPIs: oriLenient=%s, curLenient=%s\\n&quot;, oriLenient, curLenient); } /** * 测试Calendar的Date、TimeZone、MilliSecond等相关函数 * * @author skywang (kuiwu-wang@163.com) */ private static void testTimeAPIs() { Calendar cal = Calendar.getInstance(); // 设置cal的时区为“GMT+8” cal.setTimeZone(TimeZone.getTimeZone(&quot;GMT+8&quot;)); // 获取当前的cal时区 TimeZone timezone = cal.getTimeZone(); // 设置 milliseconds cal.setTimeInMillis(1279419645742l); // 获取 milliseconds long millis = cal.getTimeInMillis(); // 设置 milliseconds之后，时间也改变了。 // 获取cal对应的日期 Date date = cal.getTime(); // 设置时间为“1988-08-08” cal.set(1988, 08, 08); // 设置时间为“1999-09-09 09:09” cal.set(1999, 09, 09, 9, 9); // 设置时间为“2000-10-10 10:10:10” cal.set(2000, 10, 10, 10, 10, 10); System.out.printf(&quot;\\ntestTimeAPIs: date=%s, timezone=%s, millis=%s\\n&quot;, date, timezone, millis); } /** * 测试Calendar的clone()，getFirstDayOfWeek()等接口 * * @author skywang (kuiwu-wang@163.com) */ private static void testOtherAPIs() { Calendar cal = Calendar.getInstance(); // 克隆cal Calendar clone = (Calendar)cal.clone(); // 设置 为 2013-01-10。 // 注：2013-01-01 为“星期二”，2013-01-06为“星期天”， clone.set(Calendar.YEAR, 2013); clone.set(Calendar.MONTH, 0); clone.set(Calendar.DATE, 10); // 设置“本年的第一个星期最少包含1天”。 // 则2013-01-10属于第2个星期 clone.setMinimalDaysInFirstWeek(1); int m1 = clone.getMinimalDaysInFirstWeek(); int index1 = clone.get(Calendar.WEEK_OF_YEAR); // 设置“本年的第一个星期最少包含7天”。 // 则2013-01-10属于第1个星期 clone.setMinimalDaysInFirstWeek(7); int m2 = clone.getMinimalDaysInFirstWeek(); int index2 = clone.get(Calendar.WEEK_OF_YEAR); // 设置“每周的第一天是星期几”。 clone.setFirstDayOfWeek(Calendar.WEDNESDAY); // 获取“每周的第一天是星期几”。 int firstdayOfWeek = clone.getFirstDayOfWeek(); System.out.printf(&quot;\\ntestOtherAPIs: firstdayOfWeek=%s, [minimalDay, WeekOfYear]={(%s, %s), (%s, %s)} %s\\n&quot;, firstdayOfWeek, m1, index1, m2, index2, clone.getTime()); } } OK。今天先到此为止！ 明天再继续总结。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 时间相关内容","slug":"Java-时间相关内容","permalink":"https://smuwjs.github.io/tags/Java-时间相关内容/"}]},{"title":"设计模式14之 复合模式","date":"2017-01-13T16:00:00.000Z","path":"2017/01/14/java-source-analysis-design-pattern-series/设计模式14之 复合模式/","text":"复合模式 Compound Pattern在形式上，复合模式确实是多个模式的组合，但满足了这一条并不一定是复合模式，注意它的定义：将多个模式结合起来形成一个“框架”，以解决一般性问题，一提到“框架”，可能最容易联想到的就是MVC吧，不过MVC确实是一个经典的复合模式。 MVC与复合模式Model，View，Controller各自的职责： 这里不得不强调一下控制逻辑与应用逻辑（算法逻辑）的区别：所谓控制逻辑，就是判断在当前情景下应该调用什么对象的什么方法而应用逻辑指的是具体对象的具体方法的内部实现（某个复杂的算法，或者一系列的具体处理）（非要细说的话，View里面其实也包含了一点控制逻辑（根据用户动作判断应该调用哪一个Controller），当然，一般情况我们都把这点逻辑忽略不计的） MVC的最大优点就是把表现层View与模型Model分离，实现了设计上的松耦合（应对变化）以及代码的复用（View可以随便换，只需要改改新View里面那一丁点儿控制逻辑就好了） 前面说过了MVC是一种复合模式，那它到底复合了哪些模式，一起看看： 观察者模式： 模型实现观察者模式，当 Model 的状态改变时，相关对象将持续更。使用观察者模式可以让模型完全独立于视图和控制器，同一个模型可以使用不同的视图，甚至可以同时使用多个视图。 V和C都是M的观察者（Model的状态更新要及时通知V更新视图，或者通知C做相应逻辑处理） 策略模式： 控制器和视图实现策略模式，控制器是视图的行为，视图根据用户的行为不同 委托 不同的控制器处理用户请求，所以说Controller是View的“策略”，所以View包含的控制逻辑就是“选择策略”，也就是选择控制器Controller。 使用策略模式可让视图和模型解耦，因为控制器负责和模型交换来传递用户的请求信息，对于工作是怎么完成的，视图是可以完全不知情的。 组合模式： View的自身实现应用了组合模式（调用顶层容器的repaint方法，容器内的所有组件都会重绘） 手机显示框内，或者 web 界面，每个显示组件如果不是组合节点（窗口），就是叶节点（按钮），当控制器告诉视图更新时，只需告诉视图最顶层的组件，组合模式会处理其余的事。 MVC应用了多个模式，并能够较好的解决设计上的一般性问题，所以被称为复合模式","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式13之 代理模式","date":"2017-01-12T16:00:00.000Z","path":"2017/01/13/java-source-analysis-design-pattern-series/设计模式13之 代理模式/","text":"代理模式 Proxy Pattern为另一个对象提供替身或者占位符以控制这个对象的访问。 通常代理类内含有一个被代理类的引用。 类图 代理分类远程代理通过 RMI 和 JNDI 进行远程方法调用，在不同 JVM 中进行交互。 虚拟代理通常利用代理对象来创建和销毁占用较多资源的被代理对象。用来延迟大资源对象的创建。 动态代理 Dynamic Proxy java.lang.reflect.ProxyProxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类 InvocationHandler是代理实例的调用处理程序实现的接口，每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。 动态Proxy是这样的一种类:它是在运行生成的类，在生成时你必须提供一组Interface给它，然后该class就宣称它实现了这些interface。你可以把该class的实例当作这些interface中的任何一个来用。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。 在使用动态代理类时，我们必须实现InvocationHandler接口步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1、定义抽象角色 [共同的接口] :动态代理的使用，体会反射是动态语言的关键interface Subject &#123; void action();&#125;//2、定义真实角色 :被代理类 class RealSubject implements Subject &#123; public void action() &#123; System.out.println( \"我是被代理类，记得要执行我！\" ); &#125;&#125;//3、定义代理角色 :定义代理类class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 实现了接口的被代理类的对象的声明 // 作用：①给被代理的对象实例化②返回一个代理类的对象 public Object blind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); &#125; //当通过代理类的对象发起对被重写的方法的调用时，都会转换为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method方法的返回值时returnVal Object returnVal = method.invoke(obj, args); return returnVal; &#125;&#125;//测试类public class TestProxy &#123; public static void main(String[] args) &#123; //1.被代理类的对象 RealSubject real = new RealSubject(); //2.创建一个实现了InvacationHandler接口的代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3.调用blind()方法，动态的返回一个同样实现了real所在类实现的接口Subject的代理类的对象。 Object obj = handler.blind(real); Subject sub = (Subject)obj; //此时sub就是代理类的对象 sub.action(); //转到对InvacationHandler接口的实现类的invoke()方法的调用 &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式12之 状态模式","date":"2017-01-11T16:00:00.000Z","path":"2017/01/12/java-source-analysis-design-pattern-series/设计模式12之 状态模式/","text":"状态模式 State Pattern定义状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 可以将状态封装成一个独立的类 类图","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式11之 组合模式","date":"2017-01-10T16:00:00.000Z","path":"2017/01/11/java-source-analysis-design-pattern-series/设计模式11之 组合模式/","text":"组合模式 Composite Pattern定义组合模式允许你将对象组合成树形结构来表现 “整体/部分” 层次结构。组合能让客户以一致方式处理个别对象以及对象组合。 类图 例图 代码123456789101112131415161718192021222324252627282930313233import java.util.*;public abstract class MenuComponent &#123; public void add(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; public void remove(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; public MenuComponent getChild(int i) &#123; throw new UnsupportedOperationException(); &#125; public String getName() &#123; throw new UnsupportedOperationException(); &#125; public String getDescription() &#123; throw new UnsupportedOperationException(); &#125; public double getPrice() &#123; throw new UnsupportedOperationException(); &#125; public boolean isVegetarian() &#123; throw new UnsupportedOperationException(); &#125; public abstract Iterator createIterator(); public void print() &#123; throw new UnsupportedOperationException(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Iterator;import java.util.ArrayList;public class Menu extends MenuComponent &#123; ArrayList menuComponents = new ArrayList(); String name; String description; public Menu(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(MenuComponent menuComponent) &#123; menuComponents.add(menuComponent); &#125; public void remove(MenuComponent menuComponent) &#123; menuComponents.remove(menuComponent); &#125; public MenuComponent getChild(int i) &#123; return (MenuComponent)menuComponents.get(i); &#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public Iterator createIterator() &#123; return new CompositeIterator(menuComponents.iterator()); &#125; public void print() &#123; System.out.print(\"\\n\" + getName()); System.out.println(\", \" + getDescription()); System.out.println(\"---------------------\"); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext()) &#123; MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Iterator;import java.util.ArrayList;public class MenuItem extends MenuComponent &#123; String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) &#123; this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; &#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public double getPrice() &#123; return price; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; // 空 Iterator public Iterator createIterator() &#123; return new NullIterator(); &#125; public void print() &#123; System.out.print(\" \" + getName()); if (isVegetarian()) &#123; System.out.print(\"(v)\"); &#125; System.out.println(\", \" + getPrice()); System.out.println(\" -- \" + getDescription()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*; public class CompositeIterator implements Iterator &#123; // Stack继承于Vector，意味着Vector拥有的属性和功能 Stack stack = new Stack(); public CompositeIterator(Iterator iterator) &#123; stack.push(iterator); &#125; public Object next() &#123; if (hasNext()) &#123; /* peek()取出栈顶元素，不执行删除 */ Iterator iterator = (Iterator) stack.peek(); MenuComponent component = (MenuComponent) iterator.next(); if (component instanceof Menu) &#123; stack.push(component.createIterator()); &#125; return component; &#125; else &#123; return null; &#125; &#125; public boolean hasNext() &#123; if (stack.empty()) &#123; return false; &#125; else &#123; Iterator iterator = (Iterator) stack.peek(); if (!iterator.hasNext()) &#123; /* pop() 取出栈顶元素，且执行删除 */ stack.pop(); return hasNext(); &#125; else &#123; return true; &#125; &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 12345678910111213141516171819202122232425262728import java.util.Iterator; public class Waitress &#123; MenuComponent allMenus; public Waitress(MenuComponent allMenus) &#123; this.allMenus = allMenus; &#125; public void printMenu() &#123; allMenus.print(); &#125; public void printVegetarianMenu() &#123; Iterator iterator = allMenus.createIterator(); System.out.println(\"\\nVEGETARIAN MENU\\n----\"); while (iterator.hasNext()) &#123; MenuComponent menuComponent = (MenuComponent)iterator.next(); try &#123; if (menuComponent.isVegetarian()) &#123; menuComponent.print(); &#125; &#125; catch (UnsupportedOperationException e) &#123;&#125; &#125; &#125;&#125; 12345678910111213141516import java.util.Iterator; public class NullIterator implements Iterator &#123; public Object next() &#123; return null; &#125; public boolean hasNext() &#123; return false; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.util.*;public class MenuTestDrive &#123; public static void main(String args[]) &#123; MenuComponent pancakeHouseMenu = new Menu(\"PANCAKE HOUSE MENU\", \"Breakfast\"); MenuComponent dinerMenu = new Menu(\"DINER MENU\", \"Lunch\"); MenuComponent cafeMenu = new Menu(\"CAFE MENU\", \"Dinner\"); MenuComponent dessertMenu = new Menu(\"DESSERT MENU\", \"Dessert of course!\"); MenuComponent allMenus = new Menu(\"ALL MENUS\", \"All menus combined\"); allMenus.add(pancakeHouseMenu); allMenus.add(dinerMenu); allMenus.add(cafeMenu); pancakeHouseMenu.add(new MenuItem( \"K&amp;B's Pancake Breakfast\", \"Pancakes with scrambled eggs, and toast\", true, 2.99)); pancakeHouseMenu.add(new MenuItem( \"Regular Pancake Breakfast\", \"Pancakes with fried eggs, sausage\", false, 2.99)); pancakeHouseMenu.add(new MenuItem( \"Blueberry Pancakes\", \"Pancakes made with fresh blueberries, and blueberry syrup\", true, 3.49)); pancakeHouseMenu.add(new MenuItem( \"Waffles\", \"Waffles, with your choice of blueberries or strawberries\", true, 3.59)); dinerMenu.add(new MenuItem( \"Vegetarian BLT\", \"(Fakin') Bacon with lettuce &amp; tomato on whole wheat\", true, 2.99)); dinerMenu.add(new MenuItem( \"BLT\", \"Bacon with lettuce &amp; tomato on whole wheat\", false, 2.99)); dinerMenu.add(new MenuItem( \"Soup of the day\", \"A bowl of the soup of the day, with a side of potato salad\", false, 3.29)); dinerMenu.add(new MenuItem( \"Hotdog\", \"A hot dog, with saurkraut, relish, onions, topped with cheese\", false, 3.05)); dinerMenu.add(new MenuItem( \"Steamed Veggies and Brown Rice\", \"A medly of steamed vegetables over brown rice\", true, 3.99)); dinerMenu.add(new MenuItem( \"Pasta\", \"Spaghetti with Marinara Sauce, and a slice of sourdough bread\", true, 3.89)); dinerMenu.add(dessertMenu); dessertMenu.add(new MenuItem( \"Apple Pie\", \"Apple pie with a flakey crust, topped with vanilla icecream\", true, 1.59)); dessertMenu.add(new MenuItem( \"Cheesecake\", \"Creamy New York cheesecake, with a chocolate graham crust\", true, 1.99)); dessertMenu.add(new MenuItem( \"Sorbet\", \"A scoop of raspberry and a scoop of lime\", true, 1.89)); cafeMenu.add(new MenuItem( \"Veggie Burger and Air Fries\", \"Veggie burger on a whole wheat bun, lettuce, tomato, and fries\", true, 3.99)); cafeMenu.add(new MenuItem( \"Soup of the day\", \"A cup of the soup of the day, with a side salad\", false, 3.69)); cafeMenu.add(new MenuItem( \"Burrito\", \"A large burrito, with whole pinto beans, salsa, guacamole\", true, 4.29)); Waitress waitress = new Waitress(allMenus); waitress.printVegetarianMenu(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式10之 迭代器模式","date":"2017-01-09T16:00:00.000Z","path":"2017/01/10/java-source-analysis-design-pattern-series/设计模式10之 迭代器模式/","text":"迭代器模式 Iterator Pattern设计原则 九：单一责任原则，一个类应该只有一个引起变化的原因。将一个责任只委派给一个类。类的每个责任都有一个潜在的改变区域，超过一个责任意味着超过一个改变区域， 定义迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 用迭代器来封装集合对象的遍历细节，使调用者能够通过统一的接口来实现对集合的遍历，迭代器也给集合对象提供了一定的保护，想要遍历集合，直接调用迭代器的方法就好了，我们不知道也不必知道集合内部的数据管理方式。 类图 例图 代码迭代器接口 123456789101112131415package IteratorPattern; /** * 定义迭代器 */public interface Iterator &#123; /** * @return 集合内是否存在下一个元素 */ public abstract boolean hasNext(); /** * @return 返回集合内的下一个元素 */ public abstract Object next();&#125; 还需要实现一些具体的迭代器来实现遍历细节：Array迭代器： 1234567891011121314151617181920212223242526272829package IteratorPattern; /** * 实现数组迭代器 */public class ArrayIterator implements Iterator&#123; MyObject[] arr; //自定义对象数组 int index = 0; //当前索引 public ArrayIterator(MyObject[] arr)&#123; this.arr = arr; &#125; @Override public boolean hasNext() &#123; if(index &lt; arr.length &amp;&amp; arr[index] != null) return true; return false; &#125; @Override public Object next() &#123; MyObject mo = arr[index]; index++; return mo; &#125;&#125; P.S.注意Array迭代器的hasNext方法的具体实现List迭代器： 123456789101112131415161718192021222324252627282930package IteratorPattern;import java.util.List; /** * 实现List迭代器 */public class ListIterator implements Iterator&#123; List&lt;MyObject&gt; list; //集合对象 int index = 0; //当前索引 public ListIterator(List&lt;MyObject&gt; list)&#123; this.list = list; &#125; @Override public boolean hasNext() &#123; if(index &lt; list.size()) return true; return false; &#125; @Override public Object next() &#123; MyObject mo = list.get(index); index++; return mo; &#125;&#125; 有了这些具体迭代器，我们只需要一个循环就可以搞定了： 123456789/** * 打印集合所有内容 * @param iter 集合的迭代器 */private static void printObjs(Iterator iter)&#123; while(iter.hasNext())&#123; System.out.println(iter.next().toString()); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式09之 模板方法模式","date":"2017-01-08T16:00:00.000Z","path":"2017/01/09/java-source-analysis-design-pattern-series/设计模式09之 模板方法模式/","text":"模板方法模式设计原则 八：好莱坞原则，别调用（打电话给）我们，我们会调用（打电话给）你 即高层组件对低层组件的调用方式。 定义模板方法模式在一个方法中定义一个算法的骨架，而将一些步奏延迟到子类中去。模板方法模式使得子类可在不改变算法结构的前提下，重新定义算法中的某些步奏。 类图 例图 实现代码此处的 hook() 方法，钩子方法是一种被声明在抽象类中的方法，但只有默认的实现或者空的。钩子的存在，让子类有能力对算法的不同点进行挂钩，是否挂钩由子类自行决定。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式08之 外观模式","date":"2017-01-07T16:00:00.000Z","path":"2017/01/08/java-source-analysis-design-pattern-series/设计模式08之 外观模式/","text":"外观模式 Facade Pattern设计原则 七：最少知识原则，只和密友交谈。 维护此原则的方针，就任何对象而言，在该对象的方法内，我们只调用属于以下范围的方法： 该对象本身 被当做方法的参数而传进来的对象 此方法所创建和实例化的对象 对象的任何组件 将朋友圈子保持最小。以上告诉我们，如果某对象是调用其他方法的返回结果，不要调用该对象的方法。 定义外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 类图","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式07之 适配器模式","date":"2017-01-06T16:00:00.000Z","path":"2017/01/07/java-source-analysis-design-pattern-series/设计模式07之 适配器模式/","text":"适配器模式 Adapter Pattern定义适配器模式将一个类的接口转换为客户期望的另一个接口。适配器让原本接口不兼容的类合作无间。 Java 适配器模式的应用，将枚举Enumeration 适配到迭代器 Iterator 类图 由类图可以看到，适配器实现目标接口，并且组合一个被适配者， 实例代码1234public interface Duck &#123; public void quack(); public void fly();&#125; 1234public interface Turkey &#123; public void gobble(); public void fly();&#125; 123456789public class MallardDuck implements Duck &#123; public void quack() &#123; System.out.println(\"Quack\"); &#125; public void fly() &#123; System.out.println(\"I'm flying\"); &#125;&#125; 1234567891011121314151617public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; public void quack() &#123; turkey.gobble(); &#125; public void fly() &#123; for(int i=0; i &lt; 5; i++) &#123; turkey.fly(); &#125; &#125;&#125; 12345678910111213141516171819202122232425package headfirst.adapter.ducks;public class DuckTestDrive &#123; public static void main(String[] args) &#123; MallardDuck duck = new MallardDuck(); WildTurkey turkey = new WildTurkey(); Duck turkeyAdapter = new TurkeyAdapter(turkey); System.out.println(\"The Turkey says...\"); turkey.gobble(); turkey.fly(); System.out.println(\"\\nThe Duck says...\"); testDuck(duck); System.out.println(\"\\nThe TurkeyAdapter says...\"); testDuck(turkeyAdapter); &#125; static void testDuck(Duck duck) &#123; duck.quack(); duck.fly(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式06之 命令模式","date":"2017-01-05T16:00:00.000Z","path":"2017/01/06/java-source-analysis-design-pattern-series/设计模式06之 命令模式/","text":"命令模式定义命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 现实世界中任何一个稍微复杂的子系统都应当有一套命令，比如餐馆的运行机制：顾客A来到餐馆点一碗面（发出请求） -&gt; 柜台服务员记录下来（创建命令） -&gt; 服务员把小票扔给厨房 -&gt; 厨师C很快做好了一碗面（请求被执行）顾客不知道将由谁来做这碗面，柜台服务员也不知道，厨师不知道是谁点了这碗面，只知道做完面就可以休息了 是不是与命令模式很相像？ 不妨用代码来实现上面的机制 首先，我们需要一个命令接口，毕竟命令才是命令模式的核心，没有命令，一切都是空想 12345678package CommandPattern; /** * 定义Command接口 */public interface Command &#123; public abstract void execute(); //只需要定义一个统一的执行方法&#125; 有了命令还需要执行者，否则只有将军没有小兵，餐馆的执行者当然是厨师： 1234567891011121314package CommandPattern; /** * 定义Chef基类 */public abstract class Chef &#123; //在此定义厨师的公共属性 /** * 定义烹饪方法 */ public abstract void cook(); //在此定义其它有用的方法&#125; 我们还需要实现具体的厨师，术业有专攻：做面的厨师： 123456789101112package CommandPattern; /** * 定义专业做面的厨师 */public class NoodlesChef extends Chef&#123; @Override public void cook() &#123; System.out.println(&quot;做好了一碗美味的拉面&quot;); &#125;&#125; 做饼的厨师： 123456789101112package CommandPattern; /** * 定义专业做饼的厨师 */public class PieChef extends Chef&#123; @Override public void cook() &#123; System.out.println(&quot;做好了一块香喷喷的大饼&quot;); &#125;&#125; 有了小兵，有了将军，我们还需要一套完整的命令： 123456789101112131415161718package CommandPattern; /** * 实现具体NoodlesCommand */public class NoodlesCommand implements Command&#123; private NoodlesChef chef;//专业做面的厨师 public NoodlesCommand()&#123; chef = new NoodlesChef(); &#125; @Override public void execute() &#123; chef.cook(); //调用其它需要的方法 &#125;&#125; 123456789101112131415161718package CommandPattern; /** * 实现具体PieCommand */public class PieCommand implements Command&#123; private PieChef chef;//专业做饼的厨师 public PieCommand()&#123; chef = new PieChef(); &#125; @Override public void execute() &#123; chef.cook(); //调用其它需要的方法 &#125;&#125; 准备工作做好了，餐馆可以开张了三.效果示例需要一个Test类： 1234567891011121314151617181920212223242526272829package CommandPattern; /** * 实现测试类 */public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;Command Pattern餐馆开张。。&quot;); System.out.println(&quot;第一位客户X先生&quot;); System.out.println(&quot;X先生：你好，我需要一碗面，我饿极了&quot;); NoodlesCommand nCmd = new NoodlesCommand(); System.out.println(&quot;柜台服务员：好的，我已经记下了，马上就好&quot;); System.out.println(&quot;柜台服务员：厨房~~,接单&quot;); nCmd.execute(); System.out.println(&quot;X先生：真快啊！&quot;); System.out.println(); System.out.println(&quot;第二位客户XX先生&quot;); System.out.println(&quot;XX先生：你好，我需要一块饼，20分钟后来取&quot;); PieCommand pCmd = new PieCommand(); System.out.println(&quot;柜台服务员：好的，我已经记下了&quot;); System.out.println(&quot;15分钟后&quot;); System.out.println(&quot;柜台服务员：厨房~~,接单&quot;); pCmd.execute(); System.out.println(&quot;XX先生：真准时啊！&quot;); &#125;&#125; 结果示例：","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式05之 单例模式","date":"2017-01-04T16:00:00.000Z","path":"2017/01/05/java-source-analysis-design-pattern-series/设计模式05之 单例模式/","text":"单例模式 Singleton Pattern 私有化 构造器 私有化 静态变量 公有化 对象获取函数返回一个实例 定义单例模式确保一个类只有一个实例，并提供一个全局访问点。 懒汉单例模式12345678910111213141516171819202122232425262728293031323334/** * 最经典的懒汉单件模式 */public class Singleton &#123; private volatile static Singleton instance;//定义静态实例变量 /** * 定义私有构造方法，防止从外部new实例 */ private Singleton()&#123; //初始化操作 &#125; /** * 提供全局访问点 * 双重检查加锁 * @return 该类的实例 */ public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125; /** * 其它有用的属性和行为 * 毕竟应用了单件模式的类仍然具有原本的功能 */&#125; 123456789volatile ：原子性。它作用是解决是因为//1：分配对象的内存空间//2：初始化对象//3：设置instance指向刚分配的内存地址2 初始化对象 与 3 设置 instance 指向分配的内存地址可能会发生顺序交换，导致问题volatile关键字会告诉编译器，不要对该对象进行编译优化 饿汗单例模式123456789101112131415161718192021222324252627/** * 饿汉单件模式 */public class Singleton &#123; private static Singleton instance = new Singleton();//定义静态实例变量 /** * 定义私有构造方法，防止从外部new实例 */ private Singleton()&#123; //初始化操作 &#125; /** * 提供全局访问点 * @return 该类的实例 */ public static Singleton getInstance()&#123; return instance; &#125; /** * 其它有用的属性和行为 * 毕竟应用了单件模式的类仍然具有原本的功能 */&#125; 多个class loader环境下的单件模式如果存在多个类加载器，多个类加载器可能同时加载我们的单件类，从而产生多个实例对于这种情况，我们可以显式指定使用哪一个class loader来加载单件类，这样就有效避免了上述问题","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式04之 工厂模式","date":"2017-01-03T16:00:00.000Z","path":"2017/01/04/java-source-analysis-design-pattern-series/设计模式04之 工厂模式/","text":"工厂模式设计原则 六：依赖倒置原则 (Dependency Inversion Principe) 要依赖抽象，不要依赖具体类。 不要让高层组件依赖低层组件，要让“二者”依赖抽象。 变量不可以持有具体类的引用（如果使用 new 就会有具体类的引用，可以使用工厂模式帮助我们避开此问题） 不要让类派生自具体类（可以派生自接口或抽象类） 不要实现基类中已经实现的方法。（若覆盖基类已实现的方法，那此基类就不是真正适合被继承的抽象。基类中已实现的方法应该由所有子类共享。） 简单工厂模式 Simple Factory Pattern 也就是常用的在Factory类中定义静态方法负责new对象的方式。 严格地说，这种被称为“简单工厂模式”的方式根本不能称之为“模式”，虽然静态工厂方法并不是真正的“设计模式”，但这种方式的应用也很广泛，也能带来一些好处，所以我们不能因为它不是“设计模式”就抛弃它。 工厂模式 Factory Pattern定义了一个创建对象的接口，但由子类来决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 类图 例图 抽象工厂模式 Abstract Factory Pattern提供一个接口，用创建相关或依赖对象的家族，而不需要明确指定具体类。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式03之 装饰者模式","date":"2017-01-02T16:00:00.000Z","path":"2017/01/03/java-source-analysis-design-pattern-series/设计模式03之 装饰者模式/","text":"装饰者模式 Decorator Pattern设计原则 五：开放-关闭原则，类应该对拓展开放，对修改关闭。 定义装饰者模式装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 Java 装饰者者模式的应用，Java I/O 流的 装饰者和被装饰对象有相同的超类型。 你可以用一个或多个装饰者包装一个对象。 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合， 可以用装饰过的对象代替它。 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。（重要） 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰 对象。 类图 例图 装饰者类解析 1234567891011package headfirst.decorator.starbuzz;public abstract class Beverage &#123; String description = \"Unknown Beverage\"; public String getDescription() &#123; return description; &#125; public abstract double cost();&#125; 12345package headfirst.decorator.starbuzz;public abstract class CondimentDecorator extends Beverage &#123; public abstract String getDescription();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package headfirst.decorator.starbuzz;public class DarkRoast extends Beverage &#123; public DarkRoast() &#123; description = \"Dark Roast Coffee\"; &#125; public double cost() &#123; return .99; &#125;&#125;package headfirst.decorator.starbuzz;public class Decaf extends Beverage &#123; public Decaf() &#123; description = \"Decaf Coffee\"; &#125; public double cost() &#123; return 1.05; &#125;&#125;package headfirst.decorator.starbuzz;public class Espresso extends Beverage &#123; public Espresso() &#123; description = \"Espresso\"; &#125; public double cost() &#123; return 1.99; &#125;&#125;package headfirst.decorator.starbuzz;public class HouseBlend extends Beverage &#123; public HouseBlend() &#123; description = \"House Blend Coffee\"; &#125; public double cost() &#123; return .89; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package headfirst.decorator.starbuzz;public class Milk extends CondimentDecorator &#123; Beverage beverage; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + \", Milk\"; &#125; public double cost() &#123; return .10 + beverage.cost(); &#125;&#125;package headfirst.decorator.starbuzz;public class Mocha extends CondimentDecorator &#123; Beverage beverage; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + \", Mocha\"; &#125; public double cost() &#123; return .20 + beverage.cost(); &#125;&#125;package headfirst.decorator.starbuzz;public class Soy extends CondimentDecorator &#123; Beverage beverage; public Soy(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + \", Soy\"; &#125; public double cost() &#123; return .15 + beverage.cost(); &#125;&#125;package headfirst.decorator.starbuzz; public class Whip extends CondimentDecorator &#123; Beverage beverage; public Whip(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + \", Whip\"; &#125; public double cost() &#123; return .10 + beverage.cost(); &#125;&#125; 123456789101112131415161718192021222324package headfirst.decorator.starbuzz;public class StarbuzzCoffee &#123; public static void main(String args[]) &#123; Beverage beverage = new Espresso(); System.out.println(beverage.getDescription() + \" $\" + beverage.cost()); Beverage beverage2 = new DarkRoast(); beverage2 = new Mocha(beverage2); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(beverage2.getDescription() + \" $\" + beverage2.cost()); Beverage beverage3 = new HouseBlend(); beverage3 = new Soy(beverage3); beverage3 = new Mocha(beverage3); beverage3 = new Whip(beverage3); System.out.println(beverage3.getDescription() + \" $\" + beverage3.cost()); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式02之 观察者模式","date":"2017-01-01T16:00:00.000Z","path":"2017/01/02/java-source-analysis-design-pattern-series/设计模式02之 观察者模式/","text":"观察者模式 Observer Pattern出版者＋订阅者 = 观察者模式 出版者（主题：subject）订阅者（观察者：observer） 设计原则 四：为了交互对象之间的松耦合设计而努力。 定义观察者模式观察者模式定义了对象之间的一对多依赖，这样一来，当对象改变状态时，它的所有依赖者都会收到通知并自动更新。 Java有多种观察者模式的实现，包括了通用的java.util. Observable。 类图 123456789101112131415package headfirst.observer.weather;public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125;public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125;public interface DisplayElement &#123; public void display();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package headfirst.observer.weather;import java.util.*;public class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++) &#123; Observer observer = (Observer)observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125; // other WeatherData methods here public float getTemperature() &#123; return temperature; &#125; public float getHumidity() &#123; return humidity; &#125; public float getPressure() &#123; return pressure; &#125;&#125; 1234567891011121314151617181920212223package headfirst.observer.weather; public class CurrentConditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display() &#123; System.out.println(&quot;Current conditions: &quot; + temperature + &quot;F degrees and &quot; + humidity + &quot;% humidity&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132package headfirst.observer.weather;import java.util.*;public class ForecastDisplay implements Observer, DisplayElement &#123; private float currentPressure = 29.92f; private float lastPressure; private WeatherData weatherData; public ForecastDisplay(WeatherData weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temp, float humidity, float pressure) &#123; lastPressure = currentPressure; currentPressure = pressure; display(); &#125; public void display() &#123; System.out.print(&quot;Forecast: &quot;); if (currentPressure &gt; lastPressure) &#123; System.out.println(&quot;Improving weather on the way!&quot;); &#125; else if (currentPressure == lastPressure) &#123; System.out.println(&quot;More of the same&quot;); &#125; else if (currentPressure &lt; lastPressure) &#123; System.out.println(&quot;Watch out for cooler, rainy weather&quot;); &#125; &#125;&#125; 测试 12345678910111213141516171819package headfirst.observer.weather;import java.util.*;public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"设计模式01之 策略模式","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/java-source-analysis-design-pattern-series/设计模式01之 策略模式/","text":"策略模式 Strategy Pattern设计原则 一：找出应用中可能需要变化之处， 把它们独立出来， 不要和那些不需要变化的代码混在一起。 设计原则 二：针对接口编程，而不是针对实现编程。 针对接口编程真正的意思是针对超类型（supertype） 编程。利用多态， 程序可以针对超类型编程， 执行时会根据实际状况执行到真正的行为， 不会被绑死在超类型的行为上。 超类型： 通常是一个抽象类或者是一个接口 设计原则 三：（当我们需要扩展类的行为时）多用组合，少用继承。 使用组合建立系统具有很大的弹性， 不仅可将算法族封装成类，更可以在运行时动态地改变行为， 只要组合的行为对象， 符合正确的接口标准即可。 策略模式定义：策略模式定义了算法族， 分别封装起来， 让它们之间可以互相替换， 此模式让算法的变化独立于使用算法的客户。 2017-06-06-14965513657651","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://smuwjs.github.io/tags/Java设计模式/"}]},{"title":"Java 集合系列18之 Iterator和Enumeration比较","date":"2016-12-17T16:00:00.000Z","path":"2016/12/18/java-source-analysis-set-series/Java 集合系列18之 Iterator和Enumeration比较/","text":"Iterator和Enumeration区别在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。今天，我们就一起学习一下它们之间到底有什么区别。 我们先看看 Enumeration.java 和 Iterator.java的源码，再说它们的区别。 Enumeration是一个接口，它的源码如下： 12345678package java.util;public interface Enumeration&lt;E&gt; &#123; boolean hasMoreElements(); E nextElement();&#125; Iterator也是一个接口，它的源码如下： 123456789package java.util;public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 看完代码了，我们再来说说它们之间的区别。 函数接口不同 Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。 Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。 Iterator支持fail-fast机制，而Enumeration不支持。 Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。 而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 Iterator和Enumeration实例下面，我们编写一个Hashtable，然后分别通过 Iterator 和 Enumeration 去遍历它，比较它们的效率。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Enumeration;import java.util.Hashtable;import java.util.Iterator;import java.util.Map.Entry;import java.util.Random;/* * 测试分别通过 Iterator 和 Enumeration 去遍历Hashtable * @author skywang */public class IteratorEnumeration &#123; public static void main(String[] args) &#123; int val; Random r = new Random(); Hashtable table = new Hashtable(); for (int i=0; i&lt;100000; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); table.put(String.valueOf(i), val); &#125; // 通过Iterator遍历Hashtable iterateHashtable(table) ; // 通过Enumeration遍历Hashtable enumHashtable(table); &#125; /* * 通过Iterator遍历Hashtable */ private static void iterateHashtable(Hashtable table) &#123; long startTime = System.currentTimeMillis(); Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) &#123; //System.out.println(\"iter:\"+iter.next()); iter.next(); &#125; long endTime = System.currentTimeMillis(); countTime(startTime, endTime); &#125; /* * 通过Enumeration遍历Hashtable */ private static void enumHashtable(Hashtable table) &#123; long startTime = System.currentTimeMillis(); Enumeration enu = table.elements(); while(enu.hasMoreElements()) &#123; //System.out.println(\"enu:\"+enu.nextElement()); enu.nextElement(); &#125; long endTime = System.currentTimeMillis(); countTime(startTime, endTime); &#125; private static void countTime(long start, long end) &#123; System.out.println(\"time: \"+(end-start)+\"ms\"); &#125;&#125; 运行结果如下： 12time: 9mstime: 5ms 从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列17之 TreeSet详细介绍","date":"2016-12-16T16:00:00.000Z","path":"2016/12/17/java-source-analysis-set-series/Java 集合系列17之 TreeSet详细介绍/","text":"TreeSet简介TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet, Cloneable, java.io.Serializable接口。 TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。TreeSet 实现了Cloneable接口，意味着它能被克隆。TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。 TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。 TreeSet的构造函数1234567891011// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。TreeSet()// 创建的TreeSet包含collectionTreeSet(Collection&lt;? extends E&gt; collection)// 指定TreeSet的比较器TreeSet(Comparator&lt;? super E&gt; comparator)// 创建的TreeSet包含setTreeSet(SortedSet&lt;E&gt; set) TreeSet的API1234567891011121314151617181920212223242526boolean add(E object)boolean addAll(Collection&lt;? extends E&gt; collection)void clear()Object clone()boolean contains(Object object)E first()boolean isEmpty()E last()E pollFirst()E pollLast()E lower(E e)E floor(E e)E ceiling(E e)E higher(E e)boolean remove(Object object)int size()Comparator&lt;? super E&gt; comparator()Iterator&lt;E&gt; iterator()Iterator&lt;E&gt; descendingIterator()SortedSet&lt;E&gt; headSet(E end)NavigableSet&lt;E&gt; descendingSet()NavigableSet&lt;E&gt; headSet(E end, boolean endInclusive)SortedSet&lt;E&gt; subSet(E start, E end)NavigableSet&lt;E&gt; subSet(E start, boolean startInclusive, E end, boolean endInclusive)NavigableSet&lt;E&gt; tailSet(E start, boolean startInclusive)SortedSet&lt;E&gt; tailSet(E start) 说明： TreeSet是有序的Set集合，因此支持add、remove、get等方法。 和NavigableSet一样，TreeSet的导航方法大致可以区分为两类，一类时提供元素项的导航方法，返回某个元素；另一类时提供集合的导航方法，返回某个集合。 lower、floor、higher和 ceiling 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。 TreeSet数据结构TreeSet的继承关系 1234567java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.TreeSet&lt;E&gt;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125; TreeSet与Collection关系图： 从图中可以看出： TreeSet继承于AbstractSet，并且实现了NavigableSet接口。 TreeSet的本质是一个”有序的，并且没有重复元素”的集合，它是通过TreeMap实现的。TreeSet中含有一个”NavigableMap类型的成员变量”m，而m实际上是”TreeMap的实例”。 TreeSet源码解析(基于JDK1.6.0_45)为了更了解TreeSet的原理，下面对TreeSet源码代码作出分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239package java.util;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; // NavigableMap对象 private transient NavigableMap&lt;E,Object&gt; m; // TreeSet是通过TreeMap实现的， // PRESENT是键-值对中的值。 private static final Object PRESENT = new Object(); // 不带参数的构造函数。创建一个空的TreeMap public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; // 将TreeMap赋值给 \"NavigableMap对象m\" TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; // 带比较器的构造函数。 public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;E,Object&gt;(comparator)); &#125; // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中 public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); // 将集合c中的元素全部添加到TreeSet中 addAll(c); &#125; // 创建TreeSet，并将s中的全部元素都添加到TreeSet中 public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; // 返回TreeSet的顺序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator(); &#125; // 返回TreeSet的逆序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator(); &#125; // 返回TreeSet的大小 public int size() &#123; return m.size(); &#125; // 返回TreeSet是否为空 public boolean isEmpty() &#123; return m.isEmpty(); &#125; // 返回TreeSet是否包含对象(o) public boolean contains(Object o) &#123; return m.containsKey(o); &#125; // 添加e到TreeSet中 public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; // 删除TreeSet中的对象o public boolean remove(Object o) &#123; return m.remove(o)==PRESENT; &#125; // 清空TreeSet public void clear() &#123; m.clear(); &#125; // 将集合c中的全部元素添加到TreeSet中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // Use linear-time version if applicable if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; return super.addAll(c); &#125; // 返回子Set，实际上是通过TreeMap的subMap()实现的。 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; // 返回Set的头部，范围是：从头部到toElement。 // inclusive是是否包含toElement的标志 public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; // 返回Set的尾部，范围是：从fromElement到结尾。 // inclusive是是否包含fromElement的标志 public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。 public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; // 返回Set的头部，范围是：从头部到toElement(不包括)。 public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。 public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; // 返回Set的比较器 public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; // 返回Set的第一个元素 public E first() &#123; return m.firstKey(); &#125; // 返回Set的最后一个元素 public E first() &#123; public E last() &#123; return m.lastKey(); &#125; // 返回Set中小于e的最大元素 public E lower(E e) &#123; return m.lowerKey(e); &#125; // 返回Set中小于/等于e的最大元素 public E floor(E e) &#123; return m.floorKey(e); &#125; // 返回Set中大于/等于e的最小元素 public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; // 返回Set中大于e的最小元素 public E higher(E e) &#123; return m.higherKey(e); &#125; // 获取第一个元素，并将该元素从TreeMap中删除。 public E pollFirst() &#123; Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null)? null : e.getKey(); &#125; // 获取最后一个元素，并将该元素从TreeMap中删除。 public E pollLast() &#123; Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null)? null : e.getKey(); &#125; // 克隆一个TreeSet，并返回Object对象 public Object clone() &#123; TreeSet&lt;E&gt; clone = null; try &#123; clone = (TreeSet&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; clone.m = new TreeMap&lt;E,Object&gt;(m); return clone; &#125; // java.io.Serializable的写入函数 // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); // 写入比较器 s.writeObject(m.comparator()); // 写入容量 s.writeInt(m.size()); // 写入“TreeSet中的每一个元素” for (Iterator i=m.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeSet的“比较器、容量、所有的元素值”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden stuff s.defaultReadObject(); // 从输入流中读取TreeSet的“比较器” Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); TreeMap&lt;E,Object&gt; tm; if (c==null) tm = new TreeMap&lt;E,Object&gt;(); else tm = new TreeMap&lt;E,Object&gt;(c); m = tm; // 从输入流中读取TreeSet的“容量” int size = s.readInt(); // 从输入流中读取TreeSet的“全部元素” tm.readTreeSet(size, s, PRESENT); &#125; // TreeSet的序列版本号 private static final long serialVersionUID = -2479143000061671589L;&#125; 总结： TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 TreeSet是非线程安全的。 TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。 TreeSet遍历方式Iterator顺序遍历123for(Iterator iter = set.iterator(); iter.hasNext(); ) &#123; iter.next();&#125; Iterator倒序遍历1234// 假设set是TreeSet对象for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) &#123; iter.next();&#125; for-each遍历HashSet1234// 假设set是TreeSet对象，并且set中元素是String类型String[] arr = (String[])set.toArray(new String[0]);for (String str:arr) System.out.printf(\"for each : %s\\n\", str); TreeSet不支持快速随机遍历，只能通过迭代器进行遍历！ TreeSet遍历测试程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;/** * @desc TreeSet的遍历程序 * * @author skywang * @email kuiwu-wang@163.com */public class TreeSetIteratorTest &#123; public static void main(String[] args) &#123; TreeSet set = new TreeSet(); set.add(\"aaa\"); set.add(\"aaa\"); set.add(\"bbb\"); set.add(\"eee\"); set.add(\"ddd\"); set.add(\"ccc\"); // 顺序遍历TreeSet ascIteratorThroughIterator(set) ; // 逆序遍历TreeSet descIteratorThroughIterator(set); // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 foreachTreeSet(set); &#125; // 顺序遍历TreeSet public static void ascIteratorThroughIterator(TreeSet set) &#123; System.out.print(\"\\n ---- Ascend Iterator ----\\n\"); for(Iterator iter = set.iterator(); iter.hasNext(); ) &#123; System.out.printf(\"asc : %s\\n\", iter.next()); &#125; &#125; // 逆序遍历TreeSet public static void descIteratorThroughIterator(TreeSet set) &#123; System.out.printf(\"\\n ---- Descend Iterator ----\\n\"); for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) System.out.printf(\"desc : %s\\n\", (String)iter.next()); &#125; // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 private static void foreachTreeSet(TreeSet set) &#123; System.out.printf(\"\\n ---- For-each ----\\n\"); String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(\"for each : %s\\n\", str); &#125;&#125; 运行结果： 1234567891011121314151617181920 ---- Ascend Iterator ----asc : aaaasc : bbbasc : cccasc : dddasc : eee ---- Descend Iterator ----desc : eeedesc : ddddesc : cccdesc : bbbdesc : aaa ---- For-each ----for each : aaafor each : bbbfor each : cccfor each : dddfor each : eee TreeSet示例下面通过实例学习如何使用TreeSet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.*;/** * @desc TreeSet的API测试 * * @author skywang * @email kuiwu-wang@163.com */public class TreeSetTest &#123; public static void main(String[] args) &#123; testTreeSetAPIs(); &#125; // 测试TreeSet的api public static void testTreeSetAPIs() &#123; String val; // 新建TreeSet TreeSet tSet = new TreeSet(); // 将元素添加到TreeSet中 tSet.add(\"aaa\"); // Set中不允许重复元素，所以只会保存一个“aaa” tSet.add(\"aaa\"); tSet.add(\"bbb\"); tSet.add(\"eee\"); tSet.add(\"ddd\"); tSet.add(\"ccc\"); System.out.println(\"TreeSet:\"+tSet); // 打印TreeSet的实际大小 System.out.printf(\"size : %d\\n\", tSet.size()); // 导航方法 // floor(小于、等于) System.out.printf(\"floor bbb: %s\\n\", tSet.floor(\"bbb\")); // lower(小于) System.out.printf(\"lower bbb: %s\\n\", tSet.lower(\"bbb\")); // ceiling(大于、等于) System.out.printf(\"ceiling bbb: %s\\n\", tSet.ceiling(\"bbb\")); System.out.printf(\"ceiling eee: %s\\n\", tSet.ceiling(\"eee\")); // ceiling(大于) System.out.printf(\"higher bbb: %s\\n\", tSet.higher(\"bbb\")); // subSet() System.out.printf(\"subSet(aaa, true, ccc, true): %s\\n\", tSet.subSet(\"aaa\", true, \"ccc\", true)); System.out.printf(\"subSet(aaa, true, ccc, false): %s\\n\", tSet.subSet(\"aaa\", true, \"ccc\", false)); System.out.printf(\"subSet(aaa, false, ccc, true): %s\\n\", tSet.subSet(\"aaa\", false, \"ccc\", true)); System.out.printf(\"subSet(aaa, false, ccc, false): %s\\n\", tSet.subSet(\"aaa\", false, \"ccc\", false)); // headSet() System.out.printf(\"headSet(ccc, true): %s\\n\", tSet.headSet(\"ccc\", true)); System.out.printf(\"headSet(ccc, false): %s\\n\", tSet.headSet(\"ccc\", false)); // tailSet() System.out.printf(\"tailSet(ccc, true): %s\\n\", tSet.tailSet(\"ccc\", true)); System.out.printf(\"tailSet(ccc, false): %s\\n\", tSet.tailSet(\"ccc\", false)); // 删除“ccc” tSet.remove(\"ccc\"); // 将Set转换为数组 String[] arr = (String[])tSet.toArray(new String[0]); for (String str:arr) System.out.printf(\"for each : %s\\n\", str); // 打印TreeSet System.out.printf(\"TreeSet:%s\\n\", tSet); // 遍历TreeSet for(Iterator iter = tSet.iterator(); iter.hasNext(); ) &#123; System.out.printf(\"iter : %s\\n\", iter.next()); &#125; // 删除并返回第一个元素 val = (String)tSet.pollFirst(); System.out.printf(\"pollFirst=%s, set=%s\\n\", val, tSet); // 删除并返回最后一个元素 val = (String)tSet.pollLast(); System.out.printf(\"pollLast=%s, set=%s\\n\", val, tSet); // 清空HashSet tSet.clear(); // 输出HashSet是否为空 System.out.printf(\"%s\\n\", tSet.isEmpty()?\"set is empty\":\"set is not empty\"); &#125;&#125; 运行结果： 123456789101112131415161718192021222324252627TreeSet:[aaa, bbb, ccc, ddd, eee]size : 5floor bbb: bbblower bbb: aaaceiling bbb: bbbceiling eee: eeehigher bbb: cccsubSet(aaa, true, ccc, true): [aaa, bbb, ccc]subSet(aaa, true, ccc, false): [aaa, bbb]subSet(aaa, false, ccc, true): [bbb, ccc]subSet(aaa, false, ccc, false): [bbb]headSet(ccc, true): [aaa, bbb, ccc]headSet(ccc, false): [aaa, bbb]tailSet(ccc, true): [ccc, ddd, eee]tailSet(ccc, false): [ddd, eee]for each : aaafor each : bbbfor each : dddfor each : eeeTreeSet:[aaa, bbb, ddd, eee]iter : aaaiter : bbbiter : ddditer : eeepollFirst=aaa, set=[bbb, ddd, eee]pollLast=eee, set=[bbb, ddd]set is empty","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列16之 HashSet详细介绍","date":"2016-12-15T16:00:00.000Z","path":"2016/12/16/java-source-analysis-set-series/Java 集合系列16之 HashSet详细介绍/","text":"HashSet 简介HashSet 是一个没有重复元素的集合。 它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问： 1Set s = Collections.synchronizedSet(new HashSet(...)); HashSet通过iterator()返回的迭代器是fail-fast的。 HashSet的构造函数1234567891011121314 // 默认构造函数public HashSet() // 带集合的构造函数public HashSet(Collection&lt;? extends E&gt; c) // 指定HashSet初始容量和加载因子的构造函数public HashSet(int initialCapacity, float loadFactor) // 指定HashSet初始容量的构造函数public HashSet(int initialCapacity) // 指定HashSet初始容量和加载因子的构造函数,dummy没有任何作用HashSet(int initialCapacity, float loadFactor, boolean dummy) HashSet的主要API12345678boolean add(E object)void clear()Object clone()boolean contains(Object object)boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object object)int size() HashSet数据结构HashSet的继承关系如下：12345678java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.HashSet&lt;E&gt;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125; HashSet与Map关系图： 从图中可以看出： HashSet继承于AbstractSet，并且实现了Set接口。 HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。 HashSet源码解析(基于JDK1.6.0_45)为了更了解HashSet的原理，下面对HashSet源码代码作出分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package java.util;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; // HashSet是通过map(HashMap对象)保存内容的 private transient HashMap&lt;E,Object&gt; map; // PRESENT是向map中插入key-value对应的value // 因为HashSet中只需要用到key，而HashMap是key-value键值对； // 所以，向map中添加键值对时，键值对的值固定是PRESENT private static final Object PRESENT = new Object(); // 默认构造函数 public HashSet() &#123; // 调用HashMap的默认构造函数，创建map map = new HashMap&lt;E,Object&gt;(); &#125; // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) &#123; // 创建map。 // 为什么要调用Math.max((int) (c.size()/.75f) + 1, 16)，从 (c.size()/.75f) + 1 和 16 中选择一个比较大的树呢？ // 首先，说明(c.size()/.75f) + 1 // 因为从HashMap的效率(时间成本和空间成本)考虑，HashMap的加载因子是0.75。 // 当HashMap的“阈值”(阈值=HashMap总的大小*加载因子) &lt; “HashMap实际大小”时， // 就需要将HashMap的容量翻倍。 // 所以，(c.size()/.75f) + 1 计算出来的正好是总的空间大小。 // 接下来，说明为什么是 16 。 // HashMap的总的大小，必须是2的指数倍。若创建HashMap时，指定的大小不是2的指数倍； // HashMap的构造函数中也会重新计算，找出比“指定大小”大的最小的2的指数倍的数。 // 所以，这里指定为16是从性能考虑。避免重复计算。 map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); // 将集合(c)中的全部元素添加到HashSet中 addAll(c); &#125; // 指定HashSet初始容量和加载因子的构造函数 public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; // 返回HashSet的迭代器 public Iterator&lt;E&gt; iterator() &#123; // 实际上返回的是HashMap的“key集合的迭代器” return map.keySet().iterator(); &#125; public int size() &#123; return map.size(); &#125; public boolean isEmpty() &#123; return map.isEmpty(); &#125; public boolean contains(Object o) &#123; return map.containsKey(o); &#125; // 将元素(e)添加到HashSet中 public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; // 删除HashSet中的元素(o) public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; public void clear() &#123; map.clear(); &#125; // 克隆一个HashSet，并返回Object对象 public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (Iterator i=map.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数 // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; E e = (E) s.readObject(); map.put(e, PRESENT); &#125; &#125;&#125; 说明： HashSet的代码实际上非常简单，通过上面的注释应该很能够看懂。它是通过HashMap实现的，若对HashSet的理解有困难，建议先学习以下HashMap；学完HashMap之后，在学习HashSet就非常容易了。 HashSet遍历方式通过Iterator遍历HashSet第一步：根据iterator()获取HashSet的迭代器。第二步：遍历迭代器获取各个元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 假设set是HashSet对象for(Iterator iterator = set.iterator(); iterator.hasNext(); ) &#123; iterator.next();&#125; ``` ## 通过for-each遍历HashSet第一步：根据toArray()获取HashSet的元素集合对应的数组。第二步：遍历数组，获取各个元素。// 假设set是HashSet对象，并且set中元素是String类型String[] arr = (String[])set.toArray(new String[0]);for (String str:arr) System.out.printf(\"for each : %s\\n\", str);HashSet的遍历测试程序如下： ```javaimport java.util.Random;import java.util.Iterator;import java.util.HashSet;/* * @desc 介绍HashSet遍历方法 * * @author skywang */public class HashSetIteratorTest &#123; public static void main(String[] args) &#123; // 新建HashSet HashSet set = new HashSet(); // 添加元素 到HashSet中 for (int i=0; i&lt;5; i++) set.add(\"\"+i); // 通过Iterator遍历HashSet iteratorHashSet(set) ; // 通过for-each遍历HashSet foreachHashSet(set); &#125; /* * 通过Iterator遍历HashSet。推荐方式 */ private static void iteratorHashSet(HashSet set) &#123; for(Iterator iterator = set.iterator(); iterator.hasNext(); ) &#123; System.out.printf(\"iterator : %s\\n\", iterator.next()); &#125; &#125; /* * 通过for-each遍历HashSet。不推荐！此方法需要先将Set转换为数组 */ private static void foreachHashSet(HashSet set) &#123; String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(\"for each : %s\\n\", str); &#125;&#125; 运行结果： 12345678910iterator : 3iterator : 2iterator : 1iterator : 0iterator : 4for each : 3for each : 2for each : 1for each : 0for each : 4 HashSet示例下面我们通过实例学习如何使用HashSet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Iterator;import java.util.HashSet;/* * @desc HashSet常用API的使用。 * * @author skywang */public class HashSetTest &#123; public static void main(String[] args) &#123; // HashSet常用API testHashSetAPIs() ; &#125; /* * HashSet除了iterator()和add()之外的其它常用API */ private static void testHashSetAPIs() &#123; // 新建HashSet HashSet set = new HashSet(); // 将元素添加到Set中 set.add(\"a\"); set.add(\"b\"); set.add(\"c\"); set.add(\"d\"); set.add(\"e\"); // 打印HashSet的实际大小 System.out.printf(\"size : %d\\n\", set.size()); // 判断HashSet是否包含某个值 System.out.printf(\"HashSet contains a :%s\\n\", set.contains(\"a\")); System.out.printf(\"HashSet contains g :%s\\n\", set.contains(\"g\")); // 删除HashSet中的“e” set.remove(\"e\"); // 将Set转换为数组 String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf(\"for each : %s\\n\", str); // 新建一个包含b、c、f的HashSet HashSet otherset = new HashSet(); otherset.add(\"b\"); otherset.add(\"c\"); otherset.add(\"f\"); // 克隆一个removeset，内容和set一模一样 HashSet removeset = (HashSet)set.clone(); // 删除“removeset中，属于otherSet的元素” removeset.removeAll(otherset); // 打印removeset System.out.printf(\"removeset : %s\\n\", removeset); // 克隆一个retainset，内容和set一模一样 HashSet retainset = (HashSet)set.clone(); // 保留“retainset中，属于otherSet的元素” retainset.retainAll(otherset); // 打印retainset System.out.printf(\"retainset : %s\\n\", retainset); // 遍历HashSet for(Iterator iterator = set.iterator(); iterator.hasNext(); ) System.out.printf(\"iterator : %s\\n\", iterator.next()); // 清空HashSet set.clear(); // 输出HashSet是否为空 System.out.printf(\"%s\\n\", set.isEmpty()?\"set is empty\":\"set is not empty\"); &#125;&#125; 运行结果： 1234567891011121314size : 5HashSet contains a :trueHashSet contains g :falsefor each : dfor each : bfor each : cfor each : aremoveset : [d, a]retainset : [b, c]iterator : diterator : biterator : citerator : aset is empty","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列15之 Set架构","date":"2016-12-14T16:00:00.000Z","path":"2016/12/15/java-source-analysis-set-series/Java 集合系列15之 Set架构/","text":"Set前面，我们已经系统的对List和Map进行了学习。接下来，我们开始可以学习Set。相信经过Map的了解之后，学习Set会容易很多。毕竟，Set的实现类都是基于Map来实现的(HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。 首先，我们看看Set架构。 Set 是继承于Collection的接口。它是一个不允许有重复元素的集合。 AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了Set中的绝大部分函数，为Set的实现类提供了便利。 HastSet 和 TreeSet 是Set的两个实现类。 HashSet依赖于HashMap，它实际上是通过HashMap实现的。HashSet中的元素是无序的。 TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。TreeSet中的元素是有序的。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列14之 Map总结","date":"2016-12-13T16:00:00.000Z","path":"2016/12/14/java-source-analysis-set-series/Java 集合系列14之 Map总结/","text":"Map 总结学完了Map的全部内容，我们再回头看看Map的框架图。 Map概括 Map 是“键值对”映射的抽象接口。 AbstractMap 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。 SortedMap 有序的“键值对”映射接口。 NavigableMap 是继承于SortedMap的，支持导航函数的接口。 HashMap, Hashtable, TreeMap, WeakHashMap这4个类是“键值对”映射的实现类。它们各有区别！ HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。 Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。 WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。 TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。 HashMap和Hashtable异同HashMap和Hashtable的相同点 HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。 存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。 添加key-value键值对：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。 删除key-value键值对：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。 上面介绍了HashMap和Hashtable的相同点。正是由于它们都是散列表，我们关注更多的是“它们的区别，以及它们分别适合在什么情况下使用”。那接下来，我们先看看它们的区别。 HashMap和Hashtable的不同点继承和实现方式不同 HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 HashMap的定义: 123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125; Hashtable的定义: 123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; ... &#125; 从中，我们可以看出：1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口。 实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。 实现了Cloneable接口，意味着它能被克隆。 实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。 1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且 Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。 AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。 线程安全不同Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。 对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。 对null值的处理不同HashMap的key、value都可以为null。Hashtable的key、value都不可以为null。 我们先看看HashMap和Hashtable “添加key-value”的方法 HashMap的添加key-value的方法 123456789101112131415161718192021222324252627282930313233343536373839404142// 将“key-value”添加到HashMap中public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null;&#125;// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; // recordAccess()函数什么也没有做 e.recordAccess(this); return oldValue; &#125; &#125; // 添加第1个“key为null”的元素都table中的时候，会执行到这里。 // 它的作用是将“设置table[0]的key为null，值为value”。 modCount++; addEntry(0, null, value, 0); return null;&#125; Hashtable的添加key-value的方法 123456789101112131415161718192021222324252627282930313233343536373839404142// 将“key-value”添加到Hashtable中public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; // Hashtable中不能插入key为null的元素！！！ // 否则，下面的语句会抛出异常！ int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null;&#125; 根据上面的代码，我们可以看出： Hashtable的key或value，都不能为null！否则，会抛出异常NullPointerException。HashMap的key、value都可以为null。 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。 支持的遍历种类不同HashMap只支持Iterator(迭代器)遍历。 而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。 Iterator迭代器的遍历顺序不同HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。 容量的初始值 和 增加方式都不一样HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。 HashMap 和 Hashtable 默认的“加载因子” 都是0.75。 添加key-value时的hash值算法不同HashMap 添加元素时，是使用自定义的哈希算法。Hashtable 没有自定义哈希算法，而直接采用的key的hashCode()。 HashMap 添加元素时，是使用自定义的哈希算法。 1234567891011121314151617181920212223242526272829static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;// 将“key-value”添加到HashMap中public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null;&#125; Hashtable 没有自定义哈希算法，而直接采用的key的hashCode()。 12345678910111213141516171819202122232425262728293031323334353637383940public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null;&#125; HashMap和Hashtable使用的情景其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如：(01) 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。(02)，若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。 HashMap和WeakHashMap异同HashMap和WeakHashMap的相同点 它们都是散列表，存储的是“键值对”映射。 它们都继承于AbstractMap，并且实现Map基础。 它们的构造函数都一样。它们都包括4个构造函数，而且函数的参数都一样。 默认的容量大小是16，默认的加载因子是0.75。 它们的“键”和“值”都允许为null。 它们都是“非同步的”。 HashMap和WeakHashMap的不同点 HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。HashMap实现Cloneable，意味着它能通过clone()克隆自己。HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。 HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。 这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中： “键”是WeakReference，即key是弱键。 ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。 WeakHashMap是通过数组实现的，我们假设这个数组是table。 接下来，说说“动态回收”的步骤。 新建WeakHashMap，将“键值对”添加到WeakHashMap中。将“键值对”添加到WeakHashMap中时，添加的键都是弱键。 实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。 接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。 HashMap和WeakHashMap的比较测试程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.WeakHashMap;import java.util.Date;import java.lang.ref.WeakReference;/** * @desc HashMap 和 WeakHashMap比较程序 * @author skywang * @email kuiwu-wang@163.com */public class CompareHashmapAndWeakhashmap &#123; public static void main(String[] args) throws Exception &#123; // 当“弱键”是String时，比较HashMap和WeakHashMap compareWithString(); // 当“弱键”是自定义类型时，比较HashMap和WeakHashMap compareWithSelfClass(); &#125; /** * 遍历map，并打印map的大小 */ private static void iteratorAndCountMap(Map map) &#123; // 遍历map for (Iterator iter = map.entrySet().iterator(); iter.hasNext(); ) &#123; Map.Entry en = (Map.Entry)iter.next(); System.out.printf(\"map entry : %s - %s\\n \",en.getKey(), en.getValue()); &#125; // 打印HashMap的实际大小 System.out.printf(\" map size:%s\\n\\n\", map.size()); &#125; /** * 通过String对象测试HashMap和WeakHashMap */ private static void compareWithString() &#123; // 新建4个String字符串 String w1 = new String(\"W1\"); String w2 = new String(\"W2\"); String h1 = new String(\"H1\"); String h2 = new String(\"H2\"); // 新建 WeakHashMap对象，并将w1,w2添加到 WeakHashMap中 Map wmap = new WeakHashMap(); wmap.put(w1, \"w1\"); wmap.put(w2, \"w2\"); // 新建 HashMap对象，并将h1,h2添加到 WeakHashMap中 Map hmap = new HashMap(); hmap.put(h1, \"h1\"); hmap.put(h2, \"h2\"); // 删除HashMap中的“h1”。 // 结果：删除“h1”之后，HashMap中只有 h2 ！ hmap.remove(h1); // 将WeakHashMap中的w1设置null，并执行gc()。系统会回收w1 // 结果：w1是“弱键”，被GC回收后，WeakHashMap中w1对应的键值对，也会被从WeakHashMap中删除。 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 // 因此，WeakHashMap中只有 w2 // 注意：若去掉“w1=null” 或者“System.gc()”，结果都会不一样！ w1 = null; System.gc(); // 遍历并打印HashMap的大小 System.out.printf(\" -- HashMap --\\n\"); iteratorAndCountMap(hmap); // 遍历并打印WeakHashMap的大小 System.out.printf(\" -- WeakHashMap --\\n\"); iteratorAndCountMap(wmap); &#125; /** * 通过自定义类测试HashMap和WeakHashMap */ private static void compareWithSelfClass() &#123; // 新建4个自定义对象 Self s1 = new Self(10); Self s2 = new Self(20); Self s3 = new Self(30); Self s4 = new Self(40); // 新建 WeakHashMap对象，并将s1,s2添加到 WeakHashMap中 Map wmap = new WeakHashMap(); wmap.put(s1, \"s1\"); wmap.put(s2, \"s2\"); // 新建 HashMap对象，并将s3,s4添加到 WeakHashMap中 Map hmap = new HashMap(); hmap.put(s3, \"s3\"); hmap.put(s4, \"s4\"); // 删除HashMap中的s3。 // 结果：删除s3之后，HashMap中只有 s4 ！ hmap.remove(s3); // 将WeakHashMap中的s1设置null，并执行gc()。系统会回收w1 // 结果：s1是“弱键”，被GC回收后，WeakHashMap中s1对应的键值对，也会被从WeakHashMap中删除。 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 // 因此，WeakHashMap中只有 s2 // 注意：若去掉“s1=null” 或者“System.gc()”，结果都会不一样！ s1 = null; System.gc(); /* // 休眠500ms try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // */ // 遍历并打印HashMap的大小 System.out.printf(\" -- Self-def HashMap --\\n\"); iteratorAndCountMap(hmap); // 遍历并打印WeakHashMap的大小 System.out.printf(\" -- Self-def WeakHashMap --\\n\"); iteratorAndCountMap(wmap); &#125; private static class Self &#123; int id; public Self(int id) &#123; this.id = id; &#125; // 覆盖finalize()方法 // 在GC回收时会被执行 protected void finalize() throws Throwable &#123; super.finalize(); System.out.printf(\"GC Self: id=%d addr=0x%s)\\n\", id, this); &#125; &#125;&#125; 运行结果： 12345678910111213141516 -- HashMap --map entry : H2 - h2map size:1 -- WeakHashMap --map entry : W2 - w2map size:1 -- Self-def HashMap --map entry : CompareHashmapAndWeakhashmap$Self@1ff9dc36 - s4map size:1 -- Self-def WeakHashMap --GC Self: id=10 addr=0xCompareHashmapAndWeakhashmap$Self@12276af2)map entry : CompareHashmapAndWeakhashmap$Self@59de3f2d - s2map size:1","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列13之 WeakHashMap详细介绍","date":"2016-12-12T16:00:00.000Z","path":"2016/12/13/java-source-analysis-set-series/Java 集合系列13之 WeakHashMap详细介绍/","text":"WeakHashMap简介WeakHashMap 继承于AbstractMap，实现了Map接口。和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。 不过WeakHashMap的键是“弱键”。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。 这个“弱键”的原理呢？大致上就是，通过WeakReference和ReferenceQueue实现的。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是： 新建WeakHashMap，将“键值对”添加到WeakHashMap中。 实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。 这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。 和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。 WeakHashMap的构造函数WeakHashMap共有4个构造函数,如下： 1234567891011// 默认构造函数。WeakHashMap()// 指定“容量大小”的构造函数WeakHashMap(int capacity)// 指定“容量大小”和“加载因子”的构造函数WeakHashMap(int capacity, float loadFactor)// 包含“子Map”的构造函数WeakHashMap(Map&lt;? extends K, ? extends V&gt; map) WeakHashMap的API12345678910111213void clear()Object clone()boolean containsKey(Object key)boolean containsValue(Object value)Set&lt;Entry&lt;K, V&gt;&gt; entrySet()V get(Object key)boolean isEmpty()Set&lt;K&gt; keySet()V put(K key, V value)void putAll(Map&lt;? extends K, ? extends V&gt; map)V remove(Object key)int size()Collection&lt;V&gt; values() WeakHashMap数据结构WeakHashMap的继承关系如下 1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.WeakHashMap&lt;K, V&gt;public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; WeakHashMap与Map关系如下图： 从图中可以看出： WeakHashMap继承于AbstractMap，并且实现了Map接口。 WeakHashMap是哈希表，但是它的键是”弱键”。WeakHashMap中保护几个重要的成员变量：table, size, threshold, loadFactor, modCount, queue。 table 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size 是Hashtable的大小，它是Hashtable保存的键值对的数量。 threshold 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。 loadFactor 就是加载因子。 modCount 是用来实现fail-fast机制的 queue 保存的是“已被GC清除”的“弱引用的键”。 WeakHashMap源码解析(基于JDK1.6.0_45)下面对WeakHashMap的源码进行说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679package java.util;import java.lang.ref.WeakReference;import java.lang.ref.ReferenceQueue;public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; // 默认的初始容量是16，必须是2的幂。 private static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 private static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // WeakHashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 private Entry[] table; // WeakHashMap的大小，它是WeakHashMap保存的键值对的数量 private int size; // WeakHashMap的阈值，用于判断是否需要调整WeakHashMap的容量（threshold = 容量*加载因子） private int threshold; // 加载因子实际大小 private final float loadFactor; // queue保存的是“已被GC清除”的“弱引用的键”。 // 弱引用和ReferenceQueue 是联合使用的：如果弱引用所引用的对象被垃圾回收， // Java虚拟机就会把这个弱引用加入到与之关联的引用队列中 private final ReferenceQueue&lt;K&gt; queue = new ReferenceQueue&lt;K&gt;(); // WeakHashMap被改变的次数 private volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public WeakHashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Initial Capacity: \"+ initialCapacity); // WeakHashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal Load factor: \"+ loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 创建Entry数组，用来保存数据 table = new Entry[capacity]; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“WeakHashMap阈值”，当WeakHashMap中存储数据的数量达到threshold时， // 就需要将WeakHashMap的容量加倍。 threshold = (int)(capacity * loadFactor); &#125; // 指定“容量大小”的构造函数 public WeakHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public WeakHashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; threshold = (int)(DEFAULT_INITIAL_CAPACITY); table = new Entry[DEFAULT_INITIAL_CAPACITY]; &#125; // 包含“子Map”的构造函数 public WeakHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, 16), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到WeakHashMap中 putAll(m); &#125; // 键为null的mask值。 // 因为WeakReference中允许“null的key”，若直接插入“null的key”，将其当作弱引用时，会被删除。 // 因此，这里对于“key为null”的清空，都统一替换为“key为NULL_KEY”，“NULL_KEY”是“静态的final常量”。 private static final Object NULL_KEY = new Object(); // 对“null的key”进行特殊处理 private static Object maskNull(Object key) &#123; return (key == null ? NULL_KEY : key); &#125; // 还原对“null的key”的特殊处理 private static &lt;K&gt; K unmaskNull(Object key) &#123; return (K) (key == NULL_KEY ? null : key); &#125; // 判断“x”和“y”是否相等 static boolean eq(Object x, Object y) &#123; return x == y || x.equals(y); &#125; // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; // 清空table中无用键值对。原理如下： // (01) 当WeakHashMap中某个“弱引用的key”由于没有再被引用而被GC收回时， // 被回收的“该弱引用key”也被会被添加到\"ReferenceQueue(queue)\"中。 // (02) 当我们执行expungeStaleEntries时， // 就遍历\"ReferenceQueue(queue)\"中的所有key // 然后就在“WeakReference的table”中删除与“ReferenceQueue(queue)中key”对应的键值对 private void expungeStaleEntries() &#123; Entry&lt;K,V&gt; e; while ( (e = (Entry&lt;K,V&gt;) queue.poll()) != null) &#123; int h = e.hash; int i = indexFor(h, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; p = prev; while (p != null) &#123; Entry&lt;K,V&gt; next = p.next; if (p == e) &#123; if (prev == e) table[i] = next; else prev.next = next; e.next = null; // Help GC e.value = null; // \" \" size--; break; &#125; prev = p; p = next; &#125; &#125; &#125; // 获取WeakHashMap的table(存放键值对的数组) private Entry[] getTable() &#123; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); return table; &#125; // 获取WeakHashMap的实际大小 public int size() &#123; if (size == 0) return 0; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); return size; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; // 获取key对应的value public V get(Object key) &#123; Object k = maskNull(key); // 获取key的hash值。 int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; // 在“该hash值对应的链表”上查找“键值等于key”的元素 while (e != null) &#123; if (e.hash == h &amp;&amp; eq(k, e.get())) return e.value; e = e.next; &#125; return null; &#125; // WeakHashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 Entry&lt;K,V&gt; getEntry(Object key) &#123; Object k = maskNull(key); int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; while (e != null &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get()))) e = e.next; return e; &#125; // 将“key-value”添加到WeakHashMap中 public V put(K key, V value) &#123; K k = (K) maskNull(key); int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int i = indexFor(h, tab.length); for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (h == e.hash &amp;&amp; eq(k, e.get())) &#123; V oldValue = e.value; if (value != oldValue) e.value = value; return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在于WeakHashMap中，则将“key-value”添加到table中 modCount++; Entry&lt;K,V&gt; e = tab[i]; tab[i] = new Entry&lt;K,V&gt;(k, value, queue, h, e); if (++size &gt;= threshold) resize(tab.length * 2); return null; &#125; // 重新调整WeakHashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = getTable(); int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个newTable，将“旧的table”的全部元素添加到“新的newTable”中， // 然后，将“新的newTable”赋值给“旧的table”。 Entry[] newTable = new Entry[newCapacity]; transfer(oldTable, newTable); table = newTable; if (size &gt;= threshold / 2) &#123; threshold = (int)(newCapacity * loadFactor); &#125; else &#123; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); transfer(newTable, oldTable); table = oldTable; &#125; &#125; // 将WeakHashMap中的全部元素都添加到newTable中 private void transfer(Entry[] src, Entry[] dest) &#123; for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j]; src[j] = null; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object key = e.get(); if (key == null) &#123; e.next = null; // Help GC e.value = null; // \" \" size--; &#125; else &#123; int i = indexFor(e.hash, dest.length); e.next = dest[i]; dest[i] = e; &#125; e = next; &#125; &#125; &#125; // 将\"m\"的全部元素都添加到WeakHashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 将“m”中的元素逐个添加到WeakHashMap中。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Object k = maskNull(key); // 获取哈希值。 int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; eq(k, e.get())) &#123; modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e.value; &#125; prev = e; e = next; &#125; return null; &#125; // 删除“键值对” Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Entry[] tab = getTable(); Map.Entry entry = (Map.Entry)o; Object k = maskNull(entry.getKey()); int h = HashMap.hash(k.hashCode()); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e; &#125; prev = e; e = next; &#125; return null; &#125; // 清空WeakHashMap，将所有的元素设为null public void clear() &#123; while (queue.poll() != null) ; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; size = 0; while (queue.poll() != null) ; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value==null) return containsNullValue(); // 若“value不为null”，则查找WeakHashMap中是否有值为value的节点。 Entry[] tab = getTable(); for (int i = tab.length ; i-- &gt; 0 ;) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = getTable(); for (int i = tab.length ; i-- &gt; 0 ;) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value==null) return true; return false; &#125; // Entry是单向链表。 // 它是 “WeakHashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 private static class Entry&lt;K,V&gt; extends WeakReference&lt;K&gt; implements Map.Entry&lt;K,V&gt; &#123; private V value; private final int hash; // 指向下一个节点 private Entry&lt;K,V&gt; next; // 构造函数。 Entry(K key, V value, ReferenceQueue&lt;K&gt; queue, int hash, Entry&lt;K,V&gt; next) &#123; super(key, queue); this.value = value; this.hash = hash; this.next = next; &#125; public K getKey() &#123; return WeakHashMap.&lt;K&gt;unmaskNull(get()); &#125; public V getValue() &#123; return value; &#125; public V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public int hashCode() &#123; Object k = getKey(); Object v = getValue(); return ((k==null ? 0 : k.hashCode()) ^ (v==null ? 0 : v.hashCode())); &#125; public String toString() &#123; return getKey() + \"=\" + getValue(); &#125; &#125; // HashIterator是WeakHashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; entry = null; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned = null; // expectedModCount用于实现fast-fail机制。 int expectedModCount = modCount; // 下一个键(强引用) Object nextKey = null; // 当前键(强引用) Object currentKey = null; // 构造函数 HashIterator() &#123; index = (size() != 0 ? table.length : 0); &#125; // 是否存在下一个元素 public boolean hasNext() &#123; Entry[] t = table; // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 while (nextKey == null) &#123; Entry&lt;K,V&gt; e = entry; int i = index; while (e == null &amp;&amp; i &gt; 0) e = t[--i]; entry = e; index = i; if (e == null) &#123; currentKey = null; return false; &#125; nextKey = e.get(); // hold on to key in strong ref if (nextKey == null) entry = entry.next; &#125; return true; &#125; // 获取下一个元素 protected Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (nextKey == null &amp;&amp; !hasNext()) throw new NoSuchElementException(); lastReturned = entry; entry = entry.next; currentKey = nextKey; nextKey = null; return lastReturned; &#125; // 删除当前元素 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); WeakHashMap.this.remove(currentKey); expectedModCount = modCount; lastReturned = null; currentKey = null; &#125; &#125; // value的迭代器 private class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // WeakHashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public int size() &#123; return WeakHashMap.this.size(); &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; if (containsKey(o)) &#123; WeakHashMap.this.remove(o); return true; &#125; else return false; &#125; public void clear() &#123; WeakHashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public int size() &#123; return WeakHashMap.this.size(); &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; WeakHashMap.this.clear(); &#125; &#125; // 返回“WeakHashMap的Entry集合” // 它实际是返回一个EntrySet对象 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; // 是否包含“值(o)” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k = e.getKey(); Entry candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; // 删除“值(o)” public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; // 返回WeakHashMap的大小 public int size() &#123; return WeakHashMap.this.size(); &#125; // 清空WeakHashMap public void clear() &#123; WeakHashMap.this.clear(); &#125; // 拷贝函数。将WeakHashMap中的全部元素都拷贝到List中 private List&lt;Map.Entry&lt;K,V&gt;&gt; deepCopy() &#123; List&lt;Map.Entry&lt;K,V&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(size()); for (Map.Entry&lt;K,V&gt; e : this) list.add(new AbstractMap.SimpleEntry&lt;K,V&gt;(e)); return list; &#125; // 返回Entry对应的Object[]数组 public Object[] toArray() &#123; return deepCopy().toArray(); &#125; // 返回Entry对应的T[]数组(T[]我们新建数组时，定义的数组类型) public &lt;T&gt; T[] toArray(T[] a) &#123; return deepCopy().toArray(a); &#125; &#125;&#125; 说明：WeakHashMap和HashMap都是通过”拉链法”实现的散列表。它们的源码绝大部分内容都一样，这里就只是对它们不同的部分就是说明。 WeakReference是“弱键”实现的哈希表。 它这个“弱键”的目的就是：实现对“键值对”的动态回收。 当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。 “弱键”是一个“弱引用(WeakReference)”，在Java中，WeakReference和ReferenceQueue 是联合使用的。在WeakHashMap中亦是如此：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 接着，WeakHashMap会根据“引用队列”，来删除“WeakHashMap中已被GC回收的‘弱键’对应的键值对”。 另外，理解上面思想的重点是通过 expungeStaleEntries() 函数去理解。 WeakHashMap遍历方式遍历WeakHashMap的键值对第一步：根据entrySet()获取WeakHashMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是WeakHashMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 遍历WeakHashMap的键第一步：根据keySet()获取WeakHashMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是WeakHashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 遍历WeakHashMap的值第一步：根据value()获取WeakHashMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是WeakHashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; WeakHashMap遍历测试程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.WeakHashMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc 遍历WeakHashMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorHashMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashMapJustValues() * * @author skywang */public class WeakHashMapIteratorTest &#123; public static void main(String[] args) &#123; int val = 0; String key = null; Integer value = null; Random r = new Random(); WeakHashMap map = new WeakHashMap(); for (int i=0; i&lt;12; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到WeakHashMap中 map.put(key, value); System.out.println(\" key:\"+key+\" value:\"+value); &#125; // 通过entrySet()遍历WeakHashMap的key-value iteratorHashMapByEntryset(map) ; // 通过keySet()遍历WeakHashMap的key-value iteratorHashMapByKeyset(map) ; // 单单遍历WeakHashMap的value iteratorHashMapJustValues(map); &#125; /* * 通过entry set遍历WeakHashMap * 效率高! */ private static void iteratorHashMapByEntryset(WeakHashMap map) &#123; if (map == null) return ; System.out.println(\"\\niterator WeakHashMap By entryset\"); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+\" -- \"+integ.intValue()); &#125; &#125; /* * 通过keyset来遍历WeakHashMap * 效率低! */ private static void iteratorHashMapByKeyset(WeakHashMap map) &#123; if (map == null) return ; System.out.println(\"\\niterator WeakHashMap By keyset\"); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+\" -- \"+integ.intValue()); &#125; &#125; /* * 遍历WeakHashMap的values */ private static void iteratorHashMapJustValues(WeakHashMap map) &#123; if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125; WeakHashMap示例下面通过实例来学习如何使用WeakHashMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Iterator;import java.util.Map;import java.util.WeakHashMap;import java.util.Date;import java.lang.ref.WeakReference;/** * @desc WeakHashMap测试程序 * * @author skywang * @email kuiwu-wang@163.com */public class WeakHashMapTest &#123; public static void main(String[] args) throws Exception &#123; testWeakHashMapAPIs(); &#125; private static void testWeakHashMapAPIs() &#123; // 初始化3个“弱键” String w1 = new String(\"one\"); String w2 = new String(\"two\"); String w3 = new String(\"three\"); // 新建WeakHashMap Map wmap = new WeakHashMap(); // 添加键值对 wmap.put(w1, \"w1\"); wmap.put(w2, \"w2\"); wmap.put(w3, \"w3\"); // 打印出wmap System.out.printf(\"\\nwmap:%s\\n\",wmap ); // containsKey(Object key) :是否包含键key System.out.printf(\"contains key two : %s\\n\",wmap.containsKey(\"two\")); System.out.printf(\"contains key five : %s\\n\",wmap.containsKey(\"five\")); // containsValue(Object value) :是否包含值value System.out.printf(\"contains value 0 : %s\\n\",wmap.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 wmap.remove(\"three\"); System.out.printf(\"wmap: %s\\n\",wmap ); // ---- 测试 WeakHashMap 的自动回收特性 ---- // 将w1设置null。 // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对 w1 = null; // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对 System.gc(); // 遍历WeakHashMap Iterator iter = wmap.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry en = (Map.Entry)iter.next(); System.out.printf(\"next : %s - %s\\n\",en.getKey(),en.getValue()); &#125; // 打印WeakHashMap的实际大小 System.out.printf(\" after gc WeakHashMap size:%s\\n\", wmap.size()); &#125;&#125; 运行结果： 1234567wmap:&#123;three=w3, one=w1, two=w2&#125;contains key two : truecontains key five : falsecontains value 0 : falsewmap: &#123;one=w1, two=w2&#125;next : two - w2 after gc WeakHashMap size:1","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列12之 TreeMap详细介绍","date":"2016-12-11T16:00:00.000Z","path":"2016/12/12/java-source-analysis-set-series/Java 集合系列12之 TreeMap详细介绍/","text":"TreeMap 简介TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 TreeMap的构造函数1234567891011// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。TreeMap()// 创建的TreeMap包含MapTreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom)// 指定Tree的比较器TreeMap(Comparator&lt;? super K&gt; comparator)// 创建的TreeSet包含copyFromTreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom) TreeMap的API12345678910111213141516171819202122232425262728293031323334Entry&lt;K, V&gt; ceilingEntry(K key)K ceilingKey(K key)void clear()Object clone()Comparator&lt;? super K&gt; comparator()boolean containsKey(Object key)NavigableSet&lt;K&gt; descendingKeySet()NavigableMap&lt;K, V&gt; descendingMap()Set&lt;Entry&lt;K, V&gt;&gt; entrySet()Entry&lt;K, V&gt; firstEntry()K firstKey()Entry&lt;K, V&gt; floorEntry(K key)K floorKey(K key)V get(Object key)NavigableMap&lt;K, V&gt; headMap(K to, boolean inclusive)SortedMap&lt;K, V&gt; headMap(K toExclusive)Entry&lt;K, V&gt; higherEntry(K key)K higherKey(K key)boolean isEmpty()Set&lt;K&gt; keySet()Entry&lt;K, V&gt; lastEntry()K lastKey()Entry&lt;K, V&gt; lowerEntry(K key)K lowerKey(K key)NavigableSet&lt;K&gt; navigableKeySet()Entry&lt;K, V&gt; pollFirstEntry()Entry&lt;K, V&gt; pollLastEntry()V put(K key, V value)V remove(Object key)int size()SortedMap&lt;K, V&gt; subMap(K fromInclusive, K toExclusive)NavigableMap&lt;K, V&gt; subMap(K from, boolean fromInclusive, K to, boolean toInclusive)NavigableMap&lt;K, V&gt; tailMap(K from, boolean inclusive)SortedMap&lt;K, V&gt; tailMap(K fromInclusive) TreeMap数据结构TreeMap的继承关系 1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.TreeMap&lt;K, V&gt;public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125; TreeMap与Map关系图： 从图中可以看出： TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。 TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。 root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。 红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。 size是红黑数中节点的个数。 关于红黑数的具体算法，请参考”红黑树(一) 原理和算法详细介绍”。 TreeMap源码解析(基于JDK1.6.0_45)为了更了解TreeMap的原理，下面对TreeMap源码代码作出分析。我们先给出源码内容，后面再对源码进行详细说明，当然，源码内容中也包含了详细的代码注释。 说明: 在详细介绍TreeMap的代码之前，我们先建立一个整体概念。TreeMap是通过红黑树实现的，TreeMap存储的是key-value键值对，TreeMap的排序是基于对key的排序。TreeMap提供了操作“key”、“key-value”、“value”等方法，也提供了对TreeMap这颗树进行整体操作的方法，如获取子树、反向树。后面的解说内容分为几部分,首先，介绍TreeMap的核心，即红黑树相关部分；然后，介绍TreeMap的主要函数；再次，介绍TreeMap实现的几个接口；最后，补充介绍TreeMap的其它内容。 TreeMap本质上是一颗红黑树。要彻底理解TreeMap，建议读者先理解红黑树。关于红黑树的原理，可以参考：红黑树(一) 原理和算法详细介绍 http://www.cnblogs.com/skywang12345/p/3245399.html#a1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050package java.util;public class TreeMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; // 比较器。用来给TreeMap排序 private final Comparator&lt;? super K&gt; comparator; // TreeMap是红黑树实现的，root是红黑书的根节点 private transient Entry&lt;K,V&gt; root = null; // 红黑树的节点总数 private transient int size = 0; // 记录红黑树的修改次数 private transient int modCount = 0; // 默认构造函数 public TreeMap() &#123; comparator = null; &#125; // 带比较器的构造函数 public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125; // 带Map的构造函数，Map会成为TreeMap的子集 public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m); &#125; // 带SortedMap的构造函数，SortedMap会成为TreeMap的子集 public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; &#125; public int size() &#123; return size; &#125; // 返回TreeMap中是否包含“键(key)” public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回TreeMap中是否包含\"值(value)\" public boolean containsValue(Object value) &#123; // getFirstEntry() 是返回红黑树的第一个节点 // successor(e) 是获取节点e的后继节点 for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) if (valEquals(value, e.value)) return true; return false; &#125; // 获取“键(key)”对应的“值(value)” public V get(Object key) &#123; // 获取“键”为key的节点(p) Entry&lt;K,V&gt; p = getEntry(key); // 若节点(p)为null，返回null；否则，返回节点对应的值 return (p==null ? null : p.value); &#125; public Comparator&lt;? super K&gt; comparator() &#123; return comparator; &#125; // 获取第一个节点对应的key public K firstKey() &#123; return key(getFirstEntry()); &#125; // 获取最后一个节点对应的key public K lastKey() &#123; return key(getLastEntry()); &#125; // 将map中的全部节点添加到TreeMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; // 获取map的大小 int mapSize = map.size(); // 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对” if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) &#123; Comparator c = ((SortedMap)map).comparator(); // 如果TreeMap和map的比较器相等； // 则将map的元素全部拷贝到TreeMap中，然后返回！ if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) &#123; ++modCount; try &#123; buildFromSorted(mapSize, map.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return; &#125; &#125; // 调用AbstractMap中的putAll(); // AbstractMap中的putAll()又会调用到TreeMap的put() super.putAll(map); &#125; // 获取TreeMap中“键”为key的节点 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 若“比较器”为null，则通过getEntryUsingComparator()获取“键”为key的节点 if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的右孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; return null; &#125; // 获取TreeMap中“键”为key的节点(对应TreeMap的比较器不是null的情况) final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = cpr.compare(k, p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; &#125; return null; &#125; // 获取TreeMap中大于或等于key的最小的节点； // 若不存在(即TreeMap中所有节点的键都比key大)，就返回null final Entry&lt;K,V&gt; getCeilingEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 &#125; else if (cmp &gt; 0) &#123; // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) &#123; p = p.right; &#125; else &#123; // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”又2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; // 情况三：若“p的key” = key。 &#125; else return p; &#125; return null; &#125; // 获取TreeMap中不大于key的最大的节点； // 若不存在(即TreeMap中所有节点的键都比key小)，就返回null // getFloorEntry的原理和getCeilingEntry类似，这里不再多说。 final Entry&lt;K,V&gt; getFloorEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else if (cmp &lt; 0) &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; else return p; &#125; return null; &#125; // 获取TreeMap中大于key的最小的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getHigherEntry进行理解。 final Entry&lt;K,V&gt; getHigherEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; &#125; else &#123; if (p.right != null) &#123; p = p.right; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 获取TreeMap中小于key的最大的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getLowerEntry进行理解。 final Entry&lt;K,V&gt; getLowerEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 将“key, value”添加到TreeMap中 // 理解TreeMap的前提是掌握“红黑树”。 // 若理解“红黑树中添加节点”的算法，则很容易理解put。 public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // 若红黑树为空，则插入根节点 if (t == null) &#123; // TBD: // 5045147: (coll) Adding null to an empty TreeSet should // throw NullPointerException // // compare(key, key); // type check root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; // 在二叉树(红黑树是特殊的二叉树)中，找到(key, value)的插入位置。 // 红黑树是以key来进行排序的，所以这里以key来进行查找。 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 新建红黑树的节点(e) Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树插入节点后，不再是一颗红黑树； // 这里通过fixAfterInsertion的处理，来恢复红黑树的特性。 fixAfterInsertion(e); size++; modCount++; return null; &#125; // 删除TreeMap中的键为key的节点，并返回节点的值 public V remove(Object key) &#123; // 找到键为key的节点 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; // 保存节点的值 V oldValue = p.value; // 删除节点 deleteEntry(p); return oldValue; &#125; // 清空红黑树 public void clear() &#123; modCount++; size = 0; root = null; &#125; // 克隆一个TreeMap，并返回Object对象 public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into \"virgin\" state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone; &#125; // 获取第一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(getFirstEntry()); &#125; // 获取最后一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(getLastEntry()); &#125; // 获取第一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; // 获取第一个节点 Entry&lt;K,V&gt; p = getFirstEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除第一个节点 if (p != null) deleteEntry(p); return result; &#125; // 获取最后一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollLastEntry() &#123; // 获取最后一个节点 Entry&lt;K,V&gt; p = getLastEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除最后一个节点 if (p != null) deleteEntry(p); return result; &#125; // 返回小于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(getLowerEntry(key)); &#125; // 返回小于key的最大的键值对所对应的KEY，没有的话返回null public K lowerKey(K key) &#123; return keyOrNull(getLowerEntry(key)); &#125; // 返回不大于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(getFloorEntry(key)); &#125; // 返回不大于key的最大的键值对所对应的KEY，没有的话返回null public K floorKey(K key) &#123; return keyOrNull(getFloorEntry(key)); &#125; // 返回不小于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(getCeilingEntry(key)); &#125; // 返回不小于key的最小的键值对所对应的KEY，没有的话返回null public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key)); &#125; // 返回大于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(getHigherEntry(key)); &#125; // 返回大于key的最小的键值对所对应的KEY，没有的话返回null public K higherKey(K key) &#123; return keyOrNull(getHigherEntry(key)); &#125; // TreeMap的红黑树节点对应的集合 private transient EntrySet entrySet = null; // KeySet为KeySet导航类 private transient KeySet&lt;K&gt; navigableKeySet = null; // descendingMap为键值对的倒序“映射” private transient NavigableMap&lt;K,V&gt; descendingMap = null; // 返回TreeMap的“键的集合” public Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 获取“可导航”的Key的集合 // 实际上是返回KeySet类的对象。 public NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nks = navigableKeySet; return (nks != null) ? nks : (navigableKeySet = new KeySet(this)); &#125; // 返回“TreeMap的值对应的集合” public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); &#125; // 获取TreeMap的Entry的集合，实际上是返回EntrySet类的对象。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); &#125; // 获取TreeMap的降序Map // 实际上是返回DescendingSubMap类的对象 public NavigableMap&lt;K, V&gt; descendingMap() &#123; NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true)); &#125; // 获取TreeMap的子Map // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; return new AscendingSubMap(this, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部” // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; return new AscendingSubMap(this, true, null, true, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) &#123; return new AscendingSubMap(this, false, fromKey, inclusive, true, null, true); &#125; // 获取“子Map”。 // 范围是从fromKey(包括) 到 toKey(不包括) public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey(不包括) public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey(包括) 到 最后一个节点 public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection class Values extends AbstractCollection&lt;V&gt; &#123; // 返回迭代器 public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry()); &#125; // 返回个数 public int size() &#123; return TreeMap.this.size(); &#125; // \"TreeMap的值的集合\"中是否包含\"对象o\" public boolean contains(Object o) &#123; return TreeMap.this.containsValue(o); &#125; // 删除\"TreeMap的值的集合\"中的\"对象o\" public boolean remove(Object o) &#123; for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) &#123; if (valEquals(e.getValue(), o)) &#123; deleteEntry(e); return true; &#125; &#125; return false; &#125; // 清空删除\"TreeMap的值的集合\" public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // EntrySet是“TreeMap的所有键值对组成的集合”， // EntrySet集合的单位是单个“键值对”。 class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(getFirstEntry()); &#125; // EntrySet中是否包含“键值对Object” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); &#125; // 删除EntrySet中的“键值对Object” public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) &#123; deleteEntry(p); return true; &#125; return false; &#125; // 返回EntrySet中元素个数 public int size() &#123; return TreeMap.this.size(); &#125; // 清空EntrySet public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // 返回“TreeMap的KEY组成的迭代器(顺序)” Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry()); &#125; // 返回“TreeMap的KEY组成的迭代器(逆序)” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingKeyIterator(getLastEntry()); &#125; // KeySet是“TreeMap中所有的KEY组成的集合” // KeySet继承于AbstractSet，而且实现了NavigableSet接口。 static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; &#123; // NavigableMap成员，KeySet是通过NavigableMap实现的 private final NavigableMap&lt;E, Object&gt; m; KeySet(NavigableMap&lt;E,Object&gt; map) &#123; m = map; &#125; // 升序迭代器 public Iterator&lt;E&gt; iterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器keyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器keyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).keyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).keyIterator()); &#125; // 降序迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器descendingKeyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器descendingKeyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).descendingKeyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).descendingKeyIterator()); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public void clear() &#123; m.clear(); &#125; public E lower(E e) &#123; return m.lowerKey(e); &#125; public E floor(E e) &#123; return m.floorKey(e); &#125; public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; public E higher(E e) &#123; return m.higherKey(e); &#125; public E first() &#123; return m.firstKey(); &#125; public E last() &#123; return m.lastKey(); &#125; public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; public E pollFirst() &#123; Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return e == null? null : e.getKey(); &#125; public E pollLast() &#123; Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return e == null? null : e.getKey(); &#125; public boolean remove(Object o) &#123; int oldSize = size(); m.remove(o); return size() != oldSize; &#125; public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; public NavigableSet&lt;E&gt; descendingSet() &#123; return new TreeSet(m.descendingMap()); &#125; &#125; // 它是TreeMap中的一个抽象迭代器，实现了一些通用的接口。 abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned; // 期望的修改次数，用于实现fast-fail机制 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个节点 final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; &#125; // 获取上一个节点 final Entry&lt;K,V&gt; prevEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向\"新的当前节点\"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; &#125; &#125; // TreeMap的Entry对应的迭代器 final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // TreeMap的Value对应的迭代器 final class ValueIterator extends PrivateEntryIterator&lt;V&gt; &#123; ValueIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public V next() &#123; return nextEntry().value; &#125; &#125; // reeMap的KEY组成的迭代器(顺序) final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125; &#125; // TreeMap的KEY组成的迭代器(逆序) final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return prevEntry().key; &#125; &#125; // 比较两个对象的大小 final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); &#125; // 判断两个对象是否相等 final static boolean valEquals(Object o1, Object o2) &#123; return (o1==null ? o2==null : o1.equals(o2)); &#125; // 返回“Key-Value键值对”的一个简单拷贝(AbstractMap.SimpleImmutableEntry&lt;K,V&gt;对象) // 可用来读取“键值对”的值 static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e); &#125; // 若“键值对”不为null，则返回KEY；否则，返回null static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : e.key; &#125; // 若“键值对”不为null，则返回KEY；否则，抛出异常 static &lt;K&gt; K key(Entry&lt;K,?&gt; e) &#123; if (e==null) throw new NoSuchElementException(); return e.key; &#125; // TreeMap的SubMap，它一个抽象类，实现了公共操作。 // 它包括了\"(升序)AscendingSubMap\"和\"(降序)DescendingSubMap\"两个子类。 static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable &#123; // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; if (!fromStart &amp;&amp; !toEnd) &#123; if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException(\"fromKey &gt; toKey\"); &#125; else &#123; if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); &#125; this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; &#125; // 判断key是否太小 final boolean tooLow(Object key) &#123; // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) &#123; int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; &#125; return false; &#125; // 判断key是否太大 final boolean tooHigh(Object key) &#123; // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) &#123; int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; &#125; return false; &#125; // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) &#123; return !tooLow(key) &amp;&amp; !tooHigh(key); &#125; // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) &#123; return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); &#125; // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) &#123; return inclusive ? inRange(key) : inClosedRange(key); &#125; // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() &#123; // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() &#123; // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回\"大于/等于key的最小的Entry\" final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回\"大于key的最小的Entry\" final TreeMap.Entry&lt;K,V&gt; absHigher(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回\"小于/等于key的最大的Entry\" final TreeMap.Entry&lt;K,V&gt; absFloor(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取\"小于/等于key的最大的Entry\" TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回\"小于key的最大的Entry\" final TreeMap.Entry&lt;K,V&gt; absLower(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取\"小于key的最大的Entry\" TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() &#123; return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); &#125; // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() &#123; return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); &#125; // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() &#123; return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); &#125; // 返回SubMap的大小 public int size() &#123; return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); &#125; // 返回SubMap是否包含键key public final boolean containsKey(Object key) &#123; return inRange(key) &amp;&amp; m.containsKey(key); &#125; // 将key-value 插入SubMap中 public final V put(K key, V value) &#123; if (!inRange(key)) throw new IllegalArgumentException(\"key out of range\"); return m.put(key, value); &#125; // 获取key对应值 public final V get(Object key) &#123; return !inRange(key)? null : m.get(key); &#125; // 删除key对应的键值对 public final V remove(Object key) &#123; return !inRange(key)? null : m.remove(key); &#125; // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(subCeiling(key)); &#125; // 获取“大于/等于key的最小键” public final K ceilingKey(K key) &#123; return keyOrNull(subCeiling(key)); &#125; // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(subHigher(key)); &#125; // 获取“大于key的最小键” public final K higherKey(K key) &#123; return keyOrNull(subHigher(key)); &#125; // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(subFloor(key)); &#125; // 获取“小于/等于key的最大键” public final K floorKey(K key) &#123; return keyOrNull(subFloor(key)); &#125; // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(subLower(key)); &#125; // 获取“小于key的最大键” public final K lowerKey(K key) &#123; return keyOrNull(subLower(key)); &#125; // 获取\"SubMap的第一个键\" public final K firstKey() &#123; return key(subLowest()); &#125; // 获取\"SubMap的最后一个键\" public final K lastKey() &#123; return key(subHighest()); &#125; // 获取\"SubMap的第一个键值对\" public final Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(subLowest()); &#125; // 获取\"SubMap的最后一个键值对\" public final Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(subHighest()); &#125; // 返回\"SubMap的第一个键值对\"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // 返回\"SubMap的最后一个键值对\"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的\"Key集合\"。 public final NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); &#125; // 返回\"Key集合\"对象 public final Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() &#123; return descendingMap().navigableKeySet(); &#125; // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() &#123; // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) &#123; sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) &#123; size++; i.next(); &#125; &#125; return size; &#125; // 判断EntrySetView是否为空 public boolean isEmpty() &#123; TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); &#125; // 判断EntrySetView是否包含Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); &#125; // 从EntrySetView中删除Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue()))&#123; m.deleteEntry(node); return true; &#125; return false; &#125; &#125; // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; &#125; // 是否存在下一个Entry public final boolean hasNext() &#123; return next != null &amp;&amp; next.key != fenceKey; &#125; // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; &#125; // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向\"新的当前节点\"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; &#125; // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public K next() &#123; return nextEntry().key; &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() &#123; return prevEntry(); &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public K next() &#123; return prevEntry().key; &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; &#125; // 升序的SubMap，继承于NavigableSubMap static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866124060L; // 构造函数 AscendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 比较器 public Comparator&lt;? super K&gt; comparator() &#123; return m.comparator(); &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(\"fromKey out of range\"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(\"toKey out of range\"); return new AscendingSubMap(m, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(\"toKey out of range\"); return new AscendingSubMap(m, fromStart, lo, loInclusive, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(\"fromKey out of range\"); return new AscendingSubMap(m, false, fromKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new DescendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // “升序EntrySet集合”类 // 实现了iterator() final class AscendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new SubMapEntryIterator(absLowest(), absHighFence()); &#125; &#125; // 返回“升序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new AscendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absHigher(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absLower(key); &#125; &#125; // 降序的SubMap，继承于NavigableSubMap // 相比于升序SubMap，它的实现机制是将“SubMap的比较器反转”！ static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() &#123; return reverseComparator; &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(\"fromKey out of range\"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(\"toKey out of range\"); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(\"toKey out of range\"); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(\"fromKey out of range\"); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); &#125; &#125; // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absLower(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absHigher(key); &#125; &#125; // SubMap是旧版本的类，新的Java中没有用到。 private class SubMap extends AbstractMap&lt;K,V&gt; implements SortedMap&lt;K,V&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -6520786458950516097L; private boolean fromStart = false, toEnd = false; private K fromKey, toKey; private Object readResolve() &#123; return new AscendingSubMap(TreeMap.this, fromStart, fromKey, true, toEnd, toKey, false); &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; throw new InternalError(); &#125; public K lastKey() &#123; throw new InternalError(); &#125; public K firstKey() &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; throw new InternalError(); &#125; public Comparator&lt;? super K&gt; comparator() &#123; throw new InternalError(); &#125; &#125; // 红黑树的节点颜色--红色 private static final boolean RED = false; // 红黑树的节点颜色--黑色 private static final boolean BLACK = true; // “红黑树的节点”对应的类。 // 包含了 key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色) static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 键 K key; // 值 V value; // 左孩子 Entry&lt;K,V&gt; left = null; // 右孩子 Entry&lt;K,V&gt; right = null; // 父节点 Entry&lt;K,V&gt; parent; // 当前节点颜色 boolean color = BLACK; // 构造函数 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; // 返回“键” public K getKey() &#123; return key; &#125; // 返回“值” public V getValue() &#123; return value; &#125; // 更新“值”，返回旧的值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; // 判断两个节点是否相等的函数，覆盖equals()函数。 // 若两个节点的“key相等”并且“value相等”，则两个节点相等 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; // 覆盖hashCode函数。 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; &#125; // 覆盖toString()函数。 public String toString() &#123; return key + \"=\" + value; &#125; &#125; // 返回“红黑树的第一个节点” final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; &#125; // 返回“红黑树的最后一个节点” final Entry&lt;K,V&gt; getLastEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p; &#125; // 返回“节点t的后继节点” static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点t的前继节点” static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.left != null) &#123; Entry&lt;K,V&gt; p = t.left; while (p.right != null) p = p.right; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.left) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点p的颜色” // 根据“红黑树的特性”可知：空节点颜色是黑色。 private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? BLACK : p.color); &#125; // 返回“节点p的父节点” private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? null: p.parent); &#125; // 设置“节点p的颜色为c” private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) &#123; if (p != null) p.color = c; &#125; // 设置“节点p的左孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.left; &#125; // 设置“节点p的右孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.right; &#125; // 对节点p执行“左旋”操作 private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125; &#125; // 对节点p执行“右旋”操作 private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125; &#125; // 插入之后的修正操作。 // 目的是保证：红黑树插入节点之后，仍然是一颗红黑树 private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; // 删除“红黑树的节点p” private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor (p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; // 删除之后的修正操作。 // 目的是保证：红黑树删除节点之后，仍然是一颗红黑树 private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; private static final long serialVersionUID = 919286545866124006L; // java.io.Serializable的写入函数 // 将TreeMap的“容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeMap的“容量、所有的Entry”依次读出 private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null); &#125; // 根据已经一个排好序的map创建一个TreeMap private void buildFromSorted(int size, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; this.size = size; root = buildFromSorted(0, 0, size-1, computeRedLevel(size), it, str, defaultVal); &#125; // 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) &#123; if (defaultVal==null) &#123; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); &#125; else &#123; key = (K)it.next(); value = defaultVal; &#125; &#125; else &#123; // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); &#125; // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) &#123; middle.left = left; left.parent = middle; &#125; if (mid &lt; hi) &#123; // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; &#125; return middle; &#125; // 计算节点树为sz的最大深度，也是红色节点的深度值。 private static int computeRedLevel(int sz) &#123; int level = 0; for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1) level++; return level; &#125;&#125; TreeMap的红黑树相关内容TreeMap中于红黑树相关的主要函数有: 数据结构红黑树的节点颜色–红色1private static final boolean RED = false; 红黑树的节点颜色–黑色1private static final boolean BLACK = true; “红黑树的节点”对应的类。123static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; ... &#125;Entry包含了6个部分内容：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)Entry节点根据key进行排序，Entry节点包含的内容为value。 相关操作左旋1private void rotateLeft(Entry&lt;K,V&gt; p) &#123; ... &#125; 右旋1private void rotateRight(Entry&lt;K,V&gt; p) &#123; ... &#125; 插入操作1public V put(K key, V value) &#123; ... &#125; 插入修正操作红黑树执行插入操作之后，要执行“插入修正操作”。目的是：保红黑树在进行插入节点之后，仍然是一颗红黑树1private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; ... &#125; 删除操作1private void deleteEntry(Entry&lt;K,V&gt; p) &#123; ... &#125; 删除修正操作红黑树执行删除之后，要执行“删除修正操作”。目的是保证：红黑树删除节点之后，仍然是一颗红黑树 1private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; ... &#125; 关于红黑树部分，这里主要是指出了TreeMap中那些是红黑树的主要相关内容。具体的红黑树相关操作API，这里没有详细说明，因为它们仅仅只是将算法翻译成代码。读者可以参考“红黑树(一) 原理和算法详细介绍”进行了解。 TreeMap的构造函数默认构造函数使用默认构造函数构造TreeMap时，使用java的默认的比较器比较Key的大小，从而对TreeMap进行排序。 123public TreeMap() &#123; comparator = null;&#125; 带比较器的构造函数123public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125; 带Map的构造函数，Map会成为TreeMap的子集1234public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125; 该构造函数会调用putAll()将m中的所有元素添加到TreeMap中。putAll()源码如下： 1234public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue());&#125; 从中，我们可以看出putAll()就是将m中的key-value逐个的添加到TreeMap中。 带SortedMap的构造函数，SortedMap会成为TreeMap的子集12345678public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; 该构造函数不同于上一个构造函数，在上一个构造函数中传入的参数是Map，Map不是有序的，所以要逐个添加。而该构造函数的参数是SortedMap是一个有序的Map，我们通过buildFromSorted()来创建对应的Map。buildFromSorted涉及到的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) &#123; if (defaultVal==null) &#123; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); &#125; else &#123; key = (K)it.next(); value = defaultVal; &#125; &#125; else &#123; // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); &#125; // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) &#123; middle.left = left; left.parent = middle; &#125; if (mid &lt; hi) &#123; // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; &#125; return middle; &#125; 要理解buildFromSorted，重点说明以下几点： 第一，buildFromSorted是通过递归将SortedMap中的元素逐个关联。第二，buildFromSorted返回middle节点(中间节点)作为root。第三，buildFromSorted添加到红黑树中时，只将level == redLevel的节点设为红色。第level级节点，实际上是buildFromSorted转换成红黑树后的最底端(假设根节点在最上方)的节点；只将红黑树最底端的阶段着色为红色，其余都是黑色。 TreeMap的Entry相关函数TreeMap的 firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry() 原理都是类似的；下面以firstEntry()来进行详细说明 我们先看看firstEntry()和getFirstEntry()的代码： 1234567891011public Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(getFirstEntry());&#125;final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p;&#125; 从中，我们可以看出 firstEntry() 和 getFirstEntry() 都是用于获取第一个节点。但是，firstEntry() 是对外接口； getFirstEntry() 是内部接口。而且，firstEntry() 是通过 getFirstEntry() 来实现的。那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?先告诉大家原因，再进行详细说明。这么做的目的是：防止用户修改返回的Entry。getFirstEntry()返回的Entry是可以被修改的，但是经过firstEntry()返回的Entry不能被修改，只可以读取Entry的key值和value值。下面我们看看到底是如何实现的。 (01) getFirstEntry()返回的是Entry节点，而Entry是红黑树的节点，它的源码如下： 12345678// 返回“红黑树的第一个节点”final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p;&#125; 从中，我们可以调用Entry的getKey()、getValue()来获取key和value值，以及调用setValue()来修改value的值。 (02) firstEntry()返回的是exportEntry(getFirstEntry())。下面我们看看exportEntry()干了些什么？ 1234static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e);&#125; 实际上，exportEntry() 是新建一个AbstractMap.SimpleImmutableEntry类型的对象，并返回。 SimpleImmutableEntry的实现在AbstractMap.java中，下面我们看看AbstractMap.SimpleImmutableEntry是如何实现的，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class SimpleImmutableEntry&lt;K,V&gt;implements Entry&lt;K,V&gt;, java.io.Serializable&#123; private static final long serialVersionUID = 7138329143949025153L; private final K key; private final V value; public SimpleImmutableEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; public SimpleImmutableEntry(Entry&lt;? extends K, ? extends V&gt; entry) &#123; this.key = entry.getKey(); this.value = entry.getValue(); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue()); &#125; public int hashCode() &#123; return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key + \"=\" + value; &#125;&#125; 从中，我们可以看出SimpleImmutableEntry实际上是简化的key-value节点。它只提供了getKey()、getValue()方法类获取节点的值；但不能修改value的值，因为调用 setValue() 会抛出异常UnsupportedOperationException(); 再回到我们之前的问题：那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?现在我们清晰的了解到：(01) firstEntry()是对外接口，而getFirstEntry()是内部接口。(02) 对firstEntry()返回的Entry对象只能进行getKey()、getValue()等读取操作；而对getFirstEntry()返回的对象除了可以进行读取操作之后，还可以通过setValue()修改值。 TreeMap的key相关函数TreeMap的firstKey()、lastKey()、lowerKey()、higherKey()、floorKey()、ceilingKey()原理都是类似的；下面以ceilingKey()来进行详细说明 ceilingKey(K key)的作用是“返回大于/等于key的最小的键值对所对应的KEY，没有的话返回null”，它的代码如下： 123public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key));&#125; ceilingKey()是通过getCeilingEntry()实现的。keyOrNull()的代码很简单，它是获取节点的key，没有的话，返回null。 123static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : e.key;&#125; getCeilingEntry(K key)的作用是“获取TreeMap中大于/等于key的最小的节点，若不存在(即TreeMap中所有节点的键都比key大)，就返回null”。它的实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637final Entry&lt;K,V&gt; getCeilingEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 &#125; else if (cmp &gt; 0) &#123; // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) &#123; p = p.right; &#125; else &#123; // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”有2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; // 情况三：若“p的key” = key。 &#125; else return p; &#125; return null;&#125; TreeMap的values()函数values() 返回“TreeMap中值的集合” values()的实现代码如下： 1234public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values());&#125; 说明：从中，我们可以发现values()是通过 new Values() 来实现 “返回TreeMap中值的集合”。 那么Values()是如何实现的呢？ 没错！由于返回的是值的集合，那么Values()肯定返回一个集合；而Values()正好是集合类Value的构造函数。Values继承于AbstractCollection，它的代码如下： 123456789101112131415161718192021222324252627282930313233// ”TreeMap的值的集合“对应的类，它集成于AbstractCollectionclass Values extends AbstractCollection&lt;V&gt; &#123; // 返回迭代器 public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry()); &#125; // 返回个数 public int size() &#123; return TreeMap.this.size(); &#125; // \"TreeMap的值的集合\"中是否包含\"对象o\" public boolean contains(Object o) &#123; return TreeMap.this.containsValue(o); &#125; // 删除\"TreeMap的值的集合\"中的\"对象o\" public boolean remove(Object o) &#123; for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) &#123; if (valEquals(e.getValue(), o)) &#123; deleteEntry(e); return true; &#125; &#125; return false; &#125; // 清空删除\"TreeMap的值的集合\" public void clear() &#123; TreeMap.this.clear(); &#125;&#125; 说明：从中，我们可以知道Values类就是一个集合。而 AbstractCollection 实现了除 size() 和 iterator() 之外的其它函数，因此只需要在Values类中实现这两个函数即可。size() 的实现非常简单，Values集合中元素的个数=该TreeMap的元素个数。(TreeMap每一个元素都有一个值嘛！)iterator() 则返回一个迭代器，用于遍历Values。下面，我们一起可以看看iterator()的实现： 123public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry());&#125; 说明： iterator() 是通过ValueIterator() 返回迭代器的，ValueIterator是一个类。代码如下： 12345678final class ValueIterator extends PrivateEntryIterator&lt;V&gt; &#123; ValueIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public V next() &#123; return nextEntry().value; &#125;&#125; 说明：ValueIterator的代码很简单，它的主要实现应该在它的父类PrivateEntryIterator中。下面我们一起看看PrivateEntryIterator的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 下一节点 Entry&lt;K,V&gt; next; // 上一次返回的节点 Entry&lt;K,V&gt; lastReturned; // 修改次数统计数 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; // 是否存在下一个节点 public final boolean hasNext() &#123; return next != null; &#125; // 返回下一个节点 final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; &#125; // 返回上一节点 final Entry&lt;K,V&gt; prevEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // deleted entries are replaced by their successors if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; &#125;&#125; 说明：PrivateEntryIterator是一个抽象类，它的实现很简单，只只实现了Iterator的remove()和hasNext()接口，没有实现next()接口。而我们在ValueIterator中已经实现的next()接口。至此，我们就了解了iterator()的完整实现了。 TreeMap的entrySet()函数entrySet() 返回“键值对集合”。顾名思义，它返回的是一个集合，集合的元素是“键值对”。 下面，我们看看它是如何实现的？entrySet() 的实现代码如下： 1234public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet());&#125; 说明：entrySet()返回的是一个EntrySet对象。 下面我们看看EntrySet的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// EntrySet是“TreeMap的所有键值对组成的集合”，// EntrySet集合的单位是单个“键值对”。class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(getFirstEntry()); &#125; // EntrySet中是否包含“键值对Object” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); &#125; // 删除EntrySet中的“键值对Object” public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) &#123; deleteEntry(p); return true; &#125; return false; &#125; // 返回EntrySet中元素个数 public int size() &#123; return TreeMap.this.size(); &#125; // 清空EntrySet public void clear() &#123; TreeMap.this.clear(); &#125;&#125; 说明：EntrySet是“TreeMap的所有键值对组成的集合”，而且它单位是单个“键值对”。EntrySet是一个集合，它继承于AbstractSet。而AbstractSet实现了除size() 和 iterator() 之外的其它函数，因此，我们重点了解一下EntrySet的size() 和 iterator() 函数 size() 的实现非常简单，AbstractSet集合中元素的个数=该TreeMap的元素个数。iterator() 则返回一个迭代器，用于遍历AbstractSet。从上面的源码中，我们可以发现iterator() 是通过EntryIterator实现的；下面我们看看EntryIterator的源码： 12345678final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125;&#125; 说明：和Values类一样，EntryIterator也继承于PrivateEntryIterator类。 TreeMap实现的Cloneable接口TreeMap实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个TreeMap对象并返回。 1234567891011121314151617181920212223242526// 克隆一个TreeMap，并返回Object对象public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into \"virgin\" state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone;&#125; TreeMap实现的Serializable接口TreeMap实现java.io.Serializable，分别实现了串行读取、写入功能。串行写入函数是writeObject()，它的作用是将TreeMap的“容量，所有的Entry”都写入到输出流中。而串行读取函数是readObject()，它的作用是将TreeMap的“容量、所有的Entry”依次读出。readObject() 和 writeObject() 正好是一对，通过它们，我能实现TreeMap的串行传输。 12345678910111213141516171819202122232425262728293031// java.io.Serializable的写入函数// 将TreeMap的“容量，所有的Entry”都写入到输出流中private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125;&#125;// java.io.Serializable的读取函数：根据写入方式读出// 先将TreeMap的“容量、所有的Entry”依次读出private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null);&#125; 说到这里，就顺便说一下“关键字transient”的作用 transient是Java语言的关键字，它被用来表示一个域不是该对象串行化的一部分。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 TreeMap实现的NavigableMap接口firstKey()、lastKey()、lowerKey()、higherKey()、ceilingKey()、floorKey();firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry();上面已经讲解过这些API了，下面对其它的API进行说明。 1 反向TreeMapdescendingMap() 的作用是返回当前TreeMap的反向的TreeMap。所谓反向，就是排序顺序和原始的顺序相反。 我们已经知道TreeMap是一颗红黑树，而红黑树是有序的。TreeMap的排序方式是通过比较器，在创建TreeMap的时候，若指定了比较器，则使用该比较器；否则，就使用Java的默认比较器。而获取TreeMap的反向TreeMap的原理就是将比较器反向即可！ 理解了descendingMap()的反向原理之后，再讲解一下descendingMap()的代码。 12345678// 获取TreeMap的降序Mappublic NavigableMap&lt;K, V&gt; descendingMap() &#123; NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true));&#125; 从中，我们看出descendingMap()实际上是返回DescendingSubMap类的对象。下面，看看DescendingSubMap的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() &#123; return reverseComparator; &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException(\"fromKey out of range\"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException(\"toKey out of range\"); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException(\"toKey out of range\"); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException(\"fromKey out of range\"); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); &#125; &#125; // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absLower(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absHigher(key); &#125;&#125; 从中，我们看出DescendingSubMap是降序的SubMap，它的实现机制是将“SubMap的比较器反转”。 它继承于NavigableSubMap。而NavigableSubMap是一个继承于AbstractMap的抽象类；它包括2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”。NavigableSubMap为它的两个子类实现了许多公共API。下面看看NavigableSubMap的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable &#123; // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; if (!fromStart &amp;&amp; !toEnd) &#123; if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException(\"fromKey &gt; toKey\"); &#125; else &#123; if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); &#125; this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; &#125; // 判断key是否太小 final boolean tooLow(Object key) &#123; // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) &#123; int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; &#125; return false; &#125; // 判断key是否太大 final boolean tooHigh(Object key) &#123; // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) &#123; int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; &#125; return false; &#125; // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) &#123; return !tooLow(key) &amp;&amp; !tooHigh(key); &#125; // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) &#123; return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); &#125; // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) &#123; return inclusive ? inRange(key) : inClosedRange(key); &#125; // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() &#123; // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() &#123; // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回\"大于/等于key的最小的Entry\" final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回\"大于key的最小的Entry\" final TreeMap.Entry&lt;K,V&gt; absHigher(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回\"小于/等于key的最大的Entry\" final TreeMap.Entry&lt;K,V&gt; absFloor(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取\"小于/等于key的最大的Entry\" TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回\"小于key的最大的Entry\" final TreeMap.Entry&lt;K,V&gt; absLower(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取\"小于key的最大的Entry\" TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() &#123; return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); &#125; // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() &#123; return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); &#125; // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() &#123; return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); &#125; // 返回SubMap的大小 public int size() &#123; return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); &#125; // 返回SubMap是否包含键key public final boolean containsKey(Object key) &#123; return inRange(key) &amp;&amp; m.containsKey(key); &#125; // 将key-value 插入SubMap中 public final V put(K key, V value) &#123; if (!inRange(key)) throw new IllegalArgumentException(\"key out of range\"); return m.put(key, value); &#125; // 获取key对应值 public final V get(Object key) &#123; return !inRange(key)? null : m.get(key); &#125; // 删除key对应的键值对 public final V remove(Object key) &#123; return !inRange(key)? null : m.remove(key); &#125; // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(subCeiling(key)); &#125; // 获取“大于/等于key的最小键” public final K ceilingKey(K key) &#123; return keyOrNull(subCeiling(key)); &#125; // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(subHigher(key)); &#125; // 获取“大于key的最小键” public final K higherKey(K key) &#123; return keyOrNull(subHigher(key)); &#125; // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(subFloor(key)); &#125; // 获取“小于/等于key的最大键” public final K floorKey(K key) &#123; return keyOrNull(subFloor(key)); &#125; // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(subLower(key)); &#125; // 获取“小于key的最大键” public final K lowerKey(K key) &#123; return keyOrNull(subLower(key)); &#125; // 获取\"SubMap的第一个键\" public final K firstKey() &#123; return key(subLowest()); &#125; // 获取\"SubMap的最后一个键\" public final K lastKey() &#123; return key(subHighest()); &#125; // 获取\"SubMap的第一个键值对\" public final Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(subLowest()); &#125; // 获取\"SubMap的最后一个键值对\" public final Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(subHighest()); &#125; // 返回\"SubMap的第一个键值对\"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // 返回\"SubMap的最后一个键值对\"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的\"Key集合\"。 public final NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); &#125; // 返回\"Key集合\"对象 public final Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() &#123; return descendingMap().navigableKeySet(); &#125; // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() &#123; // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) &#123; sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) &#123; size++; i.next(); &#125; &#125; return size; &#125; // 判断EntrySetView是否为空 public boolean isEmpty() &#123; TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); &#125; // 判断EntrySetView是否包含Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); &#125; // 从EntrySetView中删除Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue()))&#123; m.deleteEntry(node); return true; &#125; return false; &#125; &#125; // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; &#125; // 是否存在下一个Entry public final boolean hasNext() &#123; return next != null &amp;&amp; next.key != fenceKey; &#125; // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; &#125; // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向\"新的当前节点\"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; &#125; // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public K next() &#123; return nextEntry().key; &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() &#123; return prevEntry(); &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public K next() &#123; return prevEntry().key; &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125;&#125; NavigableSubMap源码很多，但不难理解；读者可以通过源码和注释进行理解。 其实，读完NavigableSubMap的源码后，我们可以得出它的核心思想是：它是一个抽象集合类，为2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”而服务；因为NavigableSubMap实现了许多公共API。它的最终目的是实现下面的一系列函数： 12345678headMap(K toKey, boolean inclusive) headMap(K toKey)subMap(K fromKey, K toKey)subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)tailMap(K fromKey)tailMap(K fromKey, boolean inclusive)navigableKeySet() descendingKeySet() TreeMap其它函数1 顺序遍历和逆序遍历TreeMap的顺序遍历和逆序遍历原理非常简单。由于TreeMap中的元素是从小到大的顺序排列的。因此，顺序遍历，就是从第一个元素开始，逐个向后遍历；而倒序遍历则恰恰相反，它是从最后一个元素开始，逐个往前遍历。 我们可以通过 keyIterator() 和 descendingKeyIterator()来说明！keyIterator()的作用是返回顺序的KEY的集合，descendingKeyIterator()的作用是返回逆序的KEY的集合。 12345keyIterator() 的代码如下：Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry());&#125; 说明：从中我们可以看出keyIterator() 是返回以“第一个节点(getFirstEntry)” 为其实元素的迭代器。KeyIterator的代码如下： 12345678final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125;&#125; 说明：KeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，就是执行的顺序遍历了。 descendingKeyIterator()的代码如下： 123Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingKeyIterator(getLastEntry());&#125; 说明：从中我们可以看出descendingKeyIterator() 是返回以“最后一个节点(getLastEntry)” 为其实元素的迭代器。再看看DescendingKeyIterator的代码： 12345678final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return prevEntry().key; &#125;&#125; 说明：DescendingKeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，实际上调用的是prevEntry()获取的上一个节点，这样它实际上执行的是逆序遍历了。 至此，TreeMap的相关内容就全部介绍完毕了。若有错误或纰漏的地方，欢迎指正！ TreeMap遍历方式遍历TreeMap的键值对第一步：根据entrySet()获取TreeMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是TreeMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 4.2 遍历TreeMap的键第一步：根据keySet()获取TreeMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是TreeMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 4.3 遍历TreeMap的值第一步：根据value()获取TreeMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是TreeMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; TreeMap遍历测试程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.TreeMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc 遍历TreeMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorTreeMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorTreeMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorTreeMapJustValues() * * @author skywang */public class TreeMapIteratorTest &#123; public static void main(String[] args) &#123; int val = 0; String key = null; Integer value = null; Random r = new Random(); TreeMap map = new TreeMap(); for (int i=0; i&lt;12; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到TreeMap中 map.put(key, value); System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value); &#125; // 通过entrySet()遍历TreeMap的key-value iteratorTreeMapByEntryset(map) ; // 通过keySet()遍历TreeMap的key-value iteratorTreeMapByKeyset(map) ; // 单单遍历TreeMap的value iteratorTreeMapJustValues(map); &#125; /* * 通过entry set遍历TreeMap * 效率高! */ private static void iteratorTreeMapByEntryset(TreeMap map) &#123; if (map == null) return ; System.out.println(&quot;\\niterator TreeMap By entryset&quot;); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+&quot; -- &quot;+integ.intValue()); &#125; &#125; /* * 通过keyset来遍历TreeMap * 效率低! */ private static void iteratorTreeMapByKeyset(TreeMap map) &#123; if (map == null) return ; System.out.println(&quot;\\niterator TreeMap By keyset&quot;); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+&quot; -- &quot;+integ.intValue()); &#125; &#125; /* * 遍历TreeMap的values */ private static void iteratorTreeMapJustValues(TreeMap map) &#123; if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125; TreeMap示例下面通过实例来学习如何使用TreeMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import java.util.*;/** * @desc TreeMap测试程序 * * @author skywang */public class TreeMapTest &#123; public static void main(String[] args) &#123; // 测试常用的API testTreeMapOridinaryAPIs(); // 测试TreeMap的导航函数 //testNavigableMapAPIs(); // 测试TreeMap的子Map函数 //testSubMapAPIs(); &#125; /** * 测试常用的API */ private static void testTreeMapOridinaryAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建TreeMap TreeMap tmap = new TreeMap(); // 添加操作 tmap.put(\"one\", r.nextInt(10)); tmap.put(\"two\", r.nextInt(10)); tmap.put(\"three\", r.nextInt(10)); System.out.printf(\"\\n ---- testTreeMapOridinaryAPIs ----\\n\"); // 打印出TreeMap System.out.printf(\"%s\\n\",tmap ); // 通过Iterator遍历key-value Iterator iter = tmap.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.printf(\"next : %s - %s\\n\", entry.getKey(), entry.getValue()); &#125; // TreeMap的键值对个数 System.out.printf(\"size: %s\\n\", tmap.size()); // containsKey(Object key) :是否包含键key System.out.printf(\"contains key two : %s\\n\",tmap.containsKey(\"two\")); System.out.printf(\"contains key five : %s\\n\",tmap.containsKey(\"five\")); // containsValue(Object value) :是否包含值value System.out.printf(\"contains value 0 : %s\\n\",tmap.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 tmap.remove(\"three\"); System.out.printf(\"tmap:%s\\n\",tmap ); // clear() ： 清空TreeMap tmap.clear(); // isEmpty() : TreeMap是否为空 System.out.printf(\"%s\\n\", (tmap.isEmpty()?\"tmap is empty\":\"tmap is not empty\") ); &#125; /** * 测试TreeMap的子Map函数 */ public static void testSubMapAPIs() &#123; // 新建TreeMap TreeMap tmap = new TreeMap(); // 添加“键值对” tmap.put(\"a\", 101); tmap.put(\"b\", 102); tmap.put(\"c\", 103); tmap.put(\"d\", 104); tmap.put(\"e\", 105); System.out.printf(\"\\n ---- testSubMapAPIs ----\\n\"); // 打印出TreeMap System.out.printf(\"tmap:\\n\\t%s\\n\", tmap); // 测试 headMap(K toKey) System.out.printf(\"tmap.headMap(\\\"c\\\"):\\n\\t%s\\n\", tmap.headMap(\"c\")); // 测试 headMap(K toKey, boolean inclusive) System.out.printf(\"tmap.headMap(\\\"c\\\", true):\\n\\t%s\\n\", tmap.headMap(\"c\", true)); System.out.printf(\"tmap.headMap(\\\"c\\\", false):\\n\\t%s\\n\", tmap.headMap(\"c\", false)); // 测试 tailMap(K fromKey) System.out.printf(\"tmap.tailMap(\\\"c\\\"):\\n\\t%s\\n\", tmap.tailMap(\"c\")); // 测试 tailMap(K fromKey, boolean inclusive) System.out.printf(\"tmap.tailMap(\\\"c\\\", true):\\n\\t%s\\n\", tmap.tailMap(\"c\", true)); System.out.printf(\"tmap.tailMap(\\\"c\\\", false):\\n\\t%s\\n\", tmap.tailMap(\"c\", false)); // 测试 subMap(K fromKey, K toKey) System.out.printf(\"tmap.subMap(\\\"a\\\", \\\"c\\\"):\\n\\t%s\\n\", tmap.subMap(\"a\", \"c\")); // 测试 System.out.printf(\"tmap.subMap(\\\"a\\\", true, \\\"c\\\", true):\\n\\t%s\\n\", tmap.subMap(\"a\", true, \"c\", true)); System.out.printf(\"tmap.subMap(\\\"a\\\", true, \\\"c\\\", false):\\n\\t%s\\n\", tmap.subMap(\"a\", true, \"c\", false)); System.out.printf(\"tmap.subMap(\\\"a\\\", false, \\\"c\\\", true):\\n\\t%s\\n\", tmap.subMap(\"a\", false, \"c\", true)); System.out.printf(\"tmap.subMap(\\\"a\\\", false, \\\"c\\\", false):\\n\\t%s\\n\", tmap.subMap(\"a\", false, \"c\", false)); // 测试 navigableKeySet() System.out.printf(\"tmap.navigableKeySet():\\n\\t%s\\n\", tmap.navigableKeySet()); // 测试 descendingKeySet() System.out.printf(\"tmap.descendingKeySet():\\n\\t%s\\n\", tmap.descendingKeySet()); &#125; /** * 测试TreeMap的导航函数 */ public static void testNavigableMapAPIs() &#123; // 新建TreeMap NavigableMap nav = new TreeMap(); // 添加“键值对” nav.put(\"aaa\", 111); nav.put(\"bbb\", 222); nav.put(\"eee\", 333); nav.put(\"ccc\", 555); nav.put(\"ddd\", 444); System.out.printf(\"\\n ---- testNavigableMapAPIs ----\\n\"); // 打印出TreeMap System.out.printf(\"Whole list:%s%n\", nav); // 获取第一个key、第一个Entry System.out.printf(\"First key: %s\\tFirst entry: %s%n\",nav.firstKey(), nav.firstEntry()); // 获取最后一个key、最后一个Entry System.out.printf(\"Last key: %s\\tLast entry: %s%n\",nav.lastKey(), nav.lastEntry()); // 获取“小于/等于bbb”的最大键值对 System.out.printf(\"Key floor before bbb: %s%n\",nav.floorKey(\"bbb\")); // 获取“小于bbb”的最大键值对 System.out.printf(\"Key lower before bbb: %s%n\", nav.lowerKey(\"bbb\")); // 获取“大于/等于bbb”的最小键值对 System.out.printf(\"Key ceiling after ccc: %s%n\",nav.ceilingKey(\"ccc\")); // 获取“大于bbb”的最小键值对 System.out.printf(\"Key higher after ccc: %s%n\\n\",nav.higherKey(\"ccc\")); &#125;&#125; 运行结果： 12345678910&#123;one=8, three=4, two=2&#125;next : one - 8next : three - 4next : two - 2size: 3contains key two : truecontains key five : falsecontains value 0 : falsetmap:&#123;one=8, two=2&#125;tmap is empty","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列11之 Hashtable详细介绍","date":"2016-12-10T16:00:00.000Z","path":"2016/12/11/java-source-analysis-set-series/Java 集合系列11之 Hashtable详细介绍/","text":"Hashtable 简介和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。 Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。 Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。 初始容量 容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。 加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。 Hashtable的构造函数12345678910111213141516171819202122232425262728293031323334// 默认构造函数。public Hashtable() // 指定“容量大小”的构造函数public Hashtable(int initialCapacity) // 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor) // 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; t)``` # Hashtable的API```javasynchronized void clear()synchronized Object clone() boolean contains(Object value)synchronized boolean containsKey(Object key)synchronized boolean containsValue(Object value)synchronized Enumeration&lt;V&gt; elements()synchronized Set&lt;Entry&lt;K, V&gt;&gt; entrySet()synchronized boolean equals(Object object)synchronized V get(Object key)synchronized int hashCode()synchronized boolean isEmpty()synchronized Set&lt;K&gt; keySet()synchronized Enumeration&lt;K&gt; keys()synchronized V put(K key, V value)synchronized void putAll(Map&lt;? extends K, ? extends V&gt; map)synchronized V remove(Object key)synchronized int size()synchronized String toString()synchronized Collection&lt;V&gt; values() Hashtable数据结构Hashtable的继承关系 123456java.lang.Object ↳ java.util.Dictionary&lt;K, V&gt; ↳ java.util.Hashtable&lt;K, V&gt;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; &#125; Hashtable与Map关系如下图： 从图中可以看出： Hashtable继承于Dictionary类，实现了Map接口。Map是”key-value键值对”接口，Dictionary是声明了操作”键值对”函数接口的抽象类。 Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。 table 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 count 是Hashtable的大小，它是Hashtable保存的键值对的数量。 threshold 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。 loadFactor 就是加载因子。 modCount 是用来实现fail-fast机制的。 Hashtable源码解析(基于JDK1.6.0_45)为了更了解Hashtable的原理，下面对Hashtable源码代码作出分析。 在阅读源码时，建议参考后面的说明来建立对Hashtable的整体认识，这样更容易理解Hashtable。 说明: 在详细介绍Hashtable的代码之前，我们需要了解：和Hashmap一样，Hashtable也是一个散列表，它也是通过“拉链法”解决哈希冲突的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792package java.util;import java.io.*;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; // Hashtable保存key-value的数组。 // Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中元素的实际数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor); &#125; // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; // 默认构造函数。 public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); &#125; // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); &#125; public synchronized int size() &#123; return count; &#125; public synchronized boolean isEmpty() &#123; return count == 0; &#125; // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES); &#125; // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; // Hashtable中“键值对”的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， // % tab.length 的目的是防止数据越界 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; // 返回key对应的value，没有的话返回null public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; // 调整Hashtable的长度，将长度变成原来的(2倍+1) // (01) 将“旧的Entry数组”赋值给一个临时变量。 // (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组” // (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中 protected void rehash() &#123; int oldCapacity = table.length; Entry[] oldMap = table; int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null; &#125; // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)” // 然后在链表中找出要删除的节点，并删除该节点。 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null; &#125; // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); &#125; // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; &#125; // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; public synchronized String toString() &#123; int max = size() - 1; if (max == -1) return \"&#123;&#125;\"; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append('&#123;'); for (int i = 0; ; i++) &#123; Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? \"(this Map)\" : key.toString()); sb.append('='); sb.append(value == this ? \"(this Map)\" : value.toString()); if (i == max) return sb.append('&#125;').toString(); sb.append(\", \"); &#125; &#125; // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return (Enumeration&lt;T&gt;)emptyEnumerator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, false); &#125; &#125; // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return (Iterator&lt;T&gt;) emptyIterator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, true); &#125; &#125; // Hashtable的“key的集合”。它是一个Set，意味着没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，意味着没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，意味着可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() &#123; if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; &#125; // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return getIterator(KEYS); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return Hashtable.this.remove(o) != null; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; &#125; // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; public boolean add(Map.Entry&lt;K,V&gt; o) &#123; return super.add(o); &#125; // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry(Entry是一个单向链表) // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; &#125; // 删除元素Object(0) // 首先，在table中找到o对应的Entry(Entry是一个单向链表) // 然后，删除链表中的元素Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e.hash==hash &amp;&amp; e.equals(entry)) &#123; modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; &#125; &#125; return false; &#125; public int size() &#123; return count; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() &#123; if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; &#125; // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return getIterator(VALUES); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try &#123; // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable(o)中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; &#125; else &#123; if (!value.equals(t.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true; &#125; // 计算Hashtable的哈希值 // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() &#123; int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) for (Entry e = tab[i]; e != null; e = e.next) h += e.key.hashCode() ^ e.value.hashCode(); loadFactor = -loadFactor; // Mark hashCode computation complete return h; &#125; // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) &#123; Entry entry = table[index]; while (entry != null) &#123; s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; &#125; &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125; this.table = table; &#125; private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException &#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; &#125; // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); &#125; public int hashCode() &#123; return hash ^ (value==null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key.toString()+\"=\"+value.toString(); &#125; &#125; private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException(\"Hashtable Enumerator\"); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(\"Hashtable Enumerator\"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125; &#125; private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration&lt;Object&gt; &#123; EmptyEnumerator() &#123; &#125; // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() &#123; return false; &#125; // 空枚举类的nextElement() 抛出异常 public Object nextElement() &#123; throw new NoSuchElementException(\"Hashtable Enumerator\"); &#125; &#125; // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator&lt;Object&gt; &#123; EmptyIterator() &#123; &#125; public boolean hasNext() &#123; return false; &#125; public Object next() &#123; throw new NoSuchElementException(\"Hashtable Iterator\"); &#125; public void remove() &#123; throw new IllegalStateException(\"Hashtable Iterator\"); &#125; &#125;&#125; Hashtable的“拉链法”相关内容Hashtable数据存储数组1private transient Entry[] table; Hashtable中的key-value都是存储在table数组中的。 数据节点Entry的数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); &#125; public int hashCode() &#123; return hash ^ (value==null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key.toString()+\"=\"+value.toString(); &#125;&#125; 从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说Hashtable是通过拉链法解决哈希冲突的。 Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 Hashtable的构造函数Hashtable共包括4个构造函数 1234567891011121314151617181920212223242526272829303132// 默认构造函数。public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f);&#125;// 指定“容量大小”的构造函数public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f);&#125;// 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor);&#125;// 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t);&#125; Hashtable的主要对外接口clear()clear() 的作用是清空Hashtable。它是将Hashtable的table数组的值全部设为null 1234567public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0;&#125; contains() 和 containsValue()contains() 和 containsValue() 的作用都是判断Hashtable是否包含“值(value)” 1234567891011121314151617181920212223public boolean containsValue(Object value) &#123; return contains(value);&#125;public synchronized boolean contains(Object value) &#123; // Hashtable中“键值对”的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false;&#125; containsKey()containsKey() 的作用是判断Hashtable是否包含key 1234567891011121314public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， // % tab.length 的目的是防止数据越界 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false;&#125; elements()elements() 的作用是返回“所有value”的枚举对象 123456789101112public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES);&#125;// 获取Hashtable的枚举类对象private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return (Enumeration&lt;T&gt;)emptyEnumerator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, false); &#125;&#125; 从中，我们可以看出： 若Hashtable的实际大小为0,则返回“空枚举类”对象emptyEnumerator； 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) 我们先看看emptyEnumerator对象是如何实现的 12345678910111213141516171819private static Enumeration emptyEnumerator = new EmptyEnumerator();// 空枚举类// 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。private static class EmptyEnumerator implements Enumeration&lt;Object&gt; &#123; EmptyEnumerator() &#123; &#125; // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() &#123; return false; &#125; // 空枚举类的nextElement() 抛出异常 public Object nextElement() &#123; throw new NoSuchElementException(\"Hashtable Enumerator\"); &#125;&#125; 我们在来看看Enumeration类 Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException(\"Hashtable Enumerator\"); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(\"Hashtable Enumerator\"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125;&#125; entrySet(), keySet(), keys(), values()的实现方法和elements()差不多，而且源码中已经明确的给出了注释。这里就不再做过多说明了。 get()get() 的作用就是获取key对应的value，没有的话返回null 12345678910111213public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null;&#125; put()put() 的作用是对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。 12345678910111213141516171819202122232425262728293031323334353637383940public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null;&#125; putAll()putAll() 的作用是将“Map(t)”的中全部元素逐一添加到Hashtable中 1234public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue());&#125; remove()remove() 的作用就是删除Hashtable中键为key的元素 12345678910111213141516171819202122public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)” // 然后在链表中找出要删除的节点，并删除该节点。 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null;&#125; Hashtable实现的Cloneable接口Hashtable实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个Hashtable对象并返回。 12345678910111213141516171819// 克隆一个Hashtable，并以Object的形式返回。public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125;&#125; Hashtable实现的Serializable接口Hashtable实现java.io.Serializable，分别实现了串行读取、写入功能。 串行写入函数就是将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中串行读取函数：根据写入方式读出将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException&#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) &#123; Entry entry = table[index]; while (entry != null) &#123; s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; &#125; &#125;&#125;private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125; this.table = table;&#125; Hashtable遍历方式遍历Hashtable的键值对第一步：根据entrySet()获取Hashtable的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = table.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 通过Iterator遍历Hashtable的键第一步：根据keySet()获取Hashtable的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = table.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)table.get(key);&#125; 通过Iterator遍历Hashtable的值第一步：根据value()获取Hashtable的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型Integer value = null;Collection c = table.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 通过Enumeration遍历Hashtable的键第一步：根据keys()获取Hashtable的集合。第二步：通过Enumeration遍历“第一步”得到的集合。 1234Enumeration enu = table.keys();while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement());&#125; 通过Enumeration遍历Hashtable的值第一步：根据elements()获取Hashtable的集合。第二步：通过Enumeration遍历“第一步”得到的集合。 1234Enumeration enu = table.elements();while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement());&#125; 遍历测试程序如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/* * @desc Hashtable的测试程序。 */public class HashtableTest &#123; public static void main(String[] args) &#123; testHashtableAPIs(); &#125; private static void testHashtableAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建Hashtable Hashtable table = new Hashtable(); // 添加操作 table.put(\"one\", r.nextInt(10)); table.put(\"two\", r.nextInt(10)); table.put(\"three\", r.nextInt(10)); // 打印出table System.out.println(\"table:\"+table ); // 通过Iterator遍历key-value Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println(\"next : \"+ entry.getKey() +\" - \"+entry.getValue()); &#125; // Hashtable的键值对个数 System.out.println(\"size:\"+table.size()); // containsKey(Object key) :是否包含键key System.out.println(\"contains key two : \"+table.containsKey(\"two\")); System.out.println(\"contains key five : \"+table.containsKey(\"five\")); // containsValue(Object value) :是否包含值value System.out.println(\"contains value 0 : \"+table.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 table.remove(\"three\"); System.out.println(\"table:\"+table ); // clear() ： 清空Hashtable table.clear(); // isEmpty() : Hashtable是否为空 System.out.println((table.isEmpty()?\"table is empty\":\"table is not empty\") ); &#125;&#125; Hashtable示例下面通过一个实例来学习如何使用Hashtable。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/* * @desc Hashtable的测试程序。 */public class HashtableTest &#123; public static void main(String[] args) &#123; testHashtableAPIs(); &#125; private static void testHashtableAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建Hashtable Hashtable table = new Hashtable(); // 添加操作 table.put(\"one\", r.nextInt(10)); table.put(\"two\", r.nextInt(10)); table.put(\"three\", r.nextInt(10)); // 打印出table System.out.println(\"table:\"+table ); // 通过Iterator遍历key-value Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println(\"next : \"+ entry.getKey() +\" - \"+entry.getValue()); &#125; // Hashtable的键值对个数 System.out.println(\"size:\"+table.size()); // containsKey(Object key) :是否包含键key System.out.println(\"contains key two : \"+table.containsKey(\"two\")); System.out.println(\"contains key five : \"+table.containsKey(\"five\")); // containsValue(Object value) :是否包含值value System.out.println(\"contains value 0 : \"+table.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 table.remove(\"three\"); System.out.println(\"table:\"+table ); // clear() ： 清空Hashtable table.clear(); // isEmpty() : Hashtable是否为空 System.out.println((table.isEmpty()?\"table is empty\":\"table is not empty\") ); &#125;&#125; (某一次)运行结果： 12345678910table:&#123;two=5, one=0, three=6&#125;next : two - 5next : one - 0next : three - 6size:3contains key two : truecontains key five : falsecontains value 0 : truetable:&#123;two=5, one=0&#125;table is empty","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列10之 HashMap详细介绍","date":"2016-12-09T16:00:00.000Z","path":"2016/12/10/java-source-analysis-set-series/Java 集合系列10之 HashMap详细介绍/","text":"HashMap简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap的构造函数HashMap共有4个构造函数,如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 默认构造函数。public HashMap() &#123; // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init();&#125;// 指定“容量大小”和“加载因子”的构造函数public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init();&#125;// 指定“容量大小”的构造函数public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;// 包含“子Map”的构造函数public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m);&#125; HashMap的API12345678910111213void clear()Object clone()boolean containsKey(Object key)boolean containsValue(Object value)Set&lt;Entry&lt;K, V&gt;&gt; entrySet()V get(Object key)boolean isEmpty()Set&lt;K&gt; keySet()V put(K key, V value)void putAll(Map&lt;? extends K, ? extends V&gt; map)V remove(Object key)int size()Collection&lt;V&gt; values() HashMap数据结构HashMap的继承关系 1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.HashMap&lt;K, V&gt;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; &#125; HashMap与Map关系如下图： 从图中可以看出： HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。 HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size是HashMap的大小，它是HashMap保存的键值对的数量 threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 loadFactor就是加载因子。 modCount是用来实现fail-fast机制的。 HashMap源码解析为了更了解HashMap的原理，下面对HashMap源码代码作出分析。在阅读源码时，建议参考后面的说明来建立对HashMap的整体认识，这样更容易理解HashMap。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759package java.util;import java.io.*;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; // 默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的大小，它是HashMap保存的键值对的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public HashMap() &#123; // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); &#125; static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置！ private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; // HashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; // 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; &#125; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 这里的完全不会被执行到! modCount++; addEntry(0, null, value, 0); return null; &#125; // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; e.value = value; return; &#125; &#125; // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); &#125; // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123; // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); putForCreate(e.getKey(), e.getValue()); &#125; &#125; // 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; // 将\"m\"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125; &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 删除“键值对” final Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 清空HashMap，将所有的元素设为null public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; &#125; // 克隆一个HashMap，并返回Object对象 public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; &#125; // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; // 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 // 它和addEntry的区别是： // (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素； // put()是通过addEntry()新增Entry的。 // 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”； // 因此，需要调用addEntry() // (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中； // 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中 // 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。 // 此时，调用createEntry()即可。 void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; &#125; // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; // value的迭代器 private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // 返回一个“key迭代器” Iterator&lt;K&gt; newKeyIterator() &#123; return new KeyIterator(); &#125; // 返回一个“value迭代器” Iterator&lt;V&gt; newValueIterator() &#123; return new ValueIterator(); &#125; // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator(); &#125; // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return newValueIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0(); &#125; // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; &#125; private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125; &#125; // 返回“HashMap总的容量” int capacity() &#123; return table.length; &#125; // 返回“HashMap的加载因子” float loadFactor() &#123; return loadFactor; &#125;&#125; 说明: 在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 HashMap的“拉链法”相关内容1、HashMap数据存储数组1transient Entry[] table; HashMap中的key-value都是存储在Entry数组中的。 2、数据节点Entry的数据结构结构图表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125;&#125; 从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 HashMap的主要对外接口clear()clear() 的作用是清空HashMap。它是通过将所有的元素设为null来实现的。 1234567public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0;&#125; containsKey()containsKey() 的作用是判断HashMap是否包含key。 123public boolean containsKey(Object key) &#123; return getEntry(key) != null;&#125; containsKey() 首先通过getEntry(key)获取key对应的Entry，然后判断该Entry是否为null。getEntry()的源码如下： 123456789101112131415final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; getEntry() 的作用就是返回“键为key”的键值对，它的实现源码中已经进行了说明。这里需要强调的是：HashMap将“key为null”的元素都放在table的位置0处，即table[0]中；“key不为null”的放在table的其余位置！ containsValue()containsValue() 的作用是判断HashMap是否包含“值为value”的元素。 12345678910111213public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false;&#125; 从中，我们可以看出containsNullValue()分为两步进行处理：第一，若“value为null”，则调用containsNullValue()。第二，若“value不为null”，则查找HashMap中是否有值为value的节点。 containsNullValue() 的作用判断HashMap中是否包含“值为null”的元素。 12345678private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false;&#125; entrySet()、values()、keySet()它们3个的原理类似，这里以entrySet()为例来说明。entrySet()的作用是返回“HashMap中所有Entry的集合”，它是一个集合。实现代码如下： 12345678910111213141516171819202122232425262728293031323334// 返回“HashMap的Entry集合”public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0();&#125;// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet());&#125;// EntrySet对应的集合// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125;&#125; HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Entry，而每一个Entry本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？ 下面我们就看看HashMap是如何通过entrySet()遍历的。entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 返回一个“entry迭代器”Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator();&#125;// Entry的迭代器private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125;&#125;// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125;&#125; 当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。 get()get() 的作用是获取key对应的value，它的实现代码如下： 123456789101112131415public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; put()put() 的作用是对外提供接口，让HashMap对象可以通过put()将“key-value”添加到HashMap中。 1234567891011121314151617181920212223public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null;&#125; 若要添加到HashMap中的键值对对应的key已经存在HashMap中，则找到该键值对；然后新的value取代旧的value，并退出！若要添加到HashMap中的键值对对应的key不在HashMap中，则将其添加到该哈希值对应的链表中，并调用addEntry()。下面看看addEntry()的代码： 12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length);&#125; addEntry() 的作用是新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 说到addEntry()，就不得不说另一个函数createEntry()。createEntry()的代码如下： 12345678void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++;&#125; 它们的作用都是将key、value添加到HashMap中。而且，比较addEntry()和createEntry()的代码，我们发现addEntry()多了两句： 12if (size++ &gt;= threshold) resize(2 * table.length); 那它们的区别到底是什么呢？阅读代码，我们可以发现，它们的使用情景不同。 addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；put()是通过addEntry()新增Entry的。 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”； 因此，需要调用addEntry() createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中； 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中的全部元素添加到HashMap中，都不会超过HashMap的阈值”。 此时，调用createEntry()即可。 putAll()putAll() 的作用是将”m”的全部元素都添加到HashMap中，它的代码如下： 12345678910111213141516171819202122232425public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125;&#125; remove()remove() 的作用是删除“键为key”元素 123456789101112131415161718192021222324252627282930313233343536public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value);&#125;// 删除“键为key”的元素final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; HashMap实现的Cloneable接口HashMap实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个HashMap对象并返回。 123456789101112131415161718// 克隆一个HashMap，并返回Object对象public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result;&#125; HashMap实现的Serializable接口HashMap实现java.io.Serializable，分别实现了串行读取、写入功能。串行写入函数是writeObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中。而串行读取函数是readObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”依次读出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// java.io.Serializable的写入函数// 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中private void writeObject(java.io.ObjectOutputStream s) throws IOException&#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125;&#125;// java.io.Serializable的读取函数：根据写入方式读出// 将HashMap的“总的容量，实际容量，所有的Entry”依次读出private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125;&#125; HashMap遍历方式遍历HashMap的键值对第一步：根据entrySet()获取HashMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 遍历HashMap的键第一步：根据keySet()获取HashMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 遍历HashMap的值第一步：根据value()获取HashMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 遍历测试程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.HashMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc 遍历HashMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorHashMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashMapJustValues() * * @author skywang */public class HashMapIteratorTest &#123; public static void main(String[] args) &#123; int val = 0; String key = null; Integer value = null; Random r = new Random(); HashMap map = new HashMap(); for (int i=0; i&lt;12; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到HashMap中 map.put(key, value); System.out.println(\" key:\"+key+\" value:\"+value); &#125; // 通过entrySet()遍历HashMap的key-value iteratorHashMapByEntryset(map) ; // 通过keySet()遍历HashMap的key-value iteratorHashMapByKeyset(map) ; // 单单遍历HashMap的value iteratorHashMapJustValues(map); &#125; /* * 通过entry set遍历HashMap * 效率高! */ private static void iteratorHashMapByEntryset(HashMap map) &#123; if (map == null) return ; System.out.println(\"\\niterator HashMap By entryset\"); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+\" -- \"+integ.intValue()); &#125; &#125; /* * 通过keyset来遍历HashMap * 效率低! */ private static void iteratorHashMapByKeyset(HashMap map) &#123; if (map == null) return ; System.out.println(\"\\niterator HashMap By keyset\"); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+\" -- \"+integ.intValue()); &#125; &#125; /* * 遍历HashMap的values */ private static void iteratorHashMapJustValues(HashMap map) &#123; if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125; HashMap示例下面通过一个实例学习如何使用HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.HashMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc HashMap测试程序 * * @author skywang */public class HashMapTest &#123; public static void main(String[] args) &#123; testHashMapAPIs(); &#125; private static void testHashMapAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建HashMap HashMap map = new HashMap(); // 添加操作 map.put(\"one\", r.nextInt(10)); map.put(\"two\", r.nextInt(10)); map.put(\"three\", r.nextInt(10)); // 打印出map System.out.println(\"map:\"+map ); // 通过Iterator遍历key-value Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println(\"next : \"+ entry.getKey() +\" - \"+entry.getValue()); &#125; // HashMap的键值对个数 System.out.println(\"size:\"+map.size()); // containsKey(Object key) :是否包含键key System.out.println(\"contains key two : \"+map.containsKey(\"two\")); System.out.println(\"contains key five : \"+map.containsKey(\"five\")); // containsValue(Object value) :是否包含值value System.out.println(\"contains value 0 : \"+map.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 map.remove(\"three\"); System.out.println(\"map:\"+map ); // clear() ： 清空HashMap map.clear(); // isEmpty() : HashMap是否为空 System.out.println((map.isEmpty()?\"map is empty\":\"map is not empty\") ); &#125;&#125; (某一次)运行结果： 12345678910map:&#123;two=7, one=9, three=6&#125;next : two - 7next : one - 9next : three - 6size:3contains key two : truecontains key five : falsecontains value 0 : falsemap:&#123;two=7, one=9&#125;map is empty","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列09之 Map架构","date":"2016-12-08T16:00:00.000Z","path":"2016/12/09/java-source-analysis-set-series/Java 集合系列09之 Map架构/","text":"Map前面，我们已经系统的对List进行了学习。接下来，我们先学习Map，然后再学习Set；因为Set的实现类都是基于Map来实现的(如，HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。 首先，我们看看Map架构。 如上图： Map 是映射接口，Map中存储的内容是键值对(key-value)。 AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。 SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。 NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。 TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！ HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！ Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。 WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。 1、MapMap的定义如下： 1public interface Map&lt;K,V&gt; &#123; &#125; Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种 collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。 Map 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。 Map 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。 Map的API1234567891011121314abstract void clear()abstract boolean containsKey(Object key)abstract boolean containsValue(Object value)abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet()abstract boolean equals(Object object)abstract V get(Object key)abstract int hashCode()abstract boolean isEmpty()abstract Set&lt;K&gt; keySet()abstract V put(K key, V value)abstract void putAll(Map&lt;? extends K, ? extends V&gt; map)abstract V remove(Object key)abstract int size()abstract Collection&lt;V&gt; values() 说明： Map提供接口分别用于返回 键集、值集或键-值映射关系集。 1. entrySet()用于返回键-值集的Set集合 2. keySet()用于返回键集的Set集合 3. values()用户返回值集的Collection集合 4. 因为Map中不能包含重复的键；每个键最多只能映射到一个值。所以，键-值集、键集都是Set，值集时Collection。 Map提供了“键-值对”、“根据键获取值”、“删除键”、“获取容量大小”等方法。 2、Map.EntryMap.Entry的定义：1interface Entry&lt;K,V&gt; &#123; &#125; Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。 Map.Entry的API12345abstract boolean equals(Object object)abstract K getKey()abstract V getValue()abstract int hashCode()abstract V setValue(V object) 3、AbstractMapAbstractMap的定义：1public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。 要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。 要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。 AbstractMap的API12345678910111213141516abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet() void clear() boolean containsKey(Object key) boolean containsValue(Object value) boolean equals(Object object) V get(Object key) int hashCode() boolean isEmpty() Set&lt;K&gt; keySet() V put(K key, V value) void putAll(Map&lt;? extends K, ? extends V&gt; map) V remove(Object key) int size() String toString() Collection&lt;V&gt; values() Object clone() 4、SortedMapSortedMap的定义：1public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123; &#125; SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。SortedMap 的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。 另外，所有SortedMap 实现类都应该提供 4 个“标准”构造方法： void（无参数）构造方法，它创建一个空的有序映射，按照键的自然顺序进行排序。 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序映射，根据指定的比较器进行排序。 带有一个 Map 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系与参数相同，按照键的自然顺序进行排序。 带有一个 SortedMap 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系和排序方法与输入的有序映射相同。无法保证强制实施此建议，因为接口不能包含构造方法。 SortedMap的API12345678910111213141516171819202122// 继承于Map的APIabstract void clear()abstract boolean containsKey(Object key)abstract boolean containsValue(Object value)abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet()abstract boolean equals(Object object)abstract V get(Object key)abstract int hashCode()abstract boolean isEmpty()abstract Set&lt;K&gt; keySet()abstract V put(K key, V value)abstract void putAll(Map&lt;? extends K, ? extends V&gt; map)abstract V remove(Object key)abstract int size()abstract Collection&lt;V&gt; values()// SortedMap新增的API abstract Comparator&lt;? super K&gt; comparator()abstract K firstKey()abstract SortedMap&lt;K, V&gt; headMap(K endKey)abstract K lastKey()abstract SortedMap&lt;K, V&gt; subMap(K startKey, K endKey)abstract SortedMap&lt;K, V&gt; tailMap(K startKey) 5、NavigableMapNavigableMap的定义：1public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123; &#125; NavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。NavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。 NavigableMap的API123456789101112131415161718192021abstract Entry&lt;K, V&gt; ceilingEntry(K key)abstract Entry&lt;K, V&gt; firstEntry()abstract Entry&lt;K, V&gt; floorEntry(K key)abstract Entry&lt;K, V&gt; higherEntry(K key)abstract Entry&lt;K, V&gt; lastEntry()abstract Entry&lt;K, V&gt; lowerEntry(K key)abstract Entry&lt;K, V&gt; pollFirstEntry()abstract Entry&lt;K, V&gt; pollLastEntry()abstract K ceilingKey(K key)abstract K floorKey(K key)abstract K higherKey(K key)abstract K lowerKey(K key)abstract NavigableSet&lt;K&gt; descendingKeySet()abstract NavigableSet&lt;K&gt; navigableKeySet()abstract NavigableMap&lt;K, V&gt; descendingMap()abstract NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive)abstract SortedMap&lt;K, V&gt; headMap(K toKey)abstract SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey)abstract NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)abstract SortedMap&lt;K, V&gt; tailMap(K fromKey)abstract NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) 说明： NavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类： 提供操作键-值对的方法。 lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。 提供操作键的方法。这个和第1类比较类似 lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。 获取键集。 navigableKeySet、descendingKeySet分别获取正序/反序的键集。 获取键-值对的子集。 6、DictionaryDictionary的定义如下：1public abstract class Dictionary&lt;K,V&gt; &#123;&#125; NavigableMap是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。 Dictionary的API1234567abstract Enumeration&lt;V&gt; elements()abstract V get(Object key)abstract boolean isEmpty()abstract Enumeration&lt;K&gt; keys()abstract V put(K key, V value)abstract V remove(Object key)abstract int size()","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列08之 List总结","date":"2016-12-07T16:00:00.000Z","path":"2016/12/08/java-source-analysis-set-series/Java 集合系列08之 List总结/","text":"List 总结先回顾一下List的框架图 List 是一个接口，它继承于Collection的接口。它代表着有序的队列。 AbstractList 是一个抽象类，它继承于AbstractCollection。AbstractList实现List接口中除size()、get(int location)之外的函数。 AbstractSequentialList 是一个抽象类，它继承于AbstractList。AbstractSequentialList 实现了“链表中，根据index索引值操作链表的全部函数”。 ArrayList, LinkedList, Vector, Stack是List的4个实现类。 1. ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。 2. LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。 3. Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。 4. Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。 List使用场景学东西的最终目的是为了能够理解、使用它。下面先概括的说明一下各个List的使用场景，后面再分析原因。 如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。 对于需要快速插入，删除元素，应该使用LinkedList。 对于需要快速随机访问元素，应该使用ArrayList。 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。 对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。 通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.*;import java.lang.Class;/* * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率 */public class ListCompareTest &#123; private static final int COUNT = 100000; private static LinkedList linkedList = new LinkedList(); private static ArrayList arrayList = new ArrayList(); private static Vector vector = new Vector(); private static Stack stack = new Stack(); public static void main(String[] args) &#123; // 换行符 System.out.println(); // 插入 insertByPosition(stack) ; insertByPosition(vector) ; insertByPosition(linkedList) ; insertByPosition(arrayList) ; // 换行符 System.out.println(); // 随机读取 readByPosition(stack); readByPosition(vector); readByPosition(linkedList); readByPosition(arrayList); // 换行符 System.out.println(); // 删除 deleteByPosition(stack); deleteByPosition(vector); deleteByPosition(linkedList); deleteByPosition(arrayList); &#125; // 获取list的名称 private static String getListName(List list) &#123; if (list instanceof LinkedList) &#123; return \"LinkedList\"; &#125; else if (list instanceof ArrayList) &#123; return \"ArrayList\"; &#125; else if (list instanceof Stack) &#123; return \"Stack\"; &#125; else if (list instanceof Vector) &#123; return \"Vector\"; &#125; else &#123; return \"List\"; &#125; &#125; // 向list的指定位置插入COUNT个元素，并统计时间 private static void insertByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 向list的位置0插入COUNT个数 for (int i=0; i&lt;COUNT; i++) list.add(0, i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + \" : insert \"+COUNT+\" elements into the 1st position use time：\" + interval+\" ms\"); &#125; // 从list的指定位置删除COUNT个元素，并统计时间 private static void deleteByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 删除list第一个位置元素 for (int i=0; i&lt;COUNT; i++) list.remove(0); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + \" : delete \"+COUNT+\" elements from the 1st position use time：\" + interval+\" ms\"); &#125; // 根据position，不断从list中读取元素，并统计时间 private static void readByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 读取list元素 for (int i=0; i&lt;COUNT; i++) list.get(i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + \" : read \"+COUNT+\" elements by position use time：\" + interval+\" ms\"); &#125;&#125; 运行结果如下： 1234567891011121314Stack : insert 100000 elements into the 1st position use time：1640 msVector : insert 100000 elements into the 1st position use time：1607 msLinkedList : insert 100000 elements into the 1st position use time：29 msArrayList : insert 100000 elements into the 1st position use time：1617 msStack : read 100000 elements by position use time：9 msVector : read 100000 elements by position use time：6 msLinkedList : read 100000 elements by position use time：10809 msArrayList : read 100000 elements by position use time：5 msStack : delete 100000 elements from the 1st position use time：1916 msVector : delete 100000 elements from the 1st position use time：1910 msLinkedList : delete 100000 elements from the 1st position use time：15 msArrayList : delete 100000 elements from the 1st position use time：1909 ms 从中，我们可以发现：插入10万个元素，LinkedList所花时间最短：29ms。删除10万个元素，LinkedList所花时间最短：15ms。遍历10万个元素，LinkedList所花时间最长：10809 ms；而ArrayList、Stack和Vector则相差不多，都只用了几秒。 LinkedList和ArrayList性能差异分析为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢！LinkedList.java中向指定位置插入元素的代码如下： 1234567891011121314151617181920212223242526272829303132333435// 在index前添加节点，且节点的值为elementpublic void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index)));&#125;// 获取双向链表中指定位置的节点private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前向后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e;&#125;// 将节点(节点数据是e)添加到entry节点之前。private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); // 插入newEntry到链表中 newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; size++; modCount++; return newEntry;&#125; 从中，我们可以看出：通过add(int index, E element)向LinkedList插入元素时。先是在双向链表中找到要插入节点的位置index；找到之后，再插入一个新节点。 双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 接着，我们看看ArrayList.java中向指定位置插入元素的代码。如下： 123456789101112// 将e添加到ArrayList的指定位置public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 耗时的操作是 : 1System.arraycopy(elementData, index, elementData, index + 1, size - index); Sun JDK包的java/lang/System.java中的arraycopy()声明如下： 1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); arraycopy()是个JNI函数，它是在JVM中实现的。sunJDK中看不到源码，不过可以在OpenJDK包中看到的源码。网上有对arraycopy()的分析说明，请参考：System.arraycopy源码分析 。 实际上，我们只需要了解： 1System.arraycopy(elementData, index, elementData, index + 1, size - index); 会移动index之后所有元素即可。这就意味着，ArrayList的add(int index, E element)函数，会引起index之后所有元素的改变！ 通过上面的分析，我们就能理解为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢。 “删除元素”与“插入元素”的原理类似，这里就不再过多说明。 为什么LinkedList中随机访问很慢，而ArrayList中随机访问很快先看看LinkedList随机访问的代码 1234567891011121314151617181920212223// 返回LinkedList指定位置的元素public E get(int index) &#123; return entry(index).element;&#125;// 获取双向链表中指定位置的节点private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e;&#125; 从中，我们可以看出：通过get(int index)获取LinkedList第index个元素时。先是在双向链表中找到要index位置的元素；找到之后再返回。双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 下面看看ArrayList随机访问的代码 123456789101112// 获取index位置的元素值public E get(int index) &#123; RangeCheck(index); return (E) elementData[index];&#125;private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size);&#125; 从中，我们可以看出：通过get(int index)获取ArrayList第index个元素时。直接返回数组中index位置的元素，而不需要像LinkedList一样进行查找。 Vector和ArrayList比较相同之处它们都是List它们都继承于AbstractList，并且实现List接口。ArrayList和Vector的类定义如下： 1234567// ArrayList的定义public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable// Vector的定义public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; 它们都实现了RandomAccess和Cloneable接口 实现RandomAccess接口，意味着它们都支持快速随机访问； 实现Cloneable接口，意味着它们能克隆自己。 它们都是通过数组实现的，本质上都是动态数组ArrayList.java中定义数组elementData用于保存元素 123456// 保存ArrayList中数据的数组private transient Object[] elementData;Vector.java中也定义了数组elementData用于保存元素// 保存Vector中数据的数组protected Object[] elementData; 它们的默认数组容量是10若创建ArrayList或Vector时，没指定容量大小；则使用默认容量大小10。 123456789// ArrayList构造函数。默认容量是10。public ArrayList() &#123; this(10);&#125;// Vector构造函数。默认容量是10。public Vector() &#123; this(10);&#125; 它们都支持Iterator和listIterator遍历它们都继承于AbstractList，而AbstractList中分别实现了 “iterator()接口返回Iterator迭代器” 和 “listIterator()返回ListIterator迭代器”。 不同之处线程安全性不一样ArrayList是非线程安全；而Vector是线程安全的，它的函数都是synchronized的，即都是支持同步的。ArrayList适用于单线程，Vector适用于多线程。 对序列化支持不同ArrayList支持序列化，而Vector不支持；即ArrayList有实现java.io.Serializable接口，而Vector没有实现该接口。 构造函数个数不同ArrayList有3个构造函数，而Vector有4个构造函数。Vector除了包括和ArrayList类似的3个构造函数之外，另外的一个构造函数可以指定容量增加系数。 ArrayList的构造函数如下： 12345678// 默认构造函数ArrayList()// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含collection的ArrayListArrayList(Collection&lt;? extends E&gt; collection) Vector的构造函数如下： 1234567891011// 默认构造函数Vector()// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。Vector(int capacity)// 创建一个包含collection的VectorVector(Collection&lt;? extends E&gt; collection)// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。Vector(int capacity, int capacityIncrement) 4、容量增加方式不同逐个添加元素时，若ArrayList容量不足时，“新的容量”=“(原始容量x3)/2 + 1”。 而Vector的容量增长与“增长系数有关”，若指定了“增长系数”，且“增长系数有效(即，大于0)”；那么，每次容量不足时，“新的容量”=“原始容量+增长系数”。若增长系数无效(即，小于/等于0)，则“新的容量”=“原始容量 x 2”。 ArrayList中容量增长的主要函数如下： 12345678910111213public void ensureCapacity(int minCapacity) &#123; // 将“修改统计数”+1 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; Vector中容量增长的主要函数如下： 123456789101112131415private void ensureCapacityHelper(int minCapacity) &#123; int oldCapacity = elementData.length; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。 // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement // 否则，将容量增大一倍。 if (minCapacity &gt; oldCapacity) &#123; Object[] oldData = elementData; int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2); if (newCapacity &lt; minCapacity) &#123; newCapacity = minCapacity; &#125; elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; 5、对Enumeration的支持不同。Vector支持通过Enumeration去遍历，而List不支持Vector中实现Enumeration的代码如下： 123456789101112131415161718192021public Enumeration&lt;E&gt; elements() &#123; // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() &#123; int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; // 获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return (E)elementData[count++]; &#125; &#125; throw new NoSuchElementException(\"Vector Enumeration\"); &#125; &#125;;&#125;","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列07之 Stack详细介绍","date":"2016-12-06T16:00:00.000Z","path":"2016/12/07/java-source-analysis-set-series/Java 集合系列07之 Stack详细介绍/","text":"Stack简介Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 Java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在 Vector 中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。 Stack的继承关系1234567java.lang.Object↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt; ↳ java.util.Stack&lt;E&gt;public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;&#125; Stack和Collection的关系如下图： Stack的构造函数Stack只有一个默认构造函数，如下： 1Stack() Stack的APIStack是栈，它常用的API如下： 12345 boolean empty()synchronized E peek()synchronized E pop() E push(E object)synchronized int search(Object o) 由于Stack和继承于Vector，因此它也包含Vector中的全部API。 Stack源码解析(基于JDK1.6.0_45)Stack的源码非常简单，下面我们对它进行学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package java.util;public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; // 版本ID。这个用于版本升级控制，这里不须理会！ private static final long serialVersionUID = 1224463164541339165L; // 构造函数 public Stack() &#123; &#125; // push函数：将元素存入栈顶 public E push(E item) &#123; // 将元素存入栈顶。 // addElement()的实现在Vector.java中 addElement(item); return item; &#125; // pop函数：返回栈顶元素，并将其从栈中删除 public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); // 删除栈顶元素，removeElementAt()的实现在Vector.java中 removeElementAt(len - 1); return obj; &#125; // peek函数：返回栈顶元素，不执行删除操作 public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); // 返回栈顶元素，elementAt()具体实现在Vector.java中 return elementAt(len - 1); &#125; // 栈是否为空 public boolean empty() &#123; return size() == 0; &#125; // 查找“元素o”在栈中的位置：由栈底向栈顶方向数 public synchronized int search(Object o) &#123; // 获取元素索引，elementAt()具体实现在Vector.java中 int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1; &#125;&#125; 总结： Stack实际上也是通过数组去实现的。1. 执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 2. 执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 3. 执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。 Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。 Stack示例下面我们通过实例学习如何使用Stack 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Stack;import java.util.Iterator;import java.util.List;/** * @desc Stack的测试程序。测试常用API的用法 */public class StackTest &#123; public static void main(String[] args) &#123; Stack stack = new Stack(); // 将1,2,3,4,5添加到栈中 for(int i=1; i&lt;6; i++) &#123; stack.push(String.valueOf(i)); &#125; // 遍历并打印出该栈 iteratorThroughRandomAccess(stack) ; // 查找“2”在栈中的位置，并输出 int pos = stack.search(\"2\"); System.out.println(\"the postion of 2 is:\"+pos); // pop栈顶元素之后，遍历栈 stack.pop(); iteratorThroughRandomAccess(stack) ; // peek栈顶元素之后，遍历栈 String val = (String)stack.peek(); System.out.println(\"peek:\"+val); iteratorThroughRandomAccess(stack) ; // 通过Iterator去遍历Stack iteratorThroughIterator(stack) ; &#125; /** * 通过快速访问遍历Stack */ public static void iteratorThroughRandomAccess(List list) &#123; String val = null; for (int i=0; i&lt;list.size(); i++) &#123; val = (String)list.get(i); System.out.print(val+\" \"); &#125; System.out.println(); &#125; /** * 通过迭代器遍历Stack */ public static void iteratorThroughIterator(List list) &#123; String val = null; for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; val = (String)iter.next(); System.out.print(val+\" \"); &#125; System.out.println(); &#125;&#125; 运行结果： 1234561 2 3 4 5 the postion of 2 is:41 2 3 4 peek:41 2 3 4 1 2 3 4","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列06之 Vector详细介绍","date":"2016-12-05T16:00:00.000Z","path":"2016/12/06/java-source-analysis-set-series/Java 集合系列06之 Vector详细介绍/","text":"Vector简介Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。 Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。 Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是Java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了Cloneable 接口，即实现clone()函数。它能被克隆。 和ArrayList不同，Vector中的操作是线程安全的。 Vector的构造函数Vector共有4个构造函数 1234567891011// 默认构造函数Vector()// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。Vector(int capacity)// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。Vector(int capacity, int capacityIncrement)// 创建一个包含collection的VectorVector(Collection&lt;? extends E&gt; collection) Vector的API1234567891011121314151617181920212223242526272829303132333435363738394041synchronized boolean add(E object) void add(int location, E object)synchronized boolean addAll(Collection&lt;? extends E&gt; collection)synchronized boolean addAll(int location, Collection&lt;? extends E&gt; collection)synchronized void addElement(E object)synchronized int capacity() void clear()synchronized Object clone() boolean contains(Object object)synchronized boolean containsAll(Collection&lt;?&gt; collection)synchronized void copyInto(Object[] elements)synchronized E elementAt(int location) Enumeration&lt;E&gt; elements()synchronized void ensureCapacity(int minimumCapacity)synchronized boolean equals(Object object)synchronized E firstElement() E get(int location)synchronized int hashCode()synchronized int indexOf(Object object, int location) int indexOf(Object object)synchronized void insertElementAt(E object, int location)synchronized boolean isEmpty()synchronized E lastElement()synchronized int lastIndexOf(Object object, int location)synchronized int lastIndexOf(Object object)synchronized E remove(int location) boolean remove(Object object)synchronized boolean removeAll(Collection&lt;?&gt; collection)synchronized void removeAllElements()synchronized boolean removeElement(Object object)synchronized void removeElementAt(int location)synchronized boolean retainAll(Collection&lt;?&gt; collection)synchronized E set(int location, E object)synchronized void setElementAt(E object, int location)synchronized void setSize(int length)synchronized int size()synchronized List&lt;E&gt; subList(int start, int end)synchronized &lt;T&gt; T[] toArray(T[] contents)synchronized Object[] toArray()synchronized String toString()synchronized void trimToSize() Vector数据结构Vector的继承关系123456789java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; Vector与Collection关系图： Vector的数据结构和ArrayList差不多，它包含了3个成员变量：elementData , elementCount， capacityIncrement。 elementData 是”Object[]类型的数组”，它保存了添加到Vector中的元素。elementData是个动态数组，如果初始化Vector时，没指定动态数组的&gt;大小，则使用默认大小10。随着Vector中元素的增加，Vector的容量也会动态增长，capacityIncrement是与容量增长相关的增长系数，具体的增长方式，请参考源码分析中的ensureCapacity()函数。 elementCount 是动态数组的实际大小。 capacityIncrement 是动态数组的增长系数。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时，增加的大小都是capacityIncrement。 Vector源码解析(基于JDK1.6.0_45)为了更了解Vector的原理，下面对Vector源码代码作出分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471package java.util;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 保存Vector中数据的数组 protected Object[] elementData; // 实际数据的数量 protected int elementCount; // 容量增长系数 protected int capacityIncrement; // Vector的序列版本号 private static final long serialVersionUID = -2767605614048989439L; // Vector构造函数。默认容量是10。 public Vector() &#123; this(10); &#125; // 指定Vector容量大小的构造函数 public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; // 指定Vector\"容量大小\"和\"增长系数\"的构造函数 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); // 新建一个数组，数组容量是initialCapacity this.elementData = new Object[initialCapacity]; // 设置容量增长系数 this.capacityIncrement = capacityIncrement; &#125; // 指定集合的Vector构造函数。 public Vector(Collection&lt;? extends E&gt; c) &#123; // 获取“集合(c)”的数组，并将其赋值给elementData elementData = c.toArray(); // 设置数组长度 elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; // 将数组Vector的全部元素都拷贝到数组anArray中 public synchronized void copyInto(Object[] anArray) &#123; System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; // 将当前容量值设为 =实际元素个数 public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; // 确认“Vector容量”的帮助函数 private void ensureCapacityHelper(int minCapacity) &#123; int oldCapacity = elementData.length; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。 // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement // 否则，将容量增大一倍。 if (minCapacity &gt; oldCapacity) &#123; Object[] oldData = elementData; int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2); if (newCapacity &lt; minCapacity) &#123; newCapacity = minCapacity; &#125; elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 确定Vector的容量。 public synchronized void ensureCapacity(int minCapacity) &#123; // 将Vector的改变统计数+1 modCount++; ensureCapacityHelper(minCapacity); &#125; // 设置容量值为 newSize public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; // 若 \"newSize 大于 Vector容量\"，则调整Vector的大小。 ensureCapacityHelper(newSize); &#125; else &#123; // 若 \"newSize 小于/等于 Vector容量\"，则将newSize位置开始的元素都设置为null for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; // 返回“Vector的总的容量” public synchronized int capacity() &#123; return elementData.length; &#125; // 返回“Vector的实际大小”，即Vector中元素个数 public synchronized int size() &#123; return elementCount; &#125; // 判断Vector是否为空 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; // 返回“Vector中全部元素对应的Enumeration” public Enumeration&lt;E&gt; elements() &#123; // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() &#123; int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; // 获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return (E)elementData[count++]; &#125; &#125; throw new NoSuchElementException(\"Vector Enumeration\"); &#125; &#125;; &#125; // 返回Vector中是否包含对象(o) public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; // 从index位置开始向后查找元素(o)。 // 若找到，则返回元素的索引值；否则，返回-1 public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; // 若查找元素为null，则正向找出null元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则正向找出该元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 查找并返回元素(o)在Vector中的索引值 public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; // 从后向前查找元素(o)。并返回元素的索引 public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; // 从后向前查找元素(o)。开始位置是从前向后的第index个数； // 若找到，则返回元素的“索引值”；否则，返回-1。 public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + \" &gt;= \"+ elementCount); if (o == null) &#123; // 若查找元素为null，则反向找出null元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则反向找出该元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回Vector中index位置的元素。 // 若index月结，则抛出异常 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; return (E)elementData[index]; &#125; // 获取Vector中的第一个元素。 // 若失败，则抛出异常！ public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return (E)elementData[0]; &#125; // 获取Vector中的最后一个元素。 // 若失败，则抛出异常！ public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return (E)elementData[elementCount - 1]; &#125; // 设置index位置的元素值为obj public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; elementData[index] = obj; &#125; // 删除index位置的元素 public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; // 在index位置处插入元素(obj) public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; // 将“元素obj”添加到Vector末尾 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; // 在Vector中查找并删除元素obj。 // 成功的话，返回true；否则，返回false。 public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; // 删除Vector中的全部元素 public synchronized void removeAllElements() &#123; modCount++; // 将Vector中的全部元素设为null for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; // 克隆函数 public synchronized Object clone() &#123; try &#123; Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); // 将当前Vector的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; // 返回Object数组 public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; Vector的元素个数； // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中 if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 若数组a的大小 &gt;= Vector的元素个数； // 则将Vector的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; // 获取index位置的元素 public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return (E)elementData[index]; &#125; // 设置index位置的值为element。并返回index位置的原始值 public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); Object oldValue = elementData[index]; elementData[index] = element; return (E)oldValue; &#125; // 将“元素e”添加到Vector最后。 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; // 删除Vector中的元素o public boolean remove(Object o) &#123; return removeElement(o); &#125; // 在index位置添加元素element public void add(int index, E element) &#123; insertElementAt(element, index); &#125; // 删除index位置的元素，并返回index位置的原始值 public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); Object oldValue = elementData[index]; int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return (E)oldValue; &#125; // 清空Vector public void clear() &#123; removeAllElements(); &#125; // 返回Vector是否包含集合c public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; // 将集合c添加到Vector中 public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); // 将集合c的全部元素拷贝到数组elementData中 System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; // 删除集合c的全部元素 public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; // 删除“非集合c中的元素” public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; // 从index位置开始，将集合c添加到Vector中 public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; // 返回两个对象是否相等 public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; // 计算哈希值 public synchronized int hashCode() &#123; return super.hashCode(); &#125; // 调用父类的toString() public synchronized String toString() &#123; return super.toString(); &#125; // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集 public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; // 删除Vector中fromIndex到toIndex的元素 protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; // java.io.Serializable的写入函数 private synchronized void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); &#125;&#125; 总结： Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。 当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 &gt; 0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。 Vector的克隆函数，即是将全部元素克隆到一个数组中。 Vector遍历方式Vector支持4种遍历方式。建议使用下面的第二种去遍历Vector，因为效率问题。 第一种，通过迭代器遍历。即通过Iterator去遍历。12345Integer value = null;int size = vec.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)vec.get(i); &#125; 第二种，随机访问，通过索引值去遍历。由于Vector实现了RandomAccess接口，它支持通过索引值去随机访问元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108Integer value = null;int size = vec.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)vec.get(i); &#125;``` ## 第三种，另一种for循环。如下：```javaInteger value = null;for (Integer integ:vec) &#123; value = integ;&#125;``` ## 第四种，Enumeration遍历。如下： ```javaInteger value = null;Enumeration enu = vec.elements();while (enu.hasMoreElements()) &#123; value = (Integer)enu.nextElement();&#125;``` 测试这些遍历方式效率的代码如下：```javaimport java.util.*;/* * @desc Vector遍历方式和效率的测试程序。 * * @author skywang */public class VectorRandomAccessTest &#123; public static void main(String[] args) &#123; Vector vec= new Vector(); for (int i=0; i&lt;100000; i++) vec.add(i); iteratorThroughRandomAccess(vec) ; iteratorThroughIterator(vec) ; iteratorThroughFor2(vec) ; iteratorThroughEnumeration(vec) ; &#125; private static void isRandomAccessSupported(List list) &#123; if (list instanceof RandomAccess) &#123; System.out.println(\"RandomAccess implemented!\"); &#125; else &#123; System.out.println(\"RandomAccess not implemented!\"); &#125; &#125; public static void iteratorThroughRandomAccess(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughRandomAccess：\" + interval+\" ms\"); &#125; public static void iteratorThroughIterator(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; iter.next(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughIterator：\" + interval+\" ms\"); &#125; public static void iteratorThroughFor2(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughFor2：\" + interval+\" ms\"); &#125; public static void iteratorThroughEnumeration(Vector vec) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Enumeration enu = vec.elements(); enu.hasMoreElements(); ) &#123; enu.nextElement(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughEnumeration：\" + interval+\" ms\"); &#125;&#125; 运行结果： 1234iteratorThroughRandomAccess：6 msiteratorThroughIterator：9 msiteratorThroughFor2：8 msiteratorThroughEnumeration：7 ms 总结：遍历Vector，使用索引的随机访问方式最快，使用迭代器最慢。 Vector示例下面通过示例学习如何使用Vector 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Vector;import java.util.List;import java.util.Iterator;import java.util.Enumeration;/** * @desc Vector测试函数：遍历Vector和常用API * * @author skywang */public class VectorTest &#123; public static void main(String[] args) &#123; // 新建Vector Vector vec = new Vector(); // 添加元素 vec.add(\"1\"); vec.add(\"2\"); vec.add(\"3\"); vec.add(\"4\"); vec.add(\"5\"); // 设置第一个元素为100 vec.set(0, \"100\"); // 将“500”插入到第3个位置 vec.add(2, \"300\"); System.out.println(\"vec:\"+vec); // (顺序查找)获取100的索引 System.out.println(\"vec.indexOf(100):\"+vec.indexOf(\"100\")); // (倒序查找)获取100的索引 System.out.println(\"vec.lastIndexOf(100):\"+vec.lastIndexOf(\"100\")); // 获取第一个元素 System.out.println(\"vec.firstElement():\"+vec.firstElement()); // 获取第3个元素 System.out.println(\"vec.elementAt(2):\"+vec.elementAt(2)); // 获取最后一个元素 System.out.println(\"vec.lastElement():\"+vec.lastElement()); // 获取Vector的大小 System.out.println(\"size:\"+vec.size()); // 获取Vector的总的容量 System.out.println(\"capacity:\"+vec.capacity()); // 获取vector的“第2”到“第4”个元素 System.out.println(\"vec 2 to 4:\"+vec.subList(1, 4)); // 通过Enumeration遍历Vector Enumeration enu = vec.elements(); while(enu.hasMoreElements()) System.out.println(\"nextElement():\"+enu.nextElement()); Vector retainVec = new Vector(); retainVec.add(\"100\"); retainVec.add(\"300\"); // 获取“vec”中包含在“retainVec中的元素”的集合 System.out.println(\"vec.retain():\"+vec.retainAll(retainVec)); System.out.println(\"vec:\"+vec); // 获取vec对应的String数组 String[] arr = (String[]) vec.toArray(new String[0]); for (String str:arr) System.out.println(\"str:\"+str); // 清空Vector。clear()和removeAllElements()一样！ vec.clear();// vec.removeAllElements(); // 判断Vector是否为空 System.out.println(\"vec.isEmpty():\"+vec.isEmpty()); &#125; &#125; 运行结果： 1234567891011121314151617181920vec:[100, 2, 300, 3, 4, 5]vec.indexOf(100):0vec.lastIndexOf(100):0vec.firstElement():100vec.elementAt(2):300vec.lastElement():5size:6capacity:10vec 2 to 4:[2, 300, 3]nextElement():100nextElement():2nextElement():300nextElement():3nextElement():4nextElement():5vec.retain():truevec:[100, 300]str:100str:300vec.isEmpty():true","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列05之 LinkedList详细介绍","date":"2016-12-04T16:00:00.000Z","path":"2016/12/05/java-source-analysis-set-series/Java 集合系列05之 LinkedList详细介绍/","text":"LinkedList简介 LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 LinkedList构造函数12345// 默认构造函数LinkedList()// 创建一个LinkedList，保护Collection中的全部元素。LinkedList(Collection&lt;? extends E&gt; collection) LinkedList的API12345678910111213141516171819202122232425262728293031323334353637383940// LinkedList的APIboolean add(E object)void add(int location, E object)boolean addAll(Collection&lt;? extends E&gt; collection)boolean addAll(int location, Collection&lt;? extends E&gt; collection)void addFirst(E object)void addLast(E object)void clear()Object clone()boolean contains(Object object)Iterator&lt;E&gt; descendingIterator()E element()E get(int location)E getFirst()E getLast()int indexOf(Object object)int lastIndexOf(Object object)ListIterator&lt;E&gt; listIterator(int location)boolean offer(E o)boolean offerFirst(E e)boolean offerLast(E e)E peek()E peekFirst()E peekLast()E poll()E pollFirst()E pollLast()E pop()void push(E e)E remove()E remove(int location)boolean remove(Object object)E removeFirst()boolean removeFirstOccurrence(Object o)E removeLast()boolean removeLastOccurrence(Object o)E set(int location, E object)int size()&lt;T&gt; T[] toArray(T[] contents)Object[] toArray() AbstractSequentialList简介在介绍LinkedList的源码之前，先介绍一下AbstractSequentialList。毕竟，LinkedList是AbstractSequentialList的子类。 AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element)和remove(int index)这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了get(int index)这些接口。 此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。 LinkedList数据结构LinkedList的继承关系12345java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.AbstractSequentialList&lt;E&gt; ↳ java.util.LinkedList&lt;E&gt; 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; LinkedList与Collection关系图： LinkedList的本质是双向链表。 LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。 LinkedList包含两个重要的成员：header 和 size。 header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。size是双向链表中节点的个数。 LinkedList源码解析(基于JDK1.6.0_45)为了更了解LinkedList的原理，下面对LinkedList源码代码作出分析。 在阅读源码之前，我们先对LinkedList的整体实现进行大致说明： LinkedList实际上是通过双向链表去实现的。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。 既然LinkedList是通过双向链表的，但是它也实现了List接口{也就是说，它实现了get(int location)、remove(int location)等“根据索引值来获取、删除节点的函数”}。 LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？ 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。这就是“双线链表和索引值联系起来”的方法。 好了，接下来开始阅读源码(只要理解双向链表，那么LinkedList的源码很容易理解的)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641package java.util;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 // transient声明一个实例变量，当对象存储时，它的值不需要维持。 // 换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125;&#125; 总结： 1、LinkedList 实际上是通过双向链表去实现的。它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 2、从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。 3、LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。 4、LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 5、由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。 总结起来如下表格： 第一个元素 第一个元素 最后一个元素 最后一个元素 抛出异常 特殊值 抛出异常 特殊值 插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e) 移除 removeFirst() pollFirst() removeLast() pollLast() 检查 getFirst() peekFirst() getLast() peekLast() 6、LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价： 队列方法 等效方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 7、LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价： 栈方法 等效方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() LinkedList遍历方式LinkedList遍历方式 LinkedList支持多种遍历方式。建议不要采用随机访问的方式去遍历LinkedList，而采用逐个遍历的方式。 第一种，通过迭代器遍历。即通过Iterator去遍历。12for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); 第二种，通过快速随机访问遍历LinkedList1234int size = list.size();for (int i=0; i&lt;size; i++) &#123; list.get(i); &#125; 第三种，通过另外一种for循环来遍历LinkedList12for (Integer integ:list) ; 通过pollFirst()来遍历LinkedList12while(list.pollFirst() != null) ; 通过pollLast()来遍历LinkedList12while(list.pollLast() != null) ; 通过removeFirst()来遍历LinkedList12345try &#123; while(list.removeFirst() != null) ;&#125; catch (NoSuchElementException e) &#123;&#125; 通过removeLast()来遍历LinkedList12345try &#123; while(list.removeLast() != null) ;&#125; catch (NoSuchElementException e) &#123;&#125; 测试这些遍历方式效率的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import java.util.List;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;/* * @desc 测试LinkedList的几种遍历方式和效率 * * @author skywang */public class LinkedListThruTest &#123; public static void main(String[] args) &#123; // 通过Iterator遍历LinkedList iteratorLinkedListThruIterator(getLinkedList()) ; // 通过快速随机访问遍历LinkedList iteratorLinkedListThruForeach(getLinkedList()) ; // 通过for循环的变种来访问遍历LinkedList iteratorThroughFor2(getLinkedList()) ; // 通过PollFirst()遍历LinkedList iteratorThroughPollFirst(getLinkedList()) ; // 通过PollLast()遍历LinkedList iteratorThroughPollLast(getLinkedList()) ; // 通过removeFirst()遍历LinkedList iteratorThroughRemoveFirst(getLinkedList()) ; // 通过removeLast()遍历LinkedList iteratorThroughRemoveLast(getLinkedList()) ; &#125; private static LinkedList getLinkedList() &#123; LinkedList llist = new LinkedList(); for (int i=0; i&lt;100000; i++) llist.addLast(i); return llist; &#125; /** * 通过快迭代器遍历LinkedList */ private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorLinkedListThruIterator：\" + interval+\" ms\"); &#125; /** * 通过快速随机访问遍历LinkedList */ private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); int size = list.size(); for (int i=0; i&lt;size; i++) &#123; list.get(i); &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorLinkedListThruForeach：\" + interval+\" ms\"); &#125; /** * 通过另外一种for循环来遍历LinkedList */ private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for (Integer integ:list) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorThroughFor2：\" + interval+\" ms\"); &#125; /** * 通过pollFirst()来遍历LinkedList */ private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollFirst() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorThroughPollFirst：\" + interval+\" ms\"); &#125; /** * 通过pollLast()来遍历LinkedList */ private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollLast() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorThroughPollLast：\" + interval+\" ms\"); &#125; /** * 通过removeFirst()来遍历LinkedList */ private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try &#123; while(list.removeFirst() != null) ; &#125; catch (NoSuchElementException e) &#123; &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorThroughRemoveFirst：\" + interval+\" ms\"); &#125; /** * 通过removeLast()来遍历LinkedList */ private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try &#123; while(list.removeLast() != null) ; &#125; catch (NoSuchElementException e) &#123; &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println(\"iteratorThroughRemoveLast：\" + interval+\" ms\"); &#125;&#125; 执行结果： 1234567iteratorLinkedListThruIterator：8 msiteratorLinkedListThruForeach：3724 msiteratorThroughFor2：5 msiteratorThroughPollFirst：8 msiteratorThroughPollLast：6 msiteratorThroughRemoveFirst：2 msiteratorThroughRemoveLast：2 ms 由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种 (增强 for循环) 遍历方式。无论如何，千万不要通过随机访问去遍历LinkedList！ LinkedList示例下面通过一个示例来学习如何使用LinkedList的常用API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import java.util.List;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;/* * @desc LinkedList测试程序。 * */public class LinkedListTest &#123; public static void main(String[] args) &#123; // 测试LinkedList的API testLinkedListAPIs() ; // 将LinkedList当作 LIFO(后进先出)的堆栈 useLinkedListAsLIFO(); // 将LinkedList当作 FIFO(先进先出)的队列 useLinkedListAsFIFO(); &#125; /* * 测试LinkedList中部分API */ private static void testLinkedListAPIs() &#123; String val = null; //LinkedList llist; //llist.offer(\"10\"); // 新建一个LinkedList LinkedList llist = new LinkedList(); //---- 添加操作 ---- // 依次添加1,2,3 llist.add(\"1\"); llist.add(\"2\"); llist.add(\"3\"); // 将“4”添加到第一个位置 llist.add(1, \"4\"); System.out.println(\"\\nTest \\\"addFirst(), removeFirst(), getFirst()\\\"\"); // (01) 将“10”添加到第一个位置。 失败的话，抛出异常！ llist.addFirst(\"10\"); System.out.println(\"llist:\"+llist); // (02) 将第一个元素删除。 失败的话，抛出异常！ System.out.println(\"llist.removeFirst():\"+llist.removeFirst()); System.out.println(\"llist:\"+llist); // (03) 获取第一个元素。 失败的话，抛出异常！ System.out.println(\"llist.getFirst():\"+llist.getFirst()); System.out.println(\"\\nTest \\\"offerFirst(), pollFirst(), peekFirst()\\\"\"); // (01) 将“10”添加到第一个位置。 返回true。 llist.offerFirst(\"10\"); System.out.println(\"llist:\"+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println(\"llist.pollFirst():\"+llist.pollFirst()); System.out.println(\"llist:\"+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println(\"llist.peekFirst():\"+llist.peekFirst()); System.out.println(\"\\nTest \\\"addLast(), removeLast(), getLast()\\\"\"); // (01) 将“20”添加到最后一个位置。 失败的话，抛出异常！ llist.addLast(\"20\"); System.out.println(\"llist:\"+llist); // (02) 将最后一个元素删除。 失败的话，抛出异常！ System.out.println(\"llist.removeLast():\"+llist.removeLast()); System.out.println(\"llist:\"+llist); // (03) 获取最后一个元素。 失败的话，抛出异常！ System.out.println(\"llist.getLast():\"+llist.getLast()); System.out.println(\"\\nTest \\\"offerLast(), pollLast(), peekLast()\\\"\"); // (01) 将“20”添加到第一个位置。 返回true。 llist.offerLast(\"20\"); System.out.println(\"llist:\"+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println(\"llist.pollLast():\"+llist.pollLast()); System.out.println(\"llist:\"+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println(\"llist.peekLast():\"+llist.peekLast()); // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！ llist.set(2, \"300\"); // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！ System.out.println(\"\\nget(3):\"+llist.get(2)); // ---- toArray(T[] a) ---- // 将LinkedList转行为数组 String[] arr = (String[])llist.toArray(new String[0]); for (String str:arr) System.out.println(\"str:\"+str); // 输出大小 System.out.println(\"size:\"+llist.size()); // 清空LinkedList llist.clear(); // 判断LinkedList是否为空 System.out.println(\"isEmpty():\"+llist.isEmpty()+\"\\n\"); &#125; /** * 将LinkedList当作 LIFO(后进先出)的堆栈 */ private static void useLinkedListAsLIFO() &#123; System.out.println(\"\\nuseLinkedListAsLIFO\"); // 新建一个LinkedList LinkedList stack = new LinkedList(); // 将1,2,3,4添加到堆栈中 stack.push(\"1\"); stack.push(\"2\"); stack.push(\"3\"); stack.push(\"4\"); // 打印“栈” System.out.println(\"stack:\"+stack); // 删除“栈顶元素” System.out.println(\"stack.pop():\"+stack.pop()); // 取出“栈顶元素” System.out.println(\"stack.peek():\"+stack.peek()); // 打印“栈” System.out.println(\"stack:\"+stack); &#125; /** * 将LinkedList当作 FIFO(先进先出)的队列 */ private static void useLinkedListAsFIFO() &#123; System.out.println(\"\\nuseLinkedListAsFIFO\"); // 新建一个LinkedList LinkedList queue = new LinkedList(); // 将10,20,30,40添加到队列。每次都是插入到末尾 queue.add(\"10\"); queue.add(\"20\"); queue.add(\"30\"); queue.add(\"40\"); // 打印“队列” System.out.println(\"queue:\"+queue); // 删除(队列的第一个元素) System.out.println(\"queue.remove():\"+queue.remove()); // 读取(队列的第一个元素) System.out.println(\"queue.element():\"+queue.element()); // 打印“队列” System.out.println(\"queue:\"+queue); &#125;&#125; 运行结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344Test \"addFirst(), removeFirst(), getFirst()\"llist:[10, 1, 4, 2, 3]llist.removeFirst():10llist:[1, 4, 2, 3]llist.getFirst():1Test \"offerFirst(), pollFirst(), peekFirst()\"llist:[10, 1, 4, 2, 3]llist.pollFirst():10llist:[1, 4, 2, 3]llist.peekFirst():1Test \"addLast(), removeLast(), getLast()\"llist:[1, 4, 2, 3, 20]llist.removeLast():20llist:[1, 4, 2, 3]llist.getLast():3Test \"offerLast(), pollLast(), peekLast()\"llist:[1, 4, 2, 3, 20]llist.pollLast():20llist:[1, 4, 2, 3]llist.peekLast():3get(3):300str:1str:4str:300str:3size:4isEmpty():trueuseLinkedListAsLIFOstack:[4, 3, 2, 1]stack.pop():4stack.peek():3stack:[3, 2, 1]useLinkedListAsFIFOqueue:[10, 20, 30, 40]queue.remove():10queue.element():20queue:[20, 30, 40]","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列04之 fail-fast总结","date":"2016-12-03T16:00:00.000Z","path":"2016/12/04/java-source-analysis-set-series/Java 集合系列04之 fail-fast总结/","text":"1、fail-fast简介fail-fast 机制是Java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 在详细介绍fail-fast机制的原理之前，先通过一个示例来认识fail-fast。 2、fail-fast示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;import java.util.concurrent.*;/* * @desc java集合中Fast-Fail的测试程序。 * * fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。 * fast-fail解决办法：通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。 * * 本例中，分别测试ArrayList和CopyOnWriteArrayList这两种情况。ArrayList会产生fast-fail事件，而CopyOnWriteArrayList不会产生fast-fail事件。 * (01) 使用ArrayList时，会产生fast-fail事件，抛出ConcurrentModificationException异常；定义如下： * private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); * (02) 使用时CopyOnWriteArrayList，不会产生fast-fail事件；定义如下： * private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); * */public class FastFailTest &#123; private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对list进行操作！ new ThreadOne().start(); new ThreadTwo().start(); &#125; private static void printAll() &#123; System.out.println(\"\"); String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+\", \"); &#125; &#125; /** * 向list中依次添加0,1,2,3,4,5，每添加一个数之后，就通过printAll()遍历整个list */ private static class ThreadOne extends Thread &#123; public void run() &#123; int i = 0; while (i&lt;6) &#123; list.add(String.valueOf(i)); printAll(); i++; &#125; &#125; &#125; /** * 向list中依次添加10,11,12,13,14,15，每添加一个数之后，就通过printAll()遍历整个list */ private static class ThreadTwo extends Thread &#123; public void run() &#123; int i = 10; while (i&lt;16) &#123; list.add(String.valueOf(i)); printAll(); i++; &#125; &#125; &#125;&#125; 运行结果：运行该代码，抛出异常java.util.ConcurrentModificationException！即，产生fail-fast事件！ 结果说明：(01) FastFailTest中通过 new ThreadOne().start() 和 new ThreadTwo().start() 同时启动两个线程去操作list。 ThreadOne线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。 ThreadTwo线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。(02) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。 3、fail-fast解决办法fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。即，将代码 1private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 替换为 1private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); 则可以解决该办法。 fail-fast原理产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。那么，ArrayList是如何抛出ConcurrentModificationException异常的呢? 我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package java.util;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; ... // AbstractList中唯一的属性 // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1 protected transient int modCount = 0; // 返回List对应迭代器。实际上，是返回Itr对象。 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; // Itr是Iterator(迭代器)的实现类 private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0; int lastRet = -1; // 修改数的记录值。 // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount； // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; ...&#125; 从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。 要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。 接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... // list中容量变化时，对应的同步函数 public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 添加元素到队列最后 public boolean add(E e) &#123; // 修改modCount ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 添加元素到指定的位置 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); // 修改modCount ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 添加集合 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 修改modCount ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 删除指定位置的元素 public E remove(int index) &#123; RangeCheck(index); // 修改modCount modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 快速删除指定位置的元素 private void fastRemove(int index) &#123; // 修改modCount modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; // 清空集合 public void clear() &#123; // 修改modCount modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; ...&#125; 从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。 接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下： 新建了一个ArrayList，名称为arrayList。 向arrayList中添加内容。 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。 这时，就会产生有趣的事件了。 在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。 在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。 至此，我们就完全了解了fail-fast是如何产生的！即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 5、解决fail-fast的原理上面，说明了“解决fail-fast机制的办法”，也知道了“fail-fast产生的根本原因”。接下来，我们再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。还是以和ArrayList对应的CopyOnWriteArrayList进行说明。我们先看看CopyOnWriteArrayList的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package java.util.concurrent;import java.util.*;import java.util.concurrent.locks.*;import sun.misc.Unsafe;public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... // 返回集合对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0); &#125; ... private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; // 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。 // 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。 snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125; &#125; ...&#125; 从中，我们可以看出: 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。 ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。 ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！ 为什么CopyOnWriteArrayList可以不比较modCount也能保证数据一致性？因为getArray()返回的array的类型是volatile的（强制内存一致性）","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列03之 ArrayList详细介绍","date":"2016-12-02T16:00:00.000Z","path":"2016/12/03/java-source-analysis-set-series/Java 集合系列03之 ArrayList详细介绍/","text":"ArrayList简介123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125; ArrayList 是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList构造函数12345678// 默认构造函数ArrayList()// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含collection的ArrayListArrayList(Collection&lt;? extends E&gt; collection) ArrayList的API1234567891011121314151617181920212223242526272829303132// Collection中定义的APIboolean add(E object)boolean addAll(Collection&lt;? extends E&gt; collection)void clear()boolean contains(Object object)boolean containsAll(Collection&lt;?&gt; collection)boolean equals(Object object)int hashCode()boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object object)boolean removeAll(Collection&lt;?&gt; collection)boolean retainAll(Collection&lt;?&gt; collection)int size()&lt;T&gt; T[] toArray(T[] array)Object[] toArray()// AbstractCollection中定义的APIvoid add(int location, E object)boolean addAll(int location, Collection&lt;? extends E&gt; collection)E get(int location)int indexOf(Object object)int lastIndexOf(Object object)ListIterator&lt;E&gt; listIterator(int location)ListIterator&lt;E&gt; listIterator()E remove(int location)E set(int location, E object)List&lt;E&gt; subList(int start, int end)// ArrayList新增的APIObject clone()void ensureCapacity(int minimumCapacity)void trimToSize()void removeRange(int fromIndex, int toIndex) ArrayList数据结构ArrayList的继承关系 1234567java.lang.Object |___ java.util.AbstractCollection&lt;E&gt; |___ java.util.AbstractList&lt;E&gt; |___ java.util.ArrayList&lt;E&gt;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; ArrayList与Collection关系如下图： ArrayList包含了两个重要的对象：elementData 和 size。 elementData 是”Object[]类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的ensureCapacity()函数。 size 则是动态数组的实际大小。 ArrayList源码解析(基于JDK1.6.0_45)为了更了解ArrayList的原理，下面对ArrayList源码代码作出分析。ArrayList是通过数组实现的，源码比较容易理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // 保存ArrayList中数据的数组 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; &#125; // ArrayList构造函数。默认容量是10。 public ArrayList() &#123; this(10); &#125; // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; // 将当前容量值设为 =实际元素个数 public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; // 确定ArrarList的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) &#123; // 将“修改统计数”+1 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 添加元素e public boolean add(E e) &#123; // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; &#125; // 返回ArrayList的实际大小 public int size() &#123; return size; &#125; // 返回ArrayList是否包含Object(o) public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; // 返回ArrayList是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 正向查找，返回元素的索引值 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回ArrayList的Object数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 &gt;= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // 获取index位置的元素值 public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125; // 设置index位置的值为element public E set(int index, E element) &#123; RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; // 将e添加到ArrayList中 public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 将e添加到ArrayList的指定位置 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 删除ArrayList指定位置的元素 public E remove(int index) &#123; RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 删除ArrayList的指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 快速删除第index个元素 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; // 从\"index+1\"开始，用后面的元素替换前面的元素。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work &#125; // 删除元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 清空ArrayList，将全部的元素设为null public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \" + index + \", Size: \" + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; &#125; private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); &#125; // 克隆函数 public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); &#125;&#125; 总结： ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。 当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。 ArrayList的克隆函数，即是将全部元素克隆到一个数组中。 ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 ArrayList遍历方式ArrayList支持3种遍历方式 第一种，通过迭代器遍历。即通过Iterator去遍历。12345Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 第二种，随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 12345Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)list.get(i); &#125; 第三种，for循环遍历。如下：1234Integer value = null;for (Integer integ:list) &#123; value = integ;&#125; 下面通过一个实例，比较这3种方式的效率，实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;import java.util.concurrent.*;/** * @desc ArrayList遍历方式和效率的测试程序。 */public class ArrayListRandomAccessTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); for (int i=0; i&lt;100000; i++) list.add(i); //isRandomAccessSupported(list); iteratorThroughRandomAccess(list) ; iteratorThroughIterator(list) ; iteratorThroughFor2(list) ; &#125; private static void isRandomAccessSupported(List list) &#123; if (list instanceof RandomAccess) &#123; System.out.println(\"RandomAccess implemented!\"); &#125; else &#123; System.out.println(\"RandomAccess not implemented!\"); &#125; &#125; public static void iteratorThroughRandomAccess(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughRandomAccess：\" + interval+\" ms\"); &#125; public static void iteratorThroughIterator(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; iter.next(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughIterator：\" + interval+\" ms\"); &#125; public static void iteratorThroughFor2(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(\"iteratorThroughFor2：\" + interval+\" ms\"); &#125;&#125; 运行结果： 123iteratorThroughRandomAccess：3 msiteratorThroughIterator：8 msiteratorThroughFor2：5 ms 由此可见，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！ toArray()异常当我们调用ArrayList中的 toArray()，可能遇到过出“java.lang.ClassCastException”异常的情况。下面我们说说这是怎么回事。 ArrayList提供了2个toArray()函数： 12Object[] toArray()&lt;T&gt; T[] toArray(T[] contents) 调用 toArray() 函数会抛出“java.lang.ClassCastException”异常，但是调用 toArray(T[] contents) 能正常返回 T[]。 toArray() 会抛出异常是因为 toArray() 返回的是 Object[] 数组，将 Object[] 转换为其它类型(如如，将Object[]转换为的Integer[])则会抛出“java.lang.ClassCastException”异常，因为Java不支持向下转型。具体的可以参考前面ArrayList.java的源码介绍部分的toArray()。 解决该问题的办法是调用 T[] toArray(T[] contents) ， 而不是 Object[] toArray()。 调用 toArray(T[] contents) 返回T[]的可以通过以下几种方式实现。 12345678910111213141516171819 // toArray(T[] contents)调用方式一public static Integer[] vectorToArray1(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = new Integer[v.size()]; v.toArray(newText); return newText;&#125;// toArray(T[] contents)调用方式二。最常用！public static Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = (Integer[])v.toArray(new Integer[0]); return newText;&#125;// toArray(T[] contents)调用方式三public static Integer[] vectorToArray3(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = new Integer[v.size()]; Integer[] newStrings = (Integer[])v.toArray(newText); return newStrings;&#125; ArrayList示例本文通过一个实例(ArrayListTest.java)，介绍 ArrayList 中常用API的用法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;/* * @desc ArrayList常用API的测试程序 * @author skywang * @email kuiwu-wang@163.com */public class ArrayListTest &#123; public static void main(String[] args) &#123; // 创建ArrayList ArrayList list = new ArrayList(); // 将“” list.add(\"1\"); list.add(\"2\"); list.add(\"3\"); list.add(\"4\"); // 将下面的元素添加到第1个位置 list.add(0, \"5\"); // 获取第1个元素 System.out.println(\"the first element is: \"+ list.get(0)); // 删除“3” list.remove(\"3\"); // 获取ArrayList的大小 System.out.println(\"Arraylist size=: \"+ list.size()); // 判断list中是否包含\"3\" System.out.println(\"ArrayList contains 3 is: \"+ list.contains(3)); // 设置第2个元素为10 list.set(1, \"10\"); // 通过Iterator遍历ArrayList for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; System.out.println(\"next is: \"+ iter.next()); &#125; // 将ArrayList转换为数组 String[] arr = (String[])list.toArray(new String[0]); for (String str:arr) System.out.println(\"str: \"+ str); // 清空ArrayList list.clear(); // 判断ArrayList是否为空 System.out.println(\"ArrayList is empty: \"+ list.isEmpty()); &#125;&#125; 123456789101112the first element is: 5Arraylist size=: 4ArrayList contains 3 is: falsenext is: 5next is: 10next is: 2next is: 4str: 5str: 10str: 2str: 4ArrayList is empty: true","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列02之 Collection架构","date":"2016-12-01T16:00:00.000Z","path":"2016/12/02/java-source-analysis-set-series/Java 集合系列02之 Collection架构/","text":"CollectionCollection框架类的关系图： Collection是一个接口，它主要的两个分支是：List 和 Set。 List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！List和Set都有它们各自的实现类。 为了方便，我们抽象出了AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。 1、Collection接口简介Collection的定义如下： 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125; 它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。 Collection接口的所有子类(直接子类和间接子类)都必须实现2种构造函数：不带参数的构造函数 和 参数为Collection的构造函数。带参数的构造函数，可以用来转换Collection的类型。 12345678910111213141516// Collection的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator&lt;E&gt; iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract &lt;T&gt; T[] toArray(T[] array)abstract Object[] toArray() 2、List接口简介List的定义如下： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。 关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取List中的子队列”等。 123456789101112131415161718192021222324252627// Collection的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator&lt;E&gt; iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract &lt;T&gt; T[] toArray(T[] array)abstract Object[] toArray()// 相比与Collection，List新增的API：abstract void add(int location, E object)abstract boolean addAll(int location, Collection&lt;? extends E&gt; collection)abstract E get(int location)abstract int indexOf(Object object)abstract int lastIndexOf(Object object)abstract ListIterator&lt;E&gt; listIterator(int location)abstract ListIterator&lt;E&gt; listIterator()abstract E remove(int location)abstract E set(int location, E object)abstract List&lt;E&gt; subList(int start, int end) 3、Set 接口简介Set的定义如下： 1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; Set是一个继承于Collection的接口，即Set也是集合中的一种。Set是没有重复元素的集合。 关于API方面。Set的API和Collection完全一样。 12345678910111213141516// Set的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator&lt;E&gt; iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract &lt;T&gt; T[] toArray(T[] array)abstract Object[] toArray() 4、AbstractCollection 抽象类AbstractCollection的定义如下： 1public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123;&#125; AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。 5、AbstractList 抽象类AbstractList的定义如下： 1public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;&#125; AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。 6、AbstractSet 抽象类AbstractSet的定义如下： 1public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123;&#125; AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。 AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。 7、Iterator 接口Iterator的定义如下： 1public interface Iterator&lt;E&gt; &#123;&#125; Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。 注意：Iterator遍历Collection时，是fail-fast机制的。即，当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。关于fail-fast的详细内容，我们会在后面专门进行说明。TODO 1234// Iterator的APIabstract boolean hasNext()abstract E next()abstract void remove() 8、ListIterator 接口ListIterator的定义如下： 1public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;&#125; ListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于遍历List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。 123456789101112// ListIterator的API// 继承于Iterator的接口abstract boolean hasNext()abstract E next()abstract void remove()// 新增API接口abstract void add(E object)abstract boolean hasPrevious()abstract int nextIndex()abstract E previous()abstract int previousIndex()abstract void set(E object)","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java 集合系列01之 总体框架","date":"2016-11-30T16:00:00.000Z","path":"2016/12/01/java-source-analysis-set-series/Java 集合系列01之 总体框架/","text":"集合与数组都是对象的存储： 数组（基本数据类型 &amp; 引用数据类型） 集合（引用数据类型） 引用数据类型数组的元素是对象引用，初值为空，必须实例化；而基本类型数组元素都有默认初值。 数组存储数据的弊端： 一旦创建，其长度不可变。 真实的数组存放的对象的个数是不可知。 为什么集合不能存储基本数据类型？集合中存放的可都是对象的引用，实际内容都在堆上面或者方法区里面，但是基本数据类型是在栈上分配空间的。随时就被收回的。但是通过自动包装类就可以把基本类型转为对象类型，存放引用就解决了这个问题。 总体框架 看上面的框架图，先抓住它的主干，即Collection和Map。 Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。 List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。 List的实现类有LinkedList, ArrayList, Vector, Stack。 Set是一个不允许有重复元素的集合。 Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。 Hashtable虽然继承于Dictionary，但它实现了Map接口。 接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。 ListIterator是专门为遍历List而存在的。 再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 有了上面的整体框架之后，我们接下来对每个类分别进行分析。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java 集合系列","slug":"Java-集合系列","permalink":"https://smuwjs.github.io/tags/Java-集合系列/"}]},{"title":"Java多线程系列--“JUC锁”11之 Semaphore信号量的原理和示例","date":"2016-11-14T03:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”11之 Semaphore信号量的原理和示例/","text":"本章，我们对JUC包中的信号量Semaphore进行学习。 目录1. Semaphore简介2. Semaphore数据结构3. Semaphore源码分析(基于JDK1.7.0_40)4. Semaphore示例 1. Semaphore简介Semaphore是一个计数信号量，它的本质是一个”共享锁”。 信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。 Semaphore的函数列表 // 创建具有给定的许可数和非公平的公平设置的 Semaphore。 Semaphore(int permits) // 创建具有给定的许可数和给定的公平设置的 Semaphore。 Semaphore(int permits, boolean fair) // 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。 void acquire() // 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。 void acquire(int permits) // 从此信号量中获取许可，在有可用的许可前将其阻塞。 void acquireUninterruptibly() // 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。 void acquireUninterruptibly(int permits) // 返回此信号量中当前可用的许可数。 int availablePermits() // 获取并返回立即可用的所有许可。 int drainPermits() // 返回一个 collection，包含可能等待获取的线程。 protected Collection&lt;Thread&gt; getQueuedThreads() // 返回正在等待获取的线程的估计数目。 int getQueueLength() // 查询是否有线程正在等待获取。 boolean hasQueuedThreads() // 如果此信号量的公平设置为 true，则返回 true。 boolean isFair() // 根据指定的缩减量减小可用许可的数目。 protected void reducePermits(int reduction) // 释放一个许可，将其返回给信号量。 void release() // 释放给定数目的许可，将其返回到信号量。 void release(int permits) // 返回标识此信号量的字符串，以及信号量的状态。 String toString() // 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。 boolean tryAcquire() // 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。 boolean tryAcquire(int permits) // 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。 boolean tryAcquire(int permits, long timeout, TimeUnit unit) // 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。 boolean tryAcquire(long timeout, TimeUnit unit) 2. Semaphore数据结构Semaphore的UML类图如下： img 从图中可以看出：(01) 和”ReentrantLock”一样，Semaphore也包含了sync对象，sync是Sync类型；而且，Sync是一个继承于AQS的抽象类。(02) Sync包括两个子类：”公平信号量”FairSync 和 “非公平信号量”NonfairSync。sync是”FairSync的实例”，或者”NonfairSync的实例”；默认情况下，sync是NonfairSync(即，默认是非公平信号量)。 3. Semaphore源码分析(基于JDK1.7.0_40)Semaphore是通过共享锁实现的。根据共享锁的获取原则，Semaphore分为”公平信号量”和”非公平信号量”。 “公平信号量”和”非公平信号量”的区别 “公平信号量”和”非公平信号量”的释放信号量的机制是一样的！不同的是它们获取信号量的机制：线程在尝试获取信号量许可时，对于公平信号量而言，如果当前线程不在CLH队列的头部，则排队等候；而对于非公平信号量而言，无论当前线程是不是在CLH队列的头部，它都会直接获取信号量。该差异具体的体现在，它们的tryAcquireShared()函数的实现不同。 下面，我们逐步的对它们的源码进行分析。 3.1 信号量构造函数public Semaphore(int permits) { sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { sync = fair ? new FairSync(permits) : new NonfairSync(permits); } 从中，我们可以信号量分为“公平信号量(FairSync)”和“非公平信号量(NonfairSync)”。Semaphore(int permits)函数会默认创建“非公平信号量”。 3.2 公平信号量获取和释放3.2.1 公平信号量的获取Semaphore中的公平信号量是FairSync。它的获取API如下： public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); } public void acquire(int permits) throws InterruptedException { if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits); } 信号量中的acquire()获取函数，实际上是调用的AQS中的acquireSharedInterruptibly()。 acquireSharedInterruptibly()的源码如下： public final void acquireSharedInterruptibly(int arg) throws InterruptedException { // 如果线程是中断状态，则抛出异常。 if (Thread.interrupted()) throw new InterruptedException(); // 否则，尝试获取“共享锁”；获取成功则直接返回，获取失败，则通过doAcquireSharedInterruptibly()获取。 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); } Semaphore中”公平锁“对应的tryAcquireShared()实现如下： protected int tryAcquireShared(int acquires) { for (;;) { // 判断“当前线程”是不是CLH队列中的第一个线程线程， // 若是的话，则返回-1。 if (hasQueuedPredecessors()) return -1; // 设置“可以获得的信号量的许可数” int available = getState(); // 设置“获得acquires个信号量许可之后，剩余的信号量许可数” int remaining = available - acquires; // 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; } } 说明：tryAcquireShared()的作用是尝试获取acquires个信号量许可数。对于Semaphore而言，state表示的是“当前可获得的信号量许可数”。 下面看看AQS中doAcquireSharedInterruptibly()的实现： private void doAcquireSharedInterruptibly(long arg) throws InterruptedException { // 创建”当前线程“的Node节点，且Node中记录的锁是”共享锁“类型；并将该节点添加到CLH队列末尾。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { for (;;) { // 获取上一个节点。 // 如果上一节点是CLH队列的表头，则”尝试获取共享锁“。 final Node p = node.predecessor(); if (p == head) { long r = tryAcquireShared(arg); if (r &gt;= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; } } // 当前线程一直等待，直到获取到共享锁。 // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 说明：doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁(或被中断)才返回。(01) addWaiter(Node.SHARED)的作用是，创建”当前线程“的Node节点，且Node中记录的锁的类型是”共享锁“(Node.SHARED)；并将该节点添加到CLH队列末尾。关于Node和CLH在”Java多线程系列–“JUC锁”03之 公平锁(一)”已经详细介绍过，这里就不再重复说明了。(02) node.predecessor()的作用是，获取上一个节点。如果上一节点是CLH队列的表头，则”尝试获取共享锁“。(03) shouldParkAfterFailedAcquire()的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回true；否则，返回false。(04) 当shouldParkAfterFailedAcquire()返回ture时，则调用parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。doAcquireSharedInterruptibly()中的shouldParkAfterFailedAcquire(), parkAndCheckInterrupt等函数在”Java多线程系列–“JUC锁”03之 公平锁(一)”中介绍过，这里也就不再详细说明了。 3.2.2 公平信号量的释放Semaphore中公平信号量(FairSync)的释放API如下： public void release() { sync.releaseShared(1); } public void release(int permits) { if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits); } 信号量的releases()释放函数，实际上是调用的AQS中的releaseShared()。 releaseShared()在AQS中实现，源码如下： public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } 说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 Semaphore重写了tryReleaseShared()，它的源码如下： protected final boolean tryReleaseShared(int releases) { for (;;) { // 获取“可以获得的信号量的许可数” int current = getState(); // 获取“释放releases个信号量许可之后，剩余的信号量许可数” int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); // 设置“可以获得的信号量的许可数”为next。 if (compareAndSetState(current, next)) return true; } } 如果tryReleaseShared()尝试释放共享锁失败，则会调用doReleaseShared()去释放共享锁。doReleaseShared()的源码如下： private void doReleaseShared() { for (;;) { // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) { // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) { // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); } // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; } } 说明：doReleaseShared()会释放“共享锁”。它会从前往后的遍历CLH队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。 3.3 非公平信号量获取和释放Semaphore中的非公平信号量是NonFairSync。在Semaphore中，“非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。不同的是它们获取“信号量许可”的机制不同，下面是非公平信号量获取信号量许可的代码。 非公平信号量的tryAcquireShared()实现如下： protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } nonfairTryAcquireShared()的实现如下： final int nonfairTryAcquireShared(int acquires) { for (;;) { // 设置“可以获得的信号量的许可数” int available = getState(); // 设置“获得acquires个信号量许可之后，剩余的信号量许可数” int remaining = available - acquires; // 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; } } 说明：非公平信号量的tryAcquireShared()调用AQS中的nonfairTryAcquireShared()。而在nonfairTryAcquireShared()的for循环中，它都会直接判断“当前剩余的信号量许可数”是否足够；足够的话，则直接“设置可以获得的信号量许可数”，进而再获取信号量。而公平信号量的tryAcquireShared()中，在获取信号量之前会通过if (hasQueuedPredecessors())来判断“当前线程是不是在CLH队列的头部”，是的话，则返回-1。 4. Semaphore示例import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; public class SemaphoreTest1 { private static final int SEM_MAX = 10; public static void main(String[] args) { Semaphore sem = new Semaphore(SEM_MAX); //创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); //在线程池中执行任务 threadPool.execute(new MyThread(sem, 5)); threadPool.execute(new MyThread(sem, 4)); threadPool.execute(new MyThread(sem, 7)); //关闭池 threadPool.shutdown(); } } class MyThread extends Thread { private volatile Semaphore sem; // 信号量 private int count; // 申请信号量的大小 MyThread(Semaphore sem, int count) { this.sem = sem; this.count = count; } public void run() { try { // 从信号量中获取count个许可 sem.acquire(count); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + &quot; acquire count=&quot;+count); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放给定数目的许可，将其返回到信号量。 sem.release(count); System.out.println(Thread.currentThread().getName() + &quot; release &quot; + count + &quot;&quot;); } } } (某一次)运行结果： pool-1-thread-1 acquire count=5 pool-1-thread-2 acquire count=4 pool-1-thread-1 release 5 pool-1-thread-2 release 4 pool-1-thread-3 acquire count=7 pool-1-thread-3 release 7 结果说明：信号量sem的许可总数是10个；共3个线程，分别需要获取的信号量许可数是5,4,7。前面两个线程获取到信号量的许可后，sem中剩余的可用的许可数是1；因此，最后一个线程必须等前两个线程释放了它们所持有的信号量许可之后，才能获取到7个信号量许可。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”10之 CyclicBarrier原理和示例","date":"2016-11-14T02:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”10之 CyclicBarrier原理和示例/","text":"本章介绍JUC包中的CyclicBarrier锁。 目录1. CyclicBarrier简介2. CyclicBarrier数据结构3. CyclicBarrier源码分析(基于JDK1.7.0_40)4. CyclicBarrier的使用示例 1. CyclicBarrier简介CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 注意比较CountDownLatch和CyclicBarrier：(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。(02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 CyclicBarrier函数列表 CyclicBarrier(int parties) 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。 CyclicBarrier(int parties, Runnable barrierAction) 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。 int await() 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。 int await(long timeout, TimeUnit unit) 在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。 int getNumberWaiting() 返回当前在屏障处等待的参与者数目。 int getParties() 返回要求启动此 barrier 的参与者数目。 boolean isBroken() 查询此屏障是否处于损坏状态。 void reset() 将屏障重置为其初始状态。 2. CyclicBarrier数据结构CyclicBarrier的UML类图如下： img CyclicBarrier是包含了”ReentrantLock对象lock”和”Condition对象trip”，它是通过独占锁实现的。下面通过源码去分析到底是如何实现的。 3. CyclicBarrier源码分析(基于JDK1.7.0_40)CyclicBarrier是通过ReentrantLock(独占锁)和Condition来实现的。下面，我们分析CyclicBarrier中3个核心函数: 构造函数, await()作出分析。 3.1 构造函数CyclicBarrier的构造函数共2个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第1个构造函数是调用第2个构造函数来实现的，下面第2个构造函数的源码。 public CyclicBarrier(int parties, Runnable barrierAction) { if (parties &lt;= 0) throw new IllegalArgumentException(); // parties表示“必须同时到达barrier的线程个数”。 this.parties = parties; // count表示“处在等待状态的线程个数”。 this.count = parties; // barrierCommand表示“parties个线程到达barrier时，会执行的动作”。 this.barrierCommand = barrierAction; } 3.2 等待函数CyclicBarrier.java中await()方法如下： public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen; } } 说明：await()是通过dowait()实现的。 private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; // 获取“独占锁(lock)” lock.lock(); try { // 保存“当前的generation” final Generation g = generation; // 若“当前generation已损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } // 将“count计数器”-1 int index = --count; // 如果index=0，则意味着“有parties个线程到达barrier”。 if (index == 0) { // tripped boolean ranAction = false; try { // 如果barrierCommand不为null，则执行该动作。 final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 唤醒所有等待线程，并更新generation。 nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生， // 当前线程才继续执行。 for (;;) { try { // 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。 if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { // 如果等待过程中，线程被中断，则执行下面的函数。 if (g == generation &amp;&amp; ! g.broken) { breakBarrier(); throw ie; } else { Thread.currentThread().interrupt(); } } // 如果“当前generation已经损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果“generation已经换代”，则返回index。 if (g != generation) return index; // 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (timed &amp;&amp; nanos &lt;= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { // 释放“独占锁(lock)” lock.unlock(); } } 说明：dowait()的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。(01) generation是CyclicBarrier的一个成员遍历，它的定义如下： private Generation generation = new Generation(); private static class Generation { boolean broken = false; } 在CyclicBarrier中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier中通过generation对象，记录属于哪一代。当有parties个线程到达barrier，generation就会被更新换代。 (02) 如果当前线程被中断，即Thread.interrupted()为true；则通过breakBarrier()终止CyclicBarrier。breakBarrier()的源码如下： private void breakBarrier() { generation.broken = true; count = parties; trip.signalAll(); } breakBarrier()会设置当前中断标记broken为true，意味着“将该Generation中断”；同时，设置count=parties，即重新初始化count；最后，通过signalAll()唤醒CyclicBarrier上所有的等待线程。 (03) 将“count计数器”-1，即–count；然后判断是不是“有parties个线程到达barrier”，即index是不是为0。当index=0时，如果barrierCommand不为null，则执行该barrierCommand，barrierCommand就是我们创建CyclicBarrier时，传入的Runnable对象。然后，调用nextGeneration()进行换代工作，nextGeneration()的源码如下： private void nextGeneration() { trip.signalAll(); count = parties; generation = new Generation(); } 首先，它会调用signalAll()唤醒CyclicBarrier上所有的等待线程；接着，重新初始化count；最后，更新generation的值。 (04) 在for(;;)循环中。timed是用来表示当前是不是“超时等待”线程。如果不是，则通过trip.await()进行等待；否则，调用awaitNanos()进行超时等待。 4. CyclicBarrier的使用示例示例1新建5个线程，这5个线程达到一定的条件时，它们才继续往后运行。 import java.util.concurrent.CyclicBarrier; import java.util.concurrent.BrokenBarrierException; public class CyclicBarrierTest1 { private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) { cb = new CyclicBarrier(SIZE); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); } static class InnerThread extends Thread{ public void run() { try { System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;); } catch (BrokenBarrierException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } } } 运行结果： Thread-1 wait for CyclicBarrier. Thread-2 wait for CyclicBarrier. Thread-3 wait for CyclicBarrier. Thread-4 wait for CyclicBarrier. Thread-0 wait for CyclicBarrier. Thread-0 continued. Thread-4 continued. Thread-2 continued. Thread-3 continued. Thread-1 continued. 结果说明：主线程中新建了5个线程，所有的这些线程都调用cb.await()等待。所有这些线程一直等待，直到cb中所有线程都达到barrier时，这些线程才继续运行！ 示例2新建5个线程，当这5个线程达到一定的条件时，执行某项任务。 import java.util.concurrent.CyclicBarrier; import java.util.concurrent.BrokenBarrierException; public class CyclicBarrierTest2 { private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) { cb = new CyclicBarrier(SIZE, new Runnable () { public void run() { System.out.println(&quot;CyclicBarrier&apos;s parties is: &quot;+ cb.getParties()); } }); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); } static class InnerThread extends Thread{ public void run() { try { System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;); } catch (BrokenBarrierException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } } } 运行结果： Thread-1 wait for CyclicBarrier. Thread-2 wait for CyclicBarrier. Thread-3 wait for CyclicBarrier. Thread-4 wait for CyclicBarrier. Thread-0 wait for CyclicBarrier. CyclicBarrier&apos;s parties is: 5 Thread-0 continued. Thread-4 continued. Thread-2 continued. Thread-3 continued. Thread-1 continued. 结果说明：主线程中新建了5个线程，所有的这些线程都调用cb.await()等待。所有这些线程一直等待，直到cb中所有线程都达到barrier时，执行新建cb时注册的Runnable任务。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”09之 CountDownLatch原理和示例","date":"2016-11-14T01:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”09之 CountDownLatch原理和示例/","text":"前面对”独占锁”和”共享锁”有了个大致的了解；本章，我们对CountDownLatch进行学习。和ReadWriteLock.ReadLock一样，CountDownLatch的本质也是一个”共享锁”。 目录1. CountDownLatch简介2. CountDownLatch数据结构3. CountDownLatch源码分析(基于JDK1.7.0_40)4. CountDownLatch的使用示例 1. CountDownLatch简介CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch和CyclicBarrier的区别(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。(02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。关于CyclicBarrier的原理，后面一章再来学习。 CountDownLatch函数列表 CountDownLatch(int count) 构造一个用给定计数初始化的 CountDownLatch。 // 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。 void await() // 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。 boolean await(long timeout, TimeUnit unit) // 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。 void countDown() // 返回当前计数。 long getCount() // 返回标识此锁存器及其状态的字符串。 String toString() 2. CountDownLatch数据结构CountDownLatch的UML类图如下： img CountDownLatch的数据结构很简单，它是通过”共享锁”实现的。它包含了sync对象，sync是Sync类型。Sync是实例类，它继承于AQS。 3. CountDownLatch源码分析(基于JDK1.7.0_40)CountDownLatch是通过“共享锁”实现的。下面，我们分析CountDownLatch中3个核心函数: CountDownLatch(int count), await(), countDown()。 3.1 CountDownLatch(int count)public CountDownLatch(int count) { if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;); this.sync = new Sync(count); } 说明：该函数是创建一个Sync对象，而Sync是继承于AQS类。Sync构造函数如下： Sync(int count) { setState(count); } setState()在AQS中实现，源码如下： protected final void setState(long newState) { state = newState; } 说明：在AQS中，state是一个private volatile long类型的对象。对于CountDownLatch而言，state表示的”锁计数器“。CountDownLatch中的getCount()最终是调用AQS中的getState()，返回的state对象，即”锁计数器“。 3.2 await()public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } 说明：该函数实际上是调用的AQS的acquireSharedInterruptibly(1); AQS中的acquireSharedInterruptibly()的源码如下： public final void acquireSharedInterruptibly(long arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg); } 说明：acquireSharedInterruptibly()的作用是获取共享锁。如果当前线程是中断状态，则抛出异常InterruptedException。否则，调用tryAcquireShared(arg)尝试获取共享锁；尝试成功则返回，否则就调用doAcquireSharedInterruptibly()。doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁(或被中断)才返回。 tryAcquireShared()在CountDownLatch.java中被重写，它的源码如下： protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } 说明：tryAcquireShared()的作用是尝试获取共享锁。如果”锁计数器=0”，即锁是可获取状态，则返回1；否则，锁是不可获取状态，则返回-1。 private void doAcquireSharedInterruptibly(long arg) throws InterruptedException { // 创建&quot;当前线程&quot;的Node节点，且Node中记录的锁是&quot;共享锁&quot;类型；并将该节点添加到CLH队列末尾。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { for (;;) { // 获取上一个节点。 // 如果上一节点是CLH队列的表头，则&quot;尝试获取共享锁&quot;。 final Node p = node.predecessor(); if (p == head) { long r = tryAcquireShared(arg); if (r &gt;= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; } } // (上一节点不是CLH队列的表头) 当前线程一直等待，直到获取到共享锁。 // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 说明：(01) addWaiter(Node.SHARED)的作用是，创建”当前线程“的Node节点，且Node中记录的锁的类型是”共享锁“(Node.SHARED)；并将该节点添加到CLH队列末尾。关于Node和CLH在”Java多线程系列–“JUC锁”03之 公平锁(一)”已经详细介绍过，这里就不再重复说明了。(02) node.predecessor()的作用是，获取上一个节点。如果上一节点是CLH队列的表头，则”尝试获取共享锁“。(03) shouldParkAfterFailedAcquire()的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回true；否则，返回false。(04) 当shouldParkAfterFailedAcquire()返回ture时，则调用parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。doAcquireSharedInterruptibly()中的shouldParkAfterFailedAcquire(), parkAndCheckInterrupt等函数在”Java多线程系列–“JUC锁”03之 公平锁(一)”中介绍过，这里也就不再详细说明了。 3.3 countDown()public void countDown() { sync.releaseShared(1); } 说明：该函数实际上调用releaseShared(1)释放共享锁。 releaseShared()在AQS中实现，源码如下： public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } 说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 tryReleaseShared()在CountDownLatch.java中被重写，源码如下： protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { // 获取“锁计数器”的状态 int c = getState(); if (c == 0) return false; // “锁计数器”-1 int nextc = c-1; // 通过CAS函数进行赋值。 if (compareAndSetState(c, nextc)) return nextc == 0; } } 说明：tryReleaseShared()的作用是释放共享锁，将“锁计数器”的值-1。 总结：CountDownLatch是通过“共享锁”实现的。在创建CountDownLatch中时，会传递一个int类型参数count，该参数是“锁计数器”的初始状态，表示该“共享锁”最多能被count给线程同时获取。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取“共享锁”进而继续运行。而“共享锁”可用的条件，就是“锁计数器”的值为0！而“锁计数器”的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，才将“锁计数器”-1；通过这种方式，必须有count个线程调用countDown()之后，“锁计数器”才为0，而前面提到的等待线程才能继续运行！ 以上，就是CountDownLatch的实现原理。 4. CountDownLatch的使用示例下面通过CountDownLatch实现：”主线程”等待”5个子线程”全部都完成”指定的工作(休眠1000ms)”之后，再继续运行。 import java.util.concurrent.CountDownLatch; import java.util.concurrent.CyclicBarrier; public class CountDownLatchTest1 { private static int LATCH_SIZE = 5; private static CountDownLatch doneSignal; public static void main(String[] args) { try { doneSignal = new CountDownLatch(LATCH_SIZE); // 新建5个任务 for(int i=0; i&lt;LATCH_SIZE; i++) new InnerThread().start(); System.out.println(&quot;main await begin.&quot;); // &quot;主线程&quot;等待线程池中5个任务的完成 doneSignal.await(); System.out.println(&quot;main await finished.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } static class InnerThread extends Thread{ public void run() { try { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + &quot; sleep 1000ms.&quot;); // 将CountDownLatch的数值减1 doneSignal.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } } } 运行结果： main await begin. Thread-0 sleep 1000ms. Thread-2 sleep 1000ms. Thread-1 sleep 1000ms. Thread-4 sleep 1000ms. Thread-3 sleep 1000ms. main await finished. 结果说明：主线程通过doneSignal.await()等待其它线程将doneSignal递减至0。其它的5个InnerThread线程，每一个都通过doneSignal.countDown()将doneSignal的值减1；当doneSignal为0时，main被唤醒后继续执行。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”08之 共享锁和ReentrantReadWriteLock","date":"2016-11-14T00:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”08之 共享锁和ReentrantReadWriteLock/","text":"Java的JUC(java.util.concurrent)包中的锁包括”独占锁”和”共享锁”。在“Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock ”中，对Java的独占锁进行了说明。本章对Java的“共享锁”进行介绍，JUC中的共享锁有CountDownLatch, CyclicBarrier, Semaphore, ReentrantReadWriteLock等；本章会以ReentrantReadWriteLock为蓝本对共享锁进行说明。 目录1. ReadWriteLock 和 ReentrantReadWriteLock介绍2. 参考代码(基于JDK1.7.0_40)3. 获取共享锁4. 释放共享锁5. 公平共享锁和非公平共享锁6. ReentrantReadWriteLock示例 1. ReadWriteLock 和 ReentrantReadWriteLock介绍ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁”和“写入锁”，一个用于读取操作，另一个用于写入操作。&nbsp;&nbsp;&nbsp;&nbsp; “读取锁”用于只读操作，它是“共享锁”，能同时被多个线程获取。&nbsp;&nbsp;&nbsp;&nbsp; “写入锁”用于写入操作，它是“独占锁”，写入锁只能被一个线程锁获取。注意：不能同时存在读取锁和写入锁！ ReadWriteLock是一个接口。ReentrantReadWriteLock是它的实现类，ReentrantReadWriteLock包括子类ReadLock和WriteLock。 ReadWriteLock函数列表 // 返回用于读取操作的锁。 Lock readLock() // 返回用于写入操作的锁。 Lock writeLock() ReentrantReadWriteLock函数列表 // 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。 ReentrantReadWriteLock() // 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。 ReentrantReadWriteLock(boolean fair) // 返回当前拥有写入锁的线程，如果没有这样的线程，则返回 null。 protected Thread getOwner() // 返回一个 collection，它包含可能正在等待获取读取锁的线程。 protected Collection&lt;Thread&gt; getQueuedReaderThreads() // 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。 protected Collection&lt;Thread&gt; getQueuedThreads() // 返回一个 collection，它包含可能正在等待获取写入锁的线程。 protected Collection&lt;Thread&gt; getQueuedWriterThreads() // 返回等待获取读取或写入锁的线程估计数目。 int getQueueLength() // 查询当前线程在此锁上保持的重入读取锁数量。 int getReadHoldCount() // 查询为此锁保持的读取锁数量。 int getReadLockCount() // 返回一个 collection，它包含可能正在等待与写入锁相关的给定条件的那些线程。 protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition) // 返回正等待与写入锁相关的给定条件的线程估计数目。 int getWaitQueueLength(Condition condition) // 查询当前线程在此锁上保持的重入写入锁数量。 int getWriteHoldCount() // 查询是否给定线程正在等待获取读取或写入锁。 boolean hasQueuedThread(Thread thread) // 查询是否所有的线程正在等待获取读取或写入锁。 boolean hasQueuedThreads() // 查询是否有些线程正在等待与写入锁有关的给定条件。 boolean hasWaiters(Condition condition) // 如果此锁将公平性设置为 ture，则返回 true。 boolean isFair() // 查询是否某个线程保持了写入锁。 boolean isWriteLocked() // 查询当前线程是否保持了写入锁。 boolean isWriteLockedByCurrentThread() // 返回用于读取操作的锁。 ReentrantReadWriteLock.ReadLock readLock() // 返回用于写入操作的锁。 ReentrantReadWriteLock.WriteLock writeLock() ReentrantReadWriteLock数据结构 ReentrantReadWriteLock的UML类图如下： img 从中可以看出：(01) ReentrantReadWriteLock实现了ReadWriteLock接口。ReadWriteLock是一个读写锁的接口，提供了”获取读锁的readLock()函数” 和 “获取写锁的writeLock()函数”。(02) ReentrantReadWriteLock中包含：sync对象，读锁readerLock和写锁writerLock。读锁ReadLock和写锁WriteLock都实现了Lock接口。读锁ReadLock和写锁WriteLock中也都分别包含了”Sync对象”，它们的Sync对象和ReentrantReadWriteLock的Sync对象 是一样的，就是通过sync，读锁和写锁实现了对同一个对象的访问。(03) 和”ReentrantLock”一样，sync是Sync类型；而且，Sync也是一个继承于AQS的抽象类。Sync也包括”公平锁”FairSync和”非公平锁”NonfairSync。sync对象是”FairSync”和”NonfairSync”中的一个，默认是”NonfairSync”。 2. 参考代码(基于JDK1.7.0_40)共享锁源码相关的代码如下： public static class ReadLock implements Lock, java.io.Serializable { private static final long serialVersionUID = -5992448646407690164L; // ReentrantReadWriteLock的AQS对象 private final Sync sync; protected ReadLock(ReentrantReadWriteLock lock) { sync = lock.sync; } // 获取“共享锁” public void lock() { sync.acquireShared(1); } // 如果线程是中断状态，则抛出一场，否则尝试获取共享锁。 public void lockInterruptibly() throws InterruptedException { sync.acquireSharedInterruptibly(1); } // 尝试获取“共享锁” public boolean tryLock() { return sync.tryReadLock(); } // 在指定时间内，尝试获取“共享锁” public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } // 释放“共享锁” public void unlock() { sync.releaseShared(1); } // 新建条件 public Condition newCondition() { throw new UnsupportedOperationException(); } public String toString() { int r = sync.getReadLockCount(); return super.toString() + &quot;[Read locks = &quot; + r + &quot;]&quot;; } } 说明：ReadLock中的sync是一个Sync对象，Sync继承于AQS类，即Sync就是一个锁。ReentrantReadWriteLock中也有一个Sync对象，而且ReadLock中的sync和ReentrantReadWriteLock中的sync是对应关系。即ReentrantReadWriteLock和ReadLock共享同一个AQS对象，共享同一把锁。 ReentrantReadWriteLock中Sync的定义如下： final Sync sync; 下面，分别从“获取共享锁”和“释放共享锁”两个方面对共享锁进行说明。 3. 获取共享锁获取共享锁的思想(即lock函数的步骤)，是先通过tryAcquireShared()尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过tryAcquireShared()来进行尝试的。下面看看“获取共享锁”的详细流程。 3.1 lock()lock()在ReadLock中，源码如下： public void lock() { sync.acquireShared(1); } 3.2 acquireShared()Sync继承于AQS，acquireShared()定义在AQS中。源码如下： public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); } 说明：acquireShared()首先会通过tryAcquireShared()来尝试获取锁。尝试成功的话，则不再做任何动作(因为已经成功获取到锁了)。尝试失败的话，则通过doAcquireShared()来获取锁。doAcquireShared()会获取到锁了才返回。 3.3 tryAcquireShared()tryAcquireShared()定义在ReentrantReadWriteLock.java的Sync中，源码如下： protected final int tryAcquireShared(int unused) { Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取“读取锁”的共享计数 int r = sharedCount(c); // 如果“不需要阻塞等待”，并且“读取锁”的共享计数小于MAX_COUNT； // 则通过CAS函数更新“锁的状态”，将“读取锁”的共享计数+1。 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) { // 第1次获取“读取锁”。 if (r == 0) { firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 } else if (firstReader == current) { firstReaderHoldCount++; } else { // HoldCounter是用来统计该线程获取“读取锁”的次数。 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 将该线程获取“读取锁”的次数+1。 rh.count++; } return 1; } return fullTryAcquireShared(current); } 说明：tryAcquireShared()的作用是尝试获取“共享锁”。如果在尝试获取锁时，“不需要阻塞等待”并且“读取锁的共享计数小于MAX_COUNT”，则直接通过CAS函数更新“读取锁的共享计数”，以及将“当前线程获取读取锁的次数+1”。否则，通过fullTryAcquireShared()获取读取锁。 3.4 fullTryAcquireShared()fullTryAcquireShared()在ReentrantReadWriteLock中定义，源码如下： final int fullTryAcquireShared(Thread current) { HoldCounter rh = null; for (;;) { // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0) { if (getExclusiveOwnerThread() != current) return -1; // 如果“需要阻塞等待”。 // (01) 当“需要阻塞等待”的线程是第1个获取锁的线程的话，则继续往下执行。 // (02) 当“需要阻塞等待”的线程获取锁的次数=0时，则返回-1。 } else if (readerShouldBlock()) { // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 if (firstReader == current) { } else { if (rh == null) { rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) { rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); } } // 如果当前线程获取锁的计数=0,则返回-1。 if (rh.count == 0) return -1; } } // 如果“不需要阻塞等待”，则获取“读取锁”的共享统计数； // 如果共享统计数超过MAX_COUNT，则抛出异常。 if (sharedCount(c) == MAX_COUNT) throw new Error(&quot;Maximum lock count exceeded&quot;); // 将线程获取“读取锁”的次数+1。 if (compareAndSetState(c, c + SHARED_UNIT)) { // 如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount。 if (sharedCount(c) == 0) { firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程， // 则将firstReaderHoldCount+1。 } else if (firstReader == current) { firstReaderHoldCount++; } else { if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 更新线程的获取“读取锁”的共享计数 rh.count++; cachedHoldCounter = rh; // cache for release } return 1; } } } 说明：fullTryAcquireShared()会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回1。 3.5 doAcquireShared()doAcquireShared()定义在AQS函数中，源码如下： private void doAcquireShared(int arg) { // addWaiter(Node.SHARED)的作用是，创建“当前线程”对应的节点，并将该线程添加到CLH队列中。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { // 获取“node”的前一节点 final Node p = node.predecessor(); // 如果“当前线程”是CLH队列的表头，则尝试获取共享锁。 if (p == head) { int r = tryAcquireShared(arg); if (r &gt;= 0) { setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } // 如果“当前线程”不是CLH队列的表头，则通过shouldParkAfterFailedAcquire()判断是否需要等待， // 需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。若阻塞等待过程中，线程被中断过，则设置interrupted为true。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 说明：doAcquireShared()的作用是获取共享锁。它会首先创建线程对应的CLH队列的节点，然后将该节点添加到CLH队列中。CLH队列是管理获取锁的等待线程的队列。如果“当前线程”是CLH队列的表头，则尝试获取共享锁；否则，则需要通过shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。doAcquireShared()会通过for循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared()在每一次尝试获取锁时，是通过tryAcquireShared()来执行的！ shouldParkAfterFailedAcquire(), parkAndCheckInterrupt()等函数已经在“Java多线程系列–“JUC锁”03之 公平锁(一) ”中详细介绍过，这里就不再重复说明了。 4. 释放共享锁释放共享锁的思想，是先通过tryReleaseShared()尝试释放共享锁。尝试成功的话，则通过doReleaseShared()唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回flase。 4.1 unlock()public void unlock() { sync.releaseShared(1); } 说明：该函数实际上调用releaseShared(1)释放共享锁。 4.2 releaseShared()releaseShared()在AQS中实现，源码如下： public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } 说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 4.3 tryReleaseShared()tryReleaseShared()定义在ReentrantReadWriteLock中，源码如下： protected final boolean tryReleaseShared(int unused) { // 获取当前线程，即释放共享锁的线程。 Thread current = Thread.currentThread(); // 如果想要释放锁的线程(current)是第1个获取锁(firstReader)的线程， // 并且“第1个获取锁的线程获取锁的次数”=1，则设置firstReader为null； // 否则，将“第1个获取锁的线程的获取次数”-1。 if (firstReader == current) { // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; // 获取rh对象，并更新“当前线程获取锁的信息”。 } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) { readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); } --rh.count; } for (;;) { // 获取锁的状态 int c = getState(); // 将锁的获取次数-1。 int nextc = c - SHARED_UNIT; // 通过CAS更新锁的状态。 if (compareAndSetState(c, nextc)) return nextc == 0; } } 说明：tryReleaseShared()的作用是尝试释放共享锁。 4.4 doReleaseShared()doReleaseShared()定义在AQS中，源码如下： private void doReleaseShared() { for (;;) { // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) { // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) { // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); } // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; } } 说明：doReleaseShared()会释放“共享锁”。它会从前往后的遍历CLH队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。 5. 公平共享锁和非公平共享锁和互斥锁ReentrantLock一样，ReadLock也分为公平锁和非公平锁。 公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数readerShouldBlock()是不同的。公平锁的readerShouldBlock()的源码如下： final boolean readerShouldBlock() { return hasQueuedPredecessors(); } 在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。非公平锁的readerShouldBlock()的源码如下： final boolean readerShouldBlock() { return apparentlyFirstQueuedIsExclusive(); } 在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为null，则返回true。 6. ReentrantReadWriteLock示例import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest1 { public static void main(String[] args) { // 创建账户 MyCount myCount = new MyCount(&quot;4238920615242830&quot;, 10000); // 创建用户，并指定账户 User user = new User(&quot;Tommy&quot;, myCount); // 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程 for (int i=0; i&lt;3; i++) { user.getCash(); user.setCash((i+1)*1000); } } } class User { private String name; //用户名 private MyCount myCount; //所要操作的账户 private ReadWriteLock myLock; //执行操作所需的锁对象 User(String name, MyCount myCount) { this.name = name; this.myCount = myCount; this.myLock = new ReentrantReadWriteLock(); } public void getCash() { new Thread() { public void run() { myLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() +&quot; getCash start&quot;); myCount.getCash(); Thread.sleep(1); System.out.println(Thread.currentThread().getName() +&quot; getCash end&quot;); } catch (InterruptedException e) { } finally { myLock.readLock().unlock(); } } }.start(); } public void setCash(final int cash) { new Thread() { public void run() { myLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() +&quot; setCash start&quot;); myCount.setCash(cash); Thread.sleep(1); System.out.println(Thread.currentThread().getName() +&quot; setCash end&quot;); } catch (InterruptedException e) { } finally { myLock.writeLock().unlock(); } } }.start(); } } class MyCount { private String id; //账号 private int cash; //账户余额 MyCount(String id, int cash) { this.id = id; this.cash = cash; } public String getId() { return id; } public void setId(String id) { this.id = id; } public int getCash() { System.out.println(Thread.currentThread().getName() +&quot; getCash cash=&quot;+ cash); return cash; } public void setCash(int cash) { System.out.println(Thread.currentThread().getName() +&quot; setCash cash=&quot;+ cash); this.cash = cash; } } 运行结果： Thread-0 getCash start Thread-2 getCash start Thread-0 getCash cash=10000 Thread-2 getCash cash=10000 Thread-0 getCash end Thread-2 getCash end Thread-1 setCash start Thread-1 setCash cash=1000 Thread-1 setCash end Thread-3 setCash start Thread-3 setCash cash=2000 Thread-3 setCash end Thread-4 getCash start Thread-4 getCash cash=2000 Thread-4 getCash end Thread-5 setCash start Thread-5 setCash cash=3000 Thread-5 setCash end 结果说明：(01) 观察Thread0和Thread-2的运行结果，我们发现，Thread-0启动并获取到“读取锁”，在它还没运行完毕的时候，Thread-2也启动了并且也成功获取到“读取锁”。&nbsp;&nbsp;&nbsp;&nbsp; 因此，“读取锁”支持被多个线程同时获取。(02) 观察Thread-1,Thread-3,Thread-5这三个“写入锁”的线程。只要“写入锁”被某线程获取，则该线程运行完毕了，才释放该锁。&nbsp;&nbsp;&nbsp;&nbsp; 因此，“写入锁”不支持被多个线程同时获取。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”07之 LockSupport","date":"2016-11-13T23:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”07之 LockSupport/","text":"本章介绍JUC(java.util.concurrent)包中的LockSupport。 目录1. LockSupport介绍2. LockSupport示例 1. LockSupport介绍LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。 LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 因为park() 和 unpark()有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。 LockSupport函数列表 // 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。 static Object getBlocker(Thread t) // 为了线程调度，禁用当前线程，除非许可可用。 static void park() // 为了线程调度，在许可可用之前禁用当前线程。 static void park(Object blocker) // 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。 static void parkNanos(long nanos) // 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。 static void parkNanos(Object blocker, long nanos) // 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。 static void parkUntil(long deadline) // 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。 static void parkUntil(Object blocker, long deadline) // 如果给定线程的许可尚不可用，则使其可用。 static void unpark(Thread thread) 2. LockSupport示例对比下面的“示例1”和“示例2”可以更清晰的了解LockSupport的用法。 示例1public class WaitTest1 { public static void main(String[] args) { ThreadA ta = new ThreadA(&quot;ta&quot;); synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁” try { System.out.println(Thread.currentThread().getName()+&quot; start ta&quot;); ta.start(); System.out.println(Thread.currentThread().getName()+&quot; block&quot;); // 主线程等待 ta.wait(); System.out.println(Thread.currentThread().getName()+&quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+&quot; wakup others&quot;); notify(); // 唤醒“当前对象上的等待线程” } } } } 示例2import java.util.concurrent.locks.LockSupport; public class LockSupportTest1 { private static Thread mainThread; public static void main(String[] args) { ThreadA ta = new ThreadA(&quot;ta&quot;); // 获取主线程 mainThread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+&quot; start ta&quot;); ta.start(); System.out.println(Thread.currentThread().getName()+&quot; block&quot;); // 主线程阻塞 LockSupport.park(mainThread); System.out.println(Thread.currentThread().getName()+&quot; continue&quot;); } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { System.out.println(Thread.currentThread().getName()+&quot; wakup others&quot;); // 唤醒“主线程” LockSupport.unpark(mainThread); } } } 运行结果： main start ta main block ta wakup others main continue 说明：park和wait的区别。wait让线程阻塞前，必须通过synchronized获取同步锁。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”06之 Condition条件","date":"2016-11-13T22:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”06之 Condition条件/","text":"前面对JUC包中的锁的原理进行了介绍，本章会JUC中对与锁经常配合使用的Condition进行介绍。 目录1. Condition介绍2. Condition示例 1. Condition介绍Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。不同的是，Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与”互斥锁”/“共享锁”捆绑使用的。 Condition函数列表 // 造成当前线程在接到信号或被中断之前一直处于等待状态。 void await() // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。 boolean await(long time, TimeUnit unit) // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。 long awaitNanos(long nanosTimeout) // 造成当前线程在接到信号之前一直处于等待状态。 void awaitUninterruptibly() // 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。 boolean awaitUntil(Date deadline) // 唤醒一个等待线程。 void signal() // 唤醒所有等待线程。 void signalAll() 2. Condition示例示例1是通过Object的wait(), notify()来演示线程的休眠/唤醒功能。示例2是通过Condition的await(), signal()来演示线程的休眠/唤醒功能。示例3是通过Condition的高级功能。 示例1public class WaitTest1 { public static void main(String[] args) { ThreadA ta = new ThreadA(&quot;ta&quot;); synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁” try { System.out.println(Thread.currentThread().getName()+&quot; start ta&quot;); ta.start(); System.out.println(Thread.currentThread().getName()+&quot; block&quot;); ta.wait(); // 等待 System.out.println(Thread.currentThread().getName()+&quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+&quot; wakup others&quot;); notify(); // 唤醒“当前对象上的等待线程” } } } } 示例2import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class ConditionTest1 { private static Lock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static void main(String[] args) { ThreadA ta = new ThreadA(&quot;ta&quot;); lock.lock(); // 获取锁 try { System.out.println(Thread.currentThread().getName()+&quot; start ta&quot;); ta.start(); System.out.println(Thread.currentThread().getName()+&quot; block&quot;); condition.await(); // 等待 System.out.println(Thread.currentThread().getName()+&quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); // 释放锁 } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { lock.lock(); // 获取锁 try { System.out.println(Thread.currentThread().getName()+&quot; wakup others&quot;); condition.signal(); // 唤醒“condition所在锁上的其它线程” } finally { lock.unlock(); // 释放锁 } } } } 运行结果： main start ta main block ta wakup others main continue 通过“示例1”和“示例2”，我们知道Condition和Object的方法有一下对应关系： Object Condition 休眠 wait await 唤醒个线程 notify signal 唤醒所有线程 notifyAll signalAll Condition除了支持上面的功能之外，它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。 例如，假如多线程读/写同一个缓冲区：当向缓冲区中写入数据之后，唤醒”读线程”；当从缓冲区读出数据之后，唤醒”写线程”；并且当缓冲区满的时候，”写线程”需要等待；当缓冲区为空时，”读线程”需要等待。 如果采用Object类中的wait(), notify(), notifyAll()实现该缓冲区，当向缓冲区写入数据之后需要唤醒”读线程”时，不可能通过notify()或notifyAll()明确的指定唤醒”读线程”，而只能通过notifyAll唤醒所有线程(但是notifyAll无法区分唤醒的线程是读线程，还是写线程)。 但是，通过Condition，就能明确的指定唤醒读线程。 看看下面的示例3，可能对这个概念有更深刻的理解。 示例3import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[5]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); //获取锁 try { // 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。 while (count == items.length) notFull.await(); // 将x添加到缓冲中 items[putptr] = x; // 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。 if (++putptr == items.length) putptr = 0; // 将“缓冲”数量+1 ++count; // 唤醒take线程，因为take线程通过notEmpty.await()等待 notEmpty.signal(); // 打印写入的数据 System.out.println(Thread.currentThread().getName() + &quot; put &quot;+ (Integer)x); } finally { lock.unlock(); // 释放锁 } } public Object take() throws InterruptedException { lock.lock(); //获取锁 try { // 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。 while (count == 0) notEmpty.await(); // 将x从缓冲中取出 Object x = items[takeptr]; // 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。 if (++takeptr == items.length) takeptr = 0; // 将“缓冲”数量-1 --count; // 唤醒put线程，因为put线程通过notFull.await()等待 notFull.signal(); // 打印取出的数据 System.out.println(Thread.currentThread().getName() + &quot; take &quot;+ (Integer)x); return x; } finally { lock.unlock(); // 释放锁 } } } public class ConditionTest2 { private static BoundedBuffer bb = new BoundedBuffer(); public static void main(String[] args) { // 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)； // 启动10个“读线程”，从BoundedBuffer中不断的读数据。 for (int i=0; i&lt;10; i++) { new PutThread(&quot;p&quot;+i, i).start(); new TakeThread(&quot;t&quot;+i).start(); } } static class PutThread extends Thread { private int num; public PutThread(String name, int num) { super(name); this.num = num; } public void run() { try { Thread.sleep(1); // 线程休眠1ms bb.put(num); // 向BoundedBuffer中写入数据 } catch (InterruptedException e) { } } } static class TakeThread extends Thread { public TakeThread(String name) { super(name); } public void run() { try { Thread.sleep(10); // 线程休眠1ms Integer num = (Integer)bb.take(); // 从BoundedBuffer中取出数据 } catch (InterruptedException e) { } } } } (某一次)运行结果： p1 put 1 p4 put 4 p5 put 5 p0 put 0 p2 put 2 t0 take 1 p3 put 3 t1 take 4 p6 put 6 t2 take 5 p7 put 7 t3 take 0 p8 put 8 t4 take 2 p9 put 9 t5 take 3 t6 take 6 t7 take 7 t8 take 8 t9 take 9 结果说明：(01) BoundedBuffer 是容量为5的缓冲，缓冲中存储的是Object对象，支持多线程的读/写缓冲。多个线程操作“一个BoundedBuffer对象”时，它们通过互斥锁lock对缓冲区items进行互斥访问；而且同一个BoundedBuffer对象下的全部线程共用“notFull”和“notEmpty”这两个Condition。&nbsp;&nbsp;&nbsp;&nbsp; notFull用于控制写缓冲，notEmpty用于控制读缓冲。当缓冲已满的时候，调用put的线程会执行notFull.await()进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量count+1，最后，调用notEmpty.signal()缓冲notEmpty上的等待线程(调用notEmpty.await的线程)。 简言之，notFull控制“缓冲区的写入”，当往缓冲区写入数据之后会唤醒notEmpty上的等待线程。&nbsp;&nbsp;&nbsp;&nbsp; 同理，notEmpty控制“缓冲区的读取”，当读取了缓冲区数据之后会唤醒notFull上的等待线程。(02) 在ConditionTest2的main函数中，启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)；同时，也启动10个“读线程”，从BoundedBuffer中不断的读数据。(03) 简单分析一下运行结果。 1, p1线程向缓冲中写入1。 此时，缓冲区数据: | 1 | | | | | 2, p4线程向缓冲中写入4。 此时，缓冲区数据: | 1 | 4 | | | | 3, p5线程向缓冲中写入5。 此时，缓冲区数据: | 1 | 4 | 5 | | | 4, p0线程向缓冲中写入0。 此时，缓冲区数据: | 1 | 4 | 5 | 0 | | 5, p2线程向缓冲中写入2。 此时，缓冲区数据: | 1 | 4 | 5 | 0 | 2 | 此时，缓冲区容量为5；缓冲区已满！如果此时，还有“写线程”想往缓冲中写入数据，会调用put中的notFull.await()等待，直接缓冲区非满状态，才能继续运行。 6, t0线程从缓冲中取出数据1。此时，缓冲区数据: | | 4 | 5 | 0 | 2 | 7, p3线程向缓冲中写入3。 此时，缓冲区数据: | 3 | 4 | 5 | 0 | 2 | 8, t1线程从缓冲中取出数据4。此时，缓冲区数据: | 3 | | 5 | 0 | 2 | 9, p6线程向缓冲中写入6。 此时，缓冲区数据: | 3 | 6 | 5 | 0 | 2 | ...","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC线程池”06之 Callable和Future","date":"2016-11-13T22:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC线程池”06之 Callable和Future/","text":"本章介绍线程池中的Callable和Future。 目录第1部分 Callable 和 Future 简介第2部分 示例和源码分析(基于JDK1.7.0_40) 第1部分 Callable 和 Future 简介Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。 1. CallableCallable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。 为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。 Callable的源码如下： public interface Callable&lt;V&gt; { V call() throws Exception; } 说明：从中我们可以看出Callable支持泛型。 2. FutureFuture 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。 Future的源码如下： public interface Future&lt;V&gt; { // 试图取消对此任务的执行。 boolean cancel(boolean mayInterruptIfRunning) // 如果在任务正常完成前将其取消，则返回 true。 boolean isCancelled() // 如果任务已完成，则返回 true。 boolean isDone() // 如有必要，等待计算完成，然后获取其结果。 V get() throws InterruptedException, ExecutionException; // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } 说明： Future用于表示异步计算的结果。它的实现类是FutureTask，在讲解FutureTask之前，我们先看看Callable, Future, FutureTask它们之间的关系图，如下： img 说明：(01) RunnableFuture是一个接口，它继承了Runnable和Future这两个接口。RunnableFuture的源码如下： public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; { void run(); } (02) FutureTask实现了RunnableFuture接口。所以，我们也说它实现了Future接口。 第2部分 示例和源码分析(基于JDK1.7.0_40)我们先通过一个示例看看Callable和Future的基本用法，然后再分析示例的实现原理。 import java.util.concurrent.Callable; import java.util.concurrent.Future; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; import java.util.concurrent.ExecutionException; class MyCallable implements Callable { @Override public Integer call() throws Exception { int sum = 0; // 执行任务 for (int i=0; i&lt;100; i++) sum += i; //return sum; return Integer.valueOf(sum); } } public class CallableTest1 { public static void main(String[] args) throws ExecutionException, InterruptedException{ //创建一个线程池 ExecutorService pool = Executors.newSingleThreadExecutor(); //创建有返回值的任务 Callable c1 = new MyCallable(); //执行任务并获取Future对象 Future f1 = pool.submit(c1); // 输出结果 System.out.println(f1.get()); //关闭线程池 pool.shutdown(); } } 运行结果： 4950 结果说明：在主线程main中，通过newSingleThreadExecutor()新建一个线程池。接着创建Callable对象c1，然后再通过pool.submit(c1)将c1提交到线程池中进行处理，并且将返回的结果保存到Future对象f1中。然后，我们通过f1.get()获取Callable中保存的结果；最后通过pool.shutdown()关闭线程池。 1. submit()submit()在java/util/concurrent/AbstractExecutorService.java中实现，它的源码如下： public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) { if (task == null) throw new NullPointerException(); // 创建一个RunnableFuture对象 RunnableFuture&lt;T&gt; ftask = newTaskFor(task); // 执行“任务ftask” execute(ftask); // 返回“ftask” return ftask; } 说明：submit()通过newTaskFor(task)创建了RunnableFuture对象ftask。它的源码如下： protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) { return new FutureTask&lt;T&gt;(callable); } 2. FutureTask的构造函数FutureTask的构造函数如下： public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); // callable是一个Callable对象 this.callable = callable; // state记录FutureTask的状态 this.state = NEW; // ensure visibility of callable } 3. FutureTask的run()方法我们继续回到submit()的源码中。 在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法；ftask的run()方法在java/util/concurrent/FutureTask.java中实现，源码如下： public void run() { if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { // 将callable对象赋值给c。 Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { V result; boolean ran; try { // 执行Callable的call()方法，并保存结果到result中。 result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } // 如果运行成功，则将result保存 if (ran) set(result); } } finally { runner = null; // 设置“state状态标记” int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } 说明：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC线程池","slug":"JUC线程池","permalink":"https://smuwjs.github.io/tags/JUC线程池/"}]},{"title":"Java多线程系列--“JUC线程池”05之 线程池原理(四)","date":"2016-11-13T21:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC线程池”05之 线程池原理(四)/","text":"本章介绍线程池的拒绝策略。 目录1. 拒绝策略介绍2. 拒绝策略对比和示例 1. 拒绝策略介绍线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。 当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。 线程池共包括4种拒绝策略，它们分别是：AbortPolicy, CallerRunsPolicy, DiscardOldestPolicy和DiscardPolicy。 策略 说明 AbortPolicy 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常 CallerRunsPolicy 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务 DiscardOldestPolicy 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中 DiscardPolicy 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务 线程池默认的处理策略是AbortPolicy！ 2. 拒绝策略对比和示例下面通过示例，分别演示线程池的4种拒绝策略。(01) DiscardPolicy 示例(02) DiscardOldestPolicy 示例(03) AbortPolicy 示例(04) CallerRunsPolicy 示例 2.1 DiscardPolicy 示例import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.DiscardPolicy; public class DiscardPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为&quot;丢弃&quot; pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) { Runnable myrun = new MyRunnable(&quot;task-&quot;+i); pool.execute(myrun); } // 关闭线程池 pool.shutdown(); } } class MyRunnable implements Runnable { private String name; public MyRunnable(String name) { this.name = name; } @Override public void run() { try { System.out.println(this.name + &quot; is running.&quot;); Thread.sleep(100); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： task-0 is running. task-1 is running. 结果说明：线程池pool的”最大池大小”和”核心池大小”都为1(THREADS_SIZE)，这意味着”线程池能同时运行的任务数量最大只能是1”。线程池pool的阻塞队列是ArrayBlockingQueue，ArrayBlockingQueue是一个有界的阻塞队列，ArrayBlockingQueue的容量为1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。根据””中分析的execute()代码可知：线程池中共运行了2个任务。第1个任务直接放到Worker中，通过线程去执行；第2个任务放到阻塞队列中等待。其他的任务都被丢弃了！ 2.2 DiscardOldestPolicy 示例import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy; public class DiscardOldestPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为&quot;DiscardOldestPolicy&quot; pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) { Runnable myrun = new MyRunnable(&quot;task-&quot;+i); pool.execute(myrun); } // 关闭线程池 pool.shutdown(); } } class MyRunnable implements Runnable { private String name; public MyRunnable(String name) { this.name = name; } @Override public void run() { try { System.out.println(this.name + &quot; is running.&quot;); Thread.sleep(200); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： task-0 is running. task-9 is running. 结果说明：将”线程池的拒绝策略”由DiscardPolicy修改为DiscardOldestPolicy之后，当有任务添加到线程池被拒绝时，线程池会丢弃阻塞队列中末尾的任务，然后将被拒绝的任务添加到末尾。 2.3 AbortPolicy 示例import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.AbortPolicy; import java.util.concurrent.RejectedExecutionException; public class AbortPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为&quot;抛出异常&quot; pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); try { // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) { Runnable myrun = new MyRunnable(&quot;task-&quot;+i); pool.execute(myrun); } } catch (RejectedExecutionException e) { e.printStackTrace(); // 关闭线程池 pool.shutdown(); } } } class MyRunnable implements Runnable { private String name; public MyRunnable(String name) { this.name = name; } @Override public void run() { try { System.out.println(this.name + &quot; is running.&quot;); Thread.sleep(200); } catch (Exception e) { e.printStackTrace(); } } } (某一次)运行结果： java.util.concurrent.RejectedExecutionException at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:1774) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:768) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:656) at AbortPolicyDemo.main(AbortPolicyDemo.java:27) task-0 is running. task-1 is running. 结果说明：将”线程池的拒绝策略”由DiscardPolicy修改为AbortPolicy之后，当有任务添加到线程池被拒绝时，会抛出RejectedExecutionException。 2.4 CallerRunsPolicy 示例import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy; public class CallerRunsPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为&quot;CallerRunsPolicy&quot; pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) { Runnable myrun = new MyRunnable(&quot;task-&quot;+i); pool.execute(myrun); } // 关闭线程池 pool.shutdown(); } } class MyRunnable implements Runnable { private String name; public MyRunnable(String name) { this.name = name; } @Override public void run() { try { System.out.println(this.name + &quot; is running.&quot;); Thread.sleep(100); } catch (Exception e) { e.printStackTrace(); } } } (某一次)运行结果： task-2 is running. task-3 is running. task-4 is running. task-5 is running. task-6 is running. task-7 is running. task-8 is running. task-9 is running. task-0 is running. task-1 is running. 结果说明：将”线程池的拒绝策略”由DiscardPolicy修改为CallerRunsPolicy之后，当有任务添加到线程池被拒绝时，线程池会将被拒绝的任务添加到”线程池正在运行的线程”中取运行。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC线程池","slug":"JUC线程池","permalink":"https://smuwjs.github.io/tags/JUC线程池/"}]},{"title":"Java多线程系列--“JUC锁”05之 非公平锁","date":"2016-11-13T21:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”05之 非公平锁/","text":"前面两章分析了”公平锁的获取和释放机制”，这一章开始对“非公平锁”的获取锁/释放锁的过程进行分析。关于锁的数据结构请参考”Java多线程系列–“JUC锁”03之 公平锁(一) “，锁的使用示例请参考“Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock”。 目录第1部分 获取非公平锁(基于JDK1.7.0_40)第2部分 释放非公平锁(基于JDK1.7.0_40) 第1部分 获取非公平锁(基于JDK1.7.0_40)非公平锁和公平锁在获取锁的方法上，流程是一样的；它们的区别主要表现在“尝试获取锁的机制不同”。简单点说，“公平锁”在每次尝试获取锁时，都是采用公平策略(根据等待队列依次排序等待)；而“非公平锁”在每次尝试获取锁时，都是采用的非公平策略(无视等待队列，直接尝试获取锁，如果锁是空闲的，即可获取状态，则获取锁)。 在前面的“Java多线程系列–“JUC锁”03之 公平锁(一)”中，已经详细介绍了获取公平锁的流程和机制；下面，通过代码分析以下获取非公平锁的流程。 1. lock()lock()在ReentrantLock.java的NonfairSync类中实现，它的源码如下： final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } 说明：lock()会先通过compareAndSet(0, 1)来判断“锁”是不是空闲状态。是的话，“当前线程”直接获取“锁”；否则的话，调用acquire(1)获取锁。(01) compareAndSetState()是CAS函数，它的作用是比较并设置当前锁的状态。若锁的状态值为0，则设置锁的状态值为1。(02) setExclusiveOwnerThread(Thread.currentThread())的作用是，设置“当前线程”为“锁”的持有者。 “公平锁”和“非公平锁”关于lock()的对比 公平锁 – 公平锁的lock()函数，会直接调用acquire(1)。非公平锁 – 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。 2. acquire()acquire()在AQS中实现的，它的源码如下： public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } (01) “当前线程”首先通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列依次排序，然后获取锁。(02) “当前线程”尝试失败的情况下，会先通过addWaiter(Node.EXCLUSIVE)来将“当前线程”加入到”CLH队列(非阻塞的FIFO队列)”末尾。(03) 然后，调用acquireQueued()获取锁。在acquireQueued()中，当前线程会等待它在“CLH队列”中前面的所有线程执行并释放锁之后，才能获取锁并返回。如果“当前线程”在休眠等待过程中被中断过，则调用selfInterrupt()来自己产生一个中断。 “公平锁”和“非公平锁”关于acquire()的对比 公平锁和非公平锁，只有tryAcquire()函数的实现不同；即它们尝试获取锁的机制不同。这就是我们所说的“它们获取锁策略的不同所在之处”！在“Java多线程系列–“JUC锁”03之 公平锁(一)”中，已经详细介绍了acquire()涉及到的各个函数。这里仅对它们有差异的函数tryAcquire()进行说明。 非公平锁的tryAcquire()在ReentrantLock.java的NonfairSync类中实现，源码如下： protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } nonfairTryAcquire()在ReentrantLock.java的Sync类中实现，源码如下： final boolean nonfairTryAcquire(int acquires) { // 获取“当前线程” final Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // c=0意味着“锁没有被任何线程锁拥有” if (c == 0) { // 若“锁没有被任何线程锁拥有”，则通过CAS函数设置“锁”的状态为acquires。 // 同时，设置“当前线程”为锁的持有者。 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { // 如果“锁”的持有者已经是“当前线程”， // 则将更新锁的状态。 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; } 说明：根据代码，我们可以分析出，tryAcquire()的作用就是尝试去获取锁。(01) 如果“锁”没有被任何线程拥有，则通过CAS函数设置“锁”的状态为acquires，同时，设置“当前线程”为锁的持有者，然后返回true。(02) 如果“锁”的持有者已经是当前线程，则将更新锁的状态即可。(03) 如果不术语上面的两种情况，则认为尝试失败。 “公平锁”和“非公平锁”关于tryAcquire()的对比 公平锁和非公平锁，它们尝试获取锁的方式不同。公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。 第2部分 释放非公平锁(基于JDK1.7.0_40)非公平锁和公平锁在释放锁的方法和策略上是一样的。 而在前面的“Java多线程系列–“JUC锁”04之 公平锁(二) ”中，已经对“释放公平锁”进行了介绍；这里就不再重复的进行说明。 总结 公平锁和非公平锁的区别，是在获取锁的机制上的区别。表现在，在尝试获取锁时 —— 公平锁，只有在当前线程是CLH等待队列的表头时，才获取锁；而非公平锁，只要当前锁处于空闲状态，则直接获取锁，而不管CLH等待队列中的顺序。只有当非公平锁尝试获取锁失败的时候，它才会像公平锁一样，进入CLH等待队列排序等待。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”04之 公平锁(二)","date":"2016-11-13T20:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”04之 公平锁(二)/","text":"前面一章，我们学习了“公平锁”获取锁的详细流程；这里，我们再来看看“公平锁”释放锁的过程。“公平锁”的获取过程请参考“Java多线程系列–“JUC锁”03之 公平锁(一)”，锁的使用示例请参考“Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock”。 注意(01)这里是以“公平锁”来进行说明。(02)关于本章的术语，如“AQS”，“CAS函数”，“CLH队列”，“公平锁”，“非公平锁”，“独占锁”，“共享锁”等内容，请参考Java多线程系列–“JUC锁”03之 公平锁(一)的基本概念。 释放公平锁(基于JDK1.7.0_40)1. unlock()unlock()在ReentrantLock.java中实现的，源码如下： public void unlock() { sync.release(1); } 说明：unlock()是解锁函数，它是通过AQS的release()函数来实现的。在这里，“1”的含义和“获取锁的函数acquire(1)的含义”一样，它是设置“释放锁的状态”的参数。由于“公平锁”是可重入的，所以对于同一个线程，每释放锁一次，锁的状态-1。 关于AQS, ReentrantLock 和 sync的关系如下： public class ReentrantLock implements Lock, java.io.Serializable { private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer { ... } ... } 从中，我们发现：sync是ReentrantLock.java中的成员对象，而Sync是AQS的子类。 2. release()release()在AQS中实现的，源码如下： public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 说明：release()会先调用tryRelease()来尝试释放当前线程锁持有的锁。成功的话，则唤醒后继等待线程，并返回true。否则，直接返回false。 3. tryRelease()tryRelease()在ReentrantLock.java的Sync类中实现，源码如下： protected final boolean tryRelease(int releases) { // c是本次释放锁之后的状态 int c = getState() - releases; // 如果“当前线程”不是“锁的持有者”，则抛出异常！ if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 如果“锁”已经被当前线程彻底释放，则设置“锁”的持有者为null，即锁是可获取状态。 if (c == 0) { free = true; setExclusiveOwnerThread(null); } // 设置当前线程的锁的状态。 setState(c); return free; } 说明：tryRelease()的作用是尝试释放锁。(01) 如果“当前线程”不是“锁的持有者”，则抛出异常。(02) 如果“当前线程”在本次释放锁操作之后，对锁的拥有状态是0(即，当前线程彻底释放该“锁”)，则设置“锁”的持有者为null，即锁是可获取状态。同时，更新当前线程的锁的状态为0。getState(), setState()在前一章已经介绍过，这里不再说明。getExclusiveOwnerThread(), setExclusiveOwnerThread()在AQS的父类AbstractOwnableSynchronizer.java中定义，源码如下： public abstract class AbstractOwnableSynchronizer implements java.io.Serializable { // “锁”的持有线程 private transient Thread exclusiveOwnerThread; // 设置“锁的持有线程”为t protected final void setExclusiveOwnerThread(Thread t) { exclusiveOwnerThread = t; } // 获取“锁的持有线程” protected final Thread getExclusiveOwnerThread() { return exclusiveOwnerThread; } ... } 4. unparkSuccessor()在release()中“当前线程”释放锁成功的话，会唤醒当前线程的后继线程。根据CLH队列的FIFO规则，“当前线程”(即已经获取锁的线程)肯定是head；如果CLH队列非空的话，则唤醒锁的下一个等待线程。下面看看unparkSuccessor()的源码，它在AQS中实现。 private void unparkSuccessor(Node node) { // 获取当前线程的状态 int ws = node.waitStatus; // 如果状态&lt;0，则设置状态=0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //获取当前节点的“有效的后继节点”，无效的话，则通过for循环进行获取。 // 这里的有效，是指“后继节点对应的线程状态&lt;=0” Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } // 唤醒“后继节点对应的线程” if (s != null) LockSupport.unpark(s.thread); } 说明：unparkSuccessor()的作用是“唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。关于node.waitStatus的说明，请参考“上一章关于Node类的介绍”。 总结 “释放锁”的过程相对“获取锁”的过程比较简单。释放锁时，主要进行的操作，是更新当前线程对应的锁的状态。如果当前线程对锁已经彻底释放，则设置“锁”的持有线程为null，设置当前线程的状态为空，然后唤醒后继线程。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC线程池”04之 线程池原理(三)","date":"2016-11-13T20:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC线程池”04之 线程池原理(三)/","text":"本章介绍线程池的生命周期。在”Java多线程系列–“基础篇”01之 基本概念”中，我们介绍过，线程有5种状态：新建状态，就绪状态，运行状态，阻塞状态，死亡状态。线程池也有5种状态；然而，线程池不同于线程，线程池的5种状态是：Running, SHUTDOWN, STOP, TIDYING, TERMINATED。 线程池状态定义代码如下： private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3; private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; private static int ctlOf(int rs, int wc) { return rs | wc; } 说明：ctl是一个AtomicInteger类型的原子对象。ctl记录了”线程池中的任务数量”和”线程池状态”2个信息。ctl共包括32位。其中，高3位表示”线程池状态”，低29位表示”线程池中的任务数量”。 状态 说明 RUNNING 对应的高3位值是111 SHUTDOWN 对应的高3位值是000 STOP 对应的高3位值是001 TIDYING 对应的高3位值是010 TERMINATED 对应的高3位值是011 线程池各个状态之间的切换如下图所示： img 1. RUNNING(01) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态！道理很简单，在ctl的初始化代码中(如下)，就将它初始化为RUNNING状态，并且”任务数量”初始化为0。 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 2. SHUTDOWN(01) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。(02) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 3. STOP(01) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。(02) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。 4. TIDYING(01) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。(02) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。 5. TERMINATED(01) 状态说明：线程池彻底终止，就变成TERMINATED状态。(02) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC线程池","slug":"JUC线程池","permalink":"https://smuwjs.github.io/tags/JUC线程池/"}]},{"title":"Java多线程系列--“JUC线程池”03之 线程池原理(二)","date":"2016-11-13T19:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC线程池”03之 线程池原理(二)/","text":"在前面一章”Java多线程系列–“JUC线程池”02之 线程池原理(一)”中介绍了线程池的数据结构，本章会通过分析线程池的源码，对线程池进行说明。 目录1. 线程池示例2. 线程池源码分析 1. 线程池示例在分析线程池之前，先看一个简单的线程池示例。 import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; public class ThreadPoolDemo1 { public static void main(String[] args) { // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); } } class MyThread extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;); } } 运行结果： pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. 示例中，包括了线程池的创建，将任务添加到线程池中，关闭线程池这3个主要的步骤。稍后，我们会从这3个方面来分析ThreadPoolExecutor。 2. 线程池源码分析(一) 创建“线程池”下面以newFixedThreadPool()介绍线程池的创建过程。 1. newFixedThreadPool()newFixedThreadPool()在Executors.java中定义，源码如下： public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 说明：newFixedThreadPool(int nThreads)的作用是创建一个线程池，线程池的容量是nThreads。newFixedThreadPool()在调用ThreadPoolExecutor()时，会传递一个LinkedBlockingQueue()对象，而LinkedBlockingQueue是单向链表实现的阻塞队列。在线程池中，就是通过该阻塞队列来实现”当线程池中任务数量超过允许的任务数量时，部分任务会阻塞等待”。关于LinkedBlockingQueue的实现细节，读者可以参考”Java多线程系列–“JUC集合”08之 LinkedBlockingQueue”。 2. ThreadPoolExecutor()ThreadPoolExecutor()在ThreadPoolExecutor.java中定义，源码如下： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } 说明：该函数实际上是调用ThreadPoolExecutor的另外一个构造函数。该函数的源码如下： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 核心池大小 this.corePoolSize = corePoolSize; // 最大池大小 this.maximumPoolSize = maximumPoolSize; // 线程池的等待队列 this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); // 线程工厂对象 this.threadFactory = threadFactory; // 拒绝策略的句柄 this.handler = handler; } 说明：在ThreadPoolExecutor()的构造函数中，进行的是初始化工作。corePoolSize, maximumPoolSize, unit, keepAliveTime和workQueue这些变量的值是已知的，它们都是通过newFixedThreadPool()传递而来。下面看看threadFactory和handler对象。 2.1 ThreadFactory 线程池中的ThreadFactory是一个线程工厂，线程池创建线程都是通过线程工厂对象(threadFactory)来完成的。 上面所说的threadFactory对象，是通过 Executors.defaultThreadFactory()返回的。Executors.java中的defaultThreadFactory()源码如下： public static ThreadFactory defaultThreadFactory() { return new DefaultThreadFactory(); } defaultThreadFactory()返回DefaultThreadFactory对象。Executors.java中的DefaultThreadFactory()源码如下： static class DefaultThreadFactory implements ThreadFactory { private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() { SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; } // 提供创建线程的API。 public Thread newThread(Runnable r) { // 线程对应的任务是Runnable对象r Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); // 设为“非守护线程” if (t.isDaemon()) t.setDaemon(false); // 将优先级设为“Thread.NORM_PRIORITY” if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; } } 说明：ThreadFactory的作用就是提供创建线程的功能的线程工厂。它是通过newThread()提供创建线程功能的，下面简单说说newThread()。newThread()创建的线程对应的任务是Runnable对象，它创建的线程都是“非守护线程”而且“线程优先级都是Thread.NORM_PRIORITY”。 2.2 RejectedExecutionHandler handler是ThreadPoolExecutor中拒绝策略的处理句柄。所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。 线程池默认会采用的是defaultHandler策略，即AbortPolicy策略。在AbortPolicy策略中，线程池拒绝任务时会抛出异常！defaultHandler的定义如下： private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); AbortPolicy的源码如下： public static class AbortPolicy implements RejectedExecutionHandler { public AbortPolicy() { } // 抛出异常 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); } } (二) 添加任务到“线程池”1. execute()execute()定义在ThreadPoolExecutor.java中，源码如下： public void execute(Runnable command) { // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // 获取ctl对应的int值。该int值保存了&quot;线程池中任务的数量&quot;和&quot;线程池状态&quot;信息 int c = ctl.get(); // 当线程池中的任务数量 &lt; &quot;核心池大小&quot;时，即线程池中少于corePoolSize个任务。 // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // 当线程池中的任务数量 &gt;= &quot;核心池大小&quot;时， // 而且，&quot;线程池处于允许状态&quot;时，则尝试将任务添加到阻塞队列中。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；然后通过reject()执行相应的拒绝策略的内容。 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 否则，如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线程，新建线程对应的任务为null。 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command); } 说明：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：&nbsp;&nbsp;&nbsp;&nbsp; 情况1 – 如果”线程池中任务数量” &lt; “核心池大小”时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。&nbsp;&nbsp;&nbsp;&nbsp; 情况2 – 如果”线程池中任务数量” &gt;= “核心池大小”，并且”线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认”线程池的状态”，如果”第2次读到的线程池状态”和”第1次读到的线程池状态”不同，则从阻塞队列中删除该任务。&nbsp;&nbsp;&nbsp;&nbsp; 情况3 – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。 2. addWorker()addWorker()的源码如下： private boolean addWorker(Runnable firstTask, boolean core) { retry: // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。 for (;;) { // 获取ctl对应的int值。该int值保存了&quot;线程池中任务的数量&quot;和&quot;线程池状态&quot;信息 int c = ctl.get(); // 获取线程池状态。 int rs = runStateOf(c); // 有效性检查 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) { // 获取线程池中任务的数量。 int wc = workerCountOf(c); // 如果&quot;线程池中任务的数量&quot;超过限制，则返回false。 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 通过CAS函数将c的值+1。操作失败的话，则退出循环。 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl // 检查&quot;线程池状态&quot;，如果与之前的状态不同，则从retry重新开始。 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; // 添加任务到线程池，并启动任务所在的线程。 try { final ReentrantLock mainLock = this.mainLock; // 新建Worker，并且指定firstTask为Worker的第一个任务。 w = new Worker(firstTask); // 获取Worker对应的线程。 final Thread t = w.thread; if (t != null) { // 获取锁 mainLock.lock(); try { int c = ctl.get(); int rs = runStateOf(c); // 再次确认&quot;线程池状态&quot; if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将Worker对象(w)添加到&quot;线程池的Worker集合(workers)&quot;中 workers.add(w); // 更新largestPoolSize int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { // 释放锁 mainLock.unlock(); } // 如果&quot;成功将任务添加到线程池&quot;中，则启动任务所在的线程。 if (workerAdded) { t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } // 返回任务是否启动。 return workerStarted; } 说明：addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了”线程池中任务数量和线程池状态”。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。 从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。 (02) 通过启动Worker对应的Thread线程，则执行该任务。 3. submit()补充说明一点，submit()实际上也是通过调用execute()实现的，源码如下： public Future&lt;?&gt; submit(Runnable task) { if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask; } (三) 关闭“线程池”shutdown()的源码如下： public void shutdown() { final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try { // 检查终止线程池的“线程”是否有权限。 checkShutdownAccess(); // 设置线程池的状态为关闭状态。 advanceRunState(SHUTDOWN); // 中断线程池中空闲的线程。 interruptIdleWorkers(); // 钩子函数，在ThreadPoolExecutor中没有任何动作。 onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { // 释放锁 mainLock.unlock(); } // 尝试终止线程池 tryTerminate(); } 说明：shutdown()的作用是关闭线程池。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC线程池","slug":"JUC线程池","permalink":"https://smuwjs.github.io/tags/JUC线程池/"}]},{"title":"Java多线程系列--“JUC锁”03之 公平锁(一)","date":"2016-11-13T19:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”03之 公平锁(一)/","text":"本章对“公平锁”的获取锁机制进行介绍(本文的公平锁指的是互斥锁的公平锁)。“公平锁”的释放锁的机制在后面一章再做介绍，锁的使用示例请参考“Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock”。 目录第1部分 基本概念第2部分 ReentrantLock数据结构第3部分 参考代码第4部分 获取公平锁(基于JDK1.7.0_40)&nbsp;&nbsp;&nbsp;&nbsp; 第4.1部分 tryAcquire()&nbsp;&nbsp;&nbsp;&nbsp; 第4.2部分 addWaiter(Node.EXCLUSIVE)&nbsp;&nbsp;&nbsp;&nbsp; 第4.3部分 acquireQueued()&nbsp;&nbsp;&nbsp;&nbsp; 第4.4部分 selfInterrupt() 第1部分 基本概念本章，我们会讲解“线程获取公平锁”的原理；在讲解之前，需要了解几个基本概念。后面的内容，都是基于这些概念的；这些概念可能比较枯燥，但从这些概念中，能窥见“java锁”的一些架构，这对我们了解锁是有帮助的。 1. AQS – 指AbstractQueuedSynchronizer类。&nbsp;&nbsp;&nbsp;&nbsp; AQS是java中管理“锁”的抽象类，锁的许多公共方法都是在这个类中实现。AQS是独占锁(例如，ReentrantLock)和共享锁(例如，Semaphore)的公共父类。 2. AQS锁的类别 – 分为“独占锁”和“共享锁”两种。&nbsp;&nbsp;&nbsp;&nbsp; (01) 独占锁 – 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为“公平锁”和“非公平锁”。公平锁，是按照通过CLH等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视CLH等待队列而直接获取锁。独占锁的典型实例子是ReentrantLock，此外，ReentrantReadWriteLock.WriteLock也是独占锁。&nbsp;&nbsp;&nbsp;&nbsp; (02) 共享锁 – 能被多个线程同时拥有，能被共享的锁。JUC包中的ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch和Semaphore都是共享锁。这些锁的用途和原理，在以后的章节再详细介绍。 3. CLH队列 – Craig, Landin, and Hagersten lock queue&nbsp;&nbsp;&nbsp;&nbsp; CLH队列是AQS中“等待锁”的线程队列。在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。CLH就是管理这些“等待锁”的线程的队列。&nbsp;&nbsp;&nbsp;&nbsp; CLH是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，而是通过自旋锁和 CAS 保证节点插入和移除的原子性。 4. CAS函数 – Compare And Swap&nbsp;&nbsp;&nbsp;&nbsp; CAS函数，是比较并交换函数，它是原子操作函数；即，通过CAS操作的数据都是以原子方式进行的。例如，compareAndSetHead(), compareAndSetTail(), compareAndSetNext()等函数。它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。 本章是围绕“公平锁”如何获取锁而层次展开。“公平锁”涉及到的知识点比较多，但总的来说，不是特别难；如果读者能读懂AQS和ReentrantLock.java这两个类的大致意思，理解锁的原理和机制也就不成问题了。本章只是作者本人对锁的一点点理解，希望这部分知识能帮助您了解“公平锁”的获取过程，认识“锁”的框架。 第2部分 ReentrantLock数据结构ReentrantLock的UML类图 img 从图中可以看出：(01) ReentrantLock实现了Lock接口。(02) ReentrantLock与sync是组合关系。ReentrantLock中，包含了Sync对象；而且，Sync是AQS的子类；更重要的是，Sync有两个子类FairSync(公平锁)和NonFairSync(非公平锁)。ReentrantLock是一个独占锁，至于它到底是公平锁还是非公平锁，就取决于sync对象是”FairSync的实例”还是”NonFairSync的实例”。 第3部分 参考代码ReentranLock.java AQS(AbstractQueuedSynchronizer.java) 由于源码太多，这里就不粘贴出源码了，感兴趣的读者可以自行查看。 第4部分 获取公平锁(基于JDK1.7.0_40)通过前面“Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock”的“示例1”，我们知道，获取锁是通过lock()函数。下面，我们以lock()对获取公平锁的过程进行展开。 1. lock()lock()在ReentrantLock.java的FairSync类中实现，它的源码如下： final void lock() { acquire(1); } 说明：“当前线程”实际上是通过acquire(1)获取锁的。这里说明一下“1”的含义，它是设置“锁的状态”的参数。对于“独占锁”而言，锁处于可获取状态时，它的状态值是0；锁被线程初次获取到了，它的状态值就变成了1。由于ReentrantLock(公平锁/非公平锁)是可重入锁，所以“独占锁”可以被单个线程多此获取，每获取1次就将锁的状态+1。也就是说，初次获取锁时，通过acquire(1)将锁的状态值设为1；再次获取锁时，将锁的状态值设为2；依次类推…这就是为什么获取锁时，传入的参数是1的原因了。可重入就是指锁可以被单个线程多次获取。 2. acquire()acquire()在AQS中实现的，它的源码如下： public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } (01) “当前线程”首先通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待(前面还有可能有需要线程在等待该锁)。(02) “当前线程”尝试失败的情况下，先通过addWaiter(Node.EXCLUSIVE)来将“当前线程”加入到”CLH队列(非阻塞的FIFO队列)”末尾。CLH队列就是线程等待队列。(03) 再执行完addWaiter(Node.EXCLUSIVE)之后，会调用acquireQueued()来获取锁。由于此时ReentrantLock是公平锁，它会根据公平性原则来获取锁。(04) “当前线程”在执行acquireQueued()时，会进入到CLH队列中休眠等待，直到获取锁了才返回！如果“当前线程”在休眠等待过程中被中断过，acquireQueued会返回true，此时”当前线程”会调用selfInterrupt()来自己给自己产生一个中断。至于为什么要自己给自己产生一个中断，后面再介绍。 上面是对acquire()的概括性说明。下面，我们将该函数分为4部分来逐步解析。 一. tryAcquire()二. addWaiter()三. acquireQueued()四. selfInterrupt() 第4.1部分 tryAcquire()1. tryAcquire()公平锁的tryAcquire()在ReentrantLock.java的FairSync类中实现，源码如下： protected final boolean tryAcquire(int acquires) { // 获取“当前线程” final Thread current = Thread.currentThread(); // 获取“独占锁”的状态 int c = getState(); // c=0意味着“锁没有被任何线程锁拥有”， if (c == 0) { // 若“锁没有被任何线程锁拥有”， // 则判断“当前线程”是不是CLH队列中的第一个线程线程， // 若是的话，则获取该锁，设置锁的状态，并切设置锁的拥有者为“当前线程”。 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { // 如果“独占锁”的拥有者已经为“当前线程”， // 则将更新锁的状态。 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; } 说明：根据代码，我们可以分析出，tryAcquire()的作用就是尝试去获取锁。注意，这里只是尝试！尝试成功的话，返回true；尝试失败的话，返回false，后续再通过其它办法来获取该锁。后面我们会说明，在尝试失败的情况下，是如何一步步获取锁的。 2. hasQueuedPredecessors()hasQueuedPredecessors()在AQS中实现，源码如下： public final boolean hasQueuedPredecessors() { Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); } 说明： 通过代码，能分析出，hasQueuedPredecessors() 是通过判断”当前线程”是不是在CLH队列的队首，来返回AQS中是不是有比“当前线程”等待更久的线程。下面对head、tail和Node进行说明。 3. Node的源码Node就是CLH队列的节点。Node在AQS中实现，它的数据结构如下： private transient volatile Node head; // CLH队列的队首 private transient volatile Node tail; // CLH队列的队尾 // CLH队列的节点 static final class Node { static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; // 线程已被取消，对应的waitStatus的值 static final int CANCELLED = 1; // “当前线程的后继线程需要被unpark(唤醒)”，对应的waitStatus的值。 // 一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。 static final int SIGNAL = -1; // 线程(处在Condition休眠状态)在等待Condition唤醒，对应的waitStatus的值 static final int CONDITION = -2; // (共享锁)其它线程获取到“共享锁”，对应的waitStatus的值 static final int PROPAGATE = -3; // waitStatus为“CANCELLED, SIGNAL, CONDITION, PROPAGATE”时分别表示不同状态， // 若waitStatus=0，则意味着当前线程不属于上面的任何一种状态。 volatile int waitStatus; // 前一节点 volatile Node prev; // 后一节点 volatile Node next; // 节点所对应的线程 volatile Thread thread; // nextWaiter是“区别当前CLH队列是 ‘独占锁’队列 还是 ‘共享锁’队列 的标记” // 若nextWaiter=SHARED，则CLH队列是“独占锁”队列； // 若nextWaiter=EXCLUSIVE，(即nextWaiter=null)，则CLH队列是“共享锁”队列。 Node nextWaiter; // “共享锁”则返回true，“独占锁”则返回false。 final boolean isShared() { return nextWaiter == SHARED; } // 返回前一节点 final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // Used to establish initial head or SHARED marker } // 构造函数。thread是节点所对应的线程，mode是用来表示thread的锁是“独占锁”还是“共享锁”。 Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } // 构造函数。thread是节点所对应的线程，waitStatus是线程的等待状态。 Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } } 说明：Node是CLH队列的节点，代表“等待锁的线程队列”。(01) 每个Node都会一个线程对应。(02) 每个Node会通过prev和next分别指向上一个节点和下一个节点，这分别代表上一个等待线程和下一个等待线程。(03) Node通过waitStatus保存线程的等待状态。(04) Node通过nextWaiter来区分线程是“独占锁”线程还是“共享锁”线程。如果是“独占锁”线程，则nextWaiter的值为EXCLUSIVE；如果是“共享锁”线程，则nextWaiter的值是SHARED。 4. compareAndSetState()compareAndSetState()在AQS中实现。它的源码如下： protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 说明： compareAndSwapInt() 是sun.misc.Unsafe类中的一个本地方法。对此，我们需要了解的是 compareAndSetState(expect, update) 是以原子的方式操作当前线程；若当前线程的状态为expect，则设置它的状态为update。 5. setExclusiveOwnerThread()setExclusiveOwnerThread()在AbstractOwnableSynchronizer.java中实现，它的源码如下： // exclusiveOwnerThread是当前拥有“独占锁”的线程 private transient Thread exclusiveOwnerThread; protected final void setExclusiveOwnerThread(Thread t) { exclusiveOwnerThread = t; } 说明：setExclusiveOwnerThread()的作用就是，设置线程t为当前拥有“独占锁”的线程。 6. getState(), setState()getState()和setState()都在AQS中实现，源码如下： // 锁的状态 private volatile int state; // 设置锁的状态 protected final void setState(int newState) { state = newState; } // 获取锁的状态 protected final int getState() { return state; } 说明：state表示锁的状态，对于“独占锁”而已，state=0表示锁是可获取状态(即，锁没有被任何线程锁持有)。由于java中的独占锁是可重入的，state的值可以&gt;1。 小结：tryAcquire()的作用就是让“当前线程”尝试获取锁。获取成功返回true，失败则返回false。 第4.2部分 addWaiter(Node.EXCLUSIVE)addWaiter(Node.EXCLUSIVE)的作用是，创建“当前线程”的Node节点，且Node中记录“当前线程”对应的锁是“独占锁”类型，并且将该节点添加到CLH队列的末尾。 1.addWaiter()addWaiter()在AQS中实现，源码如下： private Node addWaiter(Node mode) { // 新建一个Node节点，节点对应的线程是“当前线程”，“当前线程”的锁的模型是mode。 Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 若CLH队列不为空，则将“当前线程”添加到CLH队列末尾 if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } // 若CLH队列为空，则调用enq()新建CLH队列，然后再将“当前线程”添加到CLH队列中。 enq(node); return node; } 说明：对于“公平锁”而言，addWaiter(Node.EXCLUSIVE)会首先创建一个Node节点，节点的类型是“独占锁”(Node.EXCLUSIVE)类型。然后，再将该节点添加到CLH队列的末尾。 2. compareAndSetTail()compareAndSetTail()在AQS中实现，源码如下： private final boolean compareAndSetTail(Node expect, Node update) { return unsafe.compareAndSwapObject(this, tailOffset, expect, update); } 说明：compareAndSetTail也属于CAS函数，也是通过“本地方法”实现的。compareAndSetTail(expect, update)会以原子的方式进行操作，它的作用是判断CLH队列的队尾是不是为expect，是的话，就将队尾设为update。 3. enq()enq()在AQS中实现，源码如下： private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 说明： enq()的作用很简单。如果CLH队列为空，则新建一个CLH表头；然后将node添加到CLH末尾。否则，直接将node添加到CLH末尾。 小结：addWaiter()的作用，就是将当前线程添加到CLH队列中。这就意味着将当前线程添加到等待获取“锁”的等待线程队列中了。 第4.3部分 acquireQueued()前面，我们已经将当前线程添加到CLH队列中了。而acquireQueued()的作用就是逐步的去执行CLH队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。下面，我们看看acquireQueued()的具体流程。 1. acquireQueued()acquireQueued()在AQS中实现，源码如下： final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { // interrupted表示在CLH队列的调度中， // “当前线程”在休眠时，有没有被中断过。 boolean interrupted = false; for (;;) { // 获取上一个节点。 // node是“当前线程”对应的节点，这里就意味着“获取上一个等待锁的线程”。 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 说明：acquireQueued()的目的是从队列中获取锁。 2. shouldParkAfterFailedAcquire()shouldParkAfterFailedAcquire()在AQS中实现，源码如下： // 返回“当前线程是否应该阻塞” private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 前继节点的状态 int ws = pred.waitStatus; // 如果前继节点是SIGNAL状态，则意味这当前线程需要被unpark唤醒。此时，返回true。 if (ws == Node.SIGNAL) return true; // 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点’的前继节点”。 if (ws &gt; 0) { do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { // 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } 说明：(01) 关于waitStatus请参考下表(中扩号内为waitStatus的值)，更多关于waitStatus的内容，可以参考前面的Node类的介绍。 CANCELLED[1] -- 当前线程已被取消 SIGNAL[-1] -- “当前线程的后继线程需要被unpark(唤醒)”。一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。 CONDITION[-2] -- 当前线程(处在Condition休眠状态)在等待Condition唤醒 PROPAGATE[-3] -- (共享锁)其它线程获取到“共享锁” [0] -- 当前线程不属于上面的任何一种状态。 (02) shouldParkAfterFailedAcquire()通过以下规则，判断“当前线程”是否需要被阻塞。 规则1：如果前继节点状态为SIGNAL，表明当前节点需要被unpark(唤醒)，此时则返回true。规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非CANCELLED状态)的节点，并返回false。规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，并返回false。 如果“规则1”发生，即“前继节点是SIGNAL”状态，则意味着“当前线程”需要被阻塞。接下来会调用parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从parkAndCheckInterrupt()中返回。 3. parkAndCheckInterrupt())parkAndCheckInterrupt()在AQS中实现，源码如下： private final boolean parkAndCheckInterrupt() { // 通过LockSupport的park()阻塞“当前线程”。 LockSupport.park(this); // 返回线程的中断状态。 return Thread.interrupted(); } 说明：parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回“线程被唤醒之后”的中断状态。它会先通过LockSupport.park()阻塞“当前线程”，然后通过Thread.interrupted()返回线程的中断状态。 这里介绍一下线程被阻塞之后如何唤醒。一般有2种情况：第1种情况：unpark()唤醒。“前继节点对应的线程”使用完锁之后，通过unpark()方式唤醒当前线程。第2种情况：中断唤醒。其它线程通过interrupt()中断当前线程。 补充：LockSupport()中的park(),unpark()的作用 和 Object中的wait(),notify()作用类似，是阻塞/唤醒。它们的用法不同，park(),unpark()是轻量级的，而wait(),notify()是必须先通过Synchronized获取同步锁。关于LockSupport，我们会在之后的章节再专门进行介绍！ 4. 再次tryAcquire()了解了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()函数之后。我们接着分析acquireQueued()的for循环部分。 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } 说明：(01) 通过node.predecessor()获取前继节点。predecessor()就是返回node的前继节点，若对此有疑惑可以查看下面关于Node类的介绍。(02) p == head &amp;&amp; tryAcquire(arg)&nbsp;&nbsp;&nbsp;&nbsp; 首先，判断“前继节点”是不是CHL表头。如果是的话，则通过tryAcquire()尝试获取锁。&nbsp;&nbsp;&nbsp;&nbsp; 其实，这样做的目的是为了“让当前线程获取锁”，但是为什么需要先判断p==head呢？理解这个对理解“公平锁”的机制很重要，因为这么做的原因就是为了保证公平性！&nbsp;&nbsp;&nbsp;&nbsp; (a) 前面，我们在shouldParkAfterFailedAcquire()我们判断“当前线程”是否需要阻塞；&nbsp;&nbsp;&nbsp;&nbsp; (b) 接着，“当前线程”阻塞的话，会调用parkAndCheckInterrupt()来阻塞线程。当线程被解除阻塞的时候，我们会返回线程的中断状态。而线程被解决阻塞，可能是由于“线程被中断”，也可能是由于“其它线程调用了该线程的unpark()函数”。&nbsp;&nbsp;&nbsp;&nbsp; (c) 再回到p==head这里。如果当前线程是因为其它线程调用了unpark()函数而被唤醒，那么唤醒它的线程，应该是它的前继节点所对应的线程(关于这一点，后面在“释放锁”的过程中会看到)。 OK，是前继节点调用unpark()唤醒了当前线程！&nbsp;&nbsp;&nbsp;&nbsp; 此时，再来理解p==head就很简单了：当前继节点是CLH队列的头节点，并且它释放锁之后；就轮到当前节点获取锁了。然后，当前节点通过tryAcquire()获取锁；获取成功的话，通过setHead(node)设置当前节点为头节点，并返回。 总之，如果“前继节点调用unpark()唤醒了当前线程”并且“前继节点是CLH表头”，此时就是满足p==head，也就是符合公平性原则的。否则，如果当前线程是因为“线程被中断”而唤醒，那么显然就不是公平了。这就是为什么说p==head就是保证公平性！ 小结：acquireQueued()的作用就是“当前线程”会根据公平性原则进行阻塞等待，直到获取锁为止；并且返回当前线程在等待过程中有没有并中断过。 第4.4部分 selfInterrupt()selfInterrupt()是AQS中实现，源码如下： private static void selfInterrupt() { Thread.currentThread().interrupt(); } 说明：selfInterrupt()的代码很简单，就是“当前线程”自己产生一个中断。但是，为什么需要这么做呢？这必须结合acquireQueued()进行分析。如果在acquireQueued()中，当前线程被中断过，则执行selfInterrupt()；否则不会执行。 在acquireQueued()中，即使是线程在阻塞状态被中断唤醒而获取到cpu执行权利；但是，如果该线程的前面还有其它等待锁的线程，根据公平性原则，该线程依然无法获取到锁。它会再次阻塞！ 该线程再次阻塞，直到该线程被它的前面等待锁的线程锁唤醒；线程才会获取锁，然后“真正执行起来”！也就是说，在该线程“成功获取锁并真正执行起来”之前，它的中断会被忽略并且中断标记会被清除！ 因为在parkAndCheckInterrupt()中，我们线程的中断状态时调用了Thread.interrupted()。该函数不同于Thread的isInterrupted()函数，isInterrupted()仅仅返回中断状态，而interrupted()在返回当前中断状态之后，还会清除中断状态。 正因为之前的中断状态被清除了，所以这里需要调用selfInterrupt()重新产生一个中断！ 小结：selfInterrupt()的作用就是当前线程自己产生一个中断。 总结 再回过头看看acquire()函数，它最终的目的是获取锁！ public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } (01) 先是通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过acquireQueued()获取锁。(02) 尝试失败的情况下，会先通过addWaiter()来将“当前线程”加入到”CLH队列”末尾；然后调用acquireQueued()，在CLH队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用selfInterrupt()来自己产生一个中断。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC线程池”02之 线程池原理(一)","date":"2016-11-13T18:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC线程池”02之 线程池原理(一)/","text":"在上一章”Java多线程系列–“JUC线程池”01之 线程池架构”中，我们了解了线程池的架构。线程池的实现类是ThreadPoolExecutor类。本章，我们通过分析ThreadPoolExecutor类，来了解线程池的原理。 1. ThreadPoolExecutor简介ThreadPoolExecutor是线程池类。对于线程池，可以通俗的将它理解为”存放一定数量线程的一个线程集合。线程池允许若个线程同时允许，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。” 2. ThreadPoolExecutor数据结构ThreadPoolExecutor的数据结构如下图所示： img 各个数据在ThreadPoolExecutor.java中的定义如下： // 阻塞队列。 private final BlockingQueue&lt;Runnable&gt; workQueue; // 互斥锁 private final ReentrantLock mainLock = new ReentrantLock(); // 线程集合。一个Worker对应一个线程。 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // “终止条件”，与“mainLock”绑定。 private final Condition termination = mainLock.newCondition(); // 线程池中线程数量曾经达到过的最大值。 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // ThreadFactory对象，用于创建线程。 private volatile ThreadFactory threadFactory; // 拒绝策略的处理句柄。 private volatile RejectedExecutionHandler handler; // 保持线程存活时间。 private volatile long keepAliveTime; private volatile boolean allowCoreThreadTimeOut; // 核心池大小 private volatile int corePoolSize; // 最大池大小 private volatile int maximumPoolSize; 2.1 workersworkers是HashSet类型，即它是一个Worker集合。而一个Worker对应一个线程，也就是说线程池通过workers包含了”一个线程集合”。当Worker对应的线程池启动时，它会执行线程池中的任务；当执行完一个任务后，它会从线程池的阻塞队列中取出一个阻塞的任务来继续运行。 wokers的作用是，线程池通过它实现了”允许多个线程同时运行”。 2.2 workQueueworkQueue是BlockingQueue类型，即它是一个阻塞队列。当线程池中的线程数超过它的容量的时候，线程会进入阻塞队列进行阻塞等待。 通过workQueue，线程池实现了阻塞功能。 2.3 mainLockmainLock是互斥锁，通过mainLock实现了对线程池的互斥访问。 2.4 corePoolSize和maximumPoolSizecorePoolSize是”核心池大小”，maximumPoolSize是”最大池大小”。它们的作用是调整”线程池中实际运行的线程的数量”。 例如，当新任务提交给线程池时(通过execute方法)。&nbsp;&nbsp;&nbsp;&nbsp; – 如果此时，线程池中运行的线程数量&lt; corePoolSize，则创建新线程来处理请求。&nbsp;&nbsp;&nbsp;&nbsp; – 如果此时，线程池中运行的线程数量&gt; corePoolSize，但是却&lt; maximumPoolSize；则仅当阻塞队列满时才创建新线程。如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心池大小和最大池大小的值是在创建线程池设置的；但是，也可以使用 setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改。 2.5 poolSizepoolSize是当前线程池的实际大小，即线程池中任务的数量。 2.6 allowCoreThreadTimeOut和keepAliveTimeallowCoreThreadTimeOut表示是否允许”线程在空闲状态时，仍然能够存活”；而keepAliveTime是当线程池处于空闲状态的时候，超过keepAliveTime时间之后，空闲的线程会被终止。 2.7 threadFactorythreadFactory是ThreadFactory对象。它是一个线程工厂类，”线程池通过ThreadFactory创建线程”。 2.8 handlerhandler是RejectedExecutionHandler类型。它是”线程池拒绝策略”的句柄，也就是说”当某任务添加到线程池中，而线程池拒绝该任务时，线程池会通过handler进行相应的处理”。 综上所说，线程池通过workers来管理”线程集合”，每个线程在启动后，会执行线程池中的任务；当一个任务执行完后，它会从线程池的阻塞队列中取出任务来继续运行。阻塞队列是管理线程池任务的队列，当添加到线程池中的任务超过线程池的容量时，该任务就会进入阻塞队列进行等待。 3. 线程池调度我们通过下面的图看看下面线程池中任务的调度策略，加深对线程池的理解。 图-01: img 图-02: img 说明：在”图-01”中，线程池中有N个任务。”任务1”, “任务2”, “任务3”这3个任务在执行，而”任务3”到”任务N”在阻塞队列中等待。正在执行的任务，在workers集合中，workers集合包含3个Worker，每一个Worker对应一个Thread线程，Thread线程每次处理一个任务。当workers集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如图-02所示。图-02表示”任务1”处理完毕之后，线程池将”任务4”从阻塞队列中取出，放到workers中进行处理。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC线程池","slug":"JUC线程池","permalink":"https://smuwjs.github.io/tags/JUC线程池/"}]},{"title":"Java多线程系列--“JUC锁”02之 互斥锁ReentrantLock","date":"2016-11-13T18:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”02之 互斥锁ReentrantLock/","text":"本章对ReentrantLock包进行基本介绍，这一章主要对ReentrantLock进行概括性的介绍。在后面的两章，会分别介绍ReentrantLock的两个子类(公平锁和非公平锁)的实现原理。 目录1. ReentrantLock介绍2. ReentrantLock示例 1. ReentrantLock介绍ReentrantLock是一个可重入的互斥锁，又被称为“独占锁”。 顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。 ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。 ReentrantLock函数列表 // 创建一个 ReentrantLock ，默认是“非公平锁”。 ReentrantLock() // 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。 ReentrantLock(boolean fair) // 查询当前线程保持此锁的次数。 int getHoldCount() // 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。 protected Thread getOwner() // 返回一个 collection，它包含可能正等待获取此锁的线程。 protected Collection&lt;Thread&gt; getQueuedThreads() // 返回正等待获取此锁的线程估计数。 int getQueueLength() // 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。 protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition) // 返回等待与此锁相关的给定条件的线程估计数。 int getWaitQueueLength(Condition condition) // 查询给定线程是否正在等待获取此锁。 boolean hasQueuedThread(Thread thread) // 查询是否有些线程正在等待获取此锁。 boolean hasQueuedThreads() // 查询是否有些线程正在等待与此锁有关的给定条件。 boolean hasWaiters(Condition condition) // 如果是“公平锁”返回true，否则返回false。 boolean isFair() // 查询当前线程是否保持此锁。 boolean isHeldByCurrentThread() // 查询此锁是否由任意线程保持。 boolean isLocked() // 获取锁。 void lock() // 如果当前线程未被中断，则获取锁。 void lockInterruptibly() // 返回用来与此 Lock 实例一起使用的 Condition 实例。 Condition newCondition() // 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 boolean tryLock() // 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。 boolean tryLock(long timeout, TimeUnit unit) // 试图释放此锁。 void unlock() 2. ReentrantLock示例通过对比“示例1”和“示例2”,我们能够清晰的认识lock和unlock的作用 2.1 示例1import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; // LockTest1.java // 仓库 class Depot { private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() { this.size = 0; this.lock = new ReentrantLock(); } public void produce(int val) { lock.lock(); try { size += val; System.out.printf(&quot;%s produce(%d) --&gt; size=%d\\n&quot;, Thread.currentThread().getName(), val, size); } finally { lock.unlock(); } } public void consume(int val) { lock.lock(); try { size -= val; System.out.printf(&quot;%s consume(%d) &lt;-- size=%d\\n&quot;, Thread.currentThread().getName(), val, size); } finally { lock.unlock(); } } }; // 生产者 class Producer { private Depot depot; public Producer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) { new Thread() { public void run() { depot.produce(val); } }.start(); } } // 消费者 class Customer { private Depot depot; public Customer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) { new Thread() { public void run() { depot.consume(val); } }.start(); } } public class LockTest1 { public static void main(String[] args) { Depot mDepot = new Depot(); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); } } 运行结果： Thread-0 produce(60) --&gt; size=60 Thread-1 produce(120) --&gt; size=180 Thread-3 consume(150) &lt;-- size=30 Thread-2 consume(90) &lt;-- size=-60 Thread-4 produce(110) --&gt; size=50 结果分析：(01) Depot 是个仓库。通过produce()能往仓库中生产货物，通过consume()能消费仓库中的货物。通过独占锁lock实现对仓库的互斥访问：在操作(生产/消费)仓库中货品前，会先通过lock()锁住仓库，操作完之后再通过unlock()解锁。(02) Producer是生产者类。调用Producer中的produce()函数可以新建一个线程往仓库中生产产品。(03) Customer是消费者类。调用Customer中的consume()函数可以新建一个线程消费仓库中的产品。(04) 在主线程main中，我们会新建1个生产者mPro，同时新建1个消费者mCus。它们分别向仓库中生产/消费产品。根据main中的生产/消费数量，仓库最终剩余的产品应该是50。运行结果是符合我们预期的！ 这个模型存在两个问题：(01) 现实中，仓库的容量不可能为负数。但是，此模型中的仓库容量可以为负数，这与现实相矛盾！(02) 现实中，仓库的容量是有限制的。但是，此模型中的容量确实没有限制的！这两个问题，我们稍微会讲到如何解决。现在，先看个简单的示例2；通过对比“示例1”和“示例2”,我们能更清晰的认识lock(),unlock()的用途。 2.2 示例2import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; // LockTest2.java // 仓库 class Depot { private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() { this.size = 0; this.lock = new ReentrantLock(); } public void produce(int val) { // lock.lock(); // try { size += val; System.out.printf(&quot;%s produce(%d) --&gt; size=%d\\n&quot;, Thread.currentThread().getName(), val, size); // } catch (InterruptedException e) { // } finally { // lock.unlock(); // } } public void consume(int val) { // lock.lock(); // try { size -= val; System.out.printf(&quot;%s consume(%d) &lt;-- size=%d\\n&quot;, Thread.currentThread().getName(), val, size); // } finally { // lock.unlock(); // } } }; // 生产者 class Producer { private Depot depot; public Producer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) { new Thread() { public void run() { depot.produce(val); } }.start(); } } // 消费者 class Customer { private Depot depot; public Customer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) { new Thread() { public void run() { depot.consume(val); } }.start(); } } public class LockTest2 { public static void main(String[] args) { Depot mDepot = new Depot(); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); } } (某一次)运行结果： Thread-0 produce(60) --&gt; size=-60 Thread-4 produce(110) --&gt; size=50 Thread-2 consume(90) &lt;-- size=-60 Thread-1 produce(120) --&gt; size=-60 Thread-3 consume(150) &lt;-- size=-60 结果说明：“示例2”在“示例1”的基础上去掉了lock锁。在“示例2”中，仓库中最终剩余的产品是-60，而不是我们期望的50。原因是我们没有实现对仓库的互斥访问。 2.3 示例3在“示例3”中，我们通过Condition去解决“示例1”中的两个问题：“仓库的容量不可能为负数”以及“仓库的容量是有限制的”。 解决该问题是通过Condition。Condition是需要和Lock联合使用的：通过Condition中的await()方法，能让线程阻塞[类似于wait()]；通过Condition的signal()方法，能让唤醒线程[类似于notify()]。 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.Condition; // LockTest3.java // 仓库 class Depot { private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 private Lock lock; // 独占锁 private Condition fullCondtion; // 生产条件 private Condition emptyCondtion; // 消费条件 public Depot(int capacity) { this.capacity = capacity; this.size = 0; this.lock = new ReentrantLock(); this.fullCondtion = lock.newCondition(); this.emptyCondtion = lock.newCondition(); } public void produce(int val) { lock.lock(); try { // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) { // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) fullCondtion.await(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf(&quot;%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\\n&quot;, Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 emptyCondtion.signal(); } } catch (InterruptedException e) { } finally { lock.unlock(); } } public void consume(int val) { lock.lock(); try { // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) { // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) emptyCondtion.await(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf(&quot;%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\\n&quot;, Thread.currentThread().getName(), val, left, dec, size); fullCondtion.signal(); } } catch (InterruptedException e) { } finally { lock.unlock(); } } public String toString() { return &quot;capacity:&quot;+capacity+&quot;, actual size:&quot;+size; } }; // 生产者 class Producer { private Depot depot; public Producer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) { new Thread() { public void run() { depot.produce(val); } }.start(); } } // 消费者 class Customer { private Depot depot; public Customer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) { new Thread() { public void run() { depot.consume(val); } }.start(); } } public class LockTest3 { public static void main(String[] args) { Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); } } (某一次)运行结果： Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60 Thread-1 produce(120) --&gt; left= 80, inc= 40, size=100 Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10 Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0 Thread-4 produce(110) --&gt; left= 10, inc=100, size=100 Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0 Thread-4 produce(110) --&gt; left= 0, inc= 10, size= 10 Thread-3 consume(150) &lt;-- left= 30, dec= 10, size= 0 Thread-1 produce(120) --&gt; left= 0, inc= 80, size= 80 Thread-3 consume(150) &lt;-- left= 0, dec= 30, size= 50 代码中的已经包含了很详细的注释，这里就不再说明了。更多“生产者/消费者模型”的更多内容，可以参考“Java多线程系列–“基础篇”11之 生产消费者问题”。而关于Condition的内容，在后面我们会详细介绍。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC锁”01之 框架","date":"2016-11-13T17:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC锁”01之 框架/","text":"本章，我们介绍锁的架构；后面的章节将会对它们逐个进行分析介绍。 根据锁的添加到Java中的时间，Java中的锁，可以分为”同步锁“和”JUC包中的锁“。 1. 同步锁即通过synchronized关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0版本中就已经支持同步锁了。 同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。这就是，多线程通过同步锁进行同步的原理！ 关于”同步锁”的更多内容，请参考”Java锁的基础部分”的内容。 2. JUC包中的锁相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。 JUC包中的锁，包括：Lock接口，ReadWriteLock接口，LockSupport阻塞原语，Condition条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer三个抽象类，ReentrantLock独占锁，ReentrantReadWriteLock读写锁。由于CountDownLatch，CyclicBarrier和Semaphore也是通过AQS来实现的；因此，我也将它们归纳到锁的框架中进行介绍。 先看看锁的框架图，如下所示。 img 2.1 Lock接口JUC包中的 Lock 接口支持那些语义不同(重入、公平等)的锁规则。所谓语义不同，是指锁可是有”公平机制的锁”、”非公平机制的锁”、”可重入的锁”等等。”公平机制”是指”不同线程获取锁的机制是公平的”，而”非公平机制”则是指”不同线程获取锁的机制是非公平的”，”可重入的锁”是指同一个锁能够被一个线程多次获取。 2.2 ReadWriteLockReadWriteLock 接口以和Lock类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 2.3 AbstractOwnableSynchronizer,AbstractQueuedSynchronizer和AbstractQueuedLongSynchronizerAbstractQueuedSynchronizer就是被称之为AQS的类。 它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier和Semaphore等这些类都是基于AQS类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。 2.4 LockSupportLockSupport提供“创建锁”和“其他同步类的基本线程阻塞原语”。 LockSupport的功能和”Thread中的Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 2.5 ConditionCondition需要和Lock联合使用，它的作用是代替Object监视器方法，可以通过await(),signal()来休眠/唤醒线程。 Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 2.6 ReentrantLockReentrantLock是独占锁。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock锁包括”公平的ReentrantLock”和”非公平的ReentrantLock”。”公平的ReentrantLock”是指”不同线程获取锁的机制是公平的”，而”非公平的 ReentrantLock”则是指”不同线程获取锁的机制是非公平的”，ReentrantLock是”可重入的锁”。 ReentrantLock的UML类图如下： img (01) ReentrantLock实现了Lock接口。(02) ReentrantLock中有一个成员变量sync，sync是Sync类型；Sync是一个抽象类，而且它继承于AQS。(03) ReentrantLock中有”公平锁类”FairSync和”非公平锁类”NonfairSync，它们都是Sync的子类。ReentrantReadWriteLock中sync对象，是FairSync与NonfairSync中的一种，这也意味着ReentrantLock是”公平锁”或”非公平锁”中的一种，ReentrantLock默认是非公平锁。 2.7 ReentrantReadWriteLockReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括子类ReadLock和WriteLock。ReentrantLock是共享锁，而WriteLock是独占锁。 ReentrantReadWriteLock的UML类图如下： img (01) ReentrantReadWriteLock实现了ReadWriteLock接口。(02) ReentrantReadWriteLock中包含sync对象，读锁readerLock和写锁writerLock。读锁ReadLock和写锁WriteLock都实现了Lock接口。(03) 和”ReentrantLock”一样，sync是Sync类型；而且，Sync也是一个继承于AQS的抽象类。Sync也包括”公平锁”FairSync和”非公平锁”NonfairSync。 2.8 CountDownLatchCountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch的UML类图如下： img CountDownLatch包含了sync对象，sync是Sync类型。CountDownLatch的Sync是实例类，它继承于AQS。 2.9 CyclicBarrierCyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier的UML类图如下： img CyclicBarrier是包含了”ReentrantLock对象lock”和”Condition对象trip”，它是通过独占锁实现的。CyclicBarrier和CountDownLatch的区别是：(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。(02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 2.10. SemaphoreSemaphore是一个计数信号量，它的本质是一个”共享锁”。 信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。Semaphore的UML类图如下： img 和”ReentrantLock”一样，Semaphore包含了sync对象，sync是Sync类型；而且，Sync也是一个继承于AQS的抽象类。Sync也包括”公平信号量”FairSync和”非公平信号量”NonfairSync。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC锁","slug":"JUC锁","permalink":"https://smuwjs.github.io/tags/JUC锁/"}]},{"title":"Java多线程系列--“JUC线程池”01之 线程池架构","date":"2016-11-13T17:00:00.000Z","path":"2016/11/14/java-source-analysis-multi-thread-series/Java多线程系列--“JUC线程池”01之 线程池架构/","text":"前面分别介绍了”Java多线程基础”、”JUC原子类”和”JUC锁”。本章介绍JUC的最后一部分的内容——线程池。 目录1. 线程池架构图2. 线程池示例 1. 线程池架构图线程池的架构图如下： img 1.1 Executor它是”执行者”接口，它是来执行任务的。准确的说，Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。Executor存在的目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。 它只包含一个函数接口： void execute(Runnable command) 2.2 ExecutorServiceExecutorService继承于Executor。它是”执行者服务”接口，它是为”执行者接口Executor”服务而存在的；准确的话，ExecutorService提供了”将任务提交给执行者的接口(submit方法)”，”让执行者执行任务(invokeAll, invokeAny方法)”的接口等等。 ExecutorService的函数列表 // 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。 boolean awaitTermination(long timeout, TimeUnit unit) // 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) // 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) // 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) // 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) // 如果此执行程序已关闭，则返回 true。 boolean isShutdown() // 如果关闭后所有任务都已完成，则返回 true。 boolean isTerminated() // 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。 void shutdown() // 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。 List&lt;Runnable&gt; shutdownNow() // 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 Future&lt;?&gt; submit(Runnable task) // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 2.3 AbstractExecutorServiceAbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。 2.4 ThreadPoolExecutorThreadPoolExecutor就是大名鼎鼎的”线程池”。它继承于AbstractExecutorService抽象类。 ThreadPoolExecutor函数列表 // 用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutor。 ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) // 用给定的初始参数和默认的线程工厂创建新的 ThreadPoolExecutor。 ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) // 用给定的初始参数和默认被拒绝的执行处理程序创建新的 ThreadPoolExecutor。 ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) // 用给定的初始参数创建新的 ThreadPoolExecutor。 ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) // 基于完成执行给定 Runnable 所调用的方法。 protected void afterExecute(Runnable r, Throwable t) // 如果在保持活动时间内没有任务到达，新任务到达时正在替换（如果需要），则设置控制核心线程是超时还是终止的策略。 void allowCoreThreadTimeOut(boolean value) // 如果此池允许核心线程超时和终止，如果在 keepAlive 时间内没有任务到达，新任务到达时正在替换（如果需要），则返回 true。 boolean allowsCoreThreadTimeOut() // 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。 boolean awaitTermination(long timeout, TimeUnit unit) // 在执行给定线程中的给定 Runnable 之前调用的方法。 protected void beforeExecute(Thread t, Runnable r) // 在将来某个时间执行给定任务。 void execute(Runnable command) // 当不再引用此执行程序时，调用 shutdown。 protected void finalize() // 返回主动执行任务的近似线程数。 int getActiveCount() // 返回已完成执行的近似任务总数。 long getCompletedTaskCount() // 返回核心线程数。 int getCorePoolSize() // 返回线程保持活动的时间，该时间就是超过核心池大小的线程可以在终止前保持空闲的时间值。 long getKeepAliveTime(TimeUnit unit) // 返回曾经同时位于池中的最大线程数。 int getLargestPoolSize() // 返回允许的最大线程数。 int getMaximumPoolSize() // 返回池中的当前线程数。 int getPoolSize() // 返回此执行程序使用的任务队列。 BlockingQueue&lt;Runnable&gt; getQueue() // 返回用于未执行任务的当前处理程序。 RejectedExecutionHandler getRejectedExecutionHandler() // 返回曾计划执行的近似任务总数。 long getTaskCount() // 返回用于创建新线程的线程工厂。 ThreadFactory getThreadFactory() // 如果此执行程序已关闭，则返回 true。 boolean isShutdown() // 如果关闭后所有任务都已完成，则返回 true。 boolean isTerminated() // 如果此执行程序处于在 shutdown 或 shutdownNow 之后正在终止但尚未完全终止的过程中，则返回 true。 boolean isTerminating() // 启动所有核心线程，使其处于等待工作的空闲状态。 int prestartAllCoreThreads() // 启动核心线程，使其处于等待工作的空闲状态。 boolean prestartCoreThread() // 尝试从工作队列移除所有已取消的 Future 任务。 void purge() // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。 boolean remove(Runnable task) // 设置核心线程数。 void setCorePoolSize(int corePoolSize) // 设置线程在终止前可以保持空闲的时间限制。 void setKeepAliveTime(long time, TimeUnit unit) // 设置允许的最大线程数。 void setMaximumPoolSize(int maximumPoolSize) // 设置用于未执行任务的新处理程序。 void setRejectedExecutionHandler(RejectedExecutionHandler handler) // 设置用于创建新线程的线程工厂。 void setThreadFactory(ThreadFactory threadFactory) // 按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。 void shutdown() // 尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。 List&lt;Runnable&gt; shutdownNow() // 当 Executor 已经终止时调用的方法。 protected void terminated() 1.5 ScheduledExecutorServiceScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了”延时”和”周期执行”功能的ExecutorService。ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。 ScheduledExecutorService函数列表 // 创建并执行在给定延迟后启用的 ScheduledFuture。 ScheduledFuture schedule(Callable callable, long delay, TimeUnit unit)// 创建并执行在给定延迟后启用的一次性操作。ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) 2.6 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了”延时”和”周期执行”功能的ScheduledExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。 ScheduledThreadPoolExecutor函数列表 // 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。 ScheduledThreadPoolExecutor(int corePoolSize) // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。 ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler) // 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。 ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) // 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。 ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) // 修改或替换用于执行 callable 的任务。 protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task) // 修改或替换用于执行 runnable 的任务。 protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) // 使用所要求的零延迟执行命令。 void execute(Runnable command) // 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。 boolean getContinueExistingPeriodicTasksAfterShutdownPolicy() // 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。 boolean getExecuteExistingDelayedTasksAfterShutdownPolicy() // 返回此执行程序使用的任务队列。 BlockingQueue&lt;Runnable&gt; getQueue() // 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。 boolean remove(Runnable task) // 创建并执行在给定延迟后启用的 ScheduledFuture。 &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) // 创建并执行在给定延迟后启用的一次性操作。 ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) // 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) // 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。 void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value) // 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。 void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) // 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。 void shutdown() // 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。 List&lt;Runnable&gt; shutdownNow() // 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 Future&lt;?&gt; submit(Runnable task) // 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 2.7 ExecutorsExecutors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。 Executors函数列表 // 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。 static Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action) // 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。 static Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action) // 返回 Callable 对象，调用它时可运行给定的任务并返回 null。 static Callable&lt;Object&gt; callable(Runnable task) // 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。 static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) // 返回用于创建新线程的默认线程工厂。 static ThreadFactory defaultThreadFactory() // 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。 static ExecutorService newCachedThreadPool() // 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。 static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) // 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。 static ExecutorService newFixedThreadPool(int nThreads) // 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。 static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) // 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) // 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) // 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。 static ExecutorService newSingleThreadExecutor() // 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。 static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) // 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。 static ScheduledExecutorService newSingleThreadScheduledExecutor() // 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。 static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) // 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。 static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable) // 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。 static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable) // 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。 static ThreadFactory privilegedThreadFactory() // 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。 static ExecutorService unconfigurableExecutorService(ExecutorService executor) // 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。 static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) 2. 线程池示例下面通过示例来对线程池的使用做简单演示。 import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; public class ThreadPoolDemo1 { public static void main(String[] args) { // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); } } class MyThread extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;); } } 运行结果： pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. 结果说明：主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。最后，通过shutdown()关闭线程池。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC线程池","slug":"JUC线程池","permalink":"https://smuwjs.github.io/tags/JUC线程池/"}]},{"title":"Java多线程系列--“JUC原子类”05之 AtomicLongFieldUpdater原子类","date":"2016-11-12T21:00:00.000Z","path":"2016/11/13/java-source-analysis-multi-thread-series/Java多线程系列--“JUC原子类”05之 AtomicLongFieldUpdater原子类/","text":"AtomicIntegerFieldUpdater，AtomicLongFieldUpdater和AtomicReferenceFieldUpdater这3个修改类的成员的原子类型的原理和用法相似。本章以对基本类型的原子类进行介绍。 目录1. AtomicLongFieldUpdater介绍和函数列表2. AtomicLongFieldUpdater示例3. AtomicLongFieldUpdater源码分析(基于JDK1.7.0_40) 1. AtomicLongFieldUpdater介绍和函数列表AtomicLongFieldUpdater可以对指定”类的 ‘volatile long’类型的成员”进行原子更新。它是基于反射原理实现的。 AtomicLongFieldUpdater函数列表 // 受保护的无操作构造方法，供子类使用。 protected AtomicLongFieldUpdater() // 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。 long addAndGet(T obj, long delta) // 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。 abstract boolean compareAndSet(T obj, long expect, long update) // 以原子方式将此更新器管理的给定对象字段当前值减 1。 long decrementAndGet(T obj) // 获取此更新器管理的在给定对象的字段中保持的当前值。 abstract long get(T obj) // 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。 long getAndAdd(T obj, long delta) // 以原子方式将此更新器管理的给定对象字段当前值减 1。 long getAndDecrement(T obj) // 以原子方式将此更新器管理的给定对象字段的当前值加 1。 long getAndIncrement(T obj) // 将此更新器管理的给定对象的字段以原子方式设置为给定值，并返回旧值。 long getAndSet(T obj, long newValue) // 以原子方式将此更新器管理的给定对象字段当前值加 1。 long incrementAndGet(T obj) // 最后将此更新器管理的给定对象的字段设置为给定更新值。 abstract void lazySet(T obj, long newValue) // 为对象创建并返回一个具有给定字段的更新器。 static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName) // 将此更新器管理的给定对象的字段设置为给定更新值。 abstract void set(T obj, long newValue) // 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。 abstract boolean weakCompareAndSet(T obj, long expect, long update) 2. AtomicLongFieldUpdater示例// LongTest.java的源码 import java.util.concurrent.atomic.AtomicLongFieldUpdater; public class LongFieldTest { public static void main(String[] args) { // 获取Person的class对象 Class cls = Person.class; // 新建AtomicLongFieldUpdater对象，传递参数是“class对象”和“long类型在类中对应的名称” AtomicLongFieldUpdater mAtoLong = AtomicLongFieldUpdater.newUpdater(cls, &quot;id&quot;); Person person = new Person(12345678L); // 比较person的&quot;id&quot;属性，如果id的值为12345678L，则设置为1000。 mAtoLong.compareAndSet(person, 12345678L, 1000); System.out.println(&quot;id=&quot;+person.getId()); } } class Person { volatile long id; public Person(long id) { this.id = id; } public void setId(long id) { this.id = id; } public long getId() { return id; } } 运行结果： id=1000 3. AtomicLongFieldUpdater源码分析(基于JDK1.7.0_40)AtomicLongFieldUpdater完整源码 package java.util.concurrent.atomic; import java.lang.reflect.*; import sun.misc.Unsafe; import sun.reflect.CallerSensitive; import sun.reflect.Reflection; /** * A reflection-based utility that enables atomic updates to * designated {@code volatile} reference fields of designated * classes. This class is designed for use in atomic data structures * in which several reference fields of the same node are * independently subject to atomic updates. For example, a tree node * might be declared as * * &lt;pre&gt; {@code * class Node { * private volatile Node left, right; * * private static final AtomicReferenceFieldUpdater&lt;Node, Node&gt; leftUpdater = * AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, &quot;left&quot;); * private static AtomicReferenceFieldUpdater&lt;Node, Node&gt; rightUpdater = * AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, &quot;right&quot;); * * Node getLeft() { return left; } * boolean compareAndSetLeft(Node expect, Node update) { * return leftUpdater.compareAndSet(this, expect, update); * } * // ... and so on * }}&lt;/pre&gt; * * &lt;p&gt;Note that the guarantees of the {@code compareAndSet} * method in this class are weaker than in other atomic classes. * Because this class cannot ensure that all uses of the field * are appropriate for purposes of atomic access, it can * guarantee atomicity only with respect to other invocations of * {@code compareAndSet} and {@code set} on the same updater. * * @since 1.5 * @author Doug Lea * @param &lt;T&gt; The type of the object holding the updatable field * @param &lt;V&gt; The type of the field */ public abstract class AtomicReferenceFieldUpdater&lt;T, V&gt; { /** * Creates and returns an updater for objects with the given field. * The Class arguments are needed to check that reflective types and * generic types match. * * @param tclass the class of the objects holding the field. * @param vclass the class of the field * @param fieldName the name of the field to be updated. * @return the updater * @throws IllegalArgumentException if the field is not a volatile reference type. * @throws RuntimeException with a nested reflection-based * exception if the class does not hold field or is the wrong type. */ @CallerSensitive public static &lt;U, W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; newUpdater(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName) { return new AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;(tclass, vclass, fieldName, Reflection.getCallerClass()); } /** * Protected do-nothing constructor for use by subclasses. */ protected AtomicReferenceFieldUpdater() { } /** * Atomically sets the field of the given object managed by this updater * to the given updated value if the current value {@code ==} the * expected value. This method is guaranteed to be atomic with respect to * other calls to {@code compareAndSet} and {@code set}, but not * necessarily with respect to other changes in the field. * * @param obj An object whose field to conditionally set * @param expect the expected value * @param update the new value * @return true if successful. */ public abstract boolean compareAndSet(T obj, V expect, V update); /** * Atomically sets the field of the given object managed by this updater * to the given updated value if the current value {@code ==} the * expected value. This method is guaranteed to be atomic with respect to * other calls to {@code compareAndSet} and {@code set}, but not * necessarily with respect to other changes in the field. * * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to {@code compareAndSet}. * * @param obj An object whose field to conditionally set * @param expect the expected value * @param update the new value * @return true if successful. */ public abstract boolean weakCompareAndSet(T obj, V expect, V update); /** * Sets the field of the given object managed by this updater to the * given updated value. This operation is guaranteed to act as a volatile * store with respect to subsequent invocations of {@code compareAndSet}. * * @param obj An object whose field to set * @param newValue the new value */ public abstract void set(T obj, V newValue); /** * Eventually sets the field of the given object managed by this * updater to the given updated value. * * @param obj An object whose field to set * @param newValue the new value * @since 1.6 */ public abstract void lazySet(T obj, V newValue); /** * Gets the current value held in the field of the given object managed * by this updater. * * @param obj An object whose field to get * @return the current value */ public abstract V get(T obj); /** * Atomically sets the field of the given object managed by this updater * to the given value and returns the old value. * * @param obj An object whose field to get and set * @param newValue the new value * @return the previous value */ public V getAndSet(T obj, V newValue) { for (;;) { V current = get(obj); if (compareAndSet(obj, current, newValue)) return current; } } private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt; extends AtomicReferenceFieldUpdater&lt;T,V&gt; { private static final Unsafe unsafe = Unsafe.getUnsafe(); private final long offset; private final Class&lt;T&gt; tclass; private final Class&lt;V&gt; vclass; private final Class cclass; /* * Internal type checks within all update methods contain * internal inlined optimizations checking for the common * cases where the class is final (in which case a simple * getClass comparison suffices) or is of type Object (in * which case no check is needed because all objects are * instances of Object). The Object case is handled simply by * setting vclass to null in constructor. The targetCheck and * updateCheck methods are invoked when these faster * screenings fail. */ AtomicReferenceFieldUpdaterImpl(Class&lt;T&gt; tclass, Class&lt;V&gt; vclass, String fieldName, Class&lt;?&gt; caller) { Field field = null; Class fieldClass = null; int modifiers = 0; try { field = tclass.getDeclaredField(fieldName); modifiers = field.getModifiers(); sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); fieldClass = field.getType(); } catch (Exception ex) { throw new RuntimeException(ex); } if (vclass != fieldClass) throw new ClassCastException(); if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException(&quot;Must be volatile type&quot;); this.cclass = (Modifier.isProtected(modifiers) &amp;&amp; caller != tclass) ? caller : null; this.tclass = tclass; if (vclass == Object.class) this.vclass = null; else this.vclass = vclass; offset = unsafe.objectFieldOffset(field); } void targetCheck(T obj) { if (!tclass.isInstance(obj)) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); } void updateCheck(T obj, V update) { if (!tclass.isInstance(obj) || (update != null &amp;&amp; vclass != null &amp;&amp; !vclass.isInstance(update))) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); } public boolean compareAndSet(T obj, V expect, V update) { if (obj == null || obj.getClass() != tclass || cclass != null || (update != null &amp;&amp; vclass != null &amp;&amp; vclass != update.getClass())) updateCheck(obj, update); return unsafe.compareAndSwapObject(obj, offset, expect, update); } public boolean weakCompareAndSet(T obj, V expect, V update) { // same implementation as strong form for now if (obj == null || obj.getClass() != tclass || cclass != null || (update != null &amp;&amp; vclass != null &amp;&amp; vclass != update.getClass())) updateCheck(obj, update); return unsafe.compareAndSwapObject(obj, offset, expect, update); } public void set(T obj, V newValue) { if (obj == null || obj.getClass() != tclass || cclass != null || (newValue != null &amp;&amp; vclass != null &amp;&amp; vclass != newValue.getClass())) updateCheck(obj, newValue); unsafe.putObjectVolatile(obj, offset, newValue); } public void lazySet(T obj, V newValue) { if (obj == null || obj.getClass() != tclass || cclass != null || (newValue != null &amp;&amp; vclass != null &amp;&amp; vclass != newValue.getClass())) updateCheck(obj, newValue); unsafe.putOrderedObject(obj, offset, newValue); } public V get(T obj) { if (obj == null || obj.getClass() != tclass || cclass != null) targetCheck(obj); return (V)unsafe.getObjectVolatile(obj, offset); } private void ensureProtectedAccess(T obj) { if (cclass.isInstance(obj)) { return; } throw new RuntimeException( new IllegalAccessException(&quot;Class &quot; + cclass.getName() + &quot; can not access a protected member of class &quot; + tclass.getName() + &quot; using an instance of &quot; + obj.getClass().getName() ) ); } } } 下面分析LongFieldTest.java的流程。 1. newUpdater() newUpdater()的源码如下： public static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName) { Class&lt;?&gt; caller = Reflection.getCallerClass(); if (AtomicLong.VM_SUPPORTS_LONG_CAS) return new CASUpdater&lt;U&gt;(tclass, fieldName, caller); else return new LockedUpdater&lt;U&gt;(tclass, fieldName, caller); } 说明：newUpdater()的作用是获取一个AtomicIntegerFieldUpdater类型的对象。它实际上返回的是CASUpdater对象，或者LockedUpdater对象；具体返回哪一个类取决于JVM是否支持long类型的CAS函数。CASUpdater和LockedUpdater都是AtomicIntegerFieldUpdater的子类，它们的实现类似。下面以CASUpdater来进行说明。 CASUpdater类的源码如下： public boolean compareAndSet(T obj, long expect, long update) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.compareAndSwapLong(obj, offset, expect, update); } 说明：它实际上是通过CAS函数操作。如果类的long对象的值是expect，则设置它的值为update。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC原子类","slug":"JUC原子类","permalink":"https://smuwjs.github.io/tags/JUC原子类/"}]},{"title":"Java多线程系列--“JUC原子类”04之 AtomicReference原子类","date":"2016-11-12T20:00:00.000Z","path":"2016/11/13/java-source-analysis-multi-thread-series/Java多线程系列--“JUC原子类”04之 AtomicReference原子类/","text":"本章对AtomicReference引用类型的原子类进行介绍。 目录1. AtomicReference介绍和函数列表2. AtomicReference源码分析(基于JDK1.7.0_40)3. AtomicReference示例 1. AtomicReference介绍和函数列表AtomicReference是作用是对”对象”进行原子操作。 AtomicReference函数列表 // 使用 null 初始值创建新的 AtomicReference。 AtomicReference() // 使用给定的初始值创建新的 AtomicReference。 AtomicReference(V initialValue) // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean compareAndSet(V expect, V update) // 获取当前值。 V get() // 以原子方式设置为给定值，并返回旧值。 V getAndSet(V newValue) // 最终设置为给定值。 void lazySet(V newValue) // 设置为给定值。 void set(V newValue) // 返回当前值的字符串表示形式。 String toString() // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean weakCompareAndSet(V expect, V update) 2. AtomicReference源码分析(基于JDK1.7.0_40)在JDK1.7.0_40中AtomicReference.java的源码如下： public class AtomicReference&lt;V&gt; implements java.io.Serializable { private static final long serialVersionUID = -1848883965231344442L; // 获取Unsafe对象，Unsafe的作用是提供CAS操作 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField(&quot;value&quot;)); } catch (Exception ex) { throw new Error(ex); } } // volatile类型 private volatile V value; public AtomicReference(V initialValue) { value = initialValue; } public AtomicReference() { } public final V get() { return value; } public final void set(V newValue) { value = newValue; } public final void lazySet(V newValue) { unsafe.putOrderedObject(this, valueOffset, newValue); } public final boolean compareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } public final boolean weakCompareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } public final V getAndSet(V newValue) { while (true) { V x = get(); if (compareAndSet(x, newValue)) return x; } } public String toString() { return String.valueOf(get()); } } 说明：AtomicReference的源码比较简单。它是通过”volatile”和”Unsafe提供的CAS函数实现”原子操作。(01) value是volatile类型。这保证了：当某线程修改value的值时，其他线程看到的value值都是最新的value值，即修改之后的volatile的值。(02) 通过CAS设置value。这保证了：当某线程池通过CAS函数(如compareAndSet函数)设置value时，它的操作是原子的，即线程在操作value时不会被中断。 3. AtomicReference示例// AtomicReferenceTest.java的源码 import java.util.concurrent.atomic.AtomicReference; public class AtomicReferenceTest { public static void main(String[] args){ // 创建两个Person对象，它们的id分别是101和102。 Person p1 = new Person(101); Person p2 = new Person(102); // 新建AtomicReference对象，初始化它的值为p1对象 AtomicReference ar = new AtomicReference(p1); // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。 ar.compareAndSet(p1, p2); Person p3 = (Person)ar.get(); System.out.println(&quot;p3 is &quot;+p3); System.out.println(&quot;p3.equals(p1)=&quot;+p3.equals(p1)); } } class Person { volatile long id; public Person(long id) { this.id = id; } public String toString() { return &quot;id:&quot;+id; } } 运行结果： p3 is id:102 p3.equals(p1)=false 结果说明：新建AtomicReference对象ar时，将它初始化为p1。紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用”==”去比较两个对象，即比较两个对象的地址是否相等。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC原子类","slug":"JUC原子类","permalink":"https://smuwjs.github.io/tags/JUC原子类/"}]},{"title":"Java多线程系列--“JUC原子类”03之 AtomicLongArray原子类","date":"2016-11-12T19:00:00.000Z","path":"2016/11/13/java-source-analysis-multi-thread-series/Java多线程系列--“JUC原子类”03之 AtomicLongArray原子类/","text":"AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray这3个数组类型的原子类的原理和用法相似。本章以AtomicLongArray对数组类型的原子类进行介绍。 目录1. AtomicLongArray介绍和函数列表2. AtomicLongArray源码分析(基于JDK1.7.0_40)3. AtomicLongArray示例 1. AtomicLongArray介绍和函数列表在”Java多线程系列–“JUC原子类”02之 AtomicLong原子类”中介绍过，AtomicLong是作用是对长整形进行原子操作。而AtomicLongArray的作用则是对”长整形数组”进行原子操作。 AtomicLongArray函数列表 // 创建给定长度的新 AtomicLongArray。 AtomicLongArray(int length) // 创建与给定数组具有相同长度的新 AtomicLongArray，并从给定数组复制其所有元素。 AtomicLongArray(long[] array) // 以原子方式将给定值添加到索引 i 的元素。 long addAndGet(int i, long delta) // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean compareAndSet(int i, long expect, long update) // 以原子方式将索引 i 的元素减1。 long decrementAndGet(int i) // 获取位置 i 的当前值。 long get(int i) // 以原子方式将给定值与索引 i 的元素相加。 long getAndAdd(int i, long delta) // 以原子方式将索引 i 的元素减 1。 long getAndDecrement(int i) // 以原子方式将索引 i 的元素加 1。 long getAndIncrement(int i) // 以原子方式将位置 i 的元素设置为给定值，并返回旧值。 long getAndSet(int i, long newValue) // 以原子方式将索引 i 的元素加1。 long incrementAndGet(int i) // 最终将位置 i 的元素设置为给定值。 void lazySet(int i, long newValue) // 返回该数组的长度。 int length() // 将位置 i 的元素设置为给定值。 void set(int i, long newValue) // 返回数组当前值的字符串表示形式。 String toString() // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean weakCompareAndSet(int i, long expect, long update) 2. AtomicLongArray源码分析(基于JDK1.7.0_40)AtomicLongArray的完整源码 package java.util.concurrent.atomic; import sun.misc.Unsafe; import java.util.*; /** * A {@code long} array in which elements may be updated atomically. * See the {@link java.util.concurrent.atomic} package specification * for description of the properties of atomic variables. * @since 1.5 * @author Doug Lea */ public class AtomicLongArray implements java.io.Serializable { private static final long serialVersionUID = -2308431214976778248L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final int base = unsafe.arrayBaseOffset(long[].class); private static final int shift; private final long[] array; static { int scale = unsafe.arrayIndexScale(long[].class); if ((scale &amp; (scale - 1)) != 0) throw new Error(&quot;data type scale not a power of two&quot;); shift = 31 - Integer.numberOfLeadingZeros(scale); } private long checkedByteOffset(int i) { if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException(&quot;index &quot; + i); return byteOffset(i); } private static long byteOffset(int i) { return ((long) i &lt;&lt; shift) + base; } /** * Creates a new AtomicLongArray of the given length, with all * elements initially zero. * * @param length the length of the array */ public AtomicLongArray(int length) { array = new long[length]; } /** * Creates a new AtomicLongArray with the same length as, and * all elements copied from, the given array. * * @param array the array to copy elements from * @throws NullPointerException if array is null */ public AtomicLongArray(long[] array) { // Visibility guaranteed by final field guarantees this.array = array.clone(); } /** * Returns the length of the array. * * @return the length of the array */ public final int length() { return array.length; } /** * Gets the current value at position {@code i}. * * @param i the index * @return the current value */ public final long get(int i) { return getRaw(checkedByteOffset(i)); } private long getRaw(long offset) { return unsafe.getLongVolatile(array, offset); } /** * Sets the element at position {@code i} to the given value. * * @param i the index * @param newValue the new value */ public final void set(int i, long newValue) { unsafe.putLongVolatile(array, checkedByteOffset(i), newValue); } /** * Eventually sets the element at position {@code i} to the given value. * * @param i the index * @param newValue the new value * @since 1.6 */ public final void lazySet(int i, long newValue) { unsafe.putOrderedLong(array, checkedByteOffset(i), newValue); } /** * Atomically sets the element at position {@code i} to the given value * and returns the old value. * * @param i the index * @param newValue the new value * @return the previous value */ public final long getAndSet(int i, long newValue) { long offset = checkedByteOffset(i); while (true) { long current = getRaw(offset); if (compareAndSetRaw(offset, current, newValue)) return current; } } /** * Atomically sets the element at position {@code i} to the given * updated value if the current value {@code ==} the expected value. * * @param i the index * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(int i, long expect, long update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } private boolean compareAndSetRaw(long offset, long expect, long update) { return unsafe.compareAndSwapLong(array, offset, expect, update); } /** * Atomically sets the element at position {@code i} to the given * updated value if the current value {@code ==} the expected value. * * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to {@code compareAndSet}. * * @param i the index * @param expect the expected value * @param update the new value * @return true if successful. */ public final boolean weakCompareAndSet(int i, long expect, long update) { return compareAndSet(i, expect, update); } /** * Atomically increments by one the element at index {@code i}. * * @param i the index * @return the previous value */ public final long getAndIncrement(int i) { return getAndAdd(i, 1); } /** * Atomically decrements by one the element at index {@code i}. * * @param i the index * @return the previous value */ public final long getAndDecrement(int i) { return getAndAdd(i, -1); } /** * Atomically adds the given value to the element at index {@code i}. * * @param i the index * @param delta the value to add * @return the previous value */ public final long getAndAdd(int i, long delta) { long offset = checkedByteOffset(i); while (true) { long current = getRaw(offset); if (compareAndSetRaw(offset, current, current + delta)) return current; } } /** * Atomically increments by one the element at index {@code i}. * * @param i the index * @return the updated value */ public final long incrementAndGet(int i) { return addAndGet(i, 1); } /** * Atomically decrements by one the element at index {@code i}. * * @param i the index * @return the updated value */ public final long decrementAndGet(int i) { return addAndGet(i, -1); } /** * Atomically adds the given value to the element at index {@code i}. * * @param i the index * @param delta the value to add * @return the updated value */ public long addAndGet(int i, long delta) { long offset = checkedByteOffset(i); while (true) { long current = getRaw(offset); long next = current + delta; if (compareAndSetRaw(offset, current, next)) return next; } } /** * Returns the String representation of the current values of array. * @return the String representation of the current values of array */ public String toString() { int iMax = array.length - 1; if (iMax == -1) return &quot;[]&quot;; StringBuilder b = new StringBuilder(); b.append(&apos;[&apos;); for (int i = 0; ; i++) { b.append(getRaw(byteOffset(i))); if (i == iMax) return b.append(&apos;]&apos;).toString(); b.append(&apos;,&apos;).append(&apos; &apos;); } } } AtomicLongArray的代码很简单，下面仅以incrementAndGet()为例，对AtomicLong的原理进行说明。incrementAndGet()源码如下： public final long incrementAndGet(int i) { return addAndGet(i, 1); } 说明：incrementAndGet()的作用是以原子方式将long数组的索引 i 的元素加1，并返回加1之后的值。 addAndGet()源码如下： public long addAndGet(int i, long delta) { // 检查数组是否越界 long offset = checkedByteOffset(i); while (true) { // 获取long型数组的索引 offset 的原始值 long current = getRaw(offset); // 修改long型值 long next = current + delta; // 通过CAS更新long型数组的索引 offset的值。 if (compareAndSetRaw(offset, current, next)) return next; } } 说明：addAndGet()首先检查数组是否越界。如果没有越界的话，则先获取数组索引i的值；然后通过CAS函数更新i的值。 getRaw()源码如下： private long getRaw(long offset) { return unsafe.getLongVolatile(array, offset); } 说明：unsafe是通过Unsafe.getUnsafe()返回的一个Unsafe对象。通过Unsafe的CAS函数对long型数组的元素进行原子操作。如compareAndSetRaw()就是调用Unsafe的CAS函数，它的源码如下： private boolean compareAndSetRaw(long offset, long expect, long update) { return unsafe.compareAndSwapLong(array, offset, expect, update); } 3. AtomicLongArray示例// LongArrayTest.java的源码 import java.util.concurrent.atomic.AtomicLongArray; public class LongArrayTest { public static void main(String[] args){ // 新建AtomicLongArray对象 long[] arrLong = new long[] {10, 20, 30, 40, 50}; AtomicLongArray ala = new AtomicLongArray(arrLong); ala.set(0, 100); for (int i=0, len=ala.length(); i&lt;len; i++) System.out.printf(&quot;get(%d) : %s\\n&quot;, i, ala.get(i)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;getAndDecrement(0)&quot;, ala.getAndDecrement(0)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;decrementAndGet(1)&quot;, ala.decrementAndGet(1)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;getAndIncrement(2)&quot;, ala.getAndIncrement(2)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;incrementAndGet(3)&quot;, ala.incrementAndGet(3)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;addAndGet(100)&quot;, ala.addAndGet(0, 100)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;getAndAdd(100)&quot;, ala.getAndAdd(1, 100)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;compareAndSet()&quot;, ala.compareAndSet(2, 31, 1000)); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;get(2)&quot;, ala.get(2)); } } 运行结果： get(0) : 100 get(1) : 20 get(2) : 30 get(3) : 40 get(4) : 50 getAndDecrement(0) : 100 decrementAndGet(1) : 19 getAndIncrement(2) : 30 incrementAndGet(3) : 41 addAndGet(100) : 199 getAndAdd(100) : 19 compareAndSet() : true get(2) : 1000","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC原子类","slug":"JUC原子类","permalink":"https://smuwjs.github.io/tags/JUC原子类/"}]},{"title":"Java多线程系列--“JUC原子类”02之 AtomicLong原子类","date":"2016-11-12T18:00:00.000Z","path":"2016/11/13/java-source-analysis-multi-thread-series/Java多线程系列--“JUC原子类”02之 AtomicLong原子类/","text":"AtomicInteger,AtomicLong和AtomicBoolean这3个基本类型的原子类的原理和用法相似。本章以AtomicLong对基本类型的原子类进行介绍。 目录1. AtomicLong介绍和函数列表2. AtomicLong源码分析(基于JDK1.7.0_40)3. AtomicLong示例 1. AtomicLong介绍和函数列表AtomicLong是作用是对长整形进行原子操作。 在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。 AtomicLong函数列表 // 构造函数 AtomicLong() // 创建值为initialValue的AtomicLong对象 AtomicLong(long initialValue) // 以原子方式设置当前值为newValue。 final void set(long newValue) // 获取当前值 final long get() // 以原子方式将当前值减 1，并返回减1后的值。等价于“--num” final long decrementAndGet() // 以原子方式将当前值减 1，并返回减1前的值。等价于“num--” final long getAndDecrement() // 以原子方式将当前值加 1，并返回加1后的值。等价于“++num” final long incrementAndGet() // 以原子方式将当前值加 1，并返回加1前的值。等价于“num++” final long getAndIncrement() // 以原子方式将delta与当前值相加，并返回相加后的值。 final long addAndGet(long delta) // 以原子方式将delta添加到当前值，并返回相加前的值。 final long getAndAdd(long delta) // 如果当前值 == expect，则以原子方式将该值设置为update。成功返回true，否则返回false，并且不修改原值。 final boolean compareAndSet(long expect, long update) // 以原子方式设置当前值为newValue，并返回旧值。 final long getAndSet(long newValue) // 返回当前值对应的int值 int intValue() // 获取当前值对应的long值 long longValue() // 以 float 形式返回当前值 float floatValue() // 以 double 形式返回当前值 double doubleValue() // 最后设置为给定值。延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。 final void lazySet(long newValue) // 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。 final boolean weakCompareAndSet(long expect, long update) 2. AtomicLong源码分析(基于JDK1.7.0_40)AtomicLong的完整源码 package java.util.concurrent.atomic; import sun.misc.Unsafe; /** * A {@code long} value that may be updated atomically. See the * {@link java.util.concurrent.atomic} package specification for * description of the properties of atomic variables. An * {@code AtomicLong} is used in applications such as atomically * incremented sequence numbers, and cannot be used as a replacement * for a {@link java.lang.Long}. However, this class does extend * {@code Number} to allow uniform access by tools and utilities that * deal with numerically-based classes. * * @since 1.5 * @author Doug Lea */ public class AtomicLong extends Number implements java.io.Serializable { private static final long serialVersionUID = 1927816293512124184L; // setup to use Unsafe.compareAndSwapLong for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; /** * Records whether the underlying JVM supports lockless * compareAndSwap for longs. While the Unsafe.compareAndSwapLong * method works in either case, some constructions should be * handled at Java level to avoid locking user-visible locks. */ static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); /** * Returns whether underlying JVM supports lockless CompareAndSet * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS. */ private static native boolean VMSupportsCS8(); static { try { valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField(&quot;value&quot;)); } catch (Exception ex) { throw new Error(ex); } } private volatile long value; /** * Creates a new AtomicLong with the given initial value. * * @param initialValue the initial value */ public AtomicLong(long initialValue) { value = initialValue; } /** * Creates a new AtomicLong with initial value {@code 0}. */ public AtomicLong() { } /** * Gets the current value. * * @return the current value */ public final long get() { return value; } /** * Sets to the given value. * * @param newValue the new value */ public final void set(long newValue) { value = newValue; } /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(long newValue) { unsafe.putOrderedLong(this, valueOffset, newValue); } /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ public final long getAndSet(long newValue) { while (true) { long current = get(); if (compareAndSet(current, newValue)) return current; } } /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); } /** * Atomically sets the value to the given updated value * if the current value {@code ==} the expected value. * * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to {@code compareAndSet}. * * @param expect the expected value * @param update the new value * @return true if successful. */ public final boolean weakCompareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); } /** * Atomically increments by one the current value. * * @return the previous value */ public final long getAndIncrement() { while (true) { long current = get(); long next = current + 1; if (compareAndSet(current, next)) return current; } } /** * Atomically decrements by one the current value. * * @return the previous value */ public final long getAndDecrement() { while (true) { long current = get(); long next = current - 1; if (compareAndSet(current, next)) return current; } } /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final long getAndAdd(long delta) { while (true) { long current = get(); long next = current + delta; if (compareAndSet(current, next)) return current; } } /** * Atomically increments by one the current value. * * @return the updated value */ public final long incrementAndGet() { for (;;) { long current = get(); long next = current + 1; if (compareAndSet(current, next)) return next; } } /** * Atomically decrements by one the current value. * * @return the updated value */ public final long decrementAndGet() { for (;;) { long current = get(); long next = current - 1; if (compareAndSet(current, next)) return next; } } /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final long addAndGet(long delta) { for (;;) { long current = get(); long next = current + delta; if (compareAndSet(current, next)) return next; } } /** * Returns the String representation of the current value. * @return the String representation of the current value. */ public String toString() { return Long.toString(get()); } public int intValue() { return (int)get(); } public long longValue() { return get(); } public float floatValue() { return (float)get(); } public double doubleValue() { return (double)get(); } } AtomicLong的代码很简单，下面仅以incrementAndGet()为例，对AtomicLong的原理进行说明。 incrementAndGet()源码如下： public final long incrementAndGet() { for (;;) { // 获取AtomicLong当前对应的long值 long current = get(); // 将current加1 long next = current + 1; // 通过CAS函数，更新current的值 if (compareAndSet(current, next)) return next; } } 说明：(01) incrementAndGet()首先会根据get()获取AtomicLong对应的long值。该值是volatile类型的变量，get()的源码如下： // value是AtomicLong对应的long值 private volatile long value; // 返回AtomicLong对应的long值 public final long get() { return value; } (02) incrementAndGet()接着将current加1,然后通过CAS函数，将新的值赋值给value。compareAndSet()的源码如下： public final boolean compareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); } compareAndSet()的作用是更新AtomicLong对应的long值。它会比较AtomicLong的原始值是否与expect相等，若相等的话，则设置AtomicLong的值为update。 3. AtomicLong示例// LongTest.java的源码 import java.util.concurrent.atomic.AtomicLong; public class LongTest { public static void main(String[] args){ // 新建AtomicLong对象 AtomicLong mAtoLong = new AtomicLong(); mAtoLong.set(0x0123456789ABCDEFL); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;get()&quot;, mAtoLong.get()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;intValue()&quot;, mAtoLong.intValue()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;longValue()&quot;, mAtoLong.longValue()); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;doubleValue()&quot;, mAtoLong.doubleValue()); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;floatValue()&quot;, mAtoLong.floatValue()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;getAndDecrement()&quot;, mAtoLong.getAndDecrement()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;decrementAndGet()&quot;, mAtoLong.decrementAndGet()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;getAndIncrement()&quot;, mAtoLong.getAndIncrement()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;incrementAndGet()&quot;, mAtoLong.incrementAndGet()); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;addAndGet(0x10)&quot;, mAtoLong.addAndGet(0x10)); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;getAndAdd(0x10)&quot;, mAtoLong.getAndAdd(0x10)); System.out.printf(&quot;\\n%20s : 0x%016X\\n&quot;, &quot;get()&quot;, mAtoLong.get()); System.out.printf(&quot;%20s : %s\\n&quot;, &quot;compareAndSet()&quot;, mAtoLong.compareAndSet(0x12345679L, 0xFEDCBA9876543210L)); System.out.printf(&quot;%20s : 0x%016X\\n&quot;, &quot;get()&quot;, mAtoLong.get()); } } 运行结果： get() : 0x0123456789ABCDEF intValue() : 0x0000000089ABCDEF longValue() : 0x0123456789ABCDEF doubleValue() : 8.1985529216486896E16 floatValue() : 8.1985531E16 getAndDecrement() : 0x0123456789ABCDEF decrementAndGet() : 0x0123456789ABCDED getAndIncrement() : 0x0123456789ABCDED incrementAndGet() : 0x0123456789ABCDEF addAndGet(0x10) : 0x0123456789ABCDFF getAndAdd(0x10) : 0x0123456789ABCDFF get() : 0x0123456789ABCE0F compareAndSet() : false get() : 0x0123456789ABCE0F","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC原子类","slug":"JUC原子类","permalink":"https://smuwjs.github.io/tags/JUC原子类/"}]},{"title":"Java多线程系列--“JUC原子类”01之 框架","date":"2016-11-12T17:00:00.000Z","path":"2016/11/13/java-source-analysis-multi-thread-series/Java多线程系列--“JUC原子类”01之 框架/","text":"根据修改的数据类型，可以将JUC包中的原子操作类可以分为4类。 基本类型: AtomicInteger, AtomicLong, AtomicBoolean ; 数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ; 引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ; 对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。 这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”10之 ConcurrentHashMap","date":"2016-11-12T02:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”10之 ConcurrentHashMap/","text":"本章对Java.util.concurrent包中的ConcurrentHashMap类进行详细的介绍。 目录1. ConcurrentLinkedQueue介绍2. ConcurrentLinkedQueue原理和数据结构3. ConcurrentLinkedQueue函数列表4. ConcurrentLinkedQueue源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1 创建&nbsp;&nbsp;&nbsp;&nbsp; 4.2 添加&nbsp;&nbsp;&nbsp;&nbsp; 4.3 删除5. ConcurrentLinkedQueue示例 1. ConcurrentLinkedQueue介绍ConcurrentLinkedQueue是线程安全的队列，它适用于“高并发”的场景。 它是一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置null元素（内部实现的特殊节点除外）。 2. ConcurrentLinkedQueue原理和数据结构ConcurrentLinkedQueue的数据结构，如下图所示： img 说明：(1) ConcurrentLinkedQueue继承于AbstractQueue。(2) ConcurrentLinkedQueue内部是通过链表来实现的。它同时包含链表的头节点head和尾节点tail。ConcurrentLinkedQueue按照 FIFO（先进先出）原则对元素进行排序。元素都是从尾部插入到链表，从头部开始返回。(3) ConcurrentLinkedQueue的链表Node中的next的类型是volatile，而且链表数据item的类型也是volatile。关于volatile，我们知道它的语义包含：“即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入”。ConcurrentLinkedQueue就是通过volatile来实现多线程对竞争资源的互斥访问的。 3. ConcurrentLinkedQueue函数列表// 创建一个最初为空的 ConcurrentLinkedQueue。 ConcurrentLinkedQueue() // 创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素。 ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c) // 将指定元素插入此队列的尾部。 boolean add(E e) // 如果此队列包含指定元素，则返回 true。 boolean contains(Object o) // 如果此队列不包含任何元素，则返回 true。 boolean isEmpty() // 返回在此队列元素上以恰当顺序进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 将指定元素插入此队列的尾部。 boolean offer(E e) // 获取但不移除此队列的头；如果此队列为空，则返回 null。 E peek() // 获取并移除此队列的头，如果此队列为空，则返回 null。 E poll() // 从队列中移除指定元素的单个实例（如果存在）。 boolean remove(Object o) // 返回此队列中的元素数量。 int size() // 返回以恰当顺序包含此队列所有元素的数组。 Object[] toArray() // 返回以恰当顺序包含此队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 &lt;T&gt; T[] toArray(T[] a) 4. ConcurrentLinkedQueue源码分析(JDK1.7.0_40版本)ConcurrentLinkedQueue的完整源码如下： package java.util.concurrent; import java.util.AbstractQueue; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue; public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Queue&lt;E&gt;, java.io.Serializable { private static final long serialVersionUID = 196745693267521676L; /* * This is a modification of the Michael &amp; Scott algorithm, * adapted for a garbage-collected environment, with support for * interior node deletion (to support remove(Object)). For * explanation, read the paper. * * Note that like most non-blocking algorithms in this package, * this implementation relies on the fact that in garbage * collected systems, there is no possibility of ABA problems due * to recycled nodes, so there is no need to use &quot;counted * pointers&quot; or related techniques seen in versions used in * non-GC&apos;ed settings. * * The fundamental invariants are: * - There is exactly one (last) Node with a null next reference, * which is CASed when enqueueing. This last Node can be * reached in O(1) time from tail, but tail is merely an * optimization - it can always be reached in O(N) time from * head as well. * - The elements contained in the queue are the non-null items in * Nodes that are reachable from head. CASing the item * reference of a Node to null atomically removes it from the * queue. Reachability of all elements from head must remain * true even in the case of concurrent modifications that cause * head to advance. A dequeued Node may remain in use * indefinitely due to creation of an Iterator or simply a * poll() that has lost its time slice. * * The above might appear to imply that all Nodes are GC-reachable * from a predecessor dequeued Node. That would cause two problems: * - allow a rogue Iterator to cause unbounded memory retention * - cause cross-generational linking of old Nodes to new Nodes if * a Node was tenured while live, which generational GCs have a * hard time dealing with, causing repeated major collections. * However, only non-deleted Nodes need to be reachable from * dequeued Nodes, and reachability does not necessarily have to * be of the kind understood by the GC. We use the trick of * linking a Node that has just been dequeued to itself. Such a * self-link implicitly means to advance to head. * * Both head and tail are permitted to lag. In fact, failing to * update them every time one could is a significant optimization * (fewer CASes). As with LinkedTransferQueue (see the internal * documentation for that class), we use a slack threshold of two; * that is, we update head/tail when the current pointer appears * to be two or more steps away from the first/last node. * * Since head and tail are updated concurrently and independently, * it is possible for tail to lag behind head (why not)? * * CASing a Node&apos;s item reference to null atomically removes the * element from the queue. Iterators skip over Nodes with null * items. Prior implementations of this class had a race between * poll() and remove(Object) where the same element would appear * to be successfully removed by two concurrent operations. The * method remove(Object) also lazily unlinks deleted Nodes, but * this is merely an optimization. * * When constructing a Node (before enqueuing it) we avoid paying * for a volatile write to item by using Unsafe.putObject instead * of a normal write. This allows the cost of enqueue to be * &quot;one-and-a-half&quot; CASes. * * Both head and tail may or may not point to a Node with a * non-null item. If the queue is empty, all items must of course * be null. Upon creation, both head and tail refer to a dummy * Node with null item. Both head and tail are only updated using * CAS, so they never regress, although again this is merely an * optimization. */ private static class Node&lt;E&gt; { volatile E item; volatile Node&lt;E&gt; next; /** * Constructs a new node. Uses relaxed write because item can * only be seen after publication via casNext. */ Node(E item) { UNSAFE.putObject(this, itemOffset, item); } boolean casItem(E cmp, E val) { return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); } void lazySetNext(Node&lt;E&gt; val) { UNSAFE.putOrderedObject(this, nextOffset, val); } boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); } catch (Exception e) { throw new Error(e); } } } /** * A node from which the first live (non-deleted) node (if any) * can be reached in O(1) time. * Invariants: * - all live nodes are reachable from head via succ() * - head != null * - (tmp = head).next != tmp || tmp != head * Non-invariants: * - head.item may or may not be null. * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! */ private transient volatile Node&lt;E&gt; head; /** * A node from which the last node on list (that is, the unique * node with node.next == null) can be reached in O(1) time. * Invariants: * - the last node is always reachable from tail via succ() * - tail != null * Non-invariants: * - tail.item may or may not be null. * - it is permitted for tail to lag behind head, that is, for tail * to not be reachable from head! * - tail.next may or may not be self-pointing to tail. */ private transient volatile Node&lt;E&gt; tail; /** * Creates a {@code ConcurrentLinkedQueue} that is initially empty. */ public ConcurrentLinkedQueue() { head = tail = new Node&lt;E&gt;(null); } /** * Creates a {@code ConcurrentLinkedQueue} * initially containing the elements of the given collection, * added in traversal order of the collection&apos;s iterator. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any * of its elements are null */ public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c) { Node&lt;E&gt; h = null, t = null; for (E e : c) { checkNotNull(e); Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); if (h == null) h = t = newNode; else { t.lazySetNext(newNode); t = newNode; } } if (h == null) h = t = new Node&lt;E&gt;(null); head = h; tail = t; } // Have to override just to update the javadoc /** * Inserts the specified element at the tail of this queue. * As the queue is unbounded, this method will never throw * {@link IllegalStateException} or return {@code false}. * * @return {@code true} (as specified by {@link Collection#add}) * @throws NullPointerException if the specified element is null */ public boolean add(E e) { return offer(e); } /** * Try to CAS head to p. If successful, repoint old head to itself * as sentinel for succ(), below. */ final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) { if (h != p &amp;&amp; casHead(h, p)) h.lazySetNext(h); } /** * Returns the successor of p, or the head node if p.next has been * linked to self, which will only be true if traversing with a * stale pointer that is now off the list. */ final Node&lt;E&gt; succ(Node&lt;E&gt; p) { Node&lt;E&gt; next = p.next; return (p == next) ? head : next; } /** * Inserts the specified element at the tail of this queue. * As the queue is unbounded, this method will never return {@code false}. * * @return {@code true} (as specified by {@link Queue#offer}) * @throws NullPointerException if the specified element is null */ public boolean offer(E e) { checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); for (Node&lt;E&gt; t = tail, p = t;;) { Node&lt;E&gt; q = p.next; if (q == null) { // p is last node if (p.casNext(null, newNode)) { // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become &quot;live&quot;. if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; } // Lost CAS race to another thread; re-read next } else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; } } public E poll() { restartFromHead: for (;;) { for (Node&lt;E&gt; h = head, p = h, q;;) { E item = p.item; if (item != null &amp;&amp; p.casItem(item, null)) { // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; } else if ((q = p.next) == null) { updateHead(h, p); return null; } else if (p == q) continue restartFromHead; else p = q; } } } public E peek() { restartFromHead: for (;;) { for (Node&lt;E&gt; h = head, p = h, q;;) { E item = p.item; if (item != null || (q = p.next) == null) { updateHead(h, p); return item; } else if (p == q) continue restartFromHead; else p = q; } } } /** * Returns the first live (non-deleted) node on list, or null if none. * This is yet another variant of poll/peek; here returning the * first node, not element. We could make peek() a wrapper around * first(), but that would cost an extra volatile read of item, * and the need to add a retry loop to deal with the possibility * of losing a race to a concurrent poll(). */ Node&lt;E&gt; first() { restartFromHead: for (;;) { for (Node&lt;E&gt; h = head, p = h, q;;) { boolean hasItem = (p.item != null); if (hasItem || (q = p.next) == null) { updateHead(h, p); return hasItem ? p : null; } else if (p == q) continue restartFromHead; else p = q; } } } /** * Returns {@code true} if this queue contains no elements. * * @return {@code true} if this queue contains no elements */ public boolean isEmpty() { return first() == null; } /** * Returns the number of elements in this queue. If this queue * contains more than {@code Integer.MAX_VALUE} elements, returns * {@code Integer.MAX_VALUE}. * * &lt;p&gt;Beware that, unlike in most collections, this method is * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the * asynchronous nature of these queues, determining the current * number of elements requires an O(n) traversal. * Additionally, if elements are added or removed during execution * of this method, the returned result may be inaccurate. Thus, * this method is typically not very useful in concurrent * applications. * * @return the number of elements in this queue */ public int size() { int count = 0; for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) if (p.item != null) // Collection.size() spec says to max out if (++count == Integer.MAX_VALUE) break; return count; } /** * Returns {@code true} if this queue contains the specified element. * More formally, returns {@code true} if and only if this queue contains * at least one element {@code e} such that {@code o.equals(e)}. * * @param o object to be checked for containment in this queue * @return {@code true} if this queue contains the specified element */ public boolean contains(Object o) { if (o == null) return false; for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) { E item = p.item; if (item != null &amp;&amp; o.equals(item)) return true; } return false; } /** * Removes a single instance of the specified element from this queue, * if it is present. More formally, removes an element {@code e} such * that {@code o.equals(e)}, if this queue contains one or more such * elements. * Returns {@code true} if this queue contained the specified element * (or equivalently, if this queue changed as a result of the call). * * @param o element to be removed from this queue, if present * @return {@code true} if this queue changed as a result of the call */ public boolean remove(Object o) { if (o == null) return false; Node&lt;E&gt; pred = null; for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) { E item = p.item; if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null)) { Node&lt;E&gt; next = succ(p); if (pred != null &amp;&amp; next != null) pred.casNext(p, next); return true; } pred = p; } return false; } /** * Appends all of the elements in the specified collection to the end of * this queue, in the order that they are returned by the specified * collection&apos;s iterator. Attempts to {@code addAll} of a queue to * itself result in {@code IllegalArgumentException}. * * @param c the elements to be inserted into this queue * @return {@code true} if this queue changed as a result of the call * @throws NullPointerException if the specified collection or any * of its elements are null * @throws IllegalArgumentException if the collection is this queue */ public boolean addAll(Collection&lt;? extends E&gt; c) { if (c == this) // As historically specified in AbstractQueue#addAll throw new IllegalArgumentException(); // Copy c into a private chain of Nodes Node&lt;E&gt; beginningOfTheEnd = null, last = null; for (E e : c) { checkNotNull(e); Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); if (beginningOfTheEnd == null) beginningOfTheEnd = last = newNode; else { last.lazySetNext(newNode); last = newNode; } } if (beginningOfTheEnd == null) return false; // Atomically append the chain at the tail of this collection for (Node&lt;E&gt; t = tail, p = t;;) { Node&lt;E&gt; q = p.next; if (q == null) { // p is last node if (p.casNext(null, beginningOfTheEnd)) { // Successful CAS is the linearization point // for all elements to be added to this queue. if (!casTail(t, last)) { // Try a little harder to update tail, // since we may be adding many elements. t = tail; if (last.next == null) casTail(t, last); } return true; } // Lost CAS race to another thread; re-read next } else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; } } /** * Returns an array containing all of the elements in this queue, in * proper sequence. * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this queue. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this queue */ public Object[] toArray() { // Use ArrayList to deal with resizing. ArrayList&lt;E&gt; al = new ArrayList&lt;E&gt;(); for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) { E item = p.item; if (item != null) al.add(item); } return al.toArray(); } /** * Returns an array containing all of the elements in this queue, in * proper sequence; the runtime type of the returned array is that of * the specified array. If the queue fits in the specified array, it * is returned therein. Otherwise, a new array is allocated with the * runtime type of the specified array and the size of this queue. * * &lt;p&gt;If this queue fits in the specified array with room to spare * (i.e., the array has more elements than this queue), the element in * the array immediately following the end of the queue is set to * {@code null}. * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose {@code x} is a queue known to contain only strings. * The following code can be used to dump the queue into a newly * allocated array of {@code String}: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that {@code toArray(new Object[0])} is identical in function to * {@code toArray()}. * * @param a the array into which the elements of the queue are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose * @return an array containing all of the elements in this queue * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this queue * @throws NullPointerException if the specified array is null */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) { // try to use sent-in array int k = 0; Node&lt;E&gt; p; for (p = first(); p != null &amp;&amp; k &lt; a.length; p = succ(p)) { E item = p.item; if (item != null) a[k++] = (T)item; } if (p == null) { if (k &lt; a.length) a[k] = null; return a; } // If won&apos;t fit, use ArrayList version ArrayList&lt;E&gt; al = new ArrayList&lt;E&gt;(); for (Node&lt;E&gt; q = first(); q != null; q = succ(q)) { E item = q.item; if (item != null) al.add(item); } return al.toArray(a); } /** * Returns an iterator over the elements in this queue in proper sequence. * The elements will be returned in order from first (head) to last (tail). * * &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that * will never throw {@link java.util.ConcurrentModificationException * ConcurrentModificationException}, and guarantees to traverse * elements as they existed upon construction of the iterator, and * may (but is not guaranteed to) reflect any modifications * subsequent to construction. * * @return an iterator over the elements in this queue in proper sequence */ public Iterator&lt;E&gt; iterator() { return new Itr(); } private class Itr implements Iterator&lt;E&gt; { /** * Next node to return item for. */ private Node&lt;E&gt; nextNode; /** * nextItem holds on to item fields because once we claim * that an element exists in hasNext(), we must return it in * the following next() call even if it was in the process of * being removed when hasNext() was called. */ private E nextItem; /** * Node of the last returned item, to support remove. */ private Node&lt;E&gt; lastRet; Itr() { advance(); } /** * Moves to next valid node and returns item to return for * next(), or null if no such. */ private E advance() { lastRet = nextNode; E x = nextItem; Node&lt;E&gt; pred, p; if (nextNode == null) { p = first(); pred = null; } else { pred = nextNode; p = succ(nextNode); } for (;;) { if (p == null) { nextNode = null; nextItem = null; return x; } E item = p.item; if (item != null) { nextNode = p; nextItem = item; return x; } else { // skip over nulls Node&lt;E&gt; next = succ(p); if (pred != null &amp;&amp; next != null) pred.casNext(p, next); p = next; } } } public boolean hasNext() { return nextNode != null; } public E next() { if (nextNode == null) throw new NoSuchElementException(); return advance(); } public void remove() { Node&lt;E&gt; l = lastRet; if (l == null) throw new IllegalStateException(); // rely on a future traversal to relink. l.item = null; lastRet = null; } } /** * Saves the state to a stream (that is, serializes it). * * @serialData All of the elements (each an {@code E}) in * the proper order, followed by a null * @param s the stream */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden stuff s.defaultWriteObject(); // Write out all elements in the proper order. for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) { Object item = p.item; if (item != null) s.writeObject(item); } // Use trailing null as sentinel s.writeObject(null); } /** * Reconstitutes the instance from a stream (that is, deserializes it). * @param s the stream */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Read in elements until trailing null sentinel found Node&lt;E&gt; h = null, t = null; Object item; while ((item = s.readObject()) != null) { @SuppressWarnings(&quot;unchecked&quot;) Node&lt;E&gt; newNode = new Node&lt;E&gt;((E) item); if (h == null) h = t = newNode; else { t.lazySetNext(newNode); t = newNode; } } if (h == null) h = t = new Node&lt;E&gt;(null); head = h; tail = t; } /** * Throws NullPointerException if argument is null. * * @param v the element */ private static void checkNotNull(Object v) { if (v == null) throw new NullPointerException(); } private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val); } private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long headOffset; private static final long tailOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = ConcurrentLinkedQueue.class; headOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;head&quot;)); tailOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;tail&quot;)); } catch (Exception e) { throw new Error(e); } } } 下面从ConcurrentLinkedQueue的创建，添加，删除这几个方面对它进行分析。 4.1 创建下面以ConcurrentLinkedQueue()来进行说明。 public ConcurrentLinkedQueue() { head = tail = new Node&lt;E&gt;(null); } 说明：在构造函数中，新建了一个“内容为null的节点”，并设置表头head和表尾tail的值为新节点。 head和tail的定义如下： private transient volatile Node&lt;E&gt; head; private transient volatile Node&lt;E&gt; tail; head和tail都是volatile类型，他们具有volatile赋予的含义：“即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入”。 Node的声明如下： private static class Node&lt;E&gt; { volatile E item; volatile Node&lt;E&gt; next; Node(E item) { UNSAFE.putObject(this, itemOffset, item); } boolean casItem(E cmp, E val) { return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); } void lazySetNext(Node&lt;E&gt; val) { UNSAFE.putOrderedObject(this, nextOffset, val); } boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); } catch (Exception e) { throw new Error(e); } } } 说明：Node是个单向链表节点，next用于指向下一个Node，item用于存储数据。Node中操作节点数据的API，都是通过Unsafe机制的CAS函数实现的；例如casNext()是通过CAS函数“比较并设置节点的下一个节点”。 4.2 添加下面以add(E e)为例对ConcurrentLinkedQueue中的添加进行说明。 public boolean add(E e) { return offer(e); } 说明：add()实际上是调用的offer()来完成添加操作的。 offer()的源码如下： public boolean offer(E e) { // 检查e是不是null，是的话抛出NullPointerException异常。 checkNotNull(e); // 创建新的节点 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); // 将“新的节点”添加到链表的末尾。 for (Node&lt;E&gt; t = tail, p = t;;) { Node&lt;E&gt; q = p.next; // 情况1：q为空 if (q == null) { // CAS操作：如果“p的下一个节点为null”(即p为尾节点)，则设置p的下一个节点为newNode。 // 如果该CAS操作成功的话，则比较“p和t”(若p不等于t，则设置newNode为新的尾节点)，然后返回true。 // 如果该CAS操作失败，这意味着“其它线程对尾节点进行了修改”，则重新循环。 if (p.casNext(null, newNode)) { if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; } } // 情况2：p和q相等 else if (p == q) p = (t != (t = tail)) ? t : head; // 情况3：其它 else p = (p != t &amp;&amp; t != (t = tail)) ? t : q; } } 说明：offer(E e)的作用就是将元素e添加到链表的末尾。offer()比较的地方是理解for循环，下面区分3种情况对for进行分析。 情况1 – q为空。这意味着q是尾节点的下一个节点。此时，通过p.casNext(null, newNode)将“p的下一个节点设为newNode”，若设置成功的话，则比较“p和t”(若p不等于t，则设置newNode为新的尾节点)，然后返回true。否则的话(意味着“其它线程对尾节点进行了修改”)，什么也不做，继续进行for循环。p.casNext(null, newNode)，是调用CAS对p进行操作。若“p的下一个节点等于null”，则设置“p的下一个节点等于newNode”；设置成功的话，返回true，失败的话返回false。 情况2 – p和q相等。这种情况什么时候会发生呢？通过“情况3”，我们知道，经过“情况3”的处理后，p的值可能等于q。此时，若尾节点没有发生变化的话，那么，应该是头节点发生了变化，则设置p为头节点，然后重新遍历链表；否则(尾节点变化的话)，则设置p为尾节点。 情况3 – 其它。我们将p = (p != t &amp;&amp; t != (t = tail)) ? t : q;转换成如下代码。 if (p==t) { p = q; } else { Node&lt;E&gt; tmp=t; t = tail; if (tmp==t) { p=q; } else { p=t; } } 如果p和t相等，则设置p为q。否则的话，判断“尾节点是否发生变化”，没有变化的话，则设置p为q；否则，设置p为尾节点。 checkNotNull()的源码如下： private static void checkNotNull(Object v) { if (v == null) throw new NullPointerException(); } 4.3 删除下面以poll()为例对ConcurrentLinkedQueue中的删除进行说明。 public E poll() { // 设置“标记” restartFromHead: for (;;) { for (Node&lt;E&gt; h = head, p = h, q;;) { E item = p.item; // 情况1 // 表头的数据不为null，并且“设置表头的数据为null”这个操作成功的话; // 则比较“p和h”(若p!=h，即表头发生了变化，则更新表头，即设置表头为p)，然后返回原表头的item值。 if (item != null &amp;&amp; p.casItem(item, null)) { if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; } // 情况2 // 表头的下一个节点为null，即链表只有一个“内容为null的表头节点”。则更新表头为p，并返回null。 else if ((q = p.next) == null) { updateHead(h, p); return null; } // 情况3 // 这可能到由于“情况4”的发生导致p=q，在该情况下跳转到restartFromHead标记重新操作。 else if (p == q) continue restartFromHead; // 情况4 // 设置p为q else p = q; } } } 说明：poll()的作用就是删除链表的表头节点，并返回被删节点对应的值。poll()的实现原理和offer()比较类似，下面根将or循环划分为4种情况进行分析。 情况1：“表头节点的数据”不为null，并且“设置表头节点的数据为null”这个操作成功。 p.casItem(item, null) – 调用CAS函数，比较“节点p的数据值”与item是否相等，是的话，设置节点p的数据值为null。在情况1发生时，先比较“p和h”，若p!=h，即表头发生了变化，则调用updateHead()更新表头；然后返回删除节点的item值。 updateHead()的源码如下： final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) { if (h != p &amp;&amp; casHead(h, p)) h.lazySetNext(h); } 说明：updateHead()的最终目的是更新表头为p，并设置h的下一个节点为h本身。casHead(h,p)是通过CAS函数设置表头，若表头等于h的话，则设置表头为p。lazySetNext()的源码如下： void lazySetNext(Node&lt;E&gt; val) { UNSAFE.putOrderedObject(this, nextOffset, val); } putOrderedObject()函数，我们在前面一章“TODO”中介绍过。h.lazySetNext(h)的作用是通过CAS函数设置h的下一个节点为h自身，该设置可能会延迟执行。 情况2：如果表头的下一个节点为null，即链表只有一个“内容为null的表头节点”。 则调用updateHead(h, p)，将表头更新p；然后返回null。 情况3：p=q 在“情况4”的发生后，会导致p=q；此时，“情况3”就会发生。当“情况3”发生后，它会跳转到restartFromHead标记重新操作。 情况4：其它情况。 设置p=q。 5. ConcurrentLinkedQueue示例import java.util.*; import java.util.concurrent.*; /* * ConcurrentLinkedQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是ConcurrentLinkedQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class ConcurrentLinkedQueueDemo1 { // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对queue进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String value; Iterator iter = queue.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); } } } } (某一次)运行结果： ta1, ta1, tb1, tb1, ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta3, tb3, ta3, ta1, tb3, tb1, ta4, ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta4, ta3, tb4, tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta5, tb3, tb5, ta4, ta1, tb4, tb1, ta5, ta2, tb5, tb2, ta6, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta6, ta4, tb6, tb4, ta5, tb5, ta6, tb6, 结果说明：如果将源码中的queue改成LinkedList对象时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”09之 LinkedBlockingDeque","date":"2016-11-12T01:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”09之 LinkedBlockingDeque/","text":"本章介绍JUC包中的LinkedBlockingDeque。 目录1. LinkedBlockingDeque介绍2. LinkedBlockingDeque原理和数据结构3. LinkedBlockingDeque函数列表4. LinkedBlockingDeque源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1 创建&nbsp;&nbsp;&nbsp;&nbsp; 4.2 添加&nbsp;&nbsp;&nbsp;&nbsp; 4.3 删除&nbsp;&nbsp;&nbsp;&nbsp; 4.4 遍历5. LinkedBlockingDeque示例 1. LinkedBlockingDeque介绍LinkedBlockingDeque是双向链表实现的双向并发阻塞队列。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)；并且，该阻塞队列是支持线程安全。 此外，LinkedBlockingDeque还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。 2. LinkedBlockingDeque原理和数据结构LinkedBlockingDeque的数据结构，如下图所示： img 说明：(1) LinkedBlockingDeque继承于AbstractQueue，它本质上是一个支持FIFO和FILO的双向的队列。(2) LinkedBlockingDeque实现了BlockingDeque接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。(3) LinkedBlockingDeque是通过双向链表实现的。&nbsp;&nbsp;&nbsp;&nbsp; (3.1) first是双向链表的表头。&nbsp;&nbsp;&nbsp;&nbsp; (3.2) last是双向链表的表尾。&nbsp;&nbsp;&nbsp;&nbsp; (3.3) count是LinkedBlockingDeque的实际大小，即双向链表中当前节点个数。&nbsp;&nbsp;&nbsp;&nbsp; (3.4) capacity是LinkedBlockingDeque的容量，它是在创建LinkedBlockingDeque时指定的。&nbsp;&nbsp;&nbsp;&nbsp; (3.5) lock是控制对LinkedBlockingDeque的互斥锁，当多个线程竞争同时访问LinkedBlockingDeque时，某线程获取到了互斥锁lock，其它线程则需要阻塞等待，直到该线程释放lock，其它线程才有机会获取lock从而获取cpu执行权。&nbsp;&nbsp;&nbsp;&nbsp; (3.6) notEmpty和notFull分别是“非空条件”和“未满条件”。通过它们能够更加细腻进行并发控制。 – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。– 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 关于ReentrantLock，公平锁，非公平锁，以及Condition等更多的内容，可以参考前面的文章。 3. LinkedBlockingDeque函数列表// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque。 LinkedBlockingDeque() // 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque，最初包含给定 collection 的元素，以该 collection 迭代器的遍历顺序添加。 LinkedBlockingDeque(Collection&lt;? extends E&gt; c) // 创建一个具有给定（固定）容量的 LinkedBlockingDeque。 LinkedBlockingDeque(int capacity) // 在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾。 boolean add(E e) // 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头；如果当前没有空间可用，则抛出 IllegalStateException。 void addFirst(E e) // 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾；如果当前没有空间可用，则抛出 IllegalStateException。 void addLast(E e) // 以原子方式 (atomically) 从此双端队列移除所有元素。 void clear() // 如果此双端队列包含指定的元素，则返回 true。 boolean contains(Object o) // 返回在此双端队列的元素上以逆向连续顺序进行迭代的迭代器。 Iterator&lt;E&gt; descendingIterator() // 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。 int drainTo(Collection&lt;? super E&gt; c) // 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。 int drainTo(Collection&lt;? super E&gt; c, int maxElements) // 获取但不移除此双端队列表示的队列的头部。 E element() // 获取，但不移除此双端队列的第一个元素。 E getFirst() // 获取，但不移除此双端队列的最后一个元素。 E getLast() // 返回在此双端队列元素上以恰当顺序进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），并在成功时返回 true；如果当前没有空间可用，则返回 false。 boolean offer(E e) // 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将在指定的等待时间内一直等待可用空间。 boolean offer(E e, long timeout, TimeUnit unit) // 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头，并在成功时返回 true；如果当前没有空间可用，则返回 false。 boolean offerFirst(E e) // 将指定的元素插入此双端队列的开头，必要时将在指定的等待时间内等待可用空间。 boolean offerFirst(E e, long timeout, TimeUnit unit) // 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾，并在成功时返回 true；如果当前没有空间可用，则返回 false。 boolean offerLast(E e) // 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间。 boolean offerLast(E e, long timeout, TimeUnit unit) // 获取但不移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。 E peek() // 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。 E peekFirst() // 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。 E peekLast() // 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。 E poll() // 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），如有必要将在指定的等待时间内等待可用元素。 E poll(long timeout, TimeUnit unit) // 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。 E pollFirst() // 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素。 E pollFirst(long timeout, TimeUnit unit) // 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。 E pollLast() // 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素。 E pollLast(long timeout, TimeUnit unit) // 从此双端队列所表示的堆栈中弹出一个元素。 E pop() // 将元素推入此双端队列表示的栈。 void push(E e) // 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将一直等待可用空间。 void put(E e) // 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。 void putFirst(E e) // 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。 void putLast(E e) // 返回理想情况下（没有内存和资源约束）此双端队列可不受阻塞地接受的额外元素数。 int remainingCapacity() // 获取并移除此双端队列表示的队列的头部。 E remove() // 从此双端队列移除第一次出现的指定元素。 boolean remove(Object o) // 获取并移除此双端队列第一个元素。 E removeFirst() // 从此双端队列移除第一次出现的指定元素。 boolean removeFirstOccurrence(Object o) // 获取并移除此双端队列的最后一个元素。 E removeLast() // 从此双端队列移除最后一次出现的指定元素。 boolean removeLastOccurrence(Object o) // 返回此双端队列中的元素数。 int size() // 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），必要时将一直等待可用元素。 E take() // 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素。 E takeFirst() // 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素。 E takeLast() // 返回以恰当顺序（从第一个元素到最后一个元素）包含此双端队列所有元素的数组。 Object[] toArray() // 返回以恰当顺序包含此双端队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 &lt;T&gt; T[] toArray(T[] a) // 返回此 collection 的字符串表示形式。 String toString() 4. LinkedBlockingDeque源码分析(JDK1.7.0_40版本)LinkedBlockingDeque.java的完整源码如下： package java.util.concurrent; import java.util.AbstractQueue; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; /** * An optionally-bounded {@linkplain BlockingDeque blocking deque} based on * linked nodes. * * &lt;p&gt; The optional capacity bound constructor argument serves as a * way to prevent excessive expansion. The capacity, if unspecified, * is equal to {@link Integer#MAX_VALUE}. Linked nodes are * dynamically created upon each insertion unless this would bring the * deque above capacity. * * &lt;p&gt;Most operations run in constant time (ignoring time spent * blocking). Exceptions include {@link #remove(Object) remove}, * {@link #removeFirstOccurrence removeFirstOccurrence}, {@link * #removeLastOccurrence removeLastOccurrence}, {@link #contains * contains}, {@link #iterator iterator.remove()}, and the bulk * operations, all of which run in linear time. * * &lt;p&gt;This class and its iterator implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link * Iterator} interfaces. * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @since 1.6 * @author Doug Lea * @param &lt;E&gt; the type of elements held in this collection */ public class LinkedBlockingDeque&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingDeque&lt;E&gt;, java.io.Serializable { /* * Implemented as a simple doubly-linked list protected by a * single lock and using conditions to manage blocking. * * To implement weakly consistent iterators, it appears we need to * keep all Nodes GC-reachable from a predecessor dequeued Node. * That would cause two problems: * - allow a rogue Iterator to cause unbounded memory retention * - cause cross-generational linking of old Nodes to new Nodes if * a Node was tenured while live, which generational GCs have a * hard time dealing with, causing repeated major collections. * However, only non-deleted Nodes need to be reachable from * dequeued Nodes, and reachability does not necessarily have to * be of the kind understood by the GC. We use the trick of * linking a Node that has just been dequeued to itself. Such a * self-link implicitly means to jump to &quot;first&quot; (for next links) * or &quot;last&quot; (for prev links). */ /* * We have &quot;diamond&quot; multiple interface/abstract class inheritance * here, and that introduces ambiguities. Often we want the * BlockingDeque javadoc combined with the AbstractQueue * implementation, so a lot of method specs are duplicated here. */ private static final long serialVersionUID = -387911632671998426L; /** Doubly-linked list node class */ static final class Node&lt;E&gt; { /** * The item, or null if this node has been removed. */ E item; /** * One of: * - the real predecessor Node * - this Node, meaning the predecessor is tail * - null, meaning there is no predecessor */ Node&lt;E&gt; prev; /** * One of: * - the real successor Node * - this Node, meaning the successor is head * - null, meaning there is no successor */ Node&lt;E&gt; next; Node(E x) { item = x; } } /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; /** Number of items in the deque */ private transient int count; /** Maximum number of items in the deque */ private final int capacity; /** Main lock guarding all access */ final ReentrantLock lock = new ReentrantLock(); /** Condition for waiting takes */ private final Condition notEmpty = lock.newCondition(); /** Condition for waiting puts */ private final Condition notFull = lock.newCondition(); /** * Creates a {@code LinkedBlockingDeque} with a capacity of * {@link Integer#MAX_VALUE}. */ public LinkedBlockingDeque() { this(Integer.MAX_VALUE); } /** * Creates a {@code LinkedBlockingDeque} with the given (fixed) capacity. * * @param capacity the capacity of this deque * @throws IllegalArgumentException if {@code capacity} is less than 1 */ public LinkedBlockingDeque(int capacity) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; } /** * Creates a {@code LinkedBlockingDeque} with a capacity of * {@link Integer#MAX_VALUE}, initially containing the elements of * the given collection, added in traversal order of the * collection&apos;s iterator. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any * of its elements are null */ public LinkedBlockingDeque(Collection&lt;? extends E&gt; c) { this(Integer.MAX_VALUE); final ReentrantLock lock = this.lock; lock.lock(); // Never contended, but necessary for visibility try { for (E e : c) { if (e == null) throw new NullPointerException(); if (!linkLast(new Node&lt;E&gt;(e))) throw new IllegalStateException(&quot;Deque full&quot;); } } finally { lock.unlock(); } } // Basic linking and unlinking operations, called only while holding lock /** * Links node as first element, or returns false if full. */ private boolean linkFirst(Node&lt;E&gt; node) { // assert lock.isHeldByCurrentThread(); if (count &gt;= capacity) return false; Node&lt;E&gt; f = first; node.next = f; first = node; if (last == null) last = node; else f.prev = node; ++count; notEmpty.signal(); return true; } /** * Links node as last element, or returns false if full. */ private boolean linkLast(Node&lt;E&gt; node) { // assert lock.isHeldByCurrentThread(); if (count &gt;= capacity) return false; Node&lt;E&gt; l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; ++count; notEmpty.signal(); return true; } /** * Removes and returns first element, or null if empty. */ private E unlinkFirst() { // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; f = first; if (f == null) return null; Node&lt;E&gt; n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; --count; notFull.signal(); return item; } /** * Removes and returns last element, or null if empty. */ private E unlinkLast() { // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; l = last; if (l == null) return null; Node&lt;E&gt; p = l.prev; E item = l.item; l.item = null; l.prev = l; // help GC last = p; if (p == null) first = null; else p.next = null; --count; notFull.signal(); return item; } /** * Unlinks x. */ void unlink(Node&lt;E&gt; x) { // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; p = x.prev; Node&lt;E&gt; n = x.next; if (p == null) { unlinkFirst(); } else if (n == null) { unlinkLast(); } else { p.next = n; n.prev = p; x.item = null; // Don&apos;t mess with x&apos;s links. They may still be in use by // an iterator. --count; notFull.signal(); } } // BlockingDeque methods /** * @throws IllegalStateException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void addFirst(E e) { if (!offerFirst(e)) throw new IllegalStateException(&quot;Deque full&quot;); } /** * @throws IllegalStateException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void addLast(E e) { if (!offerLast(e)) throw new IllegalStateException(&quot;Deque full&quot;); } /** * @throws NullPointerException {@inheritDoc} */ public boolean offerFirst(E e) { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try { return linkFirst(node); } finally { lock.unlock(); } } /** * @throws NullPointerException {@inheritDoc} */ public boolean offerLast(E e) { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try { return linkLast(node); } finally { lock.unlock(); } } /** * @throws NullPointerException {@inheritDoc} * @throws InterruptedException {@inheritDoc} */ public void putFirst(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try { while (!linkFirst(node)) notFull.await(); } finally { lock.unlock(); } } /** * @throws NullPointerException {@inheritDoc} * @throws InterruptedException {@inheritDoc} */ public void putLast(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try { while (!linkLast(node)) notFull.await(); } finally { lock.unlock(); } } /** * @throws NullPointerException {@inheritDoc} * @throws InterruptedException {@inheritDoc} */ public boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (!linkFirst(node)) { if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); } return true; } finally { lock.unlock(); } } /** * @throws NullPointerException {@inheritDoc} * @throws InterruptedException {@inheritDoc} */ public boolean offerLast(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (!linkLast(node)) { if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); } return true; } finally { lock.unlock(); } } /** * @throws NoSuchElementException {@inheritDoc} */ public E removeFirst() { E x = pollFirst(); if (x == null) throw new NoSuchElementException(); return x; } /** * @throws NoSuchElementException {@inheritDoc} */ public E removeLast() { E x = pollLast(); if (x == null) throw new NoSuchElementException(); return x; } public E pollFirst() { final ReentrantLock lock = this.lock; lock.lock(); try { return unlinkFirst(); } finally { lock.unlock(); } } public E pollLast() { final ReentrantLock lock = this.lock; lock.lock(); try { return unlinkLast(); } finally { lock.unlock(); } } public E takeFirst() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lock(); try { E x; while ( (x = unlinkFirst()) == null) notEmpty.await(); return x; } finally { lock.unlock(); } } public E takeLast() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lock(); try { E x; while ( (x = unlinkLast()) == null) notEmpty.await(); return x; } finally { lock.unlock(); } } public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { E x; while ( (x = unlinkFirst()) == null) { if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); } return x; } finally { lock.unlock(); } } public E pollLast(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { E x; while ( (x = unlinkLast()) == null) { if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); } return x; } finally { lock.unlock(); } } /** * @throws NoSuchElementException {@inheritDoc} */ public E getFirst() { E x = peekFirst(); if (x == null) throw new NoSuchElementException(); return x; } /** * @throws NoSuchElementException {@inheritDoc} */ public E getLast() { E x = peekLast(); if (x == null) throw new NoSuchElementException(); return x; } public E peekFirst() { final ReentrantLock lock = this.lock; lock.lock(); try { return (first == null) ? null : first.item; } finally { lock.unlock(); } } public E peekLast() { final ReentrantLock lock = this.lock; lock.lock(); try { return (last == null) ? null : last.item; } finally { lock.unlock(); } } public boolean removeFirstOccurrence(Object o) { if (o == null) return false; final ReentrantLock lock = this.lock; lock.lock(); try { for (Node&lt;E&gt; p = first; p != null; p = p.next) { if (o.equals(p.item)) { unlink(p); return true; } } return false; } finally { lock.unlock(); } } public boolean removeLastOccurrence(Object o) { if (o == null) return false; final ReentrantLock lock = this.lock; lock.lock(); try { for (Node&lt;E&gt; p = last; p != null; p = p.prev) { if (o.equals(p.item)) { unlink(p); return true; } } return false; } finally { lock.unlock(); } } // BlockingQueue methods /** * Inserts the specified element at the end of this deque unless it would * violate capacity restrictions. When using a capacity-restricted deque, * it is generally preferable to use method {@link #offer(Object) offer}. * * &lt;p&gt;This method is equivalent to {@link #addLast}. * * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws NullPointerException if the specified element is null */ public boolean add(E e) { addLast(e); return true; } /** * @throws NullPointerException if the specified element is null */ public boolean offer(E e) { return offerLast(e); } /** * @throws NullPointerException {@inheritDoc} * @throws InterruptedException {@inheritDoc} */ public void put(E e) throws InterruptedException { putLast(e); } /** * @throws NullPointerException {@inheritDoc} * @throws InterruptedException {@inheritDoc} */ public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { return offerLast(e, timeout, unit); } /** * Retrieves and removes the head of the queue represented by this deque. * This method differs from {@link #poll poll} only in that it throws an * exception if this deque is empty. * * &lt;p&gt;This method is equivalent to {@link #removeFirst() removeFirst}. * * @return the head of the queue represented by this deque * @throws NoSuchElementException if this deque is empty */ public E remove() { return removeFirst(); } public E poll() { return pollFirst(); } public E take() throws InterruptedException { return takeFirst(); } public E poll(long timeout, TimeUnit unit) throws InterruptedException { return pollFirst(timeout, unit); } /** * Retrieves, but does not remove, the head of the queue represented by * this deque. This method differs from {@link #peek peek} only in that * it throws an exception if this deque is empty. * * &lt;p&gt;This method is equivalent to {@link #getFirst() getFirst}. * * @return the head of the queue represented by this deque * @throws NoSuchElementException if this deque is empty */ public E element() { return getFirst(); } public E peek() { return peekFirst(); } /** * Returns the number of additional elements that this deque can ideally * (in the absence of memory or resource constraints) accept without * blocking. This is always equal to the initial capacity of this deque * less the current {@code size} of this deque. * * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert * an element will succeed by inspecting {@code remainingCapacity} * because it may be the case that another thread is about to * insert or remove an element. */ public int remainingCapacity() { final ReentrantLock lock = this.lock; lock.lock(); try { return capacity - count; } finally { lock.unlock(); } } /** * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public int drainTo(Collection&lt;? super E&gt; c) { return drainTo(c, Integer.MAX_VALUE); } /** * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public int drainTo(Collection&lt;? super E&gt; c, int maxElements) { if (c == null) throw new NullPointerException(); if (c == this) throw new IllegalArgumentException(); final ReentrantLock lock = this.lock; lock.lock(); try { int n = Math.min(maxElements, count); for (int i = 0; i &lt; n; i++) { c.add(first.item); // In this order, in case add() throws. unlinkFirst(); } return n; } finally { lock.unlock(); } } // Stack methods /** * @throws IllegalStateException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void push(E e) { addFirst(e); } /** * @throws NoSuchElementException {@inheritDoc} */ public E pop() { return removeFirst(); } // Collection methods /** * Removes the first occurrence of the specified element from this deque. * If the deque does not contain the element, it is unchanged. * More formally, removes the first element {@code e} such that * {@code o.equals(e)} (if such an element exists). * Returns {@code true} if this deque contained the specified element * (or equivalently, if this deque changed as a result of the call). * * &lt;p&gt;This method is equivalent to * {@link #removeFirstOccurrence(Object) removeFirstOccurrence}. * * @param o element to be removed from this deque, if present * @return {@code true} if this deque changed as a result of the call */ public boolean remove(Object o) { return removeFirstOccurrence(o); } /** * Returns the number of elements in this deque. * * @return the number of elements in this deque */ public int size() { final ReentrantLock lock = this.lock; lock.lock(); try { return count; } finally { lock.unlock(); } } /** * Returns {@code true} if this deque contains the specified element. * More formally, returns {@code true} if and only if this deque contains * at least one element {@code e} such that {@code o.equals(e)}. * * @param o object to be checked for containment in this deque * @return {@code true} if this deque contains the specified element */ public boolean contains(Object o) { if (o == null) return false; final ReentrantLock lock = this.lock; lock.lock(); try { for (Node&lt;E&gt; p = first; p != null; p = p.next) if (o.equals(p.item)) return true; return false; } finally { lock.unlock(); } } /* * TODO: Add support for more efficient bulk operations. * * We don&apos;t want to acquire the lock for every iteration, but we * also want other threads a chance to interact with the * collection, especially when count is close to capacity. */ // /** // * Adds all of the elements in the specified collection to this // * queue. Attempts to addAll of a queue to itself result in // * {@code IllegalArgumentException}. Further, the behavior of // * this operation is undefined if the specified collection is // * modified while the operation is in progress. // * // * @param c collection containing elements to be added to this queue // * @return {@code true} if this queue changed as a result of the call // * @throws ClassCastException {@inheritDoc} // * @throws NullPointerException {@inheritDoc} // * @throws IllegalArgumentException {@inheritDoc} // * @throws IllegalStateException {@inheritDoc} // * @see #add(Object) // */ // public boolean addAll(Collection&lt;? extends E&gt; c) { // if (c == null) // throw new NullPointerException(); // if (c == this) // throw new IllegalArgumentException(); // final ReentrantLock lock = this.lock; // lock.lock(); // try { // boolean modified = false; // for (E e : c) // if (linkLast(e)) // modified = true; // return modified; // } finally { // lock.unlock(); // } // } /** * Returns an array containing all of the elements in this deque, in * proper sequence (from first to last element). * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this deque. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this deque */ @SuppressWarnings(&quot;unchecked&quot;) public Object[] toArray() { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] a = new Object[count]; int k = 0; for (Node&lt;E&gt; p = first; p != null; p = p.next) a[k++] = p.item; return a; } finally { lock.unlock(); } } /** * Returns an array containing all of the elements in this deque, in * proper sequence; the runtime type of the returned array is that of * the specified array. If the deque fits in the specified array, it * is returned therein. Otherwise, a new array is allocated with the * runtime type of the specified array and the size of this deque. * * &lt;p&gt;If this deque fits in the specified array with room to spare * (i.e., the array has more elements than this deque), the element in * the array immediately following the end of the deque is set to * {@code null}. * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose {@code x} is a deque known to contain only strings. * The following code can be used to dump the deque into a newly * allocated array of {@code String}: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that {@code toArray(new Object[0])} is identical in function to * {@code toArray()}. * * @param a the array into which the elements of the deque are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose * @return an array containing all of the elements in this deque * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this deque * @throws NullPointerException if the specified array is null */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) { final ReentrantLock lock = this.lock; lock.lock(); try { if (a.length &lt; count) a = (T[])java.lang.reflect.Array.newInstance (a.getClass().getComponentType(), count); int k = 0; for (Node&lt;E&gt; p = first; p != null; p = p.next) a[k++] = (T)p.item; if (a.length &gt; k) a[k] = null; return a; } finally { lock.unlock(); } } public String toString() { final ReentrantLock lock = this.lock; lock.lock(); try { Node&lt;E&gt; p = first; if (p == null) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append(&apos;[&apos;); for (;;) { E e = p.item; sb.append(e == this ? &quot;(this Collection)&quot; : e); p = p.next; if (p == null) return sb.append(&apos;]&apos;).toString(); sb.append(&apos;,&apos;).append(&apos; &apos;); } } finally { lock.unlock(); } } /** * Atomically removes all of the elements from this deque. * The deque will be empty after this call returns. */ public void clear() { final ReentrantLock lock = this.lock; lock.lock(); try { for (Node&lt;E&gt; f = first; f != null; ) { f.item = null; Node&lt;E&gt; n = f.next; f.prev = null; f.next = null; f = n; } first = last = null; count = 0; notFull.signalAll(); } finally { lock.unlock(); } } /** * Returns an iterator over the elements in this deque in proper sequence. * The elements will be returned in order from first (head) to last (tail). * * &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that * will never throw {@link java.util.ConcurrentModificationException * ConcurrentModificationException}, and guarantees to traverse * elements as they existed upon construction of the iterator, and * may (but is not guaranteed to) reflect any modifications * subsequent to construction. * * @return an iterator over the elements in this deque in proper sequence */ public Iterator&lt;E&gt; iterator() { return new Itr(); } /** * Returns an iterator over the elements in this deque in reverse * sequential order. The elements will be returned in order from * last (tail) to first (head). * * &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that * will never throw {@link java.util.ConcurrentModificationException * ConcurrentModificationException}, and guarantees to traverse * elements as they existed upon construction of the iterator, and * may (but is not guaranteed to) reflect any modifications * subsequent to construction. * * @return an iterator over the elements in this deque in reverse order */ public Iterator&lt;E&gt; descendingIterator() { return new DescendingItr(); } /** * Base class for Iterators for LinkedBlockingDeque */ private abstract class AbstractItr implements Iterator&lt;E&gt; { /** * The next node to return in next() */ Node&lt;E&gt; next; /** * nextItem holds on to item fields because once we claim that * an element exists in hasNext(), we must return item read * under lock (in advance()) even if it was in the process of * being removed when hasNext() was called. */ E nextItem; /** * Node returned by most recent call to next. Needed by remove. * Reset to null if this element is deleted by a call to remove. */ private Node&lt;E&gt; lastRet; abstract Node&lt;E&gt; firstNode(); abstract Node&lt;E&gt; nextNode(Node&lt;E&gt; n); AbstractItr() { // set to initial position final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try { next = firstNode(); nextItem = (next == null) ? null : next.item; } finally { lock.unlock(); } } /** * Returns the successor node of the given non-null, but * possibly previously deleted, node. */ private Node&lt;E&gt; succ(Node&lt;E&gt; n) { // Chains of deleted nodes ending in null or self-links // are possible if multiple interior nodes are removed. for (;;) { Node&lt;E&gt; s = nextNode(n); if (s == null) return null; else if (s.item != null) return s; else if (s == n) return firstNode(); else n = s; } } /** * Advances next. */ void advance() { final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try { // assert next != null; next = succ(next); nextItem = (next == null) ? null : next.item; } finally { lock.unlock(); } } public boolean hasNext() { return next != null; } public E next() { if (next == null) throw new NoSuchElementException(); lastRet = next; E x = nextItem; advance(); return x; } public void remove() { Node&lt;E&gt; n = lastRet; if (n == null) throw new IllegalStateException(); lastRet = null; final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try { if (n.item != null) unlink(n); } finally { lock.unlock(); } } } /** Forward iterator */ private class Itr extends AbstractItr { Node&lt;E&gt; firstNode() { return first; } Node&lt;E&gt; nextNode(Node&lt;E&gt; n) { return n.next; } } /** Descending iterator */ private class DescendingItr extends AbstractItr { Node&lt;E&gt; firstNode() { return last; } Node&lt;E&gt; nextNode(Node&lt;E&gt; n) { return n.prev; } } /** * Save the state of this deque to a stream (that is, serialize it). * * @serialData The capacity (int), followed by elements (each an * {@code Object}) in the proper order, followed by a null * @param s the stream */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { final ReentrantLock lock = this.lock; lock.lock(); try { // Write out capacity and any hidden stuff s.defaultWriteObject(); // Write out all elements in the proper order. for (Node&lt;E&gt; p = first; p != null; p = p.next) s.writeObject(p.item); // Use trailing null as sentinel s.writeObject(null); } finally { lock.unlock(); } } /** * Reconstitute this deque from a stream (that is, * deserialize it). * @param s the stream */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); count = 0; first = null; last = null; // Read in all elements and place in queue for (;;) { @SuppressWarnings(&quot;unchecked&quot;) E item = (E)s.readObject(); if (item == null) break; add(item); } } } 下面从ArrayBlockingQueue的创建，添加，取出，遍历这几个方面对LinkedBlockingDeque进行分析 4.1 创建下面以LinkedBlockingDeque(int capacity)来进行说明。 public LinkedBlockingDeque(int capacity) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; } 说明：capacity是“链式阻塞队列”的容量。 LinkedBlockingDeque中相关的数据结果定义如下： // “双向队列”的表头 transient Node&lt;E&gt; first; // “双向队列”的表尾 transient Node&lt;E&gt; last; // 节点数量 private transient int count; // 容量 private final int capacity; // 互斥锁 , 互斥锁对应的“非空条件notEmpty”, 互斥锁对应的“未满条件notFull” final ReentrantLock lock = new ReentrantLock(); private final Condition notEmpty = lock.newCondition(); private final Condition notFull = lock.newCondition(); 说明：lock是互斥锁，用于控制多线程对LinkedBlockingDeque中元素的互斥访问；而notEmpty和notFull是与lock绑定的条件，它们用于实现对多线程更精确的控制。 双向链表的节点Node的定义如下： static final class Node&lt;E&gt; { E item; // 数据 Node&lt;E&gt; prev; // 前一节点 Node&lt;E&gt; next; // 后一节点 Node(E x) { item = x; } } 4.2 添加下面以offer(E e)为例，对LinkedBlockingDeque的添加方法进行说明。 public boolean offer(E e) { return offerLast(e); } offer()实际上是调用offerLast()将元素添加到队列的末尾。 offerLast()的源码如下： public boolean offerLast(E e) { if (e == null) throw new NullPointerException(); // 新建节点 Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 将“新节点”添加到双向链表的末尾 return linkLast(node); } finally { // 释放锁 lock.unlock(); } } 说明：offerLast()的作用，是新建节点并将该节点插入到双向链表的末尾。它在插入节点前，会获取锁；操作完毕，再释放锁。 linkLast()的源码如下： private boolean linkLast(Node&lt;E&gt; node) { // 如果“双向链表的节点数量” &gt; “容量”，则返回false，表示插入失败。 if (count &gt;= capacity) return false; // 将“node添加到链表末尾”，并设置node为新的尾节点 Node&lt;E&gt; l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; // 将“节点数量”+1 ++count; // 插入节点之后，唤醒notEmpty上的等待线程。 notEmpty.signal(); return true; } 说明：linkLast()的作用，是将节点插入到双向队列的末尾；插入节点之后，唤醒notEmpty上的等待线程。 4.3 删除下面以take()为例，对LinkedBlockingDeque的取出方法进行说明。 public E take() throws InterruptedException { return takeFirst(); } take()实际上是调用takeFirst()队列的第一个元素。 takeFirst()的源码如下： public E takeFirst() throws InterruptedException { final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { E x; // 若“队列为空”，则一直等待。否则，通过unlinkFirst()删除第一个节点。 while ( (x = unlinkFirst()) == null) notEmpty.await(); return x; } finally { // 释放锁 lock.unlock(); } } 说明：takeFirst()的作用，是删除双向链表的第一个节点，并返回节点对应的值。它在插入节点前，会获取锁；操作完毕，再释放锁。 unlinkFirst()的源码如下： private E unlinkFirst() { // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; f = first; if (f == null) return null; // 删除并更新“第一个节点” Node&lt;E&gt; n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; // 将“节点数量”-1 --count; // 删除节点之后，唤醒notFull上的等待线程。 notFull.signal(); return item; } 说明：unlinkFirst()的作用，是将双向队列的第一个节点删除；删除节点之后，唤醒notFull上的等待线程。 4.4 遍历下面对LinkedBlockingDeque的遍历方法进行说明。 public Iterator&lt;E&gt; iterator() { return new Itr(); } iterator()实际上是返回一个Iter对象。 Itr类的定义如下： private class Itr extends AbstractItr { // “双向队列”的表头 Node&lt;E&gt; firstNode() { return first; } // 获取“节点n的下一个节点” Node&lt;E&gt; nextNode(Node&lt;E&gt; n) { return n.next; } } Itr继承于AbstractItr，而AbstractItr的定义如下： private abstract class AbstractItr implements Iterator&lt;E&gt; { // next是下一次调用next()会返回的节点。 Node&lt;E&gt; next; // nextItem是next()返回节点对应的数据。 E nextItem; // 上一次next()返回的节点。 private Node&lt;E&gt; lastRet; // 返回第一个节点 abstract Node&lt;E&gt; firstNode(); // 返回下一个节点 abstract Node&lt;E&gt; nextNode(Node&lt;E&gt; n); AbstractItr() { final ReentrantLock lock = LinkedBlockingDeque.this.lock; // 获取“LinkedBlockingDeque的互斥锁” lock.lock(); try { // 获取“双向队列”的表头 next = firstNode(); // 获取表头对应的数据 nextItem = (next == null) ? null : next.item; } finally { // 释放“LinkedBlockingDeque的互斥锁” lock.unlock(); } } // 获取n的后继节点 private Node&lt;E&gt; succ(Node&lt;E&gt; n) { // Chains of deleted nodes ending in null or self-links // are possible if multiple interior nodes are removed. for (;;) { Node&lt;E&gt; s = nextNode(n); if (s == null) return null; else if (s.item != null) return s; else if (s == n) return firstNode(); else n = s; } } // 更新next和nextItem。 void advance() { final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try { // assert next != null; next = succ(next); nextItem = (next == null) ? null : next.item; } finally { lock.unlock(); } } // 返回“下一个节点是否为null” public boolean hasNext() { return next != null; } // 返回下一个节点 public E next() { if (next == null) throw new NoSuchElementException(); lastRet = next; E x = nextItem; advance(); return x; } // 删除下一个节点 public void remove() { Node&lt;E&gt; n = lastRet; if (n == null) throw new IllegalStateException(); lastRet = null; final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try { if (n.item != null) unlink(n); } finally { lock.unlock(); } } } 5. LinkedBlockingDeque示例import java.util.*; import java.util.concurrent.*; /* * LinkedBlockingDeque是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是LinkedBlockingDeque对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class LinkedBlockingDequeDemo1 { // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new LinkedBlockingDeque&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对queue进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String value; Iterator iter = queue.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); } } } } (某一次)运行结果： ta1, ta1, tb1, tb1, ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, tb3, tb3, ta3, ta3, ta1, tb1, ta1, tb2, tb1, ta2, tb2, tb3, ta2, ta3, tb3, tb4, ta3, ta4, tb4, ta1, ta4, tb1, tb5, tb2, ta1, ta2, tb1, tb3, tb2, ta3, ta2, tb4, tb3, ta4, ta3, tb5, tb4, ta5, ta4, ta1, tb5, tb1, ta5, tb2, tb6, ta2, ta1, tb3, tb1, ta3, tb2, tb4, ta2, ta4, tb3, tb5, ta3, ta5, tb4, tb6, ta4, ta6, tb5, ta5, tb6, ta6, 结果说明：示例程序中，启动两个线程(线程ta和线程tb)分别对LinkedBlockingDeque进行操作。以线程ta而言，它会先获取“线程名”+“序号”，然后将该字符串添加到LinkedBlockingDeque中；接着，遍历并输出LinkedBlockingDeque中的全部元素。 线程tb的操作和线程ta一样，只不过线程tb的名字和线程ta的名字不同。当queue是LinkedBlockingDeque对象时，程序能正常运行。如果将queue改为LinkedList时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”08之 LinkedBlockingQueue","date":"2016-11-12T00:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”08之 LinkedBlockingQueue/","text":"本章介绍JUC包中的LinkedBlockingQueue。 目录1. LinkedBlockingQueue介绍2. LinkedBlockingQueue原理和数据结构3. LinkedBlockingQueue函数列表4. LinkedBlockingQueue源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1 创建&nbsp;&nbsp;&nbsp;&nbsp; 4.2 添加&nbsp;&nbsp;&nbsp;&nbsp; 4.3 取出&nbsp;&nbsp;&nbsp;&nbsp; 4.4 遍历5. LinkedBlockingQueue示例 1. LinkedBlockingQueue介绍LinkedBlockingQueue是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 此外，LinkedBlockingQueue还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。 2. LinkedBlockingQueue原理和数据结构LinkedBlockingQueue的数据结构，如下图所示： img 说明：(1) LinkedBlockingQueue继承于AbstractQueue，它本质上是一个FIFO(先进先出)的队列。(2) LinkedBlockingQueue实现了BlockingQueue接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。(3) LinkedBlockingQueue是通过单链表实现的。&nbsp;&nbsp;&nbsp;&nbsp; 3.a) head是链表的表头。取出数据时，都是从表头head处插入。&nbsp;&nbsp;&nbsp;&nbsp; 3.b) last是链表的表尾。新增数据时，都是从表尾last处插入。&nbsp;&nbsp;&nbsp;&nbsp; 3.c) count是链表的实际大小，即当前链表中包含的节点个数。&nbsp;&nbsp;&nbsp;&nbsp; 3.d) capacity是列表的容量，它是在创建链表时指定的。&nbsp;&nbsp;&nbsp;&nbsp; 3.e) putLock是插入锁，takeLock是取出锁；notEmpty是“非空条件”，notFull是“未满条件”。通过它们对链表进行并发控制。&nbsp;&nbsp;&nbsp;&nbsp; LinkedBlockingQueue在实现“多线程对竞争资源的互斥访问”时，对于“插入”和“取出(删除)”操作分别使用了不同的锁。对于插入操作，通过“插入锁putLock”进行同步；对于取出操作，通过“取出锁takeLock”进行同步。&nbsp;&nbsp;&nbsp;&nbsp; 此外，插入锁putLock和“非满条件notFull”相关联，取出锁takeLock和“非空条件notEmpty”相关联。通过notFull和notEmpty更细腻的控制锁。 – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。– 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 关于ReentrantLock 和 Condition的内容，可以参考之前的章节。 3. LinkedBlockingQueue函数列表// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue。 LinkedBlockingQueue() // 创建一个容量是 Integer.MAX_VALUE 的 LinkedBlockingQueue，最初包含给定 collection 的元素，元素按该 collection 迭代器的遍历顺序添加。 LinkedBlockingQueue(Collection&lt;? extends E&gt; c) // 创建一个具有给定（固定）容量的 LinkedBlockingQueue。 LinkedBlockingQueue(int capacity) // 从队列彻底移除所有元素。 void clear() // 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。 int drainTo(Collection&lt;? super E&gt; c) // 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。 int drainTo(Collection&lt;? super E&gt; c, int maxElements) // 返回在队列中的元素上按适当顺序进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 将指定元素插入到此队列的尾部（如果立即可行且不会超出此队列的容量），在成功时返回 true，如果此队列已满，则返回 false。 boolean offer(E e) // 将指定元素插入到此队列的尾部，如有必要，则等待指定的时间以使空间变得可用。 boolean offer(E e, long timeout, TimeUnit unit) // 获取但不移除此队列的头；如果此队列为空，则返回 null。 E peek() // 获取并移除此队列的头，如果此队列为空，则返回 null。 E poll() // 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。 E poll(long timeout, TimeUnit unit) // 将指定元素插入到此队列的尾部，如有必要，则等待空间变得可用。 void put(E e) // 返回理想情况下（没有内存和资源约束）此队列可接受并且不会被阻塞的附加元素数量。 int remainingCapacity() // 从此队列移除指定元素的单个实例（如果存在）。 boolean remove(Object o) // 返回队列中的元素个数。 int size() // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。 E take() // 返回按适当顺序包含此队列中所有元素的数组。 Object[] toArray() // 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 &lt;T&gt; T[] toArray(T[] a) // 返回此 collection 的字符串表示形式。 String toString() 4. LinkedBlockingQueue源码分析(JDK1.7.0_40版本)LinkedBlockingQueue.java的完整源码如下： package java.util.concurrent; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; import java.util.AbstractQueue; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; /** * An optionally-bounded {@linkplain BlockingQueue blocking queue} based on * linked nodes. * This queue orders elements FIFO (first-in-first-out). * The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the * queue the longest time. * The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the * queue the shortest time. New elements * are inserted at the tail of the queue, and the queue retrieval * operations obtain elements at the head of the queue. * Linked queues typically have higher throughput than array-based queues but * less predictable performance in most concurrent applications. * * &lt;p&gt; The optional capacity bound constructor argument serves as a * way to prevent excessive queue expansion. The capacity, if unspecified, * is equal to {@link Integer#MAX_VALUE}. Linked nodes are * dynamically created upon each insertion unless this would bring the * queue above capacity. * * &lt;p&gt;This class and its iterator implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link * Iterator} interfaces. * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @since 1.5 * @author Doug Lea * @param &lt;E&gt; the type of elements held in this collection * */ public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable { private static final long serialVersionUID = -6903933977591709194L; /* * A variant of the &quot;two lock queue&quot; algorithm. The putLock gates * entry to put (and offer), and has an associated condition for * waiting puts. Similarly for the takeLock. The &quot;count&quot; field * that they both rely on is maintained as an atomic to avoid * needing to get both locks in most cases. Also, to minimize need * for puts to get takeLock and vice-versa, cascading notifies are * used. When a put notices that it has enabled at least one take, * it signals taker. That taker in turn signals others if more * items have been entered since the signal. And symmetrically for * takes signalling puts. Operations such as remove(Object) and * iterators acquire both locks. * * Visibility between writers and readers is provided as follows: * * Whenever an element is enqueued, the putLock is acquired and * count updated. A subsequent reader guarantees visibility to the * enqueued Node by either acquiring the putLock (via fullyLock) * or by acquiring the takeLock, and then reading n = count.get(); * this gives visibility to the first n items. * * To implement weakly consistent iterators, it appears we need to * keep all Nodes GC-reachable from a predecessor dequeued Node. * That would cause two problems: * - allow a rogue Iterator to cause unbounded memory retention * - cause cross-generational linking of old Nodes to new Nodes if * a Node was tenured while live, which generational GCs have a * hard time dealing with, causing repeated major collections. * However, only non-deleted Nodes need to be reachable from * dequeued Nodes, and reachability does not necessarily have to * be of the kind understood by the GC. We use the trick of * linking a Node that has just been dequeued to itself. Such a * self-link implicitly means to advance to head.next. */ /** * Linked list node class */ static class Node&lt;E&gt; { E item; /** * One of: * - the real successor Node * - this Node, meaning the successor is head.next * - null, meaning there is no successor (this is the last node) */ Node&lt;E&gt; next; Node(E x) { item = x; } } /** The capacity bound, or Integer.MAX_VALUE if none */ private final int capacity; /** Current number of elements */ private final AtomicInteger count = new AtomicInteger(0); /** * Head of linked list. * Invariant: head.item == null */ private transient Node&lt;E&gt; head; /** * Tail of linked list. * Invariant: last.next == null */ private transient Node&lt;E&gt; last; /** Lock held by take, poll, etc */ private final ReentrantLock takeLock = new ReentrantLock(); /** Wait queue for waiting takes */ private final Condition notEmpty = takeLock.newCondition(); /** Lock held by put, offer, etc */ private final ReentrantLock putLock = new ReentrantLock(); /** Wait queue for waiting puts */ private final Condition notFull = putLock.newCondition(); /** * Signals a waiting take. Called only from put/offer (which do not * otherwise ordinarily lock takeLock.) */ private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { notEmpty.signal(); } finally { takeLock.unlock(); } } /** * Signals a waiting put. Called only from take/poll. */ private void signalNotFull() { final ReentrantLock putLock = this.putLock; putLock.lock(); try { notFull.signal(); } finally { putLock.unlock(); } } /** * Links node at end of queue. * * @param node the node */ private void enqueue(Node&lt;E&gt; node) { // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node; } /** * Removes a node from head of queue. * * @return the node */ private E dequeue() { // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x; } /** * Lock to prevent both puts and takes. */ void fullyLock() { putLock.lock(); takeLock.lock(); } /** * Unlock to allow both puts and takes. */ void fullyUnlock() { takeLock.unlock(); putLock.unlock(); } // /** // * Tells whether both locks are held by current thread. // */ // boolean isFullyLocked() { // return (putLock.isHeldByCurrentThread() &amp;&amp; // takeLock.isHeldByCurrentThread()); // } /** * Creates a {@code LinkedBlockingQueue} with a capacity of * {@link Integer#MAX_VALUE}. */ public LinkedBlockingQueue() { this(Integer.MAX_VALUE); } /** * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if {@code capacity} is not greater * than zero */ public LinkedBlockingQueue(int capacity) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null); } /** * Creates a {@code LinkedBlockingQueue} with a capacity of * {@link Integer#MAX_VALUE}, initially containing the elements of the * given collection, * added in traversal order of the collection&apos;s iterator. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any * of its elements are null */ public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) { this(Integer.MAX_VALUE); final ReentrantLock putLock = this.putLock; putLock.lock(); // Never contended, but necessary for visibility try { int n = 0; for (E e : c) { if (e == null) throw new NullPointerException(); if (n == capacity) throw new IllegalStateException(&quot;Queue full&quot;); enqueue(new Node&lt;E&gt;(e)); ++n; } count.set(n); } finally { putLock.unlock(); } } // this doc comment is overridden to remove the reference to collections // greater in size than Integer.MAX_VALUE /** * Returns the number of elements in this queue. * * @return the number of elements in this queue */ public int size() { return count.get(); } // this doc comment is a modified copy of the inherited doc comment, // without the reference to unlimited queues. /** * Returns the number of additional elements that this queue can ideally * (in the absence of memory or resource constraints) accept without * blocking. This is always equal to the initial capacity of this queue * less the current {@code size} of this queue. * * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert * an element will succeed by inspecting {@code remainingCapacity} * because it may be the case that another thread is about to * insert or remove an element. */ public int remainingCapacity() { return capacity - count.get(); } /** * Inserts the specified element at the tail of this queue, waiting if * necessary for space to become available. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ while (count.get() == capacity) { notFull.await(); } enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); } /** * Inserts the specified element at the tail of this queue, waiting if * necessary up to the specified wait time for space to become available. * * @return {@code true} if successful, or {@code false} if * the specified waiting time elapses before space is available. * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { while (count.get() == capacity) { if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); } enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); return true; } /** * Inserts the specified element at the tail of this queue if it is * possible to do so immediately without exceeding the queue&apos;s capacity, * returning {@code true} upon success and {@code false} if this queue * is full. * When using a capacity-restricted queue, this method is generally * preferable to method {@link BlockingQueue#add add}, which can fail to * insert an element only by throwing an exception. * * @throws NullPointerException if the specified element is null */ public boolean offer(E e) { if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try { if (count.get() &lt; capacity) { enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); } } finally { putLock.unlock(); } if (c == 0) signalNotEmpty(); return c &gt;= 0; } public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { while (count.get() == 0) { notEmpty.await(); } x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } public E poll(long timeout, TimeUnit unit) throws InterruptedException { E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { while (count.get() == 0) { if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); } x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } public E poll() { final AtomicInteger count = this.count; if (count.get() == 0) return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { if (count.get() &gt; 0) { x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } public E peek() { if (count.get() == 0) return null; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { Node&lt;E&gt; first = head.next; if (first == null) return null; else return first.item; } finally { takeLock.unlock(); } } /** * Unlinks interior Node p with predecessor trail. */ void unlink(Node&lt;E&gt; p, Node&lt;E&gt; trail) { // assert isFullyLocked(); // p.next is not changed, to allow iterators that are // traversing p to maintain their weak-consistency guarantee. p.item = null; trail.next = p.next; if (last == p) last = trail; if (count.getAndDecrement() == capacity) notFull.signal(); } /** * Removes a single instance of the specified element from this queue, * if it is present. More formally, removes an element {@code e} such * that {@code o.equals(e)}, if this queue contains one or more such * elements. * Returns {@code true} if this queue contained the specified element * (or equivalently, if this queue changed as a result of the call). * * @param o element to be removed from this queue, if present * @return {@code true} if this queue changed as a result of the call */ public boolean remove(Object o) { if (o == null) return false; fullyLock(); try { for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) { if (o.equals(p.item)) { unlink(p, trail); return true; } } return false; } finally { fullyUnlock(); } } /** * Returns {@code true} if this queue contains the specified element. * More formally, returns {@code true} if and only if this queue contains * at least one element {@code e} such that {@code o.equals(e)}. * * @param o object to be checked for containment in this queue * @return {@code true} if this queue contains the specified element */ public boolean contains(Object o) { if (o == null) return false; fullyLock(); try { for (Node&lt;E&gt; p = head.next; p != null; p = p.next) if (o.equals(p.item)) return true; return false; } finally { fullyUnlock(); } } /** * Returns an array containing all of the elements in this queue, in * proper sequence. * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this queue. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this queue */ public Object[] toArray() { fullyLock(); try { int size = count.get(); Object[] a = new Object[size]; int k = 0; for (Node&lt;E&gt; p = head.next; p != null; p = p.next) a[k++] = p.item; return a; } finally { fullyUnlock(); } } /** * Returns an array containing all of the elements in this queue, in * proper sequence; the runtime type of the returned array is that of * the specified array. If the queue fits in the specified array, it * is returned therein. Otherwise, a new array is allocated with the * runtime type of the specified array and the size of this queue. * * &lt;p&gt;If this queue fits in the specified array with room to spare * (i.e., the array has more elements than this queue), the element in * the array immediately following the end of the queue is set to * {@code null}. * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose {@code x} is a queue known to contain only strings. * The following code can be used to dump the queue into a newly * allocated array of {@code String}: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that {@code toArray(new Object[0])} is identical in function to * {@code toArray()}. * * @param a the array into which the elements of the queue are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose * @return an array containing all of the elements in this queue * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this queue * @throws NullPointerException if the specified array is null */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) { fullyLock(); try { int size = count.get(); if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance (a.getClass().getComponentType(), size); int k = 0; for (Node&lt;E&gt; p = head.next; p != null; p = p.next) a[k++] = (T)p.item; if (a.length &gt; k) a[k] = null; return a; } finally { fullyUnlock(); } } public String toString() { fullyLock(); try { Node&lt;E&gt; p = head.next; if (p == null) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append(&apos;[&apos;); for (;;) { E e = p.item; sb.append(e == this ? &quot;(this Collection)&quot; : e); p = p.next; if (p == null) return sb.append(&apos;]&apos;).toString(); sb.append(&apos;,&apos;).append(&apos; &apos;); } } finally { fullyUnlock(); } } /** * Atomically removes all of the elements from this queue. * The queue will be empty after this call returns. */ public void clear() { fullyLock(); try { for (Node&lt;E&gt; p, h = head; (p = h.next) != null; h = p) { h.next = h; p.item = null; } head = last; // assert head.item == null &amp;&amp; head.next == null; if (count.getAndSet(0) == capacity) notFull.signal(); } finally { fullyUnlock(); } } /** * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public int drainTo(Collection&lt;? super E&gt; c) { return drainTo(c, Integer.MAX_VALUE); } /** * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public int drainTo(Collection&lt;? super E&gt; c, int maxElements) { if (c == null) throw new NullPointerException(); if (c == this) throw new IllegalArgumentException(); boolean signalNotFull = false; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { int n = Math.min(maxElements, count.get()); // count.get provides visibility to first n Nodes Node&lt;E&gt; h = head; int i = 0; try { while (i &lt; n) { Node&lt;E&gt; p = h.next; c.add(p.item); p.item = null; h.next = h; h = p; ++i; } return n; } finally { // Restore invariants even if c.add() threw if (i &gt; 0) { // assert h.item == null; head = h; signalNotFull = (count.getAndAdd(-i) == capacity); } } } finally { takeLock.unlock(); if (signalNotFull) signalNotFull(); } } /** * Returns an iterator over the elements in this queue in proper sequence. * The elements will be returned in order from first (head) to last (tail). * * &lt;p&gt;The returned iterator is a &quot;weakly consistent&quot; iterator that * will never throw {@link java.util.ConcurrentModificationException * ConcurrentModificationException}, and guarantees to traverse * elements as they existed upon construction of the iterator, and * may (but is not guaranteed to) reflect any modifications * subsequent to construction. * * @return an iterator over the elements in this queue in proper sequence */ public Iterator&lt;E&gt; iterator() { return new Itr(); } private class Itr implements Iterator&lt;E&gt; { /* * Basic weakly-consistent iterator. At all times hold the next * item to hand out so that if hasNext() reports true, we will * still have it to return even if lost race with a take etc. */ private Node&lt;E&gt; current; private Node&lt;E&gt; lastRet; private E currentElement; Itr() { fullyLock(); try { current = head.next; if (current != null) currentElement = current.item; } finally { fullyUnlock(); } } public boolean hasNext() { return current != null; } /** * Returns the next live successor of p, or null if no such. * * Unlike other traversal methods, iterators need to handle both: * - dequeued nodes (p.next == p) * - (possibly multiple) interior removed nodes (p.item == null) */ private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) { for (;;) { Node&lt;E&gt; s = p.next; if (s == p) return head.next; if (s == null || s.item != null) return s; p = s; } } public E next() { fullyLock(); try { if (current == null) throw new NoSuchElementException(); E x = currentElement; lastRet = current; current = nextNode(current); currentElement = (current == null) ? null : current.item; return x; } finally { fullyUnlock(); } } public void remove() { if (lastRet == null) throw new IllegalStateException(); fullyLock(); try { Node&lt;E&gt; node = lastRet; lastRet = null; for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) { if (p == node) { unlink(p, trail); break; } } } finally { fullyUnlock(); } } } /** * Save the state to a stream (that is, serialize it). * * @serialData The capacity is emitted (int), followed by all of * its elements (each an {@code Object}) in the proper order, * followed by a null * @param s the stream */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { fullyLock(); try { // Write out any hidden stuff, plus capacity s.defaultWriteObject(); // Write out all elements in the proper order. for (Node&lt;E&gt; p = head.next; p != null; p = p.next) s.writeObject(p.item); // Use trailing null as sentinel s.writeObject(null); } finally { fullyUnlock(); } } /** * Reconstitute this queue instance from a stream (that is, * deserialize it). * * @param s the stream */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in capacity, and any hidden stuff s.defaultReadObject(); count.set(0); last = head = new Node&lt;E&gt;(null); // Read in all elements and place in queue for (;;) { @SuppressWarnings(&quot;unchecked&quot;) E item = (E)s.readObject(); if (item == null) break; add(item); } } } 下面从LinkedBlockingQueue的创建，添加，删除，遍历这几个方面对它进行分析。 4.1 创建下面以LinkedBlockingQueue(int capacity)来进行说明。 public LinkedBlockingQueue(int capacity) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null); } 说明：(01) capacity是“链式阻塞队列”的容量。(02) head和last是“链式阻塞队列”的首节点和尾节点。它们在LinkedBlockingQueue中的声明如下： // 容量 private final int capacity; // 当前数量 private final AtomicInteger count = new AtomicInteger(0); private transient Node&lt;E&gt; head; // 链表的表头 private transient Node&lt;E&gt; last; // 链表的表尾 // 用于控制“删除元素”的互斥锁takeLock 和 锁对应的“非空条件”notEmpty private final ReentrantLock takeLock = new ReentrantLock(); private final Condition notEmpty = takeLock.newCondition(); // 用于控制“添加元素”的互斥锁putLock 和 锁对应的“非满条件”notFull private final ReentrantLock putLock = new ReentrantLock(); private final Condition notFull = putLock.newCondition(); 链表的节点定义如下： static class Node&lt;E&gt; { E item; // 数据 Node&lt;E&gt; next; // 下一个节点的指针 Node(E x) { item = x; } } 4.2 添加下面以offer(E e)为例，对LinkedBlockingQueue的添加方法进行说明。 public boolean offer(E e) { if (e == null) throw new NullPointerException(); // 如果“队列已满”，则返回false，表示插入失败。 final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; // 新建“节点e” Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; // 获取“插入锁putLock” putLock.lock(); try { // 再次对“队列是不是满”的进行判断。 // 若“队列未满”，则插入节点。 if (count.get() &lt; capacity) { // 插入节点 enqueue(node); // 将“当前节点数量”+1，并返回“原始的数量” c = count.getAndIncrement(); // 如果在插入元素之后，队列仍然未满，则唤醒notFull上的等待线程。 if (c + 1 &lt; capacity) notFull.signal(); } } finally { // 释放“插入锁putLock” putLock.unlock(); } // 如果在插入节点前，队列为空；则插入节点后，唤醒notEmpty上的等待线程 if (c == 0) signalNotEmpty(); return c &gt;= 0; } 说明：offer()的作用很简单，就是将元素E添加到队列的末尾。 enqueue()的源码如下： private void enqueue(Node&lt;E&gt; node) { // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node; } enqueue()的作用是将node添加到队列末尾，并设置node为新的尾节点！ signalNotEmpty()的源码如下： private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { notEmpty.signal(); } finally { takeLock.unlock(); } } signalNotEmpty()的作用是唤醒notEmpty上的等待线程。 4.3 取出下面以take()为例，对LinkedBlockingQueue的取出方法进行说明。 public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; // 获取“取出锁”，若当前线程是中断状态，则抛出InterruptedException异常 takeLock.lockInterruptibly(); try { // 若“队列为空”，则一直等待。 while (count.get() == 0) { notEmpty.await(); } // 取出元素 x = dequeue(); // 取出元素之后，将“节点数量”-1；并返回“原始的节点数量”。 c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); } finally { // 释放“取出锁” takeLock.unlock(); } // 如果在“取出元素之前”，队列是满的；则在取出元素之后，唤醒notFull上的等待线程。 if (c == capacity) signalNotFull(); return x; } 说明：take()的作用是取出并返回队列的头。若队列为空，则一直等待。 dequeue()的源码如下： private E dequeue() { // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x; } dequeue()的作用就是删除队列的头节点，并将表头指向“原头节点的下一个节点”。 signalNotFull()的源码如下： private void signalNotFull() { final ReentrantLock putLock = this.putLock; putLock.lock(); try { notFull.signal(); } finally { putLock.unlock(); } } signalNotFull()的作用就是唤醒notFull上的等待线程。 4.4 遍历下面对LinkedBlockingQueue的遍历方法进行说明。 public Iterator&lt;E&gt; iterator() { return new Itr(); } iterator()实际上是返回一个Iter对象。 Itr类的定义如下： private class Itr implements Iterator&lt;E&gt; { // 当前节点 private Node&lt;E&gt; current; // 上一次返回的节点 private Node&lt;E&gt; lastRet; // 当前节点对应的值 private E currentElement; Itr() { // 同时获取“插入锁putLock” 和 “取出锁takeLock” fullyLock(); try { // 设置“当前元素”为“队列表头的下一节点”，即为队列的第一个有效节点 current = head.next; if (current != null) currentElement = current.item; } finally { // 释放“插入锁putLock” 和 “取出锁takeLock” fullyUnlock(); } } // 返回“下一个节点是否为null” public boolean hasNext() { return current != null; } private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) { for (;;) { Node&lt;E&gt; s = p.next; if (s == p) return head.next; if (s == null || s.item != null) return s; p = s; } } // 返回下一个节点 public E next() { fullyLock(); try { if (current == null) throw new NoSuchElementException(); E x = currentElement; lastRet = current; current = nextNode(current); currentElement = (current == null) ? null : current.item; return x; } finally { fullyUnlock(); } } // 删除下一个节点 public void remove() { if (lastRet == null) throw new IllegalStateException(); fullyLock(); try { Node&lt;E&gt; node = lastRet; lastRet = null; for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) { if (p == node) { unlink(p, trail); break; } } } finally { fullyUnlock(); } } } 5. LinkedBlockingQueue示例import java.util.*; import java.util.concurrent.*; /* * LinkedBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是LinkedBlockingQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class LinkedBlockingQueueDemo1 { // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对queue进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String value; Iterator iter = queue.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); } } } } (某一次)运行结果： tb1, ta1, tb1, ta1, ta2, tb1, ta1, ta2, ta3, tb1, ta1, ta2, ta3, ta4, tb1, ta1, tb1, ta2, ta1, ta3, ta2, ta4, ta3, ta5, ta4, tb1, ta5, ta1, ta6, ta2, tb1, ta3, ta1, ta4, ta2, ta5, ta3, ta6, ta4, tb2, ta5, ta6, tb2, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb6, 结果说明：示例程序中，启动两个线程(线程ta和线程tb)分别对LinkedBlockingQueue进行操作。以线程ta而言，它会先获取“线程名”+“序号”，然后将该字符串添加到LinkedBlockingQueue中；接着，遍历并输出LinkedBlockingQueue中的全部元素。 线程tb的操作和线程ta一样，只不过线程tb的名字和线程ta的名字不同。当queue是LinkedBlockingQueue对象时，程序能正常运行。如果将queue改为LinkedList时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”07之 ArrayBlockingQueue","date":"2016-11-11T23:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”07之 ArrayBlockingQueue/","text":"本章对Java.util.concurrent包中的ArrayBlockingQueue类进行详细的介绍。 目录1. ArrayBlockingQueue介绍2. ArrayBlockingQueue原理和数据结构3. ArrayBlockingQueue函数列表4. ArrayBlockingQueue源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1 创建&nbsp;&nbsp;&nbsp;&nbsp; 4.2 添加&nbsp;&nbsp;&nbsp;&nbsp; 4.3 取出5. ArrayBlockingQueue示例 1. ArrayBlockingQueue介绍ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。 线程安全是指，ArrayBlockingQueue内部通过“互斥锁”保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指ArrayBlockingQueue对应的数组是有界限的。阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待。而且，ArrayBlockingQueue是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。 注意：ArrayBlockingQueue不同于ConcurrentLinkedQueue，ArrayBlockingQueue是数组实现的，并且是有界限的；而ConcurrentLinkedQueue是链表实现的，是无界限的。 2. ArrayBlockingQueue原理和数据结构ArrayBlockingQueue的数据结构，如下图所示： img 说明：(01). ArrayBlockingQueue继承于AbstractQueue，并且它实现了BlockingQueue接口。(02). ArrayBlockingQueue内部是通过Object[]数组保存数据的，也就是说ArrayBlockingQueue本质上是通过数组实现的。ArrayBlockingQueue的大小，即数组的容量是创建ArrayBlockingQueue时指定的。(03). ArrayBlockingQueue与ReentrantLock是组合关系，ArrayBlockingQueue中包含一个ReentrantLock对象(lock)。ReentrantLock是可重入的互斥锁，ArrayBlockingQueue就是根据该互斥锁实现“多线程对竞争资源的互斥访问”。而且，ReentrantLock分为公平锁和非公平锁，关于具体使用公平锁还是非公平锁，在创建ArrayBlockingQueue时可以指定；而且，ArrayBlockingQueue默认会使用非公平锁。(04). ArrayBlockingQueue与Condition是组合关系，ArrayBlockingQueue中包含两个Condition对象(notEmpty和notFull)。而且，Condition又依赖于ArrayBlockingQueue而存在，通过Condition可以实现对ArrayBlockingQueue的更精确的访问 – (01)若某线程(线程A)要取数据时，数组正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向数组中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。(02)若某线程(线程H)要插入数据时，数组已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 关于ReentrantLock，公平锁，非公平锁，以及Condition等更多的内容，可以参考前面的文章。 3. ArrayBlockingQueue函数列表// 创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。 ArrayBlockingQueue(int capacity) // 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。 ArrayBlockingQueue(int capacity, boolean fair) // 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。 ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) // 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException。 boolean add(E e) // 自动移除此队列中的所有元素。 void clear() // 如果此队列包含指定的元素，则返回 true。 boolean contains(Object o) // 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。 int drainTo(Collection&lt;? super E&gt; c) // 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。 int drainTo(Collection&lt;? super E&gt; c, int maxElements) // 返回在此队列中的元素上按适当顺序进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false。 boolean offer(E e) // 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间。 boolean offer(E e, long timeout, TimeUnit unit) // 获取但不移除此队列的头；如果此队列为空，则返回 null。 E peek() // 获取并移除此队列的头，如果此队列为空，则返回 null。 E poll() // 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。 E poll(long timeout, TimeUnit unit) // 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。 void put(E e) // 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量。 int remainingCapacity() // 从此队列中移除指定元素的单个实例（如果存在）。 boolean remove(Object o) // 返回此队列中元素的数量。 int size() // 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。 E take() // 返回一个按适当顺序包含此队列中所有元素的数组。 Object[] toArray() // 返回一个按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 &lt;T&gt; T[] toArray(T[] a) // 返回此 collection 的字符串表示形式。 String toString() 4. ArrayBlockingQueue源码分析(JDK1.7.0_40版本)ArrayBlockingQueue.java的完整源码如下： package java.util.concurrent; import java.util.concurrent.locks.*; import java.util.*; /** * A bounded {@linkplain BlockingQueue blocking queue} backed by an * array. This queue orders elements FIFO (first-in-first-out). The * &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the * queue the longest time. The &lt;em&gt;tail&lt;/em&gt; of the queue is that * element that has been on the queue the shortest time. New elements * are inserted at the tail of the queue, and the queue retrieval * operations obtain elements at the head of the queue. * * &lt;p&gt;This is a classic &amp;quot;bounded buffer&amp;quot;, in which a * fixed-sized array holds elements inserted by producers and * extracted by consumers. Once created, the capacity cannot be * changed. Attempts to {@code put} an element into a full queue * will result in the operation blocking; attempts to {@code take} an * element from an empty queue will similarly block. * * &lt;p&gt;This class supports an optional fairness policy for ordering * waiting producer and consumer threads. By default, this ordering * is not guaranteed. However, a queue constructed with fairness set * to {@code true} grants threads access in FIFO order. Fairness * generally decreases throughput but reduces variability and avoids * starvation. * * &lt;p&gt;This class and its iterator implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link * Iterator} interfaces. * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @since 1.5 * @author Doug Lea * @param &lt;E&gt; the type of elements held in this collection */ public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable { /** * Serialization ID. This class relies on default serialization * even for the items array, which is default-serialized, even if * it is empty. Otherwise it could not be declared final, which is * necessary here. */ private static final long serialVersionUID = -817911632652898426L; /** The queued items */ final Object[] items; /** items index for next take, poll, peek or remove */ int takeIndex; /** items index for next put, offer, or add */ int putIndex; /** Number of elements in the queue */ int count; /* * Concurrency control uses the classic two-condition algorithm * found in any textbook. */ /** Main lock guarding all access */ final ReentrantLock lock; /** Condition for waiting takes */ private final Condition notEmpty; /** Condition for waiting puts */ private final Condition notFull; // Internal helper methods /** * Circularly increment i. */ final int inc(int i) { return (++i == items.length) ? 0 : i; } /** * Circularly decrement i. */ final int dec(int i) { return ((i == 0) ? items.length : i) - 1; } @SuppressWarnings(&quot;unchecked&quot;) static &lt;E&gt; E cast(Object item) { return (E) item; } /** * Returns item at index i. */ final E itemAt(int i) { return this.&lt;E&gt;cast(items[i]); } /** * Throws NullPointerException if argument is null. * * @param v the element */ private static void checkNotNull(Object v) { if (v == null) throw new NullPointerException(); } /** * Inserts element at current put position, advances, and signals. * Call only when holding lock. */ private void insert(E x) { items[putIndex] = x; putIndex = inc(putIndex); ++count; notEmpty.signal(); } /** * Extracts element at current take position, advances, and signals. * Call only when holding lock. */ private E extract() { final Object[] items = this.items; E x = this.&lt;E&gt;cast(items[takeIndex]); items[takeIndex] = null; takeIndex = inc(takeIndex); --count; notFull.signal(); return x; } /** * Deletes item at position i. * Utility for remove and iterator.remove. * Call only when holding lock. */ void removeAt(int i) { final Object[] items = this.items; // if removing front item, just advance if (i == takeIndex) { items[takeIndex] = null; takeIndex = inc(takeIndex); } else { // slide over all others up through putIndex. for (;;) { int nexti = inc(i); if (nexti != putIndex) { items[i] = items[nexti]; i = nexti; } else { items[i] = null; putIndex = i; break; } } } --count; notFull.signal(); } /** * Creates an {@code ArrayBlockingQueue} with the given (fixed) * capacity and default access policy. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if {@code capacity &lt; 1} */ public ArrayBlockingQueue(int capacity) { this(capacity, false); } /** * Creates an {@code ArrayBlockingQueue} with the given (fixed) * capacity and the specified access policy. * * @param capacity the capacity of this queue * @param fair if {@code true} then queue accesses for threads blocked * on insertion or removal, are processed in FIFO order; * if {@code false} the access order is unspecified. * @throws IllegalArgumentException if {@code capacity &lt; 1} */ public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition(); } /** * Creates an {@code ArrayBlockingQueue} with the given (fixed) * capacity, the specified access policy and initially containing the * elements of the given collection, * added in traversal order of the collection&apos;s iterator. * * @param capacity the capacity of this queue * @param fair if {@code true} then queue accesses for threads blocked * on insertion or removal, are processed in FIFO order; * if {@code false} the access order is unspecified. * @param c the collection of elements to initially contain * @throws IllegalArgumentException if {@code capacity} is less than * {@code c.size()}, or less than 1. * @throws NullPointerException if the specified collection or any * of its elements are null */ public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) { this(capacity, fair); final ReentrantLock lock = this.lock; lock.lock(); // Lock only for visibility, not mutual exclusion try { int i = 0; try { for (E e : c) { checkNotNull(e); items[i++] = e; } } catch (ArrayIndexOutOfBoundsException ex) { throw new IllegalArgumentException(); } count = i; putIndex = (i == capacity) ? 0 : i; } finally { lock.unlock(); } } /** * Inserts the specified element at the tail of this queue if it is * possible to do so immediately without exceeding the queue&apos;s capacity, * returning {@code true} upon success and throwing an * {@code IllegalStateException} if this queue is full. * * @param e the element to add * @return {@code true} (as specified by {@link Collection#add}) * @throws IllegalStateException if this queue is full * @throws NullPointerException if the specified element is null */ public boolean add(E e) { return super.add(e); } /** * Inserts the specified element at the tail of this queue if it is * possible to do so immediately without exceeding the queue&apos;s capacity, * returning {@code true} upon success and {@code false} if this queue * is full. This method is generally preferable to method {@link #add}, * which can fail to insert an element only by throwing an exception. * * @throws NullPointerException if the specified element is null */ public boolean offer(E e) { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try { if (count == items.length) return false; else { insert(e); return true; } } finally { lock.unlock(); } } /** * Inserts the specified element at the tail of this queue, waiting * for space to become available if the queue is full. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) notFull.await(); insert(e); } finally { lock.unlock(); } } /** * Inserts the specified element at the tail of this queue, waiting * up to the specified wait time for space to become available if * the queue is full. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */ public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) { if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); } insert(e); return true; } finally { lock.unlock(); } } public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : extract(); } finally { lock.unlock(); } } public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); return extract(); } finally { lock.unlock(); } } public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) { if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); } return extract(); } finally { lock.unlock(); } } public E peek() { final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : itemAt(takeIndex); } finally { lock.unlock(); } } // this doc comment is overridden to remove the reference to collections // greater in size than Integer.MAX_VALUE /** * Returns the number of elements in this queue. * * @return the number of elements in this queue */ public int size() { final ReentrantLock lock = this.lock; lock.lock(); try { return count; } finally { lock.unlock(); } } // this doc comment is a modified copy of the inherited doc comment, // without the reference to unlimited queues. /** * Returns the number of additional elements that this queue can ideally * (in the absence of memory or resource constraints) accept without * blocking. This is always equal to the initial capacity of this queue * less the current {@code size} of this queue. * * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert * an element will succeed by inspecting {@code remainingCapacity} * because it may be the case that another thread is about to * insert or remove an element. */ public int remainingCapacity() { final ReentrantLock lock = this.lock; lock.lock(); try { return items.length - count; } finally { lock.unlock(); } } /** * Removes a single instance of the specified element from this queue, * if it is present. More formally, removes an element {@code e} such * that {@code o.equals(e)}, if this queue contains one or more such * elements. * Returns {@code true} if this queue contained the specified element * (or equivalently, if this queue changed as a result of the call). * * &lt;p&gt;Removal of interior elements in circular array based queues * is an intrinsically slow and disruptive operation, so should * be undertaken only in exceptional circumstances, ideally * only when the queue is known not to be accessible by other * threads. * * @param o element to be removed from this queue, if present * @return {@code true} if this queue changed as a result of the call */ public boolean remove(Object o) { if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { for (int i = takeIndex, k = count; k &gt; 0; i = inc(i), k--) { if (o.equals(items[i])) { removeAt(i); return true; } } return false; } finally { lock.unlock(); } } /** * Returns {@code true} if this queue contains the specified element. * More formally, returns {@code true} if and only if this queue contains * at least one element {@code e} such that {@code o.equals(e)}. * * @param o object to be checked for containment in this queue * @return {@code true} if this queue contains the specified element */ public boolean contains(Object o) { if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { for (int i = takeIndex, k = count; k &gt; 0; i = inc(i), k--) if (o.equals(items[i])) return true; return false; } finally { lock.unlock(); } } /** * Returns an array containing all of the elements in this queue, in * proper sequence. * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this queue. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all of the elements in this queue */ public Object[] toArray() { final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { final int count = this.count; Object[] a = new Object[count]; for (int i = takeIndex, k = 0; k &lt; count; i = inc(i), k++) a[k] = items[i]; return a; } finally { lock.unlock(); } } /** * Returns an array containing all of the elements in this queue, in * proper sequence; the runtime type of the returned array is that of * the specified array. If the queue fits in the specified array, it * is returned therein. Otherwise, a new array is allocated with the * runtime type of the specified array and the size of this queue. * * &lt;p&gt;If this queue fits in the specified array with room to spare * (i.e., the array has more elements than this queue), the element in * the array immediately following the end of the queue is set to * {@code null}. * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose {@code x} is a queue known to contain only strings. * The following code can be used to dump the queue into a newly * allocated array of {@code String}: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that {@code toArray(new Object[0])} is identical in function to * {@code toArray()}. * * @param a the array into which the elements of the queue are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose * @return an array containing all of the elements in this queue * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this queue * @throws NullPointerException if the specified array is null */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) { final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { final int count = this.count; final int len = a.length; if (len &lt; count) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), count); for (int i = takeIndex, k = 0; k &lt; count; i = inc(i), k++) a[k] = (T) items[i]; if (len &gt; count) a[count] = null; return a; } finally { lock.unlock(); } } public String toString() { final ReentrantLock lock = this.lock; lock.lock(); try { int k = count; if (k == 0) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append(&apos;[&apos;); for (int i = takeIndex; ; i = inc(i)) { Object e = items[i]; sb.append(e == this ? &quot;(this Collection)&quot; : e); if (--k == 0) return sb.append(&apos;]&apos;).toString(); sb.append(&apos;,&apos;).append(&apos; &apos;); } } finally { lock.unlock(); } } /** * Atomically removes all of the elements from this queue. * The queue will be empty after this call returns. */ public void clear() { final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { for (int i = takeIndex, k = count; k &gt; 0; i = inc(i), k--) items[i] = null; count = 0; putIndex = 0; takeIndex = 0; notFull.signalAll(); } finally { lock.unlock(); } } /** * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public int drainTo(Collection&lt;? super E&gt; c) { checkNotNull(c); if (c == this) throw new IllegalArgumentException(); final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { int i = takeIndex; int n = 0; int max = count; while (n &lt; max) { c.add(this.&lt;E&gt;cast(items[i])); items[i] = null; i = inc(i); ++n; } if (n &gt; 0) { count = 0; putIndex = 0; takeIndex = 0; notFull.signalAll(); } return n; } finally { lock.unlock(); } } /** * @throws UnsupportedOperationException {@inheritDoc} * @throws ClassCastException {@inheritDoc} * @throws NullPointerException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */ public int drainTo(Collection&lt;? super E&gt; c, int maxElements) { checkNotNull(c); if (c == this) throw new IllegalArgumentException(); if (maxElements &lt;= 0) return 0; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { int i = takeIndex; int n = 0; int max = (maxElements &lt; count) ? maxElements : count; while (n &lt; max) { c.add(this.&lt;E&gt;cast(items[i])); items[i] = null; i = inc(i); ++n; } if (n &gt; 0) { count -= n; takeIndex = i; notFull.signalAll(); } return n; } finally { lock.unlock(); } } /** * Returns an iterator over the elements in this queue in proper sequence. * The elements will be returned in order from first (head) to last (tail). * * &lt;p&gt;The returned {@code Iterator} is a &quot;weakly consistent&quot; iterator that * will never throw {@link java.util.ConcurrentModificationException * ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. * * @return an iterator over the elements in this queue in proper sequence */ public Iterator&lt;E&gt; iterator() { return new Itr(); } /** * Iterator for ArrayBlockingQueue. To maintain weak consistency * with respect to puts and takes, we (1) read ahead one slot, so * as to not report hasNext true but then not have an element to * return -- however we later recheck this slot to use the most * current value; (2) ensure that each array slot is traversed at * most once (by tracking &quot;remaining&quot; elements); (3) skip over * null slots, which can occur if takes race ahead of iterators. * However, for circular array-based queues, we cannot rely on any * well established definition of what it means to be weakly * consistent with respect to interior removes since these may * require slot overwrites in the process of sliding elements to * cover gaps. So we settle for resiliency, operating on * established apparent nexts, which may miss some elements that * have moved between calls to next. */ private class Itr implements Iterator&lt;E&gt; { private int remaining; // Number of elements yet to be returned private int nextIndex; // Index of element to be returned by next private E nextItem; // Element to be returned by next call to next private E lastItem; // Element returned by last call to next private int lastRet; // Index of last element returned, or -1 if none Itr() { final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try { lastRet = -1; if ((remaining = count) &gt; 0) nextItem = itemAt(nextIndex = takeIndex); } finally { lock.unlock(); } } public boolean hasNext() { return remaining &gt; 0; } public E next() { final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try { if (remaining &lt;= 0) throw new NoSuchElementException(); lastRet = nextIndex; E x = itemAt(nextIndex); // check for fresher value if (x == null) { x = nextItem; // we are forced to report old value lastItem = null; // but ensure remove fails } else lastItem = x; while (--remaining &gt; 0 &amp;&amp; // skip over nulls (nextItem = itemAt(nextIndex = inc(nextIndex))) == null) ; return x; } finally { lock.unlock(); } } public void remove() { final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try { int i = lastRet; if (i == -1) throw new IllegalStateException(); lastRet = -1; E x = lastItem; lastItem = null; // only remove if item still at index if (x != null &amp;&amp; x == items[i]) { boolean removingHead = (i == takeIndex); removeAt(i); if (!removingHead) nextIndex = dec(nextIndex); } } finally { lock.unlock(); } } } } 下面从ArrayBlockingQueue的创建，添加，取出，遍历这几个方面对ArrayBlockingQueue进行分析。 4.1 创建下面以ArrayBlockingQueue(int capacity, boolean fair)来进行说明。 public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition(); } 说明：(01) items是保存“阻塞队列”数据的数组。它的定义如下： final Object[] items; (02) fair是“可重入的独占锁(ReentrantLock)”的类型。fair为true，表示是公平锁；fair为false，表示是非公平锁。notEmpty和notFull是锁的两个Condition条件。它们的定义如下： final ReentrantLock lock; private final Condition notEmpty; private final Condition notFull; 简单对Condition和Lock的用法进行说明，更多内容请参考“Java多线程系列–“JUC锁”06之 Condition条件”。Lock的作用是提供独占锁机制，来保护竞争资源；而Condition是为了更加精细的对锁进行控制，它依赖于Lock，通过某个条件对多线程进行控制。notEmpty表示“锁的非空条件”。当某线程想从队列中取数据时，而此时又没有数据，则该线程通过notEmpty.await()进行等待；当其它线程向队列中插入了元素之后，就调用notEmpty.signal()唤醒“之前通过notEmpty.await()进入等待状态的线程”。同理，notFull表示“锁的满条件”。当某线程想向队列中插入元素，而此时队列已满时，该线程等待；当其它线程从队列中取出元素之后，就唤醒该等待的线程。 4.2 添加下面以offer(E e)为例，对ArrayBlockingQueue的添加方法进行说明。 public boolean offer(E e) { // 创建插入的元素是否为null，是的话抛出NullPointerException异常 checkNotNull(e); // 获取“该阻塞队列的独占锁” final ReentrantLock lock = this.lock; lock.lock(); try { // 如果队列已满，则返回false。 if (count == items.length) return false; else { // 如果队列未满，则插入e，并返回true。 insert(e); return true; } } finally { // 释放锁 lock.unlock(); } } 说明：offer(E e)的作用是将e插入阻塞队列的尾部。如果队列已满，则返回false，表示插入失败；否则，插入元素，并返回true。(01) count表示”队列中的元素个数“。除此之外，队列中还有另外两个遍历takeIndex和putIndex。takeIndex表示下一个被取出元素的索引，putIndex表示下一个被添加元素的索引。它们的定义如下： // 队列中的元素个数 int takeIndex; // 下一个被取出元素的索引 int putIndex; // 下一个被添加元素的索引 int count; (02) insert()的源码如下： private void insert(E x) { // 将x添加到”队列“中 items[putIndex] = x; // 设置”下一个被取出元素的索引“ putIndex = inc(putIndex); // 将”队列中的元素个数”+1 ++count; // 唤醒notEmpty上的等待线程 notEmpty.signal(); } insert()在插入元素之后，会唤醒notEmpty上面的等待线程。 inc()的源码如下： final int inc(int i) { return (++i == items.length) ? 0 : i; } 若i+1的值等于“队列的长度”，即添加元素之后，队列满；则设置“下一个被添加元素的索引”为0。 4.3 取出下面以take()为例，对ArrayBlockingQueue的取出方法进行说明。 public E take() throws InterruptedException { // 获取“队列的独占锁” final ReentrantLock lock = this.lock; // 获取“锁”，若当前线程是中断状态，则抛出InterruptedException异常 lock.lockInterruptibly(); try { // 若“队列为空”，则一直等待。 while (count == 0) notEmpty.await(); // 取出元素 return extract(); } finally { // 释放“锁” lock.unlock(); } } 说明：take()的作用是取出并返回队列的头。若队列为空，则一直等待。 extract()的源码如下： private E extract() { final Object[] items = this.items; // 强制将元素转换为“泛型E” E x = this.&lt;E&gt;cast(items[takeIndex]); // 将第takeIndex元素设为null，即删除。同时，帮助GC回收。 items[takeIndex] = null; // 设置“下一个被取出元素的索引” takeIndex = inc(takeIndex); // 将“队列中元素数量”-1 --count; // 唤醒notFull上的等待线程。 notFull.signal(); return x; } 说明：extract()在删除元素之后，会唤醒notFull上的等待线程。 4.4 遍历下面对ArrayBlockingQueue的遍历方法进行说明。 public Iterator&lt;E&gt; iterator() { return new Itr(); } Itr是实现了Iterator接口的类，它的源码如下： private class Itr implements Iterator&lt;E&gt; { // 队列中剩余元素的个数 private int remaining; // Number of elements yet to be returned // 下一次调用next()返回的元素的索引 private int nextIndex; // Index of element to be returned by next // 下一次调用next()返回的元素 private E nextItem; // Element to be returned by next call to next // 上一次调用next()返回的元素 private E lastItem; // Element returned by last call to next // 上一次调用next()返回的元素的索引 private int lastRet; // Index of last element returned, or -1 if none Itr() { // 获取“阻塞队列”的锁 final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try { lastRet = -1; if ((remaining = count) &gt; 0) nextItem = itemAt(nextIndex = takeIndex); } finally { // 释放“锁” lock.unlock(); } } public boolean hasNext() { return remaining &gt; 0; } public E next() { // 获取“阻塞队列”的锁 final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try { // 若“剩余元素&lt;=0”，则抛出异常。 if (remaining &lt;= 0) throw new NoSuchElementException(); lastRet = nextIndex; // 获取第nextIndex位置的元素 E x = itemAt(nextIndex); // check for fresher value if (x == null) { x = nextItem; // we are forced to report old value lastItem = null; // but ensure remove fails } else lastItem = x; while (--remaining &gt; 0 &amp;&amp; // skip over nulls (nextItem = itemAt(nextIndex = inc(nextIndex))) == null) ; return x; } finally { lock.unlock(); } } public void remove() { final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try { int i = lastRet; if (i == -1) throw new IllegalStateException(); lastRet = -1; E x = lastItem; lastItem = null; // only remove if item still at index if (x != null &amp;&amp; x == items[i]) { boolean removingHead = (i == takeIndex); removeAt(i); if (!removingHead) nextIndex = dec(nextIndex); } } finally { lock.unlock(); } } } 5. ArrayBlockingQueue示例import java.util.*; import java.util.concurrent.*; /* * ArrayBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是ArrayBlockingQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class ArrayBlockingQueueDemo1{ // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(20); public static void main(String[] args) { // 同时启动两个线程对queue进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String value; Iterator iter = queue.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); } } } } (某一次)运行结果： ta1, ta1, tb1, ta1, tb1, ta1, ta2, tb1, ta1, ta2, tb1, tb2, ta2, ta1, tb2, tb1, ta3, ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, tb5, ta3, ta6, tb3, ta4, tb4, ta5, tb5, ta6, tb6, 结果说明：如果将源码中的queue改成LinkedList对象时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”06之 ConcurrentSkipListSet","date":"2016-11-11T22:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”06之 ConcurrentSkipListSet/","text":"本章对Java.util.concurrent包中的ConcurrentSkipListSet类进行详细的介绍。 目录1. ConcurrentSkipListSet介绍2. ConcurrentSkipListSet原理和数据结构3. ConcurrentSkipListSet函数列表4. ConcurrentSkipListSet源码(JDK1.7.0_40版本)5. ConcurrentSkipListSet示例 1. ConcurrentSkipListSet介绍ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。 ConcurrentSkipListSet和TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。第二，ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。 2. ConcurrentSkipListSet原理和数据结构ConcurrentSkipListSet的数据结构，如下图所示： img 说明：(01) ConcurrentSkipListSet继承于AbstractSet。因此，它本质上是一个集合。(02) ConcurrentSkipListSet实现了NavigableSet接口。因此，ConcurrentSkipListSet是一个有序的集合。(03) ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的。它包含一个ConcurrentNavigableMap对象m，而m对象实际上是ConcurrentNavigableMap的实现类ConcurrentSkipListMap的实例。ConcurrentSkipListMap中的元素是key-value键值对；而ConcurrentSkipListSet是集合，它只用到了ConcurrentSkipListMap中的key！ 3. ConcurrentSkipListSet函数列表// 构造一个新的空 set，该 set 按照元素的自然顺序对其进行排序。 ConcurrentSkipListSet() // 构造一个包含指定 collection 中元素的新 set，这个新 set 按照元素的自然顺序对其进行排序。 ConcurrentSkipListSet(Collection&lt;? extends E&gt; c) // 构造一个新的空 set，该 set 按照指定的比较器对其元素进行排序。 ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator) // 构造一个新 set，该 set 所包含的元素与指定的有序 set 包含的元素相同，使用的顺序也相同。 ConcurrentSkipListSet(SortedSet&lt;E&gt; s) // 如果此 set 中不包含指定元素，则添加指定元素。 boolean add(E e) // 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。 E ceiling(E e) // 从此 set 中移除所有元素。 void clear() // 返回此 ConcurrentSkipListSet 实例的浅表副本。 ConcurrentSkipListSet&lt;E&gt; clone() // 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。 Comparator&lt;? super E&gt; comparator() // 如果此 set 包含指定的元素，则返回 true。 boolean contains(Object o) // 返回在此 set 的元素上以降序进行迭代的迭代器。 Iterator&lt;E&gt; descendingIterator() // 返回此 set 中所包含元素的逆序视图。 NavigableSet&lt;E&gt; descendingSet() // 比较指定对象与此 set 的相等性。 boolean equals(Object o) // 返回此 set 中当前第一个（最低）元素。 E first() // 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。 E floor(E e) // 返回此 set 的部分视图，其元素严格小于 toElement。 NavigableSet&lt;E&gt; headSet(E toElement) // 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。 NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) // 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。 E higher(E e) // 如果此 set 不包含任何元素，则返回 true。 boolean isEmpty() // 返回在此 set 的元素上以升序进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 返回此 set 中当前最后一个（最高）元素。 E last() // 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。 E lower(E e) // 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。 E pollFirst() // 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。 E pollLast() // 如果此 set 中存在指定的元素，则将其移除。 boolean remove(Object o) // 从此 set 中移除包含在指定 collection 中的所有元素。 boolean removeAll(Collection&lt;?&gt; c) // 返回此 set 中的元素数目。 int size() // 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。 NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) // 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。 NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) // 返回此 set 的部分视图，其元素大于等于 fromElement。 NavigableSet&lt;E&gt; tailSet(E fromElement) // 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。 NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) 4. ConcurrentSkipListSet源码(JDK1.7.0_40版本)ConcurrentSkipListSet.java的完整源码如下： public class ConcurrentSkipListSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable { private static final long serialVersionUID = -2479143111061671589L; /** * The underlying map. Uses Boolean.TRUE as value for each * element. This field is declared final for the sake of thread * safety, which entails some ugliness in clone() */ private final ConcurrentNavigableMap&lt;E,Object&gt; m; /** * Constructs a new, empty set that orders its elements according to * their {@linkplain Comparable natural ordering}. */ public ConcurrentSkipListSet() { m = new ConcurrentSkipListMap&lt;E,Object&gt;(); } /** * Constructs a new, empty set that orders its elements according to * the specified comparator. * * @param comparator the comparator that will be used to order this set. * If &lt;tt&gt;null&lt;/tt&gt;, the {@linkplain Comparable natural * ordering} of the elements will be used. */ public ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator) { m = new ConcurrentSkipListMap&lt;E,Object&gt;(comparator); } /** * Constructs a new set containing the elements in the specified * collection, that orders its elements according to their * {@linkplain Comparable natural ordering}. * * @param c The elements that will comprise the new set * @throws ClassCastException if the elements in &lt;tt&gt;c&lt;/tt&gt; are * not {@link Comparable}, or are not mutually comparable * @throws NullPointerException if the specified collection or any * of its elements are null */ public ConcurrentSkipListSet(Collection&lt;? extends E&gt; c) { m = new ConcurrentSkipListMap&lt;E,Object&gt;(); addAll(c); } /** * Constructs a new set containing the same elements and using the * same ordering as the specified sorted set. * * @param s sorted set whose elements will comprise the new set * @throws NullPointerException if the specified sorted set or any * of its elements are null */ public ConcurrentSkipListSet(SortedSet&lt;E&gt; s) { m = new ConcurrentSkipListMap&lt;E,Object&gt;(s.comparator()); addAll(s); } /** * For use by submaps */ ConcurrentSkipListSet(ConcurrentNavigableMap&lt;E,Object&gt; m) { this.m = m; } /** * Returns a shallow copy of this &lt;tt&gt;ConcurrentSkipListSet&lt;/tt&gt; * instance. (The elements themselves are not cloned.) * * @return a shallow copy of this set */ public ConcurrentSkipListSet&lt;E&gt; clone() { ConcurrentSkipListSet&lt;E&gt; clone = null; try { clone = (ConcurrentSkipListSet&lt;E&gt;) super.clone(); clone.setMap(new ConcurrentSkipListMap(m)); } catch (CloneNotSupportedException e) { throw new InternalError(); } return clone; } /* ---------------- Set operations -------------- */ /** * Returns the number of elements in this set. If this set * contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, it * returns &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;. * * &lt;p&gt;Beware that, unlike in most collections, this method is * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the * asynchronous nature of these sets, determining the current * number of elements requires traversing them all to count them. * Additionally, it is possible for the size to change during * execution of this method, in which case the returned result * will be inaccurate. Thus, this method is typically not very * useful in concurrent applications. * * @return the number of elements in this set */ public int size() { return m.size(); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements. * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements */ public boolean isEmpty() { return m.isEmpty(); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set * contains an element &lt;tt&gt;e&lt;/tt&gt; such that &lt;tt&gt;o.equals(e)&lt;/tt&gt;. * * @param o object to be checked for containment in this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element * @throws ClassCastException if the specified element cannot be * compared with the elements currently in this set * @throws NullPointerException if the specified element is null */ public boolean contains(Object o) { return m.containsKey(o); } /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * the set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that &lt;tt&gt;e.equals(e2)&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the * specified element * @throws ClassCastException if &lt;tt&gt;e&lt;/tt&gt; cannot be compared * with the elements currently in this set * @throws NullPointerException if the specified element is null */ public boolean add(E e) { return m.putIfAbsent(e, Boolean.TRUE) == null; } /** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;o.equals(e)&lt;/tt&gt;, if this set contains such an element. * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contained the element (or * equivalently, if this set changed as a result of the call). * (This set will not contain the element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this set contained the specified element * @throws ClassCastException if &lt;tt&gt;o&lt;/tt&gt; cannot be compared * with the elements currently in this set * @throws NullPointerException if the specified element is null */ public boolean remove(Object o) { return m.remove(o, Boolean.TRUE); } /** * Removes all of the elements from this set. */ public void clear() { m.clear(); } /** * Returns an iterator over the elements in this set in ascending order. * * @return an iterator over the elements in this set in ascending order */ public Iterator&lt;E&gt; iterator() { return m.navigableKeySet().iterator(); } /** * Returns an iterator over the elements in this set in descending order. * * @return an iterator over the elements in this set in descending order */ public Iterator&lt;E&gt; descendingIterator() { return m.descendingKeySet().iterator(); } /* ---------------- AbstractSet Overrides -------------- */ /** * Compares the specified object with this set for equality. Returns * &lt;tt&gt;true&lt;/tt&gt; if the specified object is also a set, the two sets * have the same size, and every member of the specified set is * contained in this set (or equivalently, every member of this set is * contained in the specified set). This definition ensures that the * equals method works properly across different implementations of the * set interface. * * @param o the object to be compared for equality with this set * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this set */ public boolean equals(Object o) { // Override AbstractSet version to avoid calling size() if (o == this) return true; if (!(o instanceof Set)) return false; Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; try { return containsAll(c) &amp;&amp; c.containsAll(this); } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } } /** * Removes from this set all of its elements that are contained in * the specified collection. If the specified collection is also * a set, this operation effectively modifies this set so that its * value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of the two sets. * * @param c collection containing elements to be removed from this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set changed as a result of the call * @throws ClassCastException if the types of one or more elements in this * set are incompatible with the specified collection * @throws NullPointerException if the specified collection or any * of its elements are null */ public boolean removeAll(Collection&lt;?&gt; c) { // Override AbstractSet version to avoid unnecessary call to size() boolean modified = false; for (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); ) if (remove(i.next())) modified = true; return modified; } /* ---------------- Relational operations -------------- */ /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified element is null */ public E lower(E e) { return m.lowerKey(e); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified element is null */ public E floor(E e) { return m.floorKey(e); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified element is null */ public E ceiling(E e) { return m.ceilingKey(e); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified element is null */ public E higher(E e) { return m.higherKey(e); } public E pollFirst() { Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return (e == null) ? null : e.getKey(); } public E pollLast() { Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return (e == null) ? null : e.getKey(); } /* ---------------- SortedSet operations -------------- */ public Comparator&lt;? super E&gt; comparator() { return m.comparator(); } /** * @throws NoSuchElementException {@inheritDoc} */ public E first() { return m.firstKey(); } /** * @throws NoSuchElementException {@inheritDoc} */ public E last() { return m.lastKey(); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromElement} or * {@code toElement} is null * @throws IllegalArgumentException {@inheritDoc} */ public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) { return new ConcurrentSkipListSet&lt;E&gt; (m.subMap(fromElement, fromInclusive, toElement, toInclusive)); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code toElement} is null * @throws IllegalArgumentException {@inheritDoc} */ public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) { return new ConcurrentSkipListSet&lt;E&gt;(m.headMap(toElement, inclusive)); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromElement} is null * @throws IllegalArgumentException {@inheritDoc} */ public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) { return new ConcurrentSkipListSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromElement} or * {@code toElement} is null * @throws IllegalArgumentException {@inheritDoc} */ public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) { return subSet(fromElement, true, toElement, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code toElement} is null * @throws IllegalArgumentException {@inheritDoc} */ public NavigableSet&lt;E&gt; headSet(E toElement) { return headSet(toElement, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromElement} is null * @throws IllegalArgumentException {@inheritDoc} */ public NavigableSet&lt;E&gt; tailSet(E fromElement) { return tailSet(fromElement, true); } /** * Returns a reverse order view of the elements contained in this set. * The descending set is backed by this set, so changes to the set are * reflected in the descending set, and vice-versa. * * &lt;p&gt;The returned set has an ordering equivalent to * &lt;tt&gt;{@link Collections#reverseOrder(Comparator) Collections.reverseOrder}(comparator())&lt;/tt&gt;. * The expression {@code s.descendingSet().descendingSet()} returns a * view of {@code s} essentially equivalent to {@code s}. * * @return a reverse order view of this set */ public NavigableSet&lt;E&gt; descendingSet() { return new ConcurrentSkipListSet(m.descendingMap()); } // Support for resetting map in clone private void setMap(ConcurrentNavigableMap&lt;E,Object&gt; map) { UNSAFE.putObjectVolatile(this, mapOffset, map); } private static final sun.misc.Unsafe UNSAFE; private static final long mapOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = ConcurrentSkipListSet.class; mapOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;m&quot;)); } catch (Exception e) { throw new Error(e); } } } ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它的接口基本上都是通过调用ConcurrentSkipListMap接口来实现的。这里就不再对它的源码进行分析了。 5. ConcurrentSkipListSet示例import java.util.*; import java.util.concurrent.*; /* * ConcurrentSkipListSet是“线程安全”的集合，而TreeSet是非线程安全的。 * * 下面是“多个线程同时操作并且遍历集合set”的示例 * (01) 当set是ConcurrentSkipListSet对象时，程序能正常运行。 * (02) 当set是TreeSet对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class ConcurrentSkipListSetDemo1 { // TODO: set是TreeSet对象时，程序会出错。 //private static Set&lt;String&gt; set = new TreeSet&lt;String&gt;(); private static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对set进行操作！ new MyThread(&quot;a&quot;).start(); new MyThread(&quot;b&quot;).start(); } private static void printAll() { String value = null; Iterator iter = set.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 10) { // “线程名” + &quot;序号&quot; String val = Thread.currentThread().getName() + (i%6); set.add(val); // 通过“Iterator”遍历set。 printAll(); } } } } (某一次)运行结果： a1, b1, a1, a1, a2, b1, b1, a1, a2, a3, b1, a1, a2, a3, a1, a4, b1, b2, a2, a1, a2, a3, a4, a5, b1, b2, a3, a0, a4, a5, a1, b1, a2, b2, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, a0, b1, a1, b2, a2, b3, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, a0, b2, a1, b3, a2, b4, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, b5, b2, a0, a1, a2, a3, a4, a5, b3, b1, b4, b2, b5, b3, a0, b4, a1, b5, a2, a0, a3, a1, a4, a2, a5, a3, b0, a4, b1, a5, b2, b0, b3, b1, b4, b2, b5, b3, b4, a0, b5, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, 结果说明：示例程序中，启动两个线程(线程a和线程b)分别对ConcurrentSkipListSet进行操作。以线程a而言，它会先获取“线程名”+“序号”，然后将该字符串添加到ConcurrentSkipListSet集合中；接着，遍历并输出集合中的全部元素。 线程b的操作和线程a一样，只不过线程b的名字和线程a的名字不同。当set是ConcurrentSkipListSet对象时，程序能正常运行。如果将set改为TreeSet时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”05之 ConcurrentSkipListMap","date":"2016-11-11T21:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”05之 ConcurrentSkipListMap/","text":"本章对Java.util.concurrent包中的ConcurrentSkipListMap类进行详细的介绍。 目录1. ConcurrentSkipListMap介绍2. ConcurrentSkipListMap原理和数据结构3. ConcurrentSkipListMap函数列表4. ConcurrentSkipListMap源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1 添加&nbsp;&nbsp;&nbsp;&nbsp; 4.2 删除&nbsp;&nbsp;&nbsp;&nbsp; 4.3 获取5. ConcurrentSkipListMap示例 1. ConcurrentSkipListMap介绍ConcurrentSkipListMap是线程安全的有序的哈希表，适用于高并发的场景。 ConcurrentSkipListMap和TreeMap，它们虽然都是有序的哈希表。 但是，第一，它们的线程安全机制不同，TreeMap是非线程安全的，而ConcurrentSkipListMap是线程安全的。第二，ConcurrentSkipListMap是通过跳表实现的，而TreeMap是通过红黑树实现的。 关于跳表(Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。 2. ConcurrentSkipListMap原理和数据结构ConcurrentSkipListMap的数据结构，如下图所示： img 说明：先以数据“7,14,21,32,37,71,85”序列为例，来对跳表进行简单说明。 跳表分为许多层(level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1)包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。现在“需要找出值为32的节点”为例，来对比说明跳表和普遍的链表。 情况1：链表中查找“32”节点路径如下图所示： img 需要4步(红色部分表示路径)。 情况2：跳表中查找“32”节点路径如下图1-03所示： img 忽略索引垂直线路上路径的情况下，只需要2步(红色部分表示路径)。 下面说说Java中ConcurrentSkipListMap的数据结构。(01) ConcurrentSkipListMap继承于AbstractMap类，也就意味着它是一个哈希表。(02) Index是ConcurrentSkipListMap的内部类，它与“跳表中的索引相对应”。HeadIndex继承于Index，ConcurrentSkipListMap中含有一个HeadIndex的对象head，head是“跳表的表头”。(03) Index是跳表中的索引，它包含“右索引的指针(right)”，“下索引的指针(down)”和“哈希表节点node”。node是Node的对象，Node也是ConcurrentSkipListMap中的内部类。 3. ConcurrentSkipListMap函数列表// 构造一个新的空映射，该映射按照键的自然顺序进行排序。 ConcurrentSkipListMap() // 构造一个新的空映射，该映射按照指定的比较器进行排序。 ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) // 构造一个新映射，该映射所包含的映射关系与给定映射包含的映射关系相同，并按照键的自然顺序进行排序。 ConcurrentSkipListMap(Map&lt;? extends K,? extends V&gt; m) // 构造一个新映射，该映射所包含的映射关系与指定的有序映射包含的映射关系相同，使用的顺序也相同。 ConcurrentSkipListMap(SortedMap&lt;K,? extends V&gt; m) // 返回与大于等于给定键的最小键关联的键-值映射关系；如果不存在这样的条目，则返回 null。 Map.Entry&lt;K,V&gt; ceilingEntry(K key) // 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。 K ceilingKey(K key) // 从此映射中移除所有映射关系。 void clear() // 返回此 ConcurrentSkipListMap 实例的浅表副本。 ConcurrentSkipListMap&lt;K,V&gt; clone() // 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。 Comparator&lt;? super K&gt; comparator() // 如果此映射包含指定键的映射关系，则返回 true。 boolean containsKey(Object key) // 如果此映射为指定值映射一个或多个键，则返回 true。 boolean containsValue(Object value) // 返回此映射中所包含键的逆序 NavigableSet 视图。 NavigableSet&lt;K&gt; descendingKeySet() // 返回此映射中所包含映射关系的逆序视图。 ConcurrentNavigableMap&lt;K,V&gt; descendingMap() // 返回此映射中所包含的映射关系的 Set 视图。 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() // 比较指定对象与此映射的相等性。 boolean equals(Object o) // 返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry&lt;K,V&gt; firstEntry() // 返回此映射中当前第一个（最低）键。 K firstKey() // 返回与小于等于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。 Map.Entry&lt;K,V&gt; floorEntry(K key) // 返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。 K floorKey(K key) // 返回指定键所映射到的值；如果此映射不包含该键的映射关系，则返回 null。 V get(Object key) // 返回此映射的部分视图，其键值严格小于 toKey。 ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey) // 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。 ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) // 返回与严格大于给定键的最小键关联的键-值映射关系；如果不存在这样的键，则返回 null。 Map.Entry&lt;K,V&gt; higherEntry(K key) // 返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。 K higherKey(K key) // 如果此映射未包含键-值映射关系，则返回 true。 boolean isEmpty() // 返回此映射中所包含键的 NavigableSet 视图。 NavigableSet&lt;K&gt; keySet() // 返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry&lt;K,V&gt; lastEntry() // 返回映射中当前最后一个（最高）键。 K lastKey() // 返回与严格小于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。 Map.Entry&lt;K,V&gt; lowerEntry(K key) // 返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。 K lowerKey(K key) // 返回此映射中所包含键的 NavigableSet 视图。 NavigableSet&lt;K&gt; navigableKeySet() // 移除并返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry&lt;K,V&gt; pollFirstEntry() // 移除并返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry&lt;K,V&gt; pollLastEntry() // 将指定值与此映射中的指定键关联。 V put(K key, V value) // 如果指定键已经不再与某个值相关联，则将它与给定值关联。 V putIfAbsent(K key, V value) // 从此映射中移除指定键的映射关系（如果存在）。 V remove(Object key) // 只有目前将键的条目映射到给定值时，才移除该键的条目。 boolean remove(Object key, Object value) // 只有目前将键的条目映射到某一值时，才替换该键的条目。 V replace(K key, V value) // 只有目前将键的条目映射到给定值时，才替换该键的条目。 boolean replace(K key, V oldValue, V newValue) // 返回此映射中的键-值映射关系数。 int size() // 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。 ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) // 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。 ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) // 返回此映射的部分视图，其键大于等于 fromKey。 ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey) // 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。 ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) // 返回此映射中所包含值的 Collection 视图。 Collection&lt;V&gt; values() 4. ConcurrentSkipListMap源码分析(JDK1.7.0_40版本)ConcurrentSkipListMap.java的完整源码如下： package java.util.concurrent; import java.util.*; import java.util.concurrent.atomic.*; /** * A scalable concurrent {@link ConcurrentNavigableMap} implementation. * The map is sorted according to the {@linkplain Comparable natural * ordering} of its keys, or by a {@link Comparator} provided at map * creation time, depending on which constructor is used. * * &lt;p&gt;This class implements a concurrent variant of &lt;a * href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_top&quot;&gt;SkipLists&lt;/a&gt; * providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the * &lt;tt&gt;containsKey&lt;/tt&gt;, &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;put&lt;/tt&gt; and * &lt;tt&gt;remove&lt;/tt&gt; operations and their variants. Insertion, removal, * update, and access operations safely execute concurrently by * multiple threads. Iterators are &lt;i&gt;weakly consistent&lt;/i&gt;, returning * elements reflecting the state of the map at some point at or since * the creation of the iterator. They do &lt;em&gt;not&lt;/em&gt; throw {@link * ConcurrentModificationException}, and may proceed concurrently with * other operations. Ascending key ordered views and their iterators * are faster than descending ones. * * &lt;p&gt;All &lt;tt&gt;Map.Entry&lt;/tt&gt; pairs returned by methods in this class * and its views represent snapshots of mappings at the time they were * produced. They do &lt;em&gt;not&lt;/em&gt; support the &lt;tt&gt;Entry.setValue&lt;/tt&gt; * method. (Note however that it is possible to change mappings in the * associated map using &lt;tt&gt;put&lt;/tt&gt;, &lt;tt&gt;putIfAbsent&lt;/tt&gt;, or * &lt;tt&gt;replace&lt;/tt&gt;, depending on exactly which effect you need.) * * &lt;p&gt;Beware that, unlike in most collections, the &lt;tt&gt;size&lt;/tt&gt; * method is &lt;em&gt;not&lt;/em&gt; a constant-time operation. Because of the * asynchronous nature of these maps, determining the current number * of elements requires a traversal of the elements, and so may report * inaccurate results if this collection is modified during traversal. * Additionally, the bulk operations &lt;tt&gt;putAll&lt;/tt&gt;, &lt;tt&gt;equals&lt;/tt&gt;, * &lt;tt&gt;toArray&lt;/tt&gt;, &lt;tt&gt;containsValue&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; are * &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an * iterator operating concurrently with a &lt;tt&gt;putAll&lt;/tt&gt; operation * might view only some of the added elements. * * &lt;p&gt;This class and its views and iterators implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator} * interfaces. Like most other concurrent collections, this class does * &lt;em&gt;not&lt;/em&gt; permit the use of &lt;tt&gt;null&lt;/tt&gt; keys or values because some * null return values cannot be reliably distinguished from the absence of * elements. * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @author Doug Lea * @param &lt;K&gt; the type of keys maintained by this map * @param &lt;V&gt; the type of mapped values * @since 1.6 */ public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable { /* * This class implements a tree-like two-dimensionally linked skip * list in which the index levels are represented in separate * nodes from the base nodes holding data. There are two reasons * for taking this approach instead of the usual array-based * structure: 1) Array based implementations seem to encounter * more complexity and overhead 2) We can use cheaper algorithms * for the heavily-traversed index lists than can be used for the * base lists. Here&apos;s a picture of some of the basics for a * possible list with 2 levels of index: * * Head nodes Index nodes * +-+ right +-+ +-+ * |2|----------------&gt;| |---------------------&gt;| |-&gt;null * +-+ +-+ +-+ * | down | | * v v v * +-+ +-+ +-+ +-+ +-+ +-+ * |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null * +-+ +-+ +-+ +-+ +-+ +-+ * v | | | | | * Nodes next v v v v v * +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ * | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null * +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ +-+ * * The base lists use a variant of the HM linked ordered set * algorithm. See Tim Harris, &quot;A pragmatic implementation of * non-blocking linked lists&quot; * http://www.cl.cam.ac.uk/~tlh20/publications.html and Maged * Michael &quot;High Performance Dynamic Lock-Free Hash Tables and * List-Based Sets&quot; * http://www.research.ibm.com/people/m/michael/pubs.htm. The * basic idea in these lists is to mark the &quot;next&quot; pointers of * deleted nodes when deleting to avoid conflicts with concurrent * insertions, and when traversing to keep track of triples * (predecessor, node, successor) in order to detect when and how * to unlink these deleted nodes. * * Rather than using mark-bits to mark list deletions (which can * be slow and space-intensive using AtomicMarkedReference), nodes * use direct CAS&apos;able next pointers. On deletion, instead of * marking a pointer, they splice in another node that can be * thought of as standing for a marked pointer (indicating this by * using otherwise impossible field values). Using plain nodes * acts roughly like &quot;boxed&quot; implementations of marked pointers, * but uses new nodes only when nodes are deleted, not for every * link. This requires less space and supports faster * traversal. Even if marked references were better supported by * JVMs, traversal using this technique might still be faster * because any search need only read ahead one more node than * otherwise required (to check for trailing marker) rather than * unmasking mark bits or whatever on each read. * * This approach maintains the essential property needed in the HM * algorithm of changing the next-pointer of a deleted node so * that any other CAS of it will fail, but implements the idea by * changing the pointer to point to a different node, not by * marking it. While it would be possible to further squeeze * space by defining marker nodes not to have key/value fields, it * isn&apos;t worth the extra type-testing overhead. The deletion * markers are rarely encountered during traversal and are * normally quickly garbage collected. (Note that this technique * would not work well in systems without garbage collection.) * * In addition to using deletion markers, the lists also use * nullness of value fields to indicate deletion, in a style * similar to typical lazy-deletion schemes. If a node&apos;s value is * null, then it is considered logically deleted and ignored even * though it is still reachable. This maintains proper control of * concurrent replace vs delete operations -- an attempted replace * must fail if a delete beat it by nulling field, and a delete * must return the last non-null value held in the field. (Note: * Null, rather than some special marker, is used for value fields * here because it just so happens to mesh with the Map API * requirement that method get returns null if there is no * mapping, which allows nodes to remain concurrently readable * even when deleted. Using any other marker value here would be * messy at best.) * * Here&apos;s the sequence of events for a deletion of node n with * predecessor b and successor f, initially: * * +------+ +------+ +------+ * ... | b |------&gt;| n |-----&gt;| f | ... * +------+ +------+ +------+ * * 1. CAS n&apos;s value field from non-null to null. * From this point on, no public operations encountering * the node consider this mapping to exist. However, other * ongoing insertions and deletions might still modify * n&apos;s next pointer. * * 2. CAS n&apos;s next pointer to point to a new marker node. * From this point on, no other nodes can be appended to n. * which avoids deletion errors in CAS-based linked lists. * * +------+ +------+ +------+ +------+ * ... | b |------&gt;| n |-----&gt;|marker|------&gt;| f | ... * +------+ +------+ +------+ +------+ * * 3. CAS b&apos;s next pointer over both n and its marker. * From this point on, no new traversals will encounter n, * and it can eventually be GCed. * +------+ +------+ * ... | b |-----------------------------------&gt;| f | ... * +------+ +------+ * * A failure at step 1 leads to simple retry due to a lost race * with another operation. Steps 2-3 can fail because some other * thread noticed during a traversal a node with null value and * helped out by marking and/or unlinking. This helping-out * ensures that no thread can become stuck waiting for progress of * the deleting thread. The use of marker nodes slightly * complicates helping-out code because traversals must track * consistent reads of up to four nodes (b, n, marker, f), not * just (b, n, f), although the next field of a marker is * immutable, and once a next field is CAS&apos;ed to point to a * marker, it never again changes, so this requires less care. * * Skip lists add indexing to this scheme, so that the base-level * traversals start close to the locations being found, inserted * or deleted -- usually base level traversals only traverse a few * nodes. This doesn&apos;t change the basic algorithm except for the * need to make sure base traversals start at predecessors (here, * b) that are not (structurally) deleted, otherwise retrying * after processing the deletion. * * Index levels are maintained as lists with volatile next fields, * using CAS to link and unlink. Races are allowed in index-list * operations that can (rarely) fail to link in a new index node * or delete one. (We can&apos;t do this of course for data nodes.) * However, even when this happens, the index lists remain sorted, * so correctly serve as indices. This can impact performance, * but since skip lists are probabilistic anyway, the net result * is that under contention, the effective &quot;p&quot; value may be lower * than its nominal value. And race windows are kept small enough * that in practice these failures are rare, even under a lot of * contention. * * The fact that retries (for both base and index lists) are * relatively cheap due to indexing allows some minor * simplifications of retry logic. Traversal restarts are * performed after most &quot;helping-out&quot; CASes. This isn&apos;t always * strictly necessary, but the implicit backoffs tend to help * reduce other downstream failed CAS&apos;s enough to outweigh restart * cost. This worsens the worst case, but seems to improve even * highly contended cases. * * Unlike most skip-list implementations, index insertion and * deletion here require a separate traversal pass occuring after * the base-level action, to add or remove index nodes. This adds * to single-threaded overhead, but improves contended * multithreaded performance by narrowing interference windows, * and allows deletion to ensure that all index nodes will be made * unreachable upon return from a public remove operation, thus * avoiding unwanted garbage retention. This is more important * here than in some other data structures because we cannot null * out node fields referencing user keys since they might still be * read by other ongoing traversals. * * Indexing uses skip list parameters that maintain good search * performance while using sparser-than-usual indices: The * hardwired parameters k=1, p=0.5 (see method randomLevel) mean * that about one-quarter of the nodes have indices. Of those that * do, half have one level, a quarter have two, and so on (see * Pugh&apos;s Skip List Cookbook, sec 3.4). The expected total space * requirement for a map is slightly less than for the current * implementation of java.util.TreeMap. * * Changing the level of the index (i.e, the height of the * tree-like structure) also uses CAS. The head index has initial * level/height of one. Creation of an index with height greater * than the current level adds a level to the head index by * CAS&apos;ing on a new top-most head. To maintain good performance * after a lot of removals, deletion methods heuristically try to * reduce the height if the topmost levels appear to be empty. * This may encounter races in which it possible (but rare) to * reduce and &quot;lose&quot; a level just as it is about to contain an * index (that will then never be encountered). This does no * structural harm, and in practice appears to be a better option * than allowing unrestrained growth of levels. * * The code for all this is more verbose than you&apos;d like. Most * operations entail locating an element (or position to insert an * element). The code to do this can&apos;t be nicely factored out * because subsequent uses require a snapshot of predecessor * and/or successor and/or value fields which can&apos;t be returned * all at once, at least not without creating yet another object * to hold them -- creating such little objects is an especially * bad idea for basic internal search operations because it adds * to GC overhead. (This is one of the few times I&apos;ve wished Java * had macros.) Instead, some traversal code is interleaved within * insertion and removal operations. The control logic to handle * all the retry conditions is sometimes twisty. Most search is * broken into 2 parts. findPredecessor() searches index nodes * only, returning a base-level predecessor of the key. findNode() * finishes out the base-level search. Even with this factoring, * there is a fair amount of near-duplication of code to handle * variants. * * For explanation of algorithms sharing at least a couple of * features with this one, see Mikhail Fomitchev&apos;s thesis * (http://www.cs.yorku.ca/~mikhail/), Keir Fraser&apos;s thesis * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell&apos;s * thesis (http://www.cs.chalmers.se/~phs/). * * Given the use of tree-like index nodes, you might wonder why * this doesn&apos;t use some kind of search tree instead, which would * support somewhat faster search operations. The reason is that * there are no known efficient lock-free insertion and deletion * algorithms for search trees. The immutability of the &quot;down&quot; * links of index nodes (as opposed to mutable &quot;left&quot; fields in * true trees) makes this tractable using only CAS operations. * * Notation guide for local variables * Node: b, n, f for predecessor, node, successor * Index: q, r, d for index node, right, down. * t for another index node * Head: h * Levels: j * Keys: k, key * Values: v, value * Comparisons: c */ private static final long serialVersionUID = -8627078645895051609L; /** * Generates the initial random seed for the cheaper per-instance * random number generators used in randomLevel. */ private static final Random seedGenerator = new Random(); /** * Special value used to identify base-level header */ private static final Object BASE_HEADER = new Object(); /** * The topmost head index of the skiplist. */ private transient volatile HeadIndex&lt;K,V&gt; head; /** * The comparator used to maintain order in this map, or null * if using natural ordering. * @serial */ private final Comparator&lt;? super K&gt; comparator; /** * Seed for simple random number generator. Not volatile since it * doesn&apos;t matter too much if different threads don&apos;t see updates. */ private transient int randomSeed; /** Lazily initialized key set */ private transient KeySet keySet; /** Lazily initialized entry set */ private transient EntrySet entrySet; /** Lazily initialized values collection */ private transient Values values; /** Lazily initialized descending key set */ private transient ConcurrentNavigableMap&lt;K,V&gt; descendingMap; /** * Initializes or resets state. Needed by constructors, clone, * clear, readObject. and ConcurrentSkipListSet.clone. * (Note that comparator must be separately initialized.) */ final void initialize() { keySet = null; entrySet = null; values = null; descendingMap = null; randomSeed = seedGenerator.nextInt() | 0x0100; // ensure nonzero head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null), null, null, 1); } /** * compareAndSet head node */ private boolean casHead(HeadIndex&lt;K,V&gt; cmp, HeadIndex&lt;K,V&gt; val) { return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val); } /* ---------------- Nodes -------------- */ /** * Nodes hold keys and values, and are singly linked in sorted * order, possibly with some intervening marker nodes. The list is * headed by a dummy node accessible as head.node. The value field * is declared only as Object because it takes special non-V * values for marker and header nodes. */ static final class Node&lt;K,V&gt; { final K key; volatile Object value; volatile Node&lt;K,V&gt; next; /** * Creates a new regular node. */ Node(K key, Object value, Node&lt;K,V&gt; next) { this.key = key; this.value = value; this.next = next; } /** * Creates a new marker node. A marker is distinguished by * having its value field point to itself. Marker nodes also * have null keys, a fact that is exploited in a few places, * but this doesn&apos;t distinguish markers from the base-level * header node (head.node), which also has a null key. */ Node(Node&lt;K,V&gt; next) { this.key = null; this.value = this; this.next = next; } /** * compareAndSet value field */ boolean casValue(Object cmp, Object val) { return UNSAFE.compareAndSwapObject(this, valueOffset, cmp, val); } /** * compareAndSet next field */ boolean casNext(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val) { return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); } /** * Returns true if this node is a marker. This method isn&apos;t * actually called in any current code checking for markers * because callers will have already read value field and need * to use that read (not another done here) and so directly * test if value points to node. * @param n a possibly null reference to a node * @return true if this node is a marker node */ boolean isMarker() { return value == this; } /** * Returns true if this node is the header of base-level list. * @return true if this node is header node */ boolean isBaseHeader() { return value == BASE_HEADER; } /** * Tries to append a deletion marker to this node. * @param f the assumed current successor of this node * @return true if successful */ boolean appendMarker(Node&lt;K,V&gt; f) { return casNext(f, new Node&lt;K,V&gt;(f)); } /** * Helps out a deletion by appending marker or unlinking from * predecessor. This is called during traversals when value * field seen to be null. * @param b predecessor * @param f successor */ void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) { /* * Rechecking links and then doing only one of the * help-out stages per call tends to minimize CAS * interference among helping threads. */ if (f == next &amp;&amp; this == b.next) { if (f == null || f.value != f) // not already marked appendMarker(f); else b.casNext(this, f.next); } } /** * Returns value if this node contains a valid key-value pair, * else null. * @return this node&apos;s value if it isn&apos;t a marker or header or * is deleted, else null. */ V getValidValue() { Object v = value; if (v == this || v == BASE_HEADER) return null; return (V)v; } /** * Creates and returns a new SimpleImmutableEntry holding current * mapping if this node holds a valid value, else null. * @return new entry or null */ AbstractMap.SimpleImmutableEntry&lt;K,V&gt; createSnapshot() { V v = getValidValue(); if (v == null) return null; return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, v); } // UNSAFE mechanics private static final sun.misc.Unsafe UNSAFE; private static final long valueOffset; private static final long nextOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; valueOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;value&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); } catch (Exception e) { throw new Error(e); } } } /* ---------------- Indexing -------------- */ /** * Index nodes represent the levels of the skip list. Note that * even though both Nodes and Indexes have forward-pointing * fields, they have different types and are handled in different * ways, that can&apos;t nicely be captured by placing field in a * shared abstract class. */ static class Index&lt;K,V&gt; { final Node&lt;K,V&gt; node; final Index&lt;K,V&gt; down; volatile Index&lt;K,V&gt; right; /** * Creates index node with given values. */ Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) { this.node = node; this.down = down; this.right = right; } /** * compareAndSet right field */ final boolean casRight(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val) { return UNSAFE.compareAndSwapObject(this, rightOffset, cmp, val); } /** * Returns true if the node this indexes has been deleted. * @return true if indexed node is known to be deleted */ final boolean indexesDeletedNode() { return node.value == null; } /** * Tries to CAS newSucc as successor. To minimize races with * unlink that may lose this index node, if the node being * indexed is known to be deleted, it doesn&apos;t try to link in. * @param succ the expected current successor * @param newSucc the new successor * @return true if successful */ final boolean link(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc) { Node&lt;K,V&gt; n = node; newSucc.right = succ; return n.value != null &amp;&amp; casRight(succ, newSucc); } /** * Tries to CAS right field to skip over apparent successor * succ. Fails (forcing a retraversal by caller) if this node * is known to be deleted. * @param succ the expected current successor * @return true if successful */ final boolean unlink(Index&lt;K,V&gt; succ) { return !indexesDeletedNode() &amp;&amp; casRight(succ, succ.right); } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long rightOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Index.class; rightOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;right&quot;)); } catch (Exception e) { throw new Error(e); } } } /* ---------------- Head nodes -------------- */ /** * Nodes heading each level keep track of their level. */ static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; { final int level; HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) { super(node, down, right); this.level = level; } } /* ---------------- Comparison utilities -------------- */ /** * Represents a key with a comparator as a Comparable. * * Because most sorted collections seem to use natural ordering on * Comparables (Strings, Integers, etc), most internal methods are * geared to use them. This is generally faster than checking * per-comparison whether to use comparator or comparable because * it doesn&apos;t require a (Comparable) cast for each comparison. * (Optimizers can only sometimes remove such redundant checks * themselves.) When Comparators are used, * ComparableUsingComparators are created so that they act in the * same way as natural orderings. This penalizes use of * Comparators vs Comparables, which seems like the right * tradeoff. */ static final class ComparableUsingComparator&lt;K&gt; implements Comparable&lt;K&gt; { final K actualKey; final Comparator&lt;? super K&gt; cmp; ComparableUsingComparator(K key, Comparator&lt;? super K&gt; cmp) { this.actualKey = key; this.cmp = cmp; } public int compareTo(K k2) { return cmp.compare(actualKey, k2); } } /** * If using comparator, return a ComparableUsingComparator, else * cast key as Comparable, which may cause ClassCastException, * which is propagated back to caller. */ private Comparable&lt;? super K&gt; comparable(Object key) throws ClassCastException { if (key == null) throw new NullPointerException(); if (comparator != null) return new ComparableUsingComparator&lt;K&gt;((K)key, comparator); else return (Comparable&lt;? super K&gt;)key; } /** * Compares using comparator or natural ordering. Used when the * ComparableUsingComparator approach doesn&apos;t apply. */ int compare(K k1, K k2) throws ClassCastException { Comparator&lt;? super K&gt; cmp = comparator; if (cmp != null) return cmp.compare(k1, k2); else return ((Comparable&lt;? super K&gt;)k1).compareTo(k2); } /** * Returns true if given key greater than or equal to least and * strictly less than fence, bypassing either test if least or * fence are null. Needed mainly in submap operations. */ boolean inHalfOpenRange(K key, K least, K fence) { if (key == null) throw new NullPointerException(); return ((least == null || compare(key, least) &gt;= 0) &amp;&amp; (fence == null || compare(key, fence) &lt; 0)); } /** * Returns true if given key greater than or equal to least and less * or equal to fence. Needed mainly in submap operations. */ boolean inOpenRange(K key, K least, K fence) { if (key == null) throw new NullPointerException(); return ((least == null || compare(key, least) &gt;= 0) &amp;&amp; (fence == null || compare(key, fence) &lt;= 0)); } /* ---------------- Traversal -------------- */ /** * Returns a base-level node with key strictly less than given key, * or the base-level header if there is no such node. Also * unlinks indexes to deleted nodes found along the way. Callers * rely on this side-effect of clearing indices to deleted nodes. * @param key the key * @return a predecessor of key */ private Node&lt;K,V&gt; findPredecessor(Comparable&lt;? super K&gt; key) { if (key == null) throw new NullPointerException(); // don&apos;t postpone errors for (;;) { Index&lt;K,V&gt; q = head; Index&lt;K,V&gt; r = q.right; for (;;) { if (r != null) { Node&lt;K,V&gt; n = r.node; K k = n.key; if (n.value == null) { if (!q.unlink(r)) break; // restart r = q.right; // reread r continue; } if (key.compareTo(k) &gt; 0) { q = r; r = r.right; continue; } } Index&lt;K,V&gt; d = q.down; if (d != null) { q = d; r = d.right; } else return q.node; } } } /** * Returns node holding key or null if no such, clearing out any * deleted nodes seen along the way. Repeatedly traverses at * base-level looking for key starting at predecessor returned * from findPredecessor, processing base-level deletions as * encountered. Some callers rely on this side-effect of clearing * deleted nodes. * * Restarts occur, at traversal step centered on node n, if: * * (1) After reading n&apos;s next field, n is no longer assumed * predecessor b&apos;s current successor, which means that * we don&apos;t have a consistent 3-node snapshot and so cannot * unlink any subsequent deleted nodes encountered. * * (2) n&apos;s value field is null, indicating n is deleted, in * which case we help out an ongoing structural deletion * before retrying. Even though there are cases where such * unlinking doesn&apos;t require restart, they aren&apos;t sorted out * here because doing so would not usually outweigh cost of * restarting. * * (3) n is a marker or n&apos;s predecessor&apos;s value field is null, * indicating (among other possibilities) that * findPredecessor returned a deleted node. We can&apos;t unlink * the node because we don&apos;t know its predecessor, so rely * on another call to findPredecessor to notice and return * some earlier predecessor, which it will do. This check is * only strictly needed at beginning of loop, (and the * b.value check isn&apos;t strictly needed at all) but is done * each iteration to help avoid contention with other * threads by callers that will fail to be able to change * links, and so will retry anyway. * * The traversal loops in doPut, doRemove, and findNear all * include the same three kinds of checks. And specialized * versions appear in findFirst, and findLast and their * variants. They can&apos;t easily share code because each uses the * reads of fields held in locals occurring in the orders they * were performed. * * @param key the key * @return node holding key, or null if no such */ private Node&lt;K,V&gt; findNode(Comparable&lt;? super K&gt; key) { for (;;) { Node&lt;K,V&gt; b = findPredecessor(key); Node&lt;K,V&gt; n = b.next; for (;;) { if (n == null) return null; Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if (c == 0) return n; if (c &lt; 0) return null; b = n; n = f; } } } /** * Gets value for key using findNode. * @param okey the key * @return the value, or null if absent */ private V doGet(Object okey) { Comparable&lt;? super K&gt; key = comparable(okey); /* * Loop needed here and elsewhere in case value field goes * null just as it is about to be returned, in which case we * lost a race with a deletion, so must retry. */ for (;;) { Node&lt;K,V&gt; n = findNode(key); if (n == null) return null; Object v = n.value; if (v != null) return (V)v; } } /* ---------------- Insertion -------------- */ /** * Main insertion method. Adds element if not present, or * replaces value if present and onlyIfAbsent is false. * @param kkey the key * @param value the value that must be associated with key * @param onlyIfAbsent if should not insert if already present * @return the old value, or null if newly inserted */ private V doPut(K kkey, V value, boolean onlyIfAbsent) { Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) { Node&lt;K,V&gt; b = findPredecessor(key); Node&lt;K,V&gt; n = b.next; for (;;) { if (n != null) { Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if (c &gt; 0) { b = n; n = f; continue; } if (c == 0) { if (onlyIfAbsent || n.casValue(v, value)) return (V)v; else break; // restart if lost race to replace value } // else c &lt; 0; fall through } Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); if (!b.casNext(n, z)) break; // restart if lost race to append to b int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; } } } /** * Returns a random level for inserting a new node. * Hardwired to k=1, p=0.5, max 31 (see above and * Pugh&apos;s &quot;Skip List Cookbook&quot;, sec 3.4). * * This uses the simplest of the generators described in George * Marsaglia&apos;s &quot;Xorshift RNGs&quot; paper. This is not a high-quality * generator but is acceptable here. */ private int randomLevel() { int x = randomSeed; x ^= x &lt;&lt; 13; x ^= x &gt;&gt;&gt; 17; randomSeed = x ^= x &lt;&lt; 5; if ((x &amp; 0x80000001) != 0) // test highest and lowest bits return 0; int level = 1; while (((x &gt;&gt;&gt;= 1) &amp; 1) != 0) ++level; return level; } /** * Creates and adds index nodes for the given node. * @param z the node * @param level the level of the index */ private void insertIndex(Node&lt;K,V&gt; z, int level) { HeadIndex&lt;K,V&gt; h = head; int max = h.level; if (level &lt;= max) { Index&lt;K,V&gt; idx = null; for (int i = 1; i &lt;= level; ++i) idx = new Index&lt;K,V&gt;(z, idx, null); addIndex(idx, h, level); } else { // Add a new level /* * To reduce interference by other threads checking for * empty levels in tryReduceLevel, new levels are added * with initialized right pointers. Which in turn requires * keeping levels in an array to access them while * creating new head index nodes from the opposite * direction. */ level = max + 1; Index&lt;K,V&gt;[] idxs = (Index&lt;K,V&gt;[])new Index[level+1]; Index&lt;K,V&gt; idx = null; for (int i = 1; i &lt;= level; ++i) idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null); HeadIndex&lt;K,V&gt; oldh; int k; for (;;) { oldh = head; int oldLevel = oldh.level; if (level &lt;= oldLevel) { // lost race to add level k = level; break; } HeadIndex&lt;K,V&gt; newh = oldh; Node&lt;K,V&gt; oldbase = oldh.node; for (int j = oldLevel+1; j &lt;= level; ++j) newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j); if (casHead(oldh, newh)) { k = oldLevel; break; } } addIndex(idxs[k], oldh, k); } } /** * Adds given index nodes from given level down to 1. * @param idx the topmost index node being inserted * @param h the value of head to use to insert. This must be * snapshotted by callers to provide correct insertion level * @param indexLevel the level of the index */ private void addIndex(Index&lt;K,V&gt; idx, HeadIndex&lt;K,V&gt; h, int indexLevel) { // Track next level to insert in case of retries int insertionLevel = indexLevel; Comparable&lt;? super K&gt; key = comparable(idx.node.key); if (key == null) throw new NullPointerException(); // Similar to findPredecessor, but adding index nodes along // path to key. for (;;) { int j = h.level; Index&lt;K,V&gt; q = h; Index&lt;K,V&gt; r = q.right; Index&lt;K,V&gt; t = idx; for (;;) { if (r != null) { Node&lt;K,V&gt; n = r.node; // compare before deletion check avoids needing recheck int c = key.compareTo(n.key); if (n.value == null) { if (!q.unlink(r)) break; r = q.right; continue; } if (c &gt; 0) { q = r; r = r.right; continue; } } if (j == insertionLevel) { // Don&apos;t insert index if node already deleted if (t.indexesDeletedNode()) { findNode(key); // cleans up return; } if (!q.link(r, t)) break; // restart if (--insertionLevel == 0) { // need final deletion check before return if (t.indexesDeletedNode()) findNode(key); return; } } if (--j &gt;= insertionLevel &amp;&amp; j &lt; indexLevel) t = t.down; q = q.down; r = q.right; } } } /* ---------------- Deletion -------------- */ /** * Main deletion method. Locates node, nulls value, appends a * deletion marker, unlinks predecessor, removes associated index * nodes, and possibly reduces head index level. * * Index nodes are cleared out simply by calling findPredecessor. * which unlinks indexes to deleted nodes found along path to key, * which will include the indexes to this node. This is done * unconditionally. We can&apos;t check beforehand whether there are * index nodes because it might be the case that some or all * indexes hadn&apos;t been inserted yet for this node during initial * search for it, and we&apos;d like to ensure lack of garbage * retention, so must call to be sure. * * @param okey the key * @param value if non-null, the value that must be * associated with key * @return the node, or null if not found */ final V doRemove(Object okey, Object value) { Comparable&lt;? super K&gt; key = comparable(okey); for (;;) { Node&lt;K,V&gt; b = findPredecessor(key); Node&lt;K,V&gt; n = b.next; for (;;) { if (n == null) return null; Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if (c &lt; 0) return null; if (c &gt; 0) { b = n; n = f; continue; } if (value != null &amp;&amp; !value.equals(v)) return null; if (!n.casValue(v, null)) break; if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // Retry via findNode else { findPredecessor(key); // Clean index if (head.right == null) tryReduceLevel(); } return (V)v; } } } /** * Possibly reduce head level if it has no nodes. This method can * (rarely) make mistakes, in which case levels can disappear even * though they are about to contain index nodes. This impacts * performance, not correctness. To minimize mistakes as well as * to reduce hysteresis, the level is reduced by one only if the * topmost three levels look empty. Also, if the removed level * looks non-empty after CAS, we try to change it back quick * before anyone notices our mistake! (This trick works pretty * well because this method will practically never make mistakes * unless current thread stalls immediately before first CAS, in * which case it is very unlikely to stall again immediately * afterwards, so will recover.) * * We put up with all this rather than just let levels grow * because otherwise, even a small map that has undergone a large * number of insertions and removals will have a lot of levels, * slowing down access more than would an occasional unwanted * reduction. */ private void tryReduceLevel() { HeadIndex&lt;K,V&gt; h = head; HeadIndex&lt;K,V&gt; d; HeadIndex&lt;K,V&gt; e; if (h.level &gt; 3 &amp;&amp; (d = (HeadIndex&lt;K,V&gt;)h.down) != null &amp;&amp; (e = (HeadIndex&lt;K,V&gt;)d.down) != null &amp;&amp; e.right == null &amp;&amp; d.right == null &amp;&amp; h.right == null &amp;&amp; casHead(h, d) &amp;&amp; // try to set h.right != null) // recheck casHead(d, h); // try to backout } /* ---------------- Finding and removing first element -------------- */ /** * Specialized variant of findNode to get first valid node. * @return first node or null if empty */ Node&lt;K,V&gt; findFirst() { for (;;) { Node&lt;K,V&gt; b = head.node; Node&lt;K,V&gt; n = b.next; if (n == null) return null; if (n.value != null) return n; n.helpDelete(b, n.next); } } /** * Removes first entry; returns its snapshot. * @return null if empty, else snapshot of first entry */ Map.Entry&lt;K,V&gt; doRemoveFirstEntry() { for (;;) { Node&lt;K,V&gt; b = head.node; Node&lt;K,V&gt; n = b.next; if (n == null) return null; Node&lt;K,V&gt; f = n.next; if (n != b.next) continue; Object v = n.value; if (v == null) { n.helpDelete(b, f); continue; } if (!n.casValue(v, null)) continue; if (!n.appendMarker(f) || !b.casNext(n, f)) findFirst(); // retry clearIndexToFirst(); return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, (V)v); } } /** * Clears out index nodes associated with deleted first entry. */ private void clearIndexToFirst() { for (;;) { Index&lt;K,V&gt; q = head; for (;;) { Index&lt;K,V&gt; r = q.right; if (r != null &amp;&amp; r.indexesDeletedNode() &amp;&amp; !q.unlink(r)) break; if ((q = q.down) == null) { if (head.right == null) tryReduceLevel(); return; } } } } /* ---------------- Finding and removing last element -------------- */ /** * Specialized version of find to get last valid node. * @return last node or null if empty */ Node&lt;K,V&gt; findLast() { /* * findPredecessor can&apos;t be used to traverse index level * because this doesn&apos;t use comparisons. So traversals of * both levels are folded together. */ Index&lt;K,V&gt; q = head; for (;;) { Index&lt;K,V&gt; d, r; if ((r = q.right) != null) { if (r.indexesDeletedNode()) { q.unlink(r); q = head; // restart } else q = r; } else if ((d = q.down) != null) { q = d; } else { Node&lt;K,V&gt; b = q.node; Node&lt;K,V&gt; n = b.next; for (;;) { if (n == null) return b.isBaseHeader() ? null : b; Node&lt;K,V&gt; f = n.next; // inconsistent read if (n != b.next) break; Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; b = n; n = f; } q = head; // restart } } } /** * Specialized variant of findPredecessor to get predecessor of last * valid node. Needed when removing the last entry. It is possible * that all successors of returned node will have been deleted upon * return, in which case this method can be retried. * @return likely predecessor of last node */ private Node&lt;K,V&gt; findPredecessorOfLast() { for (;;) { Index&lt;K,V&gt; q = head; for (;;) { Index&lt;K,V&gt; d, r; if ((r = q.right) != null) { if (r.indexesDeletedNode()) { q.unlink(r); break; // must restart } // proceed as far across as possible without overshooting if (r.node.next != null) { q = r; continue; } } if ((d = q.down) != null) q = d; else return q.node; } } } /** * Removes last entry; returns its snapshot. * Specialized variant of doRemove. * @return null if empty, else snapshot of last entry */ Map.Entry&lt;K,V&gt; doRemoveLastEntry() { for (;;) { Node&lt;K,V&gt; b = findPredecessorOfLast(); Node&lt;K,V&gt; n = b.next; if (n == null) { if (b.isBaseHeader()) // empty return null; else continue; // all b&apos;s successors are deleted; retry } for (;;) { Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; if (f != null) { b = n; n = f; continue; } if (!n.casValue(v, null)) break; K key = n.key; Comparable&lt;? super K&gt; ck = comparable(key); if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(ck); // Retry via findNode else { findPredecessor(ck); // Clean index if (head.right == null) tryReduceLevel(); } return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, (V)v); } } } /* ---------------- Relational operations -------------- */ // Control values OR&apos;ed as arguments to findNear private static final int EQ = 1; private static final int LT = 2; private static final int GT = 0; // Actually checked as !LT /** * Utility for ceiling, floor, lower, higher methods. * @param kkey the key * @param rel the relation -- OR&apos;ed combination of EQ, LT, GT * @return nearest node fitting relation, or null if no such */ Node&lt;K,V&gt; findNear(K kkey, int rel) { Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) { Node&lt;K,V&gt; b = findPredecessor(key); Node&lt;K,V&gt; n = b.next; for (;;) { if (n == null) return ((rel &amp; LT) == 0 || b.isBaseHeader()) ? null : b; Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if ((c == 0 &amp;&amp; (rel &amp; EQ) != 0) || (c &lt; 0 &amp;&amp; (rel &amp; LT) == 0)) return n; if ( c &lt;= 0 &amp;&amp; (rel &amp; LT) != 0) return b.isBaseHeader() ? null : b; b = n; n = f; } } } /** * Returns SimpleImmutableEntry for results of findNear. * @param key the key * @param rel the relation -- OR&apos;ed combination of EQ, LT, GT * @return Entry fitting relation, or null if no such */ AbstractMap.SimpleImmutableEntry&lt;K,V&gt; getNear(K key, int rel) { for (;;) { Node&lt;K,V&gt; n = findNear(key, rel); if (n == null) return null; AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot(); if (e != null) return e; } } /* ---------------- Constructors -------------- */ /** * Constructs a new, empty map, sorted according to the * {@linkplain Comparable natural ordering} of the keys. */ public ConcurrentSkipListMap() { this.comparator = null; initialize(); } /** * Constructs a new, empty map, sorted according to the specified * comparator. * * @param comparator the comparator that will be used to order this map. * If &lt;tt&gt;null&lt;/tt&gt;, the {@linkplain Comparable natural * ordering} of the keys will be used. */ public ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) { this.comparator = comparator; initialize(); } /** * Constructs a new map containing the same mappings as the given map, * sorted according to the {@linkplain Comparable natural ordering} of * the keys. * * @param m the map whose mappings are to be placed in this map * @throws ClassCastException if the keys in &lt;tt&gt;m&lt;/tt&gt; are not * {@link Comparable}, or are not mutually comparable * @throws NullPointerException if the specified map or any of its keys * or values are null */ public ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m) { this.comparator = null; initialize(); putAll(m); } /** * Constructs a new map containing the same mappings and using the * same ordering as the specified sorted map. * * @param m the sorted map whose mappings are to be placed in this * map, and whose comparator is to be used to sort this map * @throws NullPointerException if the specified sorted map or any of * its keys or values are null */ public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) { this.comparator = m.comparator(); initialize(); buildFromSorted(m); } /** * Returns a shallow copy of this &lt;tt&gt;ConcurrentSkipListMap&lt;/tt&gt; * instance. (The keys and values themselves are not cloned.) * * @return a shallow copy of this map */ public ConcurrentSkipListMap&lt;K,V&gt; clone() { ConcurrentSkipListMap&lt;K,V&gt; clone = null; try { clone = (ConcurrentSkipListMap&lt;K,V&gt;) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } clone.initialize(); clone.buildFromSorted(this); return clone; } /** * Streamlined bulk insertion to initialize from elements of * given sorted map. Call only from constructor or clone * method. */ private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) { if (map == null) throw new NullPointerException(); HeadIndex&lt;K,V&gt; h = head; Node&lt;K,V&gt; basepred = h.node; // Track the current rightmost node at each level. Uses an // ArrayList to avoid committing to initial or maximum level. ArrayList&lt;Index&lt;K,V&gt;&gt; preds = new ArrayList&lt;Index&lt;K,V&gt;&gt;(); // initialize for (int i = 0; i &lt;= h.level; ++i) preds.add(null); Index&lt;K,V&gt; q = h; for (int i = h.level; i &gt; 0; --i) { preds.set(i, q); q = q.down; } Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;? extends K, ? extends V&gt; e = it.next(); int j = randomLevel(); if (j &gt; h.level) j = h.level + 1; K k = e.getKey(); V v = e.getValue(); if (k == null || v == null) throw new NullPointerException(); Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null); basepred.next = z; basepred = z; if (j &gt; 0) { Index&lt;K,V&gt; idx = null; for (int i = 1; i &lt;= j; ++i) { idx = new Index&lt;K,V&gt;(z, idx, null); if (i &gt; h.level) h = new HeadIndex&lt;K,V&gt;(h.node, h, idx, i); if (i &lt; preds.size()) { preds.get(i).right = idx; preds.set(i, idx); } else preds.add(idx); } } } head = h; } /* ---------------- Serialization -------------- */ /** * Save the state of this map to a stream. * * @serialData The key (Object) and value (Object) for each * key-value mapping represented by the map, followed by * &lt;tt&gt;null&lt;/tt&gt;. The key-value mappings are emitted in key-order * (as determined by the Comparator, or by the keys&apos; natural * ordering if no Comparator). */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out keys and values (alternating) for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) { V v = n.getValidValue(); if (v != null) { s.writeObject(n.key); s.writeObject(v); } } s.writeObject(null); } /** * Reconstitute the map from a stream. */ private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Reset transients initialize(); /* * This is nearly identical to buildFromSorted, but is * distinct because readObject calls can&apos;t be nicely adapted * as the kind of iterator needed by buildFromSorted. (They * can be, but doing so requires type cheats and/or creation * of adaptor classes.) It is simpler to just adapt the code. */ HeadIndex&lt;K,V&gt; h = head; Node&lt;K,V&gt; basepred = h.node; ArrayList&lt;Index&lt;K,V&gt;&gt; preds = new ArrayList&lt;Index&lt;K,V&gt;&gt;(); for (int i = 0; i &lt;= h.level; ++i) preds.add(null); Index&lt;K,V&gt; q = h; for (int i = h.level; i &gt; 0; --i) { preds.set(i, q); q = q.down; } for (;;) { Object k = s.readObject(); if (k == null) break; Object v = s.readObject(); if (v == null) throw new NullPointerException(); K key = (K) k; V val = (V) v; int j = randomLevel(); if (j &gt; h.level) j = h.level + 1; Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(key, val, null); basepred.next = z; basepred = z; if (j &gt; 0) { Index&lt;K,V&gt; idx = null; for (int i = 1; i &lt;= j; ++i) { idx = new Index&lt;K,V&gt;(z, idx, null); if (i &gt; h.level) h = new HeadIndex&lt;K,V&gt;(h.node, h, idx, i); if (i &lt; preds.size()) { preds.get(i).right = idx; preds.set(i, idx); } else preds.add(idx); } } } head = h; } /* ------ Map API methods ------ */ /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. * * @param key key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null */ public boolean containsKey(Object key) { return doGet(key) != null; } /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code key} compares * equal to {@code k} according to the map&apos;s ordering, then this * method returns {@code v}; otherwise it returns {@code null}. * (There can be at most one such mapping.) * * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null */ public V get(Object key) { return doGet(key); } /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with the specified key, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key or value is null */ public V put(K key, V value) { if (value == null) throw new NullPointerException(); return doPut(key, value, false); } /** * Removes the mapping for the specified key from this map if present. * * @param key key for which mapping should be removed * @return the previous value associated with the specified key, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null */ public V remove(Object key) { return doRemove(key, null); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. This operation requires time linear in the * map size. Additionally, it is possible for the map to change * during execution of this method, in which case the returned * result may be inaccurate. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if a mapping to &lt;tt&gt;value&lt;/tt&gt; exists; * &lt;tt&gt;false&lt;/tt&gt; otherwise * @throws NullPointerException if the specified value is null */ public boolean containsValue(Object value) { if (value == null) throw new NullPointerException(); for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) { V v = n.getValidValue(); if (v != null &amp;&amp; value.equals(v)) return true; } return false; } /** * Returns the number of key-value mappings in this map. If this map * contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, it * returns &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;. * * &lt;p&gt;Beware that, unlike in most collections, this method is * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the * asynchronous nature of these maps, determining the current * number of elements requires traversing them all to count them. * Additionally, it is possible for the size to change during * execution of this method, in which case the returned result * will be inaccurate. Thus, this method is typically not very * useful in concurrent applications. * * @return the number of elements in this map */ public int size() { long count = 0; for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) { if (n.getValidValue() != null) ++count; } return (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */ public boolean isEmpty() { return findFirst() == null; } /** * Removes all of the mappings from this map. */ public void clear() { initialize(); } /* ---------------- View methods -------------- */ /* * Note: Lazy initialization works for views because view classes * are stateless/immutable so it doesn&apos;t matter wrt correctness if * more than one is created (which will only rarely happen). Even * so, the following idiom conservatively ensures that the method * returns the one it created if it does so, not one created by * another racing thread. */ /** * Returns a {@link NavigableSet} view of the keys contained in this map. * The set&apos;s iterator returns the keys in ascending order. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. The set supports element * removal, which removes the corresponding mapping from the map, * via the {@code Iterator.remove}, {@code Set.remove}, * {@code removeAll}, {@code retainAll}, and {@code clear} * operations. It does not support the {@code add} or {@code addAll} * operations. * * &lt;p&gt;The view&apos;s {@code iterator} is a &quot;weakly consistent&quot; iterator * that will never throw {@link ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. * * &lt;p&gt;This method is equivalent to method {@code navigableKeySet}. * * @return a navigable set view of the keys in this map */ public NavigableSet&lt;K&gt; keySet() { KeySet ks = keySet; return (ks != null) ? ks : (keySet = new KeySet(this)); } public NavigableSet&lt;K&gt; navigableKeySet() { KeySet ks = keySet; return (ks != null) ? ks : (keySet = new KeySet(this)); } /** * Returns a {@link Collection} view of the values contained in this map. * The collection&apos;s iterator returns the values in ascending order * of the corresponding keys. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator * that will never throw {@link ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. */ public Collection&lt;V&gt; values() { Values vs = values; return (vs != null) ? vs : (values = new Values(this)); } /** * Returns a {@link Set} view of the mappings contained in this map. * The set&apos;s iterator returns the entries in ascending key order. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. The set supports element * removal, which removes the corresponding mapping from the map, * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or * &lt;tt&gt;addAll&lt;/tt&gt; operations. * * &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator * that will never throw {@link ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. * * &lt;p&gt;The &lt;tt&gt;Map.Entry&lt;/tt&gt; elements returned by * &lt;tt&gt;iterator.next()&lt;/tt&gt; do &lt;em&gt;not&lt;/em&gt; support the * &lt;tt&gt;setValue&lt;/tt&gt; operation. * * @return a set view of the mappings contained in this map, * sorted in ascending key order */ public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet(this)); } public ConcurrentNavigableMap&lt;K,V&gt; descendingMap() { ConcurrentNavigableMap&lt;K,V&gt; dm = descendingMap; return (dm != null) ? dm : (descendingMap = new SubMap&lt;K,V&gt; (this, null, false, null, false, true)); } public NavigableSet&lt;K&gt; descendingKeySet() { return descendingMap().navigableKeySet(); } /* ---------------- AbstractMap Overrides -------------- */ /** * Compares the specified object with this map for equality. * Returns &lt;tt&gt;true&lt;/tt&gt; if the given object is also a map and the * two maps represent the same mappings. More formally, two maps * &lt;tt&gt;m1&lt;/tt&gt; and &lt;tt&gt;m2&lt;/tt&gt; represent the same mappings if * &lt;tt&gt;m1.entrySet().equals(m2.entrySet())&lt;/tt&gt;. This * operation may return misleading results if either map is * concurrently modified during execution of this method. * * @param o object to be compared for equality with this map * @return &lt;tt&gt;true&lt;/tt&gt; if the specified object is equal to this map */ public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; try { for (Map.Entry&lt;K,V&gt; e : this.entrySet()) if (! e.getValue().equals(m.get(e.getKey()))) return false; for (Map.Entry&lt;?,?&gt; e : m.entrySet()) { Object k = e.getKey(); Object v = e.getValue(); if (k == null || v == null || !v.equals(get(k))) return false; } return true; } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } } /* ------ ConcurrentMap API methods ------ */ /** * {@inheritDoc} * * @return the previous value associated with the specified key, * or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key or value is null */ public V putIfAbsent(K key, V value) { if (value == null) throw new NullPointerException(); return doPut(key, value, true); } /** * {@inheritDoc} * * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null */ public boolean remove(Object key, Object value) { if (key == null) throw new NullPointerException(); if (value == null) return false; return doRemove(key, value) != null; } /** * {@inheritDoc} * * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if any of the arguments are null */ public boolean replace(K key, V oldValue, V newValue) { if (oldValue == null || newValue == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = comparable(key); for (;;) { Node&lt;K,V&gt; n = findNode(k); if (n == null) return false; Object v = n.value; if (v != null) { if (!oldValue.equals(v)) return false; if (n.casValue(v, newValue)) return true; } } } /** * {@inheritDoc} * * @return the previous value associated with the specified key, * or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key or value is null */ public V replace(K key, V value) { if (value == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = comparable(key); for (;;) { Node&lt;K,V&gt; n = findNode(k); if (n == null) return null; Object v = n.value; if (v != null &amp;&amp; n.casValue(v, value)) return (V)v; } } /* ------ SortedMap API methods ------ */ public Comparator&lt;? super K&gt; comparator() { return comparator; } /** * @throws NoSuchElementException {@inheritDoc} */ public K firstKey() { Node&lt;K,V&gt; n = findFirst(); if (n == null) throw new NoSuchElementException(); return n.key; } /** * @throws NoSuchElementException {@inheritDoc} */ public K lastKey() { Node&lt;K,V&gt; n = findLast(); if (n == null) throw new NoSuchElementException(); return n.key; } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromKey} or {@code toKey} is null * @throws IllegalArgumentException {@inheritDoc} */ public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { if (fromKey == null || toKey == null) throw new NullPointerException(); return new SubMap&lt;K,V&gt; (this, fromKey, fromInclusive, toKey, toInclusive, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code toKey} is null * @throws IllegalArgumentException {@inheritDoc} */ public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) { if (toKey == null) throw new NullPointerException(); return new SubMap&lt;K,V&gt; (this, null, false, toKey, inclusive, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromKey} is null * @throws IllegalArgumentException {@inheritDoc} */ public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) { if (fromKey == null) throw new NullPointerException(); return new SubMap&lt;K,V&gt; (this, fromKey, inclusive, null, false, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromKey} or {@code toKey} is null * @throws IllegalArgumentException {@inheritDoc} */ public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) { return subMap(fromKey, true, toKey, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code toKey} is null * @throws IllegalArgumentException {@inheritDoc} */ public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey) { return headMap(toKey, false); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if {@code fromKey} is null * @throws IllegalArgumentException {@inheritDoc} */ public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey) { return tailMap(fromKey, true); } /* ---------------- Relational operations -------------- */ /** * Returns a key-value mapping associated with the greatest key * strictly less than the given key, or &lt;tt&gt;null&lt;/tt&gt; if there is * no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support the * &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public Map.Entry&lt;K,V&gt; lowerEntry(K key) { return getNear(key, LT); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public K lowerKey(K key) { Node&lt;K,V&gt; n = findNear(key, LT); return (n == null) ? null : n.key; } /** * Returns a key-value mapping associated with the greatest key * less than or equal to the given key, or &lt;tt&gt;null&lt;/tt&gt; if there * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support * the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. * * @param key the key * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public Map.Entry&lt;K,V&gt; floorEntry(K key) { return getNear(key, LT|EQ); } /** * @param key the key * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public K floorKey(K key) { Node&lt;K,V&gt; n = findNear(key, LT|EQ); return (n == null) ? null : n.key; } /** * Returns a key-value mapping associated with the least key * greater than or equal to the given key, or &lt;tt&gt;null&lt;/tt&gt; if * there is no such entry. The returned entry does &lt;em&gt;not&lt;/em&gt; * support the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. * * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public Map.Entry&lt;K,V&gt; ceilingEntry(K key) { return getNear(key, GT|EQ); } /** * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public K ceilingKey(K key) { Node&lt;K,V&gt; n = findNear(key, GT|EQ); return (n == null) ? null : n.key; } /** * Returns a key-value mapping associated with the least key * strictly greater than the given key, or &lt;tt&gt;null&lt;/tt&gt; if there * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support * the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. * * @param key the key * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public Map.Entry&lt;K,V&gt; higherEntry(K key) { return getNear(key, GT); } /** * @param key the key * @throws ClassCastException {@inheritDoc} * @throws NullPointerException if the specified key is null */ public K higherKey(K key) { Node&lt;K,V&gt; n = findNear(key, GT); return (n == null) ? null : n.key; } /** * Returns a key-value mapping associated with the least * key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty. * The returned entry does &lt;em&gt;not&lt;/em&gt; support * the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. */ public Map.Entry&lt;K,V&gt; firstEntry() { for (;;) { Node&lt;K,V&gt; n = findFirst(); if (n == null) return null; AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot(); if (e != null) return e; } } /** * Returns a key-value mapping associated with the greatest * key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty. * The returned entry does &lt;em&gt;not&lt;/em&gt; support * the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. */ public Map.Entry&lt;K,V&gt; lastEntry() { for (;;) { Node&lt;K,V&gt; n = findLast(); if (n == null) return null; AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot(); if (e != null) return e; } } /** * Removes and returns a key-value mapping associated with * the least key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty. * The returned entry does &lt;em&gt;not&lt;/em&gt; support * the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. */ public Map.Entry&lt;K,V&gt; pollFirstEntry() { return doRemoveFirstEntry(); } /** * Removes and returns a key-value mapping associated with * the greatest key in this map, or &lt;tt&gt;null&lt;/tt&gt; if the map is empty. * The returned entry does &lt;em&gt;not&lt;/em&gt; support * the &lt;tt&gt;Entry.setValue&lt;/tt&gt; method. */ public Map.Entry&lt;K,V&gt; pollLastEntry() { return doRemoveLastEntry(); } /* ---------------- Iterators -------------- */ /** * Base of iterator classes: */ abstract class Iter&lt;T&gt; implements Iterator&lt;T&gt; { /** the last node returned by next() */ Node&lt;K,V&gt; lastReturned; /** the next node to return from next(); */ Node&lt;K,V&gt; next; /** Cache of next value field to maintain weak consistency */ V nextValue; /** Initializes ascending iterator for entire range. */ Iter() { for (;;) { next = findFirst(); if (next == null) break; Object x = next.value; if (x != null &amp;&amp; x != next) { nextValue = (V) x; break; } } } public final boolean hasNext() { return next != null; } /** Advances next to higher entry. */ final void advance() { if (next == null) throw new NoSuchElementException(); lastReturned = next; for (;;) { next = next.next; if (next == null) break; Object x = next.value; if (x != null &amp;&amp; x != next) { nextValue = (V) x; break; } } } public void remove() { Node&lt;K,V&gt; l = lastReturned; if (l == null) throw new IllegalStateException(); // It would not be worth all of the overhead to directly // unlink from here. Using remove is fast enough. ConcurrentSkipListMap.this.remove(l.key); lastReturned = null; } } final class ValueIterator extends Iter&lt;V&gt; { public V next() { V v = nextValue; advance(); return v; } } final class KeyIterator extends Iter&lt;K&gt; { public K next() { Node&lt;K,V&gt; n = next; advance(); return n.key; } } final class EntryIterator extends Iter&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { Node&lt;K,V&gt; n = next; V v = nextValue; advance(); return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v); } } // Factory methods for iterators needed by ConcurrentSkipListSet etc Iterator&lt;K&gt; keyIterator() { return new KeyIterator(); } Iterator&lt;V&gt; valueIterator() { return new ValueIterator(); } Iterator&lt;Map.Entry&lt;K,V&gt;&gt; entryIterator() { return new EntryIterator(); } /* ---------------- View Classes -------------- */ /* * View classes are static, delegating to a ConcurrentNavigableMap * to allow use by SubMaps, which outweighs the ugliness of * needing type-tests for Iterator methods. */ static final &lt;E&gt; List&lt;E&gt; toList(Collection&lt;E&gt; c) { // Using size() here would be a pessimization. List&lt;E&gt; list = new ArrayList&lt;E&gt;(); for (E e : c) list.add(e); return list; } static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; { private final ConcurrentNavigableMap&lt;E,Object&gt; m; KeySet(ConcurrentNavigableMap&lt;E,Object&gt; map) { m = map; } public int size() { return m.size(); } public boolean isEmpty() { return m.isEmpty(); } public boolean contains(Object o) { return m.containsKey(o); } public boolean remove(Object o) { return m.remove(o) != null; } public void clear() { m.clear(); } public E lower(E e) { return m.lowerKey(e); } public E floor(E e) { return m.floorKey(e); } public E ceiling(E e) { return m.ceilingKey(e); } public E higher(E e) { return m.higherKey(e); } public Comparator&lt;? super E&gt; comparator() { return m.comparator(); } public E first() { return m.firstKey(); } public E last() { return m.lastKey(); } public E pollFirst() { Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return (e == null) ? null : e.getKey(); } public E pollLast() { Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return (e == null) ? null : e.getKey(); } public Iterator&lt;E&gt; iterator() { if (m instanceof ConcurrentSkipListMap) return ((ConcurrentSkipListMap&lt;E,Object&gt;)m).keyIterator(); else return ((ConcurrentSkipListMap.SubMap&lt;E,Object&gt;)m).keyIterator(); } public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Set)) return false; Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; try { return containsAll(c) &amp;&amp; c.containsAll(this); } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } } public Object[] toArray() { return toList(this).toArray(); } public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); } public Iterator&lt;E&gt; descendingIterator() { return descendingSet().iterator(); } public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) { return new KeySet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); } public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) { return new KeySet&lt;E&gt;(m.headMap(toElement, inclusive)); } public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) { return new KeySet&lt;E&gt;(m.tailMap(fromElement, inclusive)); } public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) { return subSet(fromElement, true, toElement, false); } public NavigableSet&lt;E&gt; headSet(E toElement) { return headSet(toElement, false); } public NavigableSet&lt;E&gt; tailSet(E fromElement) { return tailSet(fromElement, true); } public NavigableSet&lt;E&gt; descendingSet() { return new KeySet(m.descendingMap()); } } static final class Values&lt;E&gt; extends AbstractCollection&lt;E&gt; { private final ConcurrentNavigableMap&lt;Object, E&gt; m; Values(ConcurrentNavigableMap&lt;Object, E&gt; map) { m = map; } public Iterator&lt;E&gt; iterator() { if (m instanceof ConcurrentSkipListMap) return ((ConcurrentSkipListMap&lt;Object,E&gt;)m).valueIterator(); else return ((SubMap&lt;Object,E&gt;)m).valueIterator(); } public boolean isEmpty() { return m.isEmpty(); } public int size() { return m.size(); } public boolean contains(Object o) { return m.containsValue(o); } public void clear() { m.clear(); } public Object[] toArray() { return toList(this).toArray(); } public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); } } static final class EntrySet&lt;K1,V1&gt; extends AbstractSet&lt;Map.Entry&lt;K1,V1&gt;&gt; { private final ConcurrentNavigableMap&lt;K1, V1&gt; m; EntrySet(ConcurrentNavigableMap&lt;K1, V1&gt; map) { m = map; } public Iterator&lt;Map.Entry&lt;K1,V1&gt;&gt; iterator() { if (m instanceof ConcurrentSkipListMap) return ((ConcurrentSkipListMap&lt;K1,V1&gt;)m).entryIterator(); else return ((SubMap&lt;K1,V1&gt;)m).entryIterator(); } public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K1,V1&gt; e = (Map.Entry&lt;K1,V1&gt;)o; V1 v = m.get(e.getKey()); return v != null &amp;&amp; v.equals(e.getValue()); } public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K1,V1&gt; e = (Map.Entry&lt;K1,V1&gt;)o; return m.remove(e.getKey(), e.getValue()); } public boolean isEmpty() { return m.isEmpty(); } public int size() { return m.size(); } public void clear() { m.clear(); } public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Set)) return false; Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; try { return containsAll(c) &amp;&amp; c.containsAll(this); } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } } public Object[] toArray() { return toList(this).toArray(); } public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); } } /** * Submaps returned by {@link ConcurrentSkipListMap} submap operations * represent a subrange of mappings of their underlying * maps. Instances of this class support all methods of their * underlying maps, differing in that mappings outside their range are * ignored, and attempts to add mappings outside their ranges result * in {@link IllegalArgumentException}. Instances of this class are * constructed only using the &lt;tt&gt;subMap&lt;/tt&gt;, &lt;tt&gt;headMap&lt;/tt&gt;, and * &lt;tt&gt;tailMap&lt;/tt&gt; methods of their underlying maps. * * @serial include */ static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable { private static final long serialVersionUID = -7647078645895051609L; /** Underlying map */ private final ConcurrentSkipListMap&lt;K,V&gt; m; /** lower bound key, or null if from start */ private final K lo; /** upper bound key, or null if to end */ private final K hi; /** inclusion flag for lo */ private final boolean loInclusive; /** inclusion flag for hi */ private final boolean hiInclusive; /** direction */ private final boolean isDescending; // Lazily initialized view holders private transient KeySet&lt;K&gt; keySetView; private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySetView; private transient Collection&lt;V&gt; valuesView; /** * Creates a new submap, initializing all fields */ SubMap(ConcurrentSkipListMap&lt;K,V&gt; map, K fromKey, boolean fromInclusive, K toKey, boolean toInclusive, boolean isDescending) { if (fromKey != null &amp;&amp; toKey != null &amp;&amp; map.compare(fromKey, toKey) &gt; 0) throw new IllegalArgumentException(&quot;inconsistent range&quot;); this.m = map; this.lo = fromKey; this.hi = toKey; this.loInclusive = fromInclusive; this.hiInclusive = toInclusive; this.isDescending = isDescending; } /* ---------------- Utilities -------------- */ private boolean tooLow(K key) { if (lo != null) { int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; } return false; } private boolean tooHigh(K key) { if (hi != null) { int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; } return false; } private boolean inBounds(K key) { return !tooLow(key) &amp;&amp; !tooHigh(key); } private void checkKeyBounds(K key) throws IllegalArgumentException { if (key == null) throw new NullPointerException(); if (!inBounds(key)) throw new IllegalArgumentException(&quot;key out of range&quot;); } /** * Returns true if node key is less than upper bound of range */ private boolean isBeforeEnd(ConcurrentSkipListMap.Node&lt;K,V&gt; n) { if (n == null) return false; if (hi == null) return true; K k = n.key; if (k == null) // pass by markers and headers return true; int c = m.compare(k, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return false; return true; } /** * Returns lowest node. This node might not be in range, so * most usages need to check bounds */ private ConcurrentSkipListMap.Node&lt;K,V&gt; loNode() { if (lo == null) return m.findFirst(); else if (loInclusive) return m.findNear(lo, m.GT|m.EQ); else return m.findNear(lo, m.GT); } /** * Returns highest node. This node might not be in range, so * most usages need to check bounds */ private ConcurrentSkipListMap.Node&lt;K,V&gt; hiNode() { if (hi == null) return m.findLast(); else if (hiInclusive) return m.findNear(hi, m.LT|m.EQ); else return m.findNear(hi, m.LT); } /** * Returns lowest absolute key (ignoring directonality) */ private K lowestKey() { ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(); if (isBeforeEnd(n)) return n.key; else throw new NoSuchElementException(); } /** * Returns highest absolute key (ignoring directonality) */ private K highestKey() { ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(); if (n != null) { K last = n.key; if (inBounds(last)) return last; } throw new NoSuchElementException(); } private Map.Entry&lt;K,V&gt; lowestEntry() { for (;;) { ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(); if (!isBeforeEnd(n)) return null; Map.Entry&lt;K,V&gt; e = n.createSnapshot(); if (e != null) return e; } } private Map.Entry&lt;K,V&gt; highestEntry() { for (;;) { ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(); if (n == null || !inBounds(n.key)) return null; Map.Entry&lt;K,V&gt; e = n.createSnapshot(); if (e != null) return e; } } private Map.Entry&lt;K,V&gt; removeLowest() { for (;;) { Node&lt;K,V&gt; n = loNode(); if (n == null) return null; K k = n.key; if (!inBounds(k)) return null; V v = m.doRemove(k, null); if (v != null) return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v); } } private Map.Entry&lt;K,V&gt; removeHighest() { for (;;) { Node&lt;K,V&gt; n = hiNode(); if (n == null) return null; K k = n.key; if (!inBounds(k)) return null; V v = m.doRemove(k, null); if (v != null) return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v); } } /** * Submap version of ConcurrentSkipListMap.getNearEntry */ private Map.Entry&lt;K,V&gt; getNearEntry(K key, int rel) { if (isDescending) { // adjust relation for direction if ((rel &amp; m.LT) == 0) rel |= m.LT; else rel &amp;= ~m.LT; } if (tooLow(key)) return ((rel &amp; m.LT) != 0) ? null : lowestEntry(); if (tooHigh(key)) return ((rel &amp; m.LT) != 0) ? highestEntry() : null; for (;;) { Node&lt;K,V&gt; n = m.findNear(key, rel); if (n == null || !inBounds(n.key)) return null; K k = n.key; V v = n.getValidValue(); if (v != null) return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v); } } // Almost the same as getNearEntry, except for keys private K getNearKey(K key, int rel) { if (isDescending) { // adjust relation for direction if ((rel &amp; m.LT) == 0) rel |= m.LT; else rel &amp;= ~m.LT; } if (tooLow(key)) { if ((rel &amp; m.LT) == 0) { ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(); if (isBeforeEnd(n)) return n.key; } return null; } if (tooHigh(key)) { if ((rel &amp; m.LT) != 0) { ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(); if (n != null) { K last = n.key; if (inBounds(last)) return last; } } return null; } for (;;) { Node&lt;K,V&gt; n = m.findNear(key, rel); if (n == null || !inBounds(n.key)) return null; K k = n.key; V v = n.getValidValue(); if (v != null) return k; } } /* ---------------- Map API methods -------------- */ public boolean containsKey(Object key) { if (key == null) throw new NullPointerException(); K k = (K)key; return inBounds(k) &amp;&amp; m.containsKey(k); } public V get(Object key) { if (key == null) throw new NullPointerException(); K k = (K)key; return ((!inBounds(k)) ? null : m.get(k)); } public V put(K key, V value) { checkKeyBounds(key); return m.put(key, value); } public V remove(Object key) { K k = (K)key; return (!inBounds(k)) ? null : m.remove(k); } public int size() { long count = 0; for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(); isBeforeEnd(n); n = n.next) { if (n.getValidValue() != null) ++count; } return count &gt;= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)count; } public boolean isEmpty() { return !isBeforeEnd(loNode()); } public boolean containsValue(Object value) { if (value == null) throw new NullPointerException(); for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(); isBeforeEnd(n); n = n.next) { V v = n.getValidValue(); if (v != null &amp;&amp; value.equals(v)) return true; } return false; } public void clear() { for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(); isBeforeEnd(n); n = n.next) { if (n.getValidValue() != null) m.remove(n.key); } } /* ---------------- ConcurrentMap API methods -------------- */ public V putIfAbsent(K key, V value) { checkKeyBounds(key); return m.putIfAbsent(key, value); } public boolean remove(Object key, Object value) { K k = (K)key; return inBounds(k) &amp;&amp; m.remove(k, value); } public boolean replace(K key, V oldValue, V newValue) { checkKeyBounds(key); return m.replace(key, oldValue, newValue); } public V replace(K key, V value) { checkKeyBounds(key); return m.replace(key, value); } /* ---------------- SortedMap API methods -------------- */ public Comparator&lt;? super K&gt; comparator() { Comparator&lt;? super K&gt; cmp = m.comparator(); if (isDescending) return Collections.reverseOrder(cmp); else return cmp; } /** * Utility to create submaps, where given bounds override * unbounded(null) ones and/or are checked against bounded ones. */ private SubMap&lt;K,V&gt; newSubMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { if (isDescending) { // flip senses K tk = fromKey; fromKey = toKey; toKey = tk; boolean ti = fromInclusive; fromInclusive = toInclusive; toInclusive = ti; } if (lo != null) { if (fromKey == null) { fromKey = lo; fromInclusive = loInclusive; } else { int c = m.compare(fromKey, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive &amp;&amp; fromInclusive)) throw new IllegalArgumentException(&quot;key out of range&quot;); } } if (hi != null) { if (toKey == null) { toKey = hi; toInclusive = hiInclusive; } else { int c = m.compare(toKey, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive &amp;&amp; toInclusive)) throw new IllegalArgumentException(&quot;key out of range&quot;); } } return new SubMap&lt;K,V&gt;(m, fromKey, fromInclusive, toKey, toInclusive, isDescending); } public SubMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) { if (fromKey == null || toKey == null) throw new NullPointerException(); return newSubMap(fromKey, fromInclusive, toKey, toInclusive); } public SubMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) { if (toKey == null) throw new NullPointerException(); return newSubMap(null, false, toKey, inclusive); } public SubMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) { if (fromKey == null) throw new NullPointerException(); return newSubMap(fromKey, inclusive, null, false); } public SubMap&lt;K,V&gt; subMap(K fromKey, K toKey) { return subMap(fromKey, true, toKey, false); } public SubMap&lt;K,V&gt; headMap(K toKey) { return headMap(toKey, false); } public SubMap&lt;K,V&gt; tailMap(K fromKey) { return tailMap(fromKey, true); } public SubMap&lt;K,V&gt; descendingMap() { return new SubMap&lt;K,V&gt;(m, lo, loInclusive, hi, hiInclusive, !isDescending); } /* ---------------- Relational methods -------------- */ public Map.Entry&lt;K,V&gt; ceilingEntry(K key) { return getNearEntry(key, (m.GT|m.EQ)); } public K ceilingKey(K key) { return getNearKey(key, (m.GT|m.EQ)); } public Map.Entry&lt;K,V&gt; lowerEntry(K key) { return getNearEntry(key, (m.LT)); } public K lowerKey(K key) { return getNearKey(key, (m.LT)); } public Map.Entry&lt;K,V&gt; floorEntry(K key) { return getNearEntry(key, (m.LT|m.EQ)); } public K floorKey(K key) { return getNearKey(key, (m.LT|m.EQ)); } public Map.Entry&lt;K,V&gt; higherEntry(K key) { return getNearEntry(key, (m.GT)); } public K higherKey(K key) { return getNearKey(key, (m.GT)); } public K firstKey() { return isDescending ? highestKey() : lowestKey(); } public K lastKey() { return isDescending ? lowestKey() : highestKey(); } public Map.Entry&lt;K,V&gt; firstEntry() { return isDescending ? highestEntry() : lowestEntry(); } public Map.Entry&lt;K,V&gt; lastEntry() { return isDescending ? lowestEntry() : highestEntry(); } public Map.Entry&lt;K,V&gt; pollFirstEntry() { return isDescending ? removeHighest() : removeLowest(); } public Map.Entry&lt;K,V&gt; pollLastEntry() { return isDescending ? removeLowest() : removeHighest(); } /* ---------------- Submap Views -------------- */ public NavigableSet&lt;K&gt; keySet() { KeySet&lt;K&gt; ks = keySetView; return (ks != null) ? ks : (keySetView = new KeySet(this)); } public NavigableSet&lt;K&gt; navigableKeySet() { KeySet&lt;K&gt; ks = keySetView; return (ks != null) ? ks : (keySetView = new KeySet(this)); } public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = valuesView; return (vs != null) ? vs : (valuesView = new Values(this)); } public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySetView; return (es != null) ? es : (entrySetView = new EntrySet(this)); } public NavigableSet&lt;K&gt; descendingKeySet() { return descendingMap().navigableKeySet(); } Iterator&lt;K&gt; keyIterator() { return new SubMapKeyIterator(); } Iterator&lt;V&gt; valueIterator() { return new SubMapValueIterator(); } Iterator&lt;Map.Entry&lt;K,V&gt;&gt; entryIterator() { return new SubMapEntryIterator(); } /** * Variant of main Iter class to traverse through submaps. */ abstract class SubMapIter&lt;T&gt; implements Iterator&lt;T&gt; { /** the last node returned by next() */ Node&lt;K,V&gt; lastReturned; /** the next node to return from next(); */ Node&lt;K,V&gt; next; /** Cache of next value field to maintain weak consistency */ V nextValue; SubMapIter() { for (;;) { next = isDescending ? hiNode() : loNode(); if (next == null) break; Object x = next.value; if (x != null &amp;&amp; x != next) { if (! inBounds(next.key)) next = null; else nextValue = (V) x; break; } } } public final boolean hasNext() { return next != null; } final void advance() { if (next == null) throw new NoSuchElementException(); lastReturned = next; if (isDescending) descend(); else ascend(); } private void ascend() { for (;;) { next = next.next; if (next == null) break; Object x = next.value; if (x != null &amp;&amp; x != next) { if (tooHigh(next.key)) next = null; else nextValue = (V) x; break; } } } private void descend() { for (;;) { next = m.findNear(lastReturned.key, LT); if (next == null) break; Object x = next.value; if (x != null &amp;&amp; x != next) { if (tooLow(next.key)) next = null; else nextValue = (V) x; break; } } } public void remove() { Node&lt;K,V&gt; l = lastReturned; if (l == null) throw new IllegalStateException(); m.remove(l.key); lastReturned = null; } } final class SubMapValueIterator extends SubMapIter&lt;V&gt; { public V next() { V v = nextValue; advance(); return v; } } final class SubMapKeyIterator extends SubMapIter&lt;K&gt; { public K next() { Node&lt;K,V&gt; n = next; advance(); return n.key; } } final class SubMapEntryIterator extends SubMapIter&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { Node&lt;K,V&gt; n = next; V v = nextValue; advance(); return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v); } } } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long headOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = ConcurrentSkipListMap.class; headOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;head&quot;)); } catch (Exception e) { throw new Error(e); } } } 下面从ConcurrentSkipListMap的添加，删除，获取这3个方面对它进行分析。 4.1 添加下面以put(K key, V value)为例，对ConcurrentSkipListMap的添加方法进行说明。 public V put(K key, V value) { if (value == null) throw new NullPointerException(); return doPut(key, value, false); } 实际上，put()是通过doPut()将key-value键值对添加到ConcurrentSkipListMap中的。 doPut()的源码如下： private V doPut(K kkey, V value, boolean onlyIfAbsent) { Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) { // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“key的前继节点的后继节点”，即n应该是“插入节点”的“后继节点” Node&lt;K,V&gt; n = b.next; for (;;) { if (n != null) { Node&lt;K,V&gt; f = n.next; // 如果两次获得的b.next不是相同的Node，就跳转到”外层for循环“，重新获得b和n后再遍历。 if (n != b.next) break; // v是“n的值” Object v = n.value; // 当n的值为null(意味着其它线程删除了n)；此时删除b的下一个节点，然后跳转到”外层for循环“，重新获得b和n后再遍历。 if (v == null) { // n is deleted n.helpDelete(b, f); break; } // 如果其它线程删除了b；则跳转到”外层for循环“，重新获得b和n后再遍历。 if (v == n || b.value == null) // b is deleted break; // 比较key和n.key int c = key.compareTo(n.key); if (c &gt; 0) { b = n; n = f; continue; } if (c == 0) { if (onlyIfAbsent || n.casValue(v, value)) return (V)v; else break; // restart if lost race to replace value } // else c &lt; 0; fall through } // 新建节点(对应是“要插入的键值对”) Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); // 设置“b的后继节点”为z if (!b.casNext(n, z)) break; // 多线程情况下，break才可能发生(其它线程对b进行了操作) // 随机获取一个level // 然后在“第1层”到“第level层”的链表中都插入新建节点 int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; } } } 说明：doPut() 的作用就是将键值对添加到“跳表”中。要想搞清doPut()，首先要弄清楚它的主干部分 —— 我们先单纯的只考虑“单线程的情况下，将key-value添加到跳表中”，即忽略“多线程相关的内容”。它的流程如下： 第1步：找到“插入位置”。&nbsp;&nbsp;&nbsp;&nbsp; 即，找到“key的前继节点(b)”和“key的后继节点(n)”；key是要插入节点的键。第2步：新建并插入节点。&nbsp;&nbsp;&nbsp;&nbsp; 即，新建节点z(key对应的节点)，并将新节点z插入到“跳表”中(设置“b的后继节点为z”，“z的后继节点为n”)。第3步：更新跳表。&nbsp;&nbsp;&nbsp;&nbsp; 即，随机获取一个level，然后在“跳表”的第1层～第level层之间，每一层都插入节点z；在第level层之上就不再插入节点了。若level数值大于“跳表的层次”，则新建一层。 主干部分“对应的精简后的doPut()的代码”如下(仅供参考)： private V doPut(K kkey, V value, boolean onlyIfAbsent) { Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) { // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为key的后继节点 Node&lt;K,V&gt; n = b.next; for (;;) { // 新建节点(对应是“要被插入的键值对”) Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); // 设置“b的后继节点”为z b.casNext(n, z); // 随机获取一个level // 然后在“第1层”到“第level层”的链表中都插入新建节点 int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; } } } 理清主干之后，剩余的工作就相对简单了。主要是上面几步的对应算法的具体实现，以及多线程相关情况的处理！ 4.2 删除下面以remove(Object key)为例，对ConcurrentSkipListMap的删除方法进行说明。 public V remove(Object key) { return doRemove(key, null); } 实际上，remove()是通过doRemove()将ConcurrentSkipListMap中的key对应的键值对删除的。 doRemove()的源码如下： final V doRemove(Object okey, Object value) { Comparable&lt;? super K&gt; key = comparable(okey); for (;;) { // 找到“key的前继节点” Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) { if (n == null) return null; // f是“当前节点n的后继节点” Node&lt;K,V&gt; f = n.next; // 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (n != b.next) // inconsistent read break; // 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 Object v = n.value; if (v == null) { // n is deleted n.helpDelete(b, f); break; } // 如果“前继节点b”被删除(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if (c &lt; 0) return null; if (c &gt; 0) { b = n; n = f; continue; } // 以下是c=0的情况 if (value != null &amp;&amp; !value.equals(v)) return null; // 设置“当前节点n”的值为null if (!n.casValue(v, null)) break; // 设置“b的后继节点”为f if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // Retry via findNode else { // 清除“跳表”中每一层的key节点 findPredecessor(key); // Clean index // 如果“表头的右索引为空”，则将“跳表的层次”-1。 if (head.right == null) tryReduceLevel(); } return (V)v; } } } 说明：doRemove()的作用是删除跳表中的节点。和doPut()一样，我们重点看doRemove()的主干部分，了解主干部分之后，其余部分就非常容易理解了。下面是“单线程的情况下，删除跳表中键值对的步骤”： 第1步：找到“被删除节点的位置”。&nbsp;&nbsp;&nbsp;&nbsp; 即，找到“key的前继节点(b)”，“key所对应的节点(n)”，“n的后继节点f”；key是要删除节点的键。第2步：删除节点。&nbsp;&nbsp;&nbsp;&nbsp; 即，将“key所对应的节点n”从跳表中移除 – 将“b的后继节点”设为“f”！第3步：更新跳表。&nbsp;&nbsp;&nbsp;&nbsp; 即，遍历跳表，删除每一层的“key节点”(如果存在的话)。如果删除“key节点”之后，跳表的层次需要-1；则执行相应的操作！ 主干部分“对应的精简后的doRemove()的代码”如下(仅供参考)： final V doRemove(Object okey, Object value) { Comparable&lt;? super K&gt; key = comparable(okey); for (;;) { // 找到“key的前继节点” Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) { // f是“当前节点n的后继节点” Node&lt;K,V&gt; f = n.next; // 设置“当前节点n”的值为null n.casValue(v, null); // 设置“b的后继节点”为f b.casNext(n, f); // 清除“跳表”中每一层的key节点 findPredecessor(key); // 如果“表头的右索引为空”，则将“跳表的层次”-1。 if (head.right == null) tryReduceLevel(); return (V)v; } } } 4.3 获取下面以get(Object key)为例，对ConcurrentSkipListMap的获取方法进行说明。 public V get(Object key) { return doGet(key); } doGet的源码如下： private V doGet(Object okey) { Comparable&lt;? super K&gt; key = comparable(okey); for (;;) { // 找到“key对应的节点” Node&lt;K,V&gt; n = findNode(key); if (n == null) return null; Object v = n.value; if (v != null) return (V)v; } } 说明：doGet()是通过findNode()找到并返回节点的。 private Node&lt;K,V&gt; findNode(Comparable&lt;? super K&gt; key) { for (;;) { // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) { // 如果“n为null”，则跳转中不存在key对应的节点，直接返回null。 if (n == null) return null; Node&lt;K,V&gt; f = n.next; // 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (n != b.next) // inconsistent read break; Object v = n.value; // 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (v == null) { // n is deleted n.helpDelete(b, f); break; } if (v == n || b.value == null) // b is deleted break; // 若n是当前节点，则返回n。 int c = key.compareTo(n.key); if (c == 0) return n; // 若“节点n的key”小于“key”，则说明跳表中不存在key对应的节点，返回null if (c &lt; 0) return null; // 若“节点n的key”大于“key”，则更新b和n，继续查找。 b = n; n = f; } } } 说明：findNode(key)的作用是在返回跳表中key对应的节点；存在则返回节点，不存在则返回null。先弄清函数的主干部分，即抛开“多线程相关内容”，单纯的考虑单线程情况下，从跳表获取节点的算法。 第1步：找到“被删除节点的位置”。&nbsp;&nbsp;&nbsp;&nbsp; 根据findPredecessor()定位key所在的层次以及找到key的前继节点(b)，然后找到b的后继节点n。第2步：根据“key的前继节点(b)”和“key的前继节点的后继节点(n)”来定位“key对应的节点”。&nbsp;&nbsp;&nbsp;&nbsp; 具体是通过比较“n的键值”和“key”的大小。如果相等，则n就是所要查找的键。 5. ConcurrentSkipListMap示例import java.util.*; import java.util.concurrent.*; /* * ConcurrentSkipListMap是“线程安全”的哈希表，而TreeMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentSkipListMap对象时，程序能正常运行。 * (02) 当map是TreeMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class ConcurrentSkipListMapDemo1 { // TODO: map是TreeMap对象时，程序会出错。 //private static Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(); private static Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;String, String&gt;(); public static void main(String[] args) { // 同时启动两个线程对map进行操作！ new MyThread(&quot;a&quot;).start(); new MyThread(&quot;b&quot;).start(); } private static void printAll() { String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print(&quot;(&quot;+key+&quot;, &quot;+value+&quot;), &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;序号&quot; String val = Thread.currentThread().getName()+i; map.put(val, &quot;0&quot;); // 通过“Iterator”遍历map。 printAll(); } } } } (某一次)运行结果： (a1, 0), (a1, 0), (b1, 0), (b1, 0), (a1, 0), (b1, 0), (b2, 0), (a1, 0), (a1, 0), (a2, 0), (a2, 0), (b1, 0), (b1, 0), (b2, 0), (b2, 0), (b3, 0), (b3, 0), (a1, 0), (a2, 0), (a3, 0), (a1, 0), (b1, 0), (a2, 0), (b2, 0), (a3, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (a1, 0), (b3, 0), (a2, 0), (b4, 0), (a3, 0), (a1, 0), (a4, 0), (a2, 0), (b1, 0), (a3, 0), (b2, 0), (a4, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (a1, 0), (b4, 0), (a2, 0), (b5, 0), (a3, 0), (a1, 0), (a4, 0), (a2, 0), (a5, 0), (a3, 0), (b1, 0), (a4, 0), (b2, 0), (a5, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (b6, 0), (b4, 0), (a1, 0), (b5, 0), (a2, 0), (b6, 0), (a3, 0), (a4, 0), (a5, 0), (a6, 0), (b1, 0), (b2, 0), (b3, 0), (b4, 0), (b5, 0), (b6, 0), 结果说明：示例程序中，启动两个线程(线程a和线程b)分别对ConcurrentSkipListMap进行操作。以线程a而言，它会先获取“线程名”+“序号”，然后将该字符串作为key，将“0”作为value，插入到ConcurrentSkipListMap中；接着，遍历并输出ConcurrentSkipListMap中的全部元素。 线程b的操作和线程a一样，只不过线程b的名字和线程a的名字不同。当map是ConcurrentSkipListMap对象时，程序能正常运行。如果将map改为TreeMap时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”04之 ConcurrentHashMap","date":"2016-11-11T20:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”04之 ConcurrentHashMap/","text":"本章是JUC系列的ConcurrentHashMap篇。 目录1. ConcurrentHashMap介绍2. ConcurrentHashMap原理和数据结构3. ConcurrentHashMap函数列表4. ConcurrentHashMap源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1 创建&nbsp;&nbsp;&nbsp;&nbsp; 4.2 获取&nbsp;&nbsp;&nbsp;&nbsp; 4.3 增加&nbsp;&nbsp;&nbsp;&nbsp; 4.4 删除5. ConcurrentHashMap示例 1. ConcurrentHashMap介绍ConcurrentHashMap是线程安全的哈希表。HashMap, Hashtable, ConcurrentHashMap之间的关联如下： (01) HashMap是非线程安全的哈希表，常用于单线程程序中。(02) Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的。&nbsp;&nbsp;&nbsp;&nbsp; 即，多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低(此时建议使用ConcurrentHashMap)！因为当一个线程访问Hashtable的同步方法时，其它线程就访问Hashtable的同步方法时，可能会进入阻塞状态。(03) ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来保证线程安全的。&nbsp;&nbsp;&nbsp;&nbsp; ConcurrentHashMap将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。 关于HashMap,Hashtable以及ReentrantLock的更多内容，可以参考：[1. Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例][link_java_collection_10][2. Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例][link_java_collection_11][3. Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock][link_juc_lock02] 2. ConcurrentHashMap原理和数据结构要想搞清ConcurrentHashMap，必须先弄清楚它的数据结构： img (01) ConcurrentHashMap继承于AbstractMap抽象类。(02) Segment是ConcurrentHashMap中的内部类，它就是ConcurrentHashMap中的“锁分段”对应的存储结构。ConcurrentHashMap与Segment是组合关系，1个ConcurrentHashMap对象包含若干个Segment对象。在代码中，这表现为ConcurrentHashMap类中存在“Segment数组”成员。(03) Segment类继承于ReentrantLock类，所以Segment本质上是一个可重入的互斥锁。(04) HashEntry也是ConcurrentHashMap的内部类，是单向链表节点，存储着key-value键值对。Segment与HashEntry是组合关系，Segment类中存在“HashEntry数组”成员，“HashEntry数组”中的每个HashEntry就是一个单向链表。 对于多线程访问对一个“哈希表对象”竞争资源，Hashtable是通过一把锁来控制并发；而ConcurrentHashMap则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap对并发的控制更加细腻，它也更加适应于高并发场景！ 3. ConcurrentHashMap函数列表// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。 ConcurrentHashMap() // 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。 ConcurrentHashMap(int initialCapacity) // 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。 ConcurrentHashMap(int initialCapacity, float loadFactor) // 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。 ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) // 构造一个与给定映射具有相同映射关系的新映射。 ConcurrentHashMap(Map&lt;? extends K,? extends V&gt; m) // 从该映射中移除所有映射关系 void clear() // 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。 boolean contains(Object value) // 测试指定对象是否为此表中的键。 boolean containsKey(Object key) // 如果此映射将一个或多个键映射到指定值，则返回 true。 boolean containsValue(Object value) // 返回此表中值的枚举。 Enumeration&lt;V&gt; elements() // 返回此映射所包含的映射关系的 Set 视图。 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() // 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。 V get(Object key) // 如果此映射不包含键-值映射关系，则返回 true。 boolean isEmpty() // 返回此表中键的枚举。 Enumeration&lt;K&gt; keys() // 返回此映射中包含的键的 Set 视图。 Set&lt;K&gt; keySet() // 将指定键映射到此表中的指定值。 V put(K key, V value) // 将指定映射中所有映射关系复制到此映射中。 void putAll(Map&lt;? extends K,? extends V&gt; m) // 如果指定键已经不再与某个值相关联，则将它与给定值关联。 V putIfAbsent(K key, V value) // 从此映射中移除键（及其相应的值）。 V remove(Object key) // 只有目前将键的条目映射到给定值时，才移除该键的条目。 boolean remove(Object key, Object value) // 只有目前将键的条目映射到某一值时，才替换该键的条目。 V replace(K key, V value) // 只有目前将键的条目映射到给定值时，才替换该键的条目。 boolean replace(K key, V oldValue, V newValue) // 返回此映射中的键-值映射关系数。 int size() // 返回此映射中包含的值的 Collection 视图。 Collection&lt;V&gt; values() 4. ConcurrentHashMap源码分析(JDK1.7.0_40版本)ConcurrentHashMap.java的完整源码如下： public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable { private static final long serialVersionUID = 7249069246763182397L; /** * The default initial capacity for this table, * used when not otherwise specified in a constructor. */ static final int DEFAULT_INITIAL_CAPACITY = 16; /** * The default load factor for this table, used when not * otherwise specified in a constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The default concurrency level for this table, used when not * otherwise specified in a constructor. */ static final int DEFAULT_CONCURRENCY_LEVEL = 16; /** * The maximum capacity, used if a higher value is implicitly * specified by either of the constructors with arguments. MUST * be a power of two &lt;= 1&lt;&lt;30 to ensure that entries are indexable * using ints. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The minimum capacity for per-segment tables. Must be a power * of two, at least two to avoid immediate resizing on next use * after lazy construction. */ static final int MIN_SEGMENT_TABLE_CAPACITY = 2; /** * The maximum number of segments to allow; used to bound * constructor arguments. Must be power of two less than 1 &lt;&lt; 24. */ static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative /** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */ static final int RETRIES_BEFORE_LOCK = 2; /* ---------------- Fields -------------- */ /** * holds values which can&apos;t be initialized until after VM is booted. */ private static class Holder { /** * Enable alternative hashing of String keys? * * &lt;p&gt;Unlike the other hash map implementations we do not implement a * threshold for regulating whether alternative hashing is used for * String keys. Alternative hashing is either enabled for all instances * or disabled for all instances. */ static final boolean ALTERNATIVE_HASHING; static { // Use the &quot;threshold&quot; system property even though our threshold // behaviour is &quot;ON&quot; or &quot;OFF&quot;. String altThreshold = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction( &quot;jdk.map.althashing.threshold&quot;)); int threshold; try { threshold = (null != altThreshold) ? Integer.parseInt(altThreshold) : Integer.MAX_VALUE; // disable alternative hashing if -1 if (threshold == -1) { threshold = Integer.MAX_VALUE; } if (threshold &lt; 0) { throw new IllegalArgumentException(&quot;value must be positive integer.&quot;); } } catch(IllegalArgumentException failed) { throw new Error(&quot;Illegal value for &apos;jdk.map.althashing.threshold&apos;&quot;, failed); } ALTERNATIVE_HASHING = threshold &lt;= MAXIMUM_CAPACITY; } } /** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. */ private transient final int hashSeed = randomHashSeed(this); private static int randomHashSeed(ConcurrentHashMap instance) { if (sun.misc.VM.isBooted() &amp;&amp; Holder.ALTERNATIVE_HASHING) { return sun.misc.Hashing.randomHashSeed(instance); } return 0; } /** * Mask value for indexing into segments. The upper bits of a * key&apos;s hash code are used to choose the segment. */ final int segmentMask; /** * Shift value for indexing within segments. */ final int segmentShift; /** * The segments, each of which is a specialized hash table. */ final Segment&lt;K,V&gt;[] segments; transient Set&lt;K&gt; keySet; transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient Collection&lt;V&gt; values; /** * ConcurrentHashMap list entry. Note that this is never exported * out as a user-visible Map.Entry. */ static final class HashEntry&lt;K,V&gt; { final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } /** * Sets next field with volatile write semantics. (See above * about use of putOrderedObject.) */ final void setNext(HashEntry&lt;K,V&gt; n) { UNSAFE.putOrderedObject(this, nextOffset, n); } // Unsafe mechanics static final sun.misc.Unsafe UNSAFE; static final long nextOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = HashEntry.class; nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); } catch (Exception e) { throw new Error(e); } } } /** * Gets the ith element of given table (if nonnull) with volatile * read semantics. Note: This is manually integrated into a few * performance-sensitive methods to reduce call overhead. */ @SuppressWarnings(&quot;unchecked&quot;) static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryAt(HashEntry&lt;K,V&gt;[] tab, int i) { return (tab == null) ? null : (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)i &lt;&lt; TSHIFT) + TBASE); } /** * Sets the ith element of given table, with volatile write * semantics. (See above about use of putOrderedObject.) */ static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) { UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e); } /** * Applies a supplemental hash function to a given hashCode, which * defends against poor quality hash functions. This is critical * because ConcurrentHashMap uses power-of-two length hash tables, * that otherwise encounter collisions for hashCodes that do not * differ in lower or upper bits. */ private int hash(Object k) { int h = hashSeed; if ((0 != h) &amp;&amp; (k instanceof String)) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16); } /** * Segments are specialized versions of hash tables. This * subclasses from ReentrantLock opportunistically, just to * simplify some locking and avoid separate construction. */ static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable { /* * Segments maintain a table of entry lists that are always * kept in a consistent state, so can be read (via volatile * reads of segments and tables) without locking. This * requires replicating nodes when necessary during table * resizing, so the old lists can be traversed by readers * still using old version of table. * * This class defines only mutative methods requiring locking. * Except as noted, the methods of this class perform the * per-segment versions of ConcurrentHashMap methods. (Other * methods are integrated directly into ConcurrentHashMap * methods.) These mutative methods use a form of controlled * spinning on contention via methods scanAndLock and * scanAndLockForPut. These intersperse tryLocks with * traversals to locate nodes. The main benefit is to absorb * cache misses (which are very common for hash tables) while * obtaining locks so that traversal is faster once * acquired. We do not actually use the found nodes since they * must be re-acquired under lock anyway to ensure sequential * consistency of updates (and in any case may be undetectably * stale), but they will normally be much faster to re-locate. * Also, scanAndLockForPut speculatively creates a fresh node * to use in put if no node is found. */ private static final long serialVersionUID = 2249069246763182397L; /** * The maximum number of times to tryLock in a prescan before * possibly blocking on acquire in preparation for a locked * segment operation. On multiprocessors, using a bounded * number of retries maintains cache acquired while locating * nodes. */ static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; /** * The per-segment table. Elements are accessed via * entryAt/setEntryAt providing volatile semantics. */ transient volatile HashEntry&lt;K,V&gt;[] table; /** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */ transient int count; /** * The total number of mutative operations in this segment. * Even though this may overflows 32 bits, it provides * sufficient accuracy for stability checks in CHM isEmpty() * and size() methods. Accessed only either within locks or * among other volatile reads that maintain visibility. */ transient int modCount; /** * The table is rehashed when its size exceeds this threshold. * (The value of this field is always &lt;tt&gt;(int)(capacity * * loadFactor)&lt;/tt&gt;.) */ transient int threshold; /** * The load factor for the hash table. Even though this value * is same for all segments, it is replicated to avoid needing * links to outer object. * @serial */ final float loadFactor; Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) { this.loadFactor = lf; this.threshold = threshold; this.table = tab; } final V put(K key, int hash, V value, boolean onlyIfAbsent) { HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) { if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } /** * Doubles size of table and repacks entries, also adding the * given node to new table */ @SuppressWarnings(&quot;unchecked&quot;) private void rehash(HashEntry&lt;K,V&gt; node) { /* * Reclassify nodes in each list to new table. Because we * are using power-of-two expansion, the elements from * each bin must either stay at same index, or move with a * power of two offset. We eliminate unnecessary node * creation by catching cases where old nodes can be * reused because their next fields won&apos;t change. * Statistically, at the default threshold, only about * one-sixth of them need cloning when a table * doubles. The nodes they replace will be garbage * collectable as soon as they are no longer referenced by * any reader thread that may be in the midst of * concurrently traversing table. Entry accesses use plain * array indexing because they are followed by volatile * table write. */ HashEntry&lt;K,V&gt;[] oldTable = table; int oldCapacity = oldTable.length; int newCapacity = oldCapacity &lt;&lt; 1; threshold = (int)(newCapacity * loadFactor); HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1; for (int i = 0; i &lt; oldCapacity ; i++) { HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) { HashEntry&lt;K,V&gt; next = e.next; int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list newTable[idx] = e; else { // Reuse consecutive sequence at same slot HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) { int k = last.hash &amp; sizeMask; if (k != lastIdx) { lastIdx = k; lastRun = last; } } newTable[lastIdx] = lastRun; // Clone remaining nodes for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) { V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); } } } } int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable; } /** * Scans for a node containing given key while trying to * acquire lock, creating and returning one if not found. Upon * return, guarantees that lock is held. UNlike in most * methods, calls to method equals are not screened: Since * traversal speed doesn&apos;t matter, we might as well help warm * up the associated code and accesses as well. * * @return a new node if key not found, else null */ private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) { HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; int retries = -1; // negative while locating node while (!tryLock()) { HashEntry&lt;K,V&gt; f; // to recheck first below if (retries &lt; 0) { if (e == null) { if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; } else if (key.equals(e.key)) retries = 0; else e = e.next; } else if (++retries &gt; MAX_SCAN_RETRIES) { lock(); break; } else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) { e = first = f; // re-traverse if entry changed retries = -1; } } return node; } /** * Scans for a node containing the given key while trying to * acquire lock for a remove or replace operation. Upon * return, guarantees that lock is held. Note that we must * lock even if the key is not found, to ensure sequential * consistency of updates. */ private void scanAndLock(Object key, int hash) { // similar to but simpler than scanAndLockForPut HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; int retries = -1; while (!tryLock()) { HashEntry&lt;K,V&gt; f; if (retries &lt; 0) { if (e == null || key.equals(e.key)) retries = 0; else e = e.next; } else if (++retries &gt; MAX_SCAN_RETRIES) { lock(); break; } else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) { e = first = f; retries = -1; } } } /** * Remove; match on key only if value null, else match both. */ final V remove(Object key, int hash, Object value) { if (!tryLock()) scanAndLock(key, hash); V oldValue = null; try { HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; e = entryAt(tab, index); HashEntry&lt;K,V&gt; pred = null; while (e != null) { K k; HashEntry&lt;K,V&gt; next = e.next; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { V v = e.value; if (value == null || value == v || value.equals(v)) { if (pred == null) setEntryAt(tab, index, next); else pred.setNext(next); ++modCount; --count; oldValue = v; } break; } pred = e; e = next; } } finally { unlock(); } return oldValue; } final boolean replace(K key, int hash, V oldValue, V newValue) { if (!tryLock()) scanAndLock(key, hash); boolean replaced = false; try { HashEntry&lt;K,V&gt; e; for (e = entryForHash(this, hash); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { if (oldValue.equals(e.value)) { e.value = newValue; ++modCount; replaced = true; } break; } } } finally { unlock(); } return replaced; } final V replace(K key, int hash, V value) { if (!tryLock()) scanAndLock(key, hash); V oldValue = null; try { HashEntry&lt;K,V&gt; e; for (e = entryForHash(this, hash); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { oldValue = e.value; e.value = value; ++modCount; break; } } } finally { unlock(); } return oldValue; } final void clear() { lock(); try { HashEntry&lt;K,V&gt;[] tab = table; for (int i = 0; i &lt; tab.length ; i++) setEntryAt(tab, i, null); ++modCount; count = 0; } finally { unlock(); } } } // Accessing segments /** * Gets the jth element of given segment array (if nonnull) with * volatile element access semantics via Unsafe. (The null check * can trigger harmlessly only during deserialization.) Note: * because each element of segments array is set only once (using * fully ordered writes), some performance-sensitive methods rely * on this method only as a recheck upon null reads. */ @SuppressWarnings(&quot;unchecked&quot;) static final &lt;K,V&gt; Segment&lt;K,V&gt; segmentAt(Segment&lt;K,V&gt;[] ss, int j) { long u = (j &lt;&lt; SSHIFT) + SBASE; return ss == null ? null : (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(ss, u); } /** * Returns the segment for the given index, creating it and * recording in segment table (via CAS) if not already present. * * @param k the index * @return the segment */ @SuppressWarnings(&quot;unchecked&quot;) private Segment&lt;K,V&gt; ensureSegment(int k) { final Segment&lt;K,V&gt;[] ss = this.segments; long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset Segment&lt;K,V&gt; seg; if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype int cap = proto.table.length; float lf = proto.loadFactor; int threshold = (int)(cap * lf); HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap]; if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab); while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s)) break; } } } return seg; } // Hash-based segment and entry accesses /** * Get the segment for the given hash */ @SuppressWarnings(&quot;unchecked&quot;) private Segment&lt;K,V&gt; segmentForHash(int h) { long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; return (Segment&lt;K,V&gt;) UNSAFE.getObjectVolatile(segments, u); } /** * Gets the table entry for the given segment and hash */ @SuppressWarnings(&quot;unchecked&quot;) static final &lt;K,V&gt; HashEntry&lt;K,V&gt; entryForHash(Segment&lt;K,V&gt; seg, int h) { HashEntry&lt;K,V&gt;[] tab; return (seg == null || (tab = seg.table) == null) ? null : (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); } /* ---------------- Public operations -------------- */ /** * Creates a new, empty map with the specified initial * capacity, load factor and concurrency level. * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements. * @param loadFactor the load factor threshold, used to control resizing. * Resizing may be performed when the average number of elements per * bin exceeds this threshold. * @param concurrencyLevel the estimated number of concurrently * updating threads. The implementation performs internal sizing * to try to accommodate this many threads. * @throws IllegalArgumentException if the initial capacity is * negative or the load factor or concurrencyLevel are * nonpositive. */ @SuppressWarnings(&quot;unchecked&quot;) public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1; while (ssize &lt; concurrencyLevel) { ++sshift; ssize &lt;&lt;= 1; } this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } /** * Creates a new, empty map with the specified initial capacity * and load factor and with the default concurrencyLevel (16). * * @param initialCapacity The implementation performs internal * sizing to accommodate this many elements. * @param loadFactor the load factor threshold, used to control resizing. * Resizing may be performed when the average number of elements per * bin exceeds this threshold. * @throws IllegalArgumentException if the initial capacity of * elements is negative or the load factor is nonpositive * * @since 1.6 */ public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL); } /** * Creates a new, empty map with the specified initial capacity, * and with default load factor (0.75) and concurrencyLevel (16). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements. * @throws IllegalArgumentException if the initial capacity of * elements is negative. */ public ConcurrentHashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); } /** * Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16). */ public ConcurrentHashMap() { this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); } /** * Creates a new map with the same mappings as the given map. * The map is created with a capacity of 1.5 times the number * of mappings in the given map or 16 (whichever is greater), * and a default load factor (0.75) and concurrencyLevel (16). * * @param m the map */ public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); putAll(m); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */ public boolean isEmpty() { /* * Sum per-segment modCounts to avoid mis-reporting when * elements are concurrently added and removed in one segment * while checking another, in which case the table was never * actually empty at any point. (The sum ensures accuracy up * through at least 1&lt;&lt;31 per-segment modifications before * recheck.) Methods size() and containsValue() use similar * constructions for stability checks. */ long sum = 0L; final Segment&lt;K,V&gt;[] segments = this.segments; for (int j = 0; j &lt; segments.length; ++j) { Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) { if (seg.count != 0) return false; sum += seg.modCount; } } if (sum != 0L) { // recheck unless no modifications for (int j = 0; j &lt; segments.length; ++j) { Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) { if (seg.count != 0) return false; sum -= seg.modCount; } } if (sum != 0L) return false; } return true; } /** * Returns the number of key-value mappings in this map. If the * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;. * * @return the number of key-value mappings in this map */ public int size() { // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn&apos;t retry try { for (;;) { if (retries++ == RETRIES_BEFORE_LOCK) { for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation } sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) { Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) { sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; } } if (sum == last) break; last = sum; } } finally { if (retries &gt; RETRIES_BEFORE_LOCK) { for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); } } return overflow ? Integer.MAX_VALUE : size; } /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code key.equals(k)}, * then this method returns {@code v}; otherwise it returns * {@code null}. (There can be at most one such mapping.) * * @throws NullPointerException if the specified key is null */ public V get(Object key) { Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) { for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; } } return null; } /** * Tests if the specified object is a key in this table. * * @param key possible key * @return &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object * is a key in this table, as determined by the * &lt;tt&gt;equals&lt;/tt&gt; method; &lt;tt&gt;false&lt;/tt&gt; otherwise. * @throws NullPointerException if the specified key is null */ @SuppressWarnings(&quot;unchecked&quot;) public boolean containsKey(Object key) { Segment&lt;K,V&gt; s; // same as get() except no need for volatile value read HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) { for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return true; } } return false; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. Note: This method requires a full internal * traversal of the hash table, and so is much slower than * method &lt;tt&gt;containsKey&lt;/tt&gt;. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value * @throws NullPointerException if the specified value is null */ public boolean containsValue(Object value) { // Same idea as size() if (value == null) throw new NullPointerException(); final Segment&lt;K,V&gt;[] segments = this.segments; boolean found = false; long last = 0; int retries = -1; try { outer: for (;;) { if (retries++ == RETRIES_BEFORE_LOCK) { for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation } long hashSum = 0L; int sum = 0; for (int j = 0; j &lt; segments.length; ++j) { HashEntry&lt;K,V&gt;[] tab; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null &amp;&amp; (tab = seg.table) != null) { for (int i = 0 ; i &lt; tab.length; i++) { HashEntry&lt;K,V&gt; e; for (e = entryAt(tab, i); e != null; e = e.next) { V v = e.value; if (v != null &amp;&amp; value.equals(v)) { found = true; break outer; } } } sum += seg.modCount; } } if (retries &gt; 0 &amp;&amp; sum == last) break; last = sum; } } finally { if (retries &gt; RETRIES_BEFORE_LOCK) { for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); } } return found; } /** * Legacy method testing if some key maps into the specified value * in this table. This method is identical in functionality to * {@link #containsValue}, and exists solely to ensure * full compatibility with class {@link java.util.Hashtable}, * which supported this method prior to introduction of the * Java Collections framework. * @param value a value to search for * @return &lt;tt&gt;true&lt;/tt&gt; if and only if some key maps to the * &lt;tt&gt;value&lt;/tt&gt; argument in this table as * determined by the &lt;tt&gt;equals&lt;/tt&gt; method; * &lt;tt&gt;false&lt;/tt&gt; otherwise * @throws NullPointerException if the specified value is null */ public boolean contains(Object value) { return containsValue(value); } /** * Maps the specified key to the specified value in this table. * Neither the key nor the value can be null. * * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method * with a key that is equal to the original key. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt; * @throws NullPointerException if the specified key or value is null */ @SuppressWarnings(&quot;unchecked&quot;) public V put(K key, V value) { Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); } /** * {@inheritDoc} * * @return the previous value associated with the specified key, * or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key * @throws NullPointerException if the specified key or value is null */ @SuppressWarnings(&quot;unchecked&quot;) public V putIfAbsent(K key, V value) { Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) s = ensureSegment(j); return s.put(key, hash, value, true); } /** * Copies all of the mappings from the specified map to this one. * These mappings replace any mappings that this map had for any of the * keys currently in the specified map. * * @param m mappings to be stored in this map */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) { for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); } /** * Removes the key (and its corresponding value) from this map. * This method does nothing if the key is not in the map. * * @param key the key that needs to be removed * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt; * @throws NullPointerException if the specified key is null */ public V remove(Object key) { int hash = hash(key); Segment&lt;K,V&gt; s = segmentForHash(hash); return s == null ? null : s.remove(key, hash, null); } /** * {@inheritDoc} * * @throws NullPointerException if the specified key is null */ public boolean remove(Object key, Object value) { int hash = hash(key); Segment&lt;K,V&gt; s; return value != null &amp;&amp; (s = segmentForHash(hash)) != null &amp;&amp; s.remove(key, hash, value) != null; } /** * {@inheritDoc} * * @throws NullPointerException if any of the arguments are null */ public boolean replace(K key, V oldValue, V newValue) { int hash = hash(key); if (oldValue == null || newValue == null) throw new NullPointerException(); Segment&lt;K,V&gt; s = segmentForHash(hash); return s != null &amp;&amp; s.replace(key, hash, oldValue, newValue); } /** * {@inheritDoc} * * @return the previous value associated with the specified key, * or &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key * @throws NullPointerException if the specified key or value is null */ public V replace(K key, V value) { int hash = hash(key); if (value == null) throw new NullPointerException(); Segment&lt;K,V&gt; s = segmentForHash(hash); return s == null ? null : s.replace(key, hash, value); } /** * Removes all of the mappings from this map. */ public void clear() { final Segment&lt;K,V&gt;[] segments = this.segments; for (int j = 0; j &lt; segments.length; ++j) { Segment&lt;K,V&gt; s = segmentAt(segments, j); if (s != null) s.clear(); } } /** * Returns a {@link Set} view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. The set supports element * removal, which removes the corresponding mapping from this map, * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or * &lt;tt&gt;addAll&lt;/tt&gt; operations. * * &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator * that will never throw {@link ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. */ public Set&lt;K&gt; keySet() { Set&lt;K&gt; ks = keySet; return (ks != null) ? ks : (keySet = new KeySet()); } /** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. The collection * supports element removal, which removes the corresponding * mapping from this map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator * that will never throw {@link ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. */ public Collection&lt;V&gt; values() { Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); } /** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. The set supports element * removal, which removes the corresponding mapping from the map, * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or * &lt;tt&gt;addAll&lt;/tt&gt; operations. * * &lt;p&gt;The view&apos;s &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator * that will never throw {@link ConcurrentModificationException}, * and guarantees to traverse elements as they existed upon * construction of the iterator, and may (but is not guaranteed to) * reflect any modifications subsequent to construction. */ public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); } /** * Returns an enumeration of the keys in this table. * * @return an enumeration of the keys in this table * @see #keySet() */ public Enumeration&lt;K&gt; keys() { return new KeyIterator(); } /** * Returns an enumeration of the values in this table. * * @return an enumeration of the values in this table * @see #values() */ public Enumeration&lt;V&gt; elements() { return new ValueIterator(); } /* ---------------- Iterator Support -------------- */ abstract class HashIterator { int nextSegmentIndex; int nextTableIndex; HashEntry&lt;K,V&gt;[] currentTable; HashEntry&lt;K, V&gt; nextEntry; HashEntry&lt;K, V&gt; lastReturned; HashIterator() { nextSegmentIndex = segments.length - 1; nextTableIndex = -1; advance(); } /** * Set nextEntry to first node of next non-empty table * (in backwards order, to simplify checks). */ final void advance() { for (;;) { if (nextTableIndex &gt;= 0) { if ((nextEntry = entryAt(currentTable, nextTableIndex--)) != null) break; } else if (nextSegmentIndex &gt;= 0) { Segment&lt;K,V&gt; seg = segmentAt(segments, nextSegmentIndex--); if (seg != null &amp;&amp; (currentTable = seg.table) != null) nextTableIndex = currentTable.length - 1; } else break; } } final HashEntry&lt;K,V&gt; nextEntry() { HashEntry&lt;K,V&gt; e = nextEntry; if (e == null) throw new NoSuchElementException(); lastReturned = e; // cannot assign until after null check if ((nextEntry = e.next) == null) advance(); return e; } public final boolean hasNext() { return nextEntry != null; } public final boolean hasMoreElements() { return nextEntry != null; } public final void remove() { if (lastReturned == null) throw new IllegalStateException(); ConcurrentHashMap.this.remove(lastReturned.key); lastReturned = null; } } final class KeyIterator extends HashIterator implements Iterator&lt;K&gt;, Enumeration&lt;K&gt; { public final K next() { return super.nextEntry().key; } public final K nextElement() { return super.nextEntry().key; } } final class ValueIterator extends HashIterator implements Iterator&lt;V&gt;, Enumeration&lt;V&gt; { public final V next() { return super.nextEntry().value; } public final V nextElement() { return super.nextEntry().value; } } /** * Custom Entry class used by EntryIterator.next(), that relays * setValue changes to the underlying map. */ final class WriteThroughEntry extends AbstractMap.SimpleEntry&lt;K,V&gt; { WriteThroughEntry(K k, V v) { super(k,v); } /** * Set our entry&apos;s value and write through to the map. The * value to return is somewhat arbitrary here. Since a * WriteThroughEntry does not necessarily track asynchronous * changes, the most recent &quot;previous&quot; value could be * different from what we return (or could even have been * removed in which case the put will re-establish). We do not * and cannot guarantee more. */ public V setValue(V value) { if (value == null) throw new NullPointerException(); V v = super.setValue(value); ConcurrentHashMap.this.put(getKey(), value); return v; } } final class EntryIterator extends HashIterator implements Iterator&lt;Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() { HashEntry&lt;K,V&gt; e = super.nextEntry(); return new WriteThroughEntry(e.key, e.value); } } final class KeySet extends AbstractSet&lt;K&gt; { public Iterator&lt;K&gt; iterator() { return new KeyIterator(); } public int size() { return ConcurrentHashMap.this.size(); } public boolean isEmpty() { return ConcurrentHashMap.this.isEmpty(); } public boolean contains(Object o) { return ConcurrentHashMap.this.containsKey(o); } public boolean remove(Object o) { return ConcurrentHashMap.this.remove(o) != null; } public void clear() { ConcurrentHashMap.this.clear(); } } final class Values extends AbstractCollection&lt;V&gt; { public Iterator&lt;V&gt; iterator() { return new ValueIterator(); } public int size() { return ConcurrentHashMap.this.size(); } public boolean isEmpty() { return ConcurrentHashMap.this.isEmpty(); } public boolean contains(Object o) { return ConcurrentHashMap.this.containsValue(o); } public void clear() { ConcurrentHashMap.this.clear(); } } final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; { public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() { return new EntryIterator(); } public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; V v = ConcurrentHashMap.this.get(e.getKey()); return v != null &amp;&amp; v.equals(e.getValue()); } public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return ConcurrentHashMap.this.remove(e.getKey(), e.getValue()); } public int size() { return ConcurrentHashMap.this.size(); } public boolean isEmpty() { return ConcurrentHashMap.this.isEmpty(); } public void clear() { ConcurrentHashMap.this.clear(); } } /* ---------------- Serialization Support -------------- */ /** * Save the state of the &lt;tt&gt;ConcurrentHashMap&lt;/tt&gt; instance to a * stream (i.e., serialize it). * @param s the stream * @serialData * the key (Object) and value (Object) * for each key-value mapping, followed by a null pair. * The key-value mappings are emitted in no particular order. */ private void writeObject(java.io.ObjectOutputStream s) throws IOException { // force all segments for serialization compatibility for (int k = 0; k &lt; segments.length; ++k) ensureSegment(k); s.defaultWriteObject(); final Segment&lt;K,V&gt;[] segments = this.segments; for (int k = 0; k &lt; segments.length; ++k) { Segment&lt;K,V&gt; seg = segmentAt(segments, k); seg.lock(); try { HashEntry&lt;K,V&gt;[] tab = seg.table; for (int i = 0; i &lt; tab.length; ++i) { HashEntry&lt;K,V&gt; e; for (e = entryAt(tab, i); e != null; e = e.next) { s.writeObject(e.key); s.writeObject(e.value); } } } finally { seg.unlock(); } } s.writeObject(null); s.writeObject(null); } /** * Reconstitute the &lt;tt&gt;ConcurrentHashMap&lt;/tt&gt; instance from a * stream (i.e., deserialize it). * @param s the stream */ @SuppressWarnings(&quot;unchecked&quot;) private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Don&apos;t call defaultReadObject() ObjectInputStream.GetField oisFields = s.readFields(); final Segment&lt;K,V&gt;[] oisSegments = (Segment&lt;K,V&gt;[])oisFields.get(&quot;segments&quot;, null); final int ssize = oisSegments.length; if (ssize &lt; 1 || ssize &gt; MAX_SEGMENTS || (ssize &amp; (ssize-1)) != 0 ) // ssize not power of two throw new java.io.InvalidObjectException(&quot;Bad number of segments:&quot; + ssize); int sshift = 0, ssizeTmp = ssize; while (ssizeTmp &gt; 1) { ++sshift; ssizeTmp &gt;&gt;&gt;= 1; } UNSAFE.putIntVolatile(this, SEGSHIFT_OFFSET, 32 - sshift); UNSAFE.putIntVolatile(this, SEGMASK_OFFSET, ssize - 1); UNSAFE.putObjectVolatile(this, SEGMENTS_OFFSET, oisSegments); // set hashMask UNSAFE.putIntVolatile(this, HASHSEED_OFFSET, randomHashSeed(this)); // Re-initialize segments to be minimally sized, and let grow. int cap = MIN_SEGMENT_TABLE_CAPACITY; final Segment&lt;K,V&gt;[] segments = this.segments; for (int k = 0; k &lt; segments.length; ++k) { Segment&lt;K,V&gt; seg = segments[k]; if (seg != null) { seg.threshold = (int)(cap * seg.loadFactor); seg.table = (HashEntry&lt;K,V&gt;[]) new HashEntry[cap]; } } // Read the keys and values, and put the mappings in the table for (;;) { K key = (K) s.readObject(); V value = (V) s.readObject(); if (key == null) break; put(key, value); } } // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long SBASE; private static final int SSHIFT; private static final long TBASE; private static final int TSHIFT; private static final long HASHSEED_OFFSET; private static final long SEGSHIFT_OFFSET; private static final long SEGMASK_OFFSET; private static final long SEGMENTS_OFFSET; static { int ss, ts; try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class tc = HashEntry[].class; Class sc = Segment[].class; TBASE = UNSAFE.arrayBaseOffset(tc); SBASE = UNSAFE.arrayBaseOffset(sc); ts = UNSAFE.arrayIndexScale(tc); ss = UNSAFE.arrayIndexScale(sc); HASHSEED_OFFSET = UNSAFE.objectFieldOffset( ConcurrentHashMap.class.getDeclaredField(&quot;hashSeed&quot;)); SEGSHIFT_OFFSET = UNSAFE.objectFieldOffset( ConcurrentHashMap.class.getDeclaredField(&quot;segmentShift&quot;)); SEGMASK_OFFSET = UNSAFE.objectFieldOffset( ConcurrentHashMap.class.getDeclaredField(&quot;segmentMask&quot;)); SEGMENTS_OFFSET = UNSAFE.objectFieldOffset( ConcurrentHashMap.class.getDeclaredField(&quot;segments&quot;)); } catch (Exception e) { throw new Error(e); } if ((ss &amp; (ss-1)) != 0 || (ts &amp; (ts-1)) != 0) throw new Error(&quot;data type scale not a power of two&quot;); SSHIFT = 31 - Integer.numberOfLeadingZeros(ss); TSHIFT = 31 - Integer.numberOfLeadingZeros(ts); } } 下面从ConcurrentHashMap的创建，获取，添加，删除这4个方面对ConcurrentHashMap进行分析。 4.1 创建下面以ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)来进行说明。 @SuppressWarnings(&quot;unchecked&quot;) public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { // 参数有效性判断 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); // concurrencyLevel是“用来计算segments的容量” if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; int sshift = 0; int ssize = 1; // ssize=“大于或等于concurrencyLevel的最小的2的N次方值” while (ssize &lt; concurrencyLevel) { ++sshift; ssize &lt;&lt;= 1; } // 初始化segmentShift和segmentMask this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; // 哈希表的初始容量 // 哈希表的实际容量=“segments的容量” x “segments中数组的长度” if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // “哈希表的初始容量” / “segments的容量” int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; // cap就是“segments中的HashEntry数组的长度” int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // segments Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } 说明：(01) 前面我们说过，ConcurrentHashMap采用了“锁分段”技术；在代码中，它通过“segments数组”对象来保存各个分段。segments的定义如下： final Segment&lt;K,V&gt;[] segments; concurrencyLevel的作用就是用来计算segments数组的容量大小。先计算出“大于或等于concurrencyLevel的最小的2的N次方值”，然后将其保存为“segments的容量大小(ssize)”。(02) initialCapacity是哈希表的初始容量。需要注意的是，哈希表的实际容量=“segments的容量” x “segments中数组的长度”。(03) loadFactor是加载因子。它是哈希表在其容量自动增加之前可以达到多满的一种尺度。 ConcurrentHashMap的构造函数中涉及到的非常重要的一个结构体，它就是Segment。下面看看Segment的声明： static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable { ... transient volatile HashEntry&lt;K,V&gt;[] table; // threshold阈，是哈希表在其容量自动增加之前可以达到多满的一种尺度。 transient int threshold; // loadFactor是加载因子 final float loadFactor; Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) { this.loadFactor = lf; this.threshold = threshold; this.table = tab; } ... } 说明：Segment包含HashEntry数组，HashEntry保存了哈希表中的键值对。此外，还需要说明的Segment继承于ReentrantLock。这意味着，Segment本质上就是可重入的互斥锁。 HashEntry的源码如下： static final class HashEntry&lt;K,V&gt; { final int hash; // 哈希值 final K key; // 键 volatile V value; // 值 volatile HashEntry&lt;K,V&gt; next; // 下一个HashEntry节点 HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } ... } 说明：和HashMap的节点一样，HashEntry也是链表。这就说明，ConcurrentHashMap是链式哈希表，它是通过“拉链法”来解决哈希冲突的。 4.2 获取下面以get(Object key)为例，对ConcurrentHashMap的获取方法进行说明。 public V get(Object key) { Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 获取key对应的Segment片段。 // 如果Segment片段不为null，则在“Segment片段的HashEntry数组中”中找到key所对应的HashEntry列表； // 接着遍历该HashEntry链表，找到于key-value键值对对应的HashEntry节点。 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) { for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) { K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; } } return null; } 说明：get(Object key)的作用是返回key在ConcurrentHashMap哈希表中对应的值。它首先根据key计算出来的哈希值，获取key所对应的Segment片段。如果Segment片段不为null，则在“Segment片段的HashEntry数组中”中找到key所对应的HashEntry列表。Segment包含“HashEntry数组”对象，而每一个HashEntry本质上是一个单向链表。接着遍历该HashEntry链表，找到于key-value键值对对应的HashEntry节点。 下面是hash()的源码 private int hash(Object k) { int h = hashSeed; if ((0 != h) &amp;&amp; (k instanceof String)) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16); } 4.3 增加下面以put(K key, V value)来对ConcurrentHashMap中增加键值对来进行说明。 public V put(K key, V value) { Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); // 获取key对应的哈希值 int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // 如果找不到该Segment，则新建一个。 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); } 说明：(01) put()根据key获取对应的哈希值，再根据哈希值找到对应的Segment片段。如果Segment片段不存在，则新增一个Segment。(02) 将key-value键值对添加到Segment片段中。 final V put(K key, int hash, V value, boolean onlyIfAbsent) { // tryLock()获取锁，成功返回true，失败返回false。 // 获取锁失败的话，则通过scanAndLockForPut()获取锁，并返回”要插入的key-value“对应的”HashEntry链表“。 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { // tab代表”当前Segment中的HashEntry数组“ HashEntry&lt;K,V&gt;[] tab = table; // 根据”hash值“获取”HashEntry数组中对应的HashEntry链表“ int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) { // 如果”HashEntry链表中的当前HashEntry节点“不为null， if (e != null) { K k; // 当”要插入的key-value键值对“已经存在于”HashEntry链表中“时，先保存原有的值。 // 若”onlyIfAbsent“为true，即”要插入的key不存在时才插入”，则直接退出； // 否则，用新的value值覆盖原有的原有的值。 if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { // 如果node非空，则将first设置为“node的下一个节点”。 // 否则，新建HashEntry链表 if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 如果添加key-value键值对之后，Segment中的元素超过阈值(并且，HashEntry数组的长度没超过限制)，则rehash； // 否则，直接添加key-value键值对。 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { // 释放锁 unlock(); } return oldValue; } 说明：put()的作用是将key-value键值对插入到“当前Segment对应的HashEntry中”，在插入前它会获取Segment对应的互斥锁，插入后会释放锁。具体的插入过程如下：(01) 首先根据“hash值”获取“当前Segment的HashEntry数组对象”中的“HashEntry节点”，每个HashEntry节点都是一个单向链表。(02) 接着，遍历HashEntry链表。&nbsp;&nbsp;&nbsp;&nbsp; 若在遍历HashEntry链表时，找到与“要key-value键值对”对应的节点，即“要插入的key-value键值对”的key已经存在于HashEntry链表中。则根据onlyIfAbsent进行判断，若onlyIfAbsent为true，即“当要插入的key不存在时才插入”，则不进行插入，直接返回；否则，用新的value值覆盖原始的value值，然后再返回。&nbsp;&nbsp;&nbsp;&nbsp; 若在遍历HashEntry链表时，没有找到与“要key-value键值对”对应的节点。当node!=null时，即在scanAndLockForPut()获取锁时，已经新建了key-value对应的HashEntry节点，则”将HashEntry添加到Segment中“；否则，新建key-value对应的HashEntry节点，然后再“将HashEntry添加到Segment中”。 在”将HashEntry添加到Segment中“前，会判断是否需要rehash。如果在添加key-value键值之后，容量会超过阈值，并且HashEntry数组的长度没有超过限制，则进行rehash；否则，直接通过setEntryAt()将key-value键值对添加到Segment中。 在介绍rehash()和setEntryAt()之前，我们先看看自旋函数scanAndLockForPut()。下面是它的源码： private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) { // 第一个HashEntry节点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); // 当前的HashEntry节点 HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; // 重复计数(自旋计数器) int retries = -1; // negative while locating node // 查找”key-value键值对“在”HashEntry链表上对应的节点“； // 若找到的话，则不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。 // 若没有找到的话，则新建一个HashEntry链表。然后不断的自旋。 // 此外，若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋工作！ while (!tryLock()) { HashEntry&lt;K,V&gt; f; // to recheck first below // 1. retries&lt;0的处理情况 if (retries &lt; 0) { // 1.1 如果当前的HashEntry节点为空(意味着，在该HashEntry链表上上没有找到”要插入的键值对“对应的节点)，而且node=null；则新建HashEntry链表。 if (e == null) { if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; } // 1.2 如果当前的HashEntry节点是”要插入的键值对在该HashEntry上对应的节点“，则设置retries=0 else if (key.equals(e.key)) retries = 0; // 1.3 设置为下一个HashEntry。 else e = e.next; } // 2. 如果自旋次数超过限制，则获取“锁”并退出 else if (++retries &gt; MAX_SCAN_RETRIES) { lock(); break; } // 3. 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。 // 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。 // 若是的话，则重置e，first和retries的值，并重新遍历。 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) { e = first = f; // re-traverse if entry changed retries = -1; } } return node; } 说明：scanAndLockForPut()的目标是获取锁。流程如下： 它首先会调用entryForHash()，根据hash值获取”当前Segment中对应的HashEntry节点(first)，即找到对应的HashEntry链表“。紧接着进入while循环。在while循环中，它会遍历”HashEntry链表(e)“，查找”要插入的key-value键值对“在”该HashEntry链表上对应的节点“。&nbsp;&nbsp;&nbsp;&nbsp; 若找到的话，则不断的自旋，即不断的执行while循环。在自旋期间，若通过tryLock()获取锁成功则返回；否则，在自旋MAX_SCAN_RETRIES次数之后，强制获取锁并退出。&nbsp;&nbsp;&nbsp;&nbsp; 若没有找到的话，则新建一个HashEntry链表，然后不断的自旋。在自旋期间，若通过tryLock()获取锁成功则返回；否则，在自旋MAX_SCAN_RETRIES次数之后，强制获取锁并退出。 此外，若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋工作！ 理解scanAndLockForPut()时，务必要联系”哈希表“的数据结构。一个Segment本身就是一个哈希表，Segment中包含了”HashEntry数组“对象，而每一个HashEntry对象本身是一个”单向链表“。 下面看看rehash()的实现代码。 private void rehash(HashEntry&lt;K,V&gt; node) { HashEntry&lt;K,V&gt;[] oldTable = table; // ”Segment中原始的HashEntry数组的长度“ int oldCapacity = oldTable.length; // ”Segment中新HashEntry数组的长度“ int newCapacity = oldCapacity &lt;&lt; 1; // 新的阈值 threshold = (int)(newCapacity * loadFactor); // 新的HashEntry数组 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1; // 遍历”原始的HashEntry数组“， // 将”原始的HashEntry数组“中的每个”HashEntry链表“的值，都复制到”新的HashEntry数组的HashEntry元素“中。 for (int i = 0; i &lt; oldCapacity ; i++) { // 获取”原始的HashEntry数组“中的”第i个HashEntry链表“ HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) { HashEntry&lt;K,V&gt; next = e.next; int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list newTable[idx] = e; else { // Reuse consecutive sequence at same slot HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) { int k = last.hash &amp; sizeMask; if (k != lastIdx) { lastIdx = k; lastRun = last; } } newTable[lastIdx] = lastRun; // 将”原始的HashEntry数组“中的”HashEntry链表(e)“的值，都复制到”新的HashEntry数组的HashEntry“中。 for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) { V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); } } } } // 将新的node节点添加到“Segment的新HashEntry数组(newTable)“中。 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable; } 说明：rehash()的作用是将”Segment的容量“变为”原始的Segment容量的2倍“。在将原始的数据拷贝到“新的Segment”中后，会将新增加的key-value键值对添加到“新的Segment”中。 setEntryAt()的源码如下： static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) { UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e); } UNSAFE是Segment类中定义的“静态sun.misc.Unsafe”对象。源码如下： static final sun.misc.Unsafe UNSAFE; Unsafe.java在openjdk6中的路径是：openjdk6/jdk/src/share/classes/sun/misc/Unsafe.java。其中，putOrderedObject()的源码下： public native void putOrderedObject(Object o, long offset, Object x); 说明：putOrderedObject()是一个本地方法。它会设置obj对象中offset偏移地址对应的object型field的值为指定值。它是一个有序或者有延迟的putObjectVolatile()方法，并且不保证值的改变被其他线程立即看到。只有在field被volatile修饰并且期望被意外修改的时候，使用putOrderedObject()才有用。 总之，setEntryAt()的目的是设置tab中第i位置元素的值为e，且该设置会有延迟。 4.4 删除下面以remove(Object key)来对ConcurrentHashMap中的删除操作来进行说明。 public V remove(Object key) { int hash = hash(key); // 根据hash值，找到key对应的Segment片段。 Segment&lt;K,V&gt; s = segmentForHash(hash); return s == null ? null : s.remove(key, hash, null); } 说明：remove()首先根据“key的计算出来的哈希值”找到对应的Segment片段，然后再从该Segment片段中删除对应的“key-value键值对”。 remove()的方法如下： final V remove(Object key, int hash, Object value) { // 尝试获取Segment对应的锁。 // 尝试失败的话，则通过scanAndLock()来获取锁。 if (!tryLock()) scanAndLock(key, hash); V oldValue = null; try { // 根据“hash值”找到“Segment的HashEntry数组”中对应的“HashEntry节点(e)”，该HashEntry节点是一HashEntry个链表。 HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; e = entryAt(tab, index); HashEntry&lt;K,V&gt; pred = null; // 遍历“HashEntry链表”，删除key-value键值对 while (e != null) { K k; HashEntry&lt;K,V&gt; next = e.next; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { V v = e.value; if (value == null || value == v || value.equals(v)) { if (pred == null) setEntryAt(tab, index, next); else pred.setNext(next); ++modCount; --count; oldValue = v; } break; } pred = e; e = next; } } finally { // 释放锁 unlock(); } return oldValue; } 说明：remove()的目的就是删除key-value键值对。在删除之前，它会获取到Segment的互斥锁，在删除之后，再释放锁。它的删除过程也比较简单，它会先根据hash值，找到“Segment的HashEntry数组”中对应的“HashEntry”节点。根据Segment的数据结构，我们知道Segment中包含一个HashEntry数组对象，而每一个HashEntry本质上是一个单向链表。 在找到“HashEntry”节点之后，就遍历该“HashEntry”节点对应的链表，找到key-value键值对对应的节点，然后删除。 下面对scanAndLock()进行说明。它的源码如下： private void scanAndLock(Object key, int hash) { // 第一个HashEntry节点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; int retries = -1; // 查找”key-value键值对“在”HashEntry链表上对应的节点“； // 无论找没找到，最后都会不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。 // 若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋！ while (!tryLock()) { HashEntry&lt;K,V&gt; f; if (retries &lt; 0) { // 如果“遍历完该HashEntry链表，仍然没找到”要删除的键值对“对应的节点” // 或者“在该HashEntry链表上找到”要删除的键值对“对应的节点”，则设置retries=0 // 否则，设置e为下一个HashEntry节点。 if (e == null || key.equals(e.key)) retries = 0; else e = e.next; } // 自旋超过限制次数之后，获取锁并退出。 else if (++retries &gt; MAX_SCAN_RETRIES) { lock(); break; } // 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。 // 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。 // 若是的话，则重置e，first和retries的值，并重新遍历。 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) { e = first = f; retries = -1; } } } 说明：scanAndLock()的目标是获取锁。它的实现与scanAndLockForPut()类似，这里就不再过多说明。 总结：ConcurrentHashMap是线程安全的哈希表，它是通过“锁分段”来实现的。ConcurrentHashMap中包括了“Segment(锁分段)数组”，每个Segment就是一个哈希表，而且也是可重入的互斥锁。第一，Segment是哈希表表现在，Segment包含了“HashEntry数组”，而“HashEntry数组”中的每一个HashEntry元素是一个单向链表。即Segment是通过链式哈希表。第二，Segment是可重入的互斥锁表现在，Segment继承于ReentrantLock，而ReentrantLock就是可重入的互斥锁。对于ConcurrentHashMap的添加，删除操作，在操作开始前，线程都会获取Segment的互斥锁；操作完毕之后，才会释放。而对于读取操作，它是通过volatile去实现的，HashEntry数组是volatile类型的，而volatile能保证“即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入”，即我们总能读到其它线程写入HashEntry之后的值。 以上这些方式，就是ConcurrentHashMap线程安全的实现原理。 5. ConcurrentHashMap示例下面，我们通过一个例子去对比HashMap和ConcurrentHashMap。 import java.util.*; import java.util.concurrent.*; /* * ConcurrentHashMap是“线程安全”的哈希表，而HashMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentHashMap对象时，程序能正常运行。 * (02) 当map是HashMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class ConcurrentHashMapDemo1 { // TODO: map是HashMap对象时，程序会出错。 //private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); private static Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;(); public static void main(String[] args) { // 同时启动两个线程对map进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print(key+&quot; - &quot;+value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName()+i; map.put(String.valueOf(i), val); // 通过“Iterator”遍历map。 printAll(); } } } } (某一次)运行结果： 1 - tb1, 1 - tb1, 1 - tb1, 1 - tb1, 2 - tb2, 2 - tb2, 1 - tb1, 3 - ta3, 1 - tb1, 2 - tb2, 3 - tb3, 1 - tb1, 2 - tb2, 3 - tb3, 1 - tb1, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 1 - tb1, 2 - tb2, 5 - ta5, 1 - tb1, 3 - tb3, 5 - tb5, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 1 - tb1, 2 - tb2, 5 - tb5, 1 - tb1, 6 - tb6, 5 - tb5, 3 - tb3, 6 - tb6, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 2 - tb2, 结果说明：如果将源码中的map改成HashMap对象时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”03之 CopyOnWriteArraySet","date":"2016-11-11T19:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”03之 CopyOnWriteArraySet/","text":"本章是JUC系列中的CopyOnWriteArraySet篇。接下来，会先对CopyOnWriteArraySet进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解CopyOnWriteArraySet。 目录1. CopyOnWriteArraySet介绍2. CopyOnWriteArraySet原理和数据结构3. CopyOnWriteArraySet函数列表4. CopyOnWriteArraySet源码(JDK1.7.0_40版本)5. CopyOnWriteArraySet示例 1. CopyOnWriteArraySet介绍它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表(HashMap)”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。 和CopyOnWriteArrayList类似，CopyOnWriteArraySet具有以下特性：(01). 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。(02). 它是线程安全的。(03). 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。(04). 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等 操作。**(05). 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 建议：在学习CopyOnWriteArraySet之前，先通过”[Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例][link_java_collection_16]”对HashSet进行了解。 2. CopyOnWriteArraySet原理和数据结构CopyOnWriteArraySet的数据结构，如下图所示： img 说明：(01). CopyOnWriteArraySet继承于AbstractSet，这就意味着它是一个集合。(02). CopyOnWriteArraySet包含CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。而CopyOnWriteArrayList本质是个动态数组队列， 所以CopyOnWriteArraySet相当于通过通过动态数组实现的“集合”！ CopyOnWriteArrayList中允许有重复的元素；但是，CopyOnWriteArraySet是一个集合，所以它不能有重复集合。因此，CopyOnWriteArrayList额外提供了addIfAbsent()和addAllAbsent()这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作！至于CopyOnWriteArraySet的“线程安全”机制，和CopyOnWriteArrayList一样，是通过volatile和互斥锁来实现的。这个在前一章节介绍CopyOnWriteArrayList时数据结构时，已经进行了说明，这里就不再重复叙述了。 3. CopyOnWriteArraySet函数列表// 创建一个空 set。 CopyOnWriteArraySet() // 创建一个包含指定 collection 所有元素的 set。 CopyOnWriteArraySet(Collection&lt;? extends E&gt; c) // 如果指定元素并不存在于此 set 中，则添加它。 boolean add(E e) // 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。 boolean addAll(Collection&lt;? extends E&gt; c) // 移除此 set 中的所有元素。 void clear() // 如果此 set 包含指定元素，则返回 true。 boolean contains(Object o) // 如果此 set 包含指定 collection 的所有元素，则返回 true。 boolean containsAll(Collection&lt;?&gt; c) // 比较指定对象与此 set 的相等性。 boolean equals(Object o) // 如果此 set 不包含任何元素，则返回 true。 boolean isEmpty() // 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 如果指定元素存在于此 set 中，则将其移除。 boolean remove(Object o) // 移除此 set 中包含在指定 collection 中的所有元素。 boolean removeAll(Collection&lt;?&gt; c) // 仅保留此 set 中那些包含在指定 collection 中的元素。 boolean retainAll(Collection&lt;?&gt; c) // 返回此 set 中的元素数目。 int size() // 返回一个包含此 set 所有元素的数组。 Object[] toArray() // 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。 &lt;T&gt; T[] toArray(T[] a) 4. CopyOnWriteArraySet源码(JDK1.7.0_40版本)CopyOnWriteArraySet.java的完整源码如下： package java.util.concurrent; import java.util.*; /** * A {@link java.util.Set} that uses an internal {@link CopyOnWriteArrayList} * for all of its operations. Thus, it shares the same basic properties: * &lt;ul&gt; * &lt;li&gt;It is best suited for applications in which set sizes generally * stay small, read-only operations * vastly outnumber mutative operations, and you need * to prevent interference among threads during traversal. * &lt;li&gt;It is thread-safe. * &lt;li&gt;Mutative operations (&lt;tt&gt;add&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt;, etc.) * are expensive since they usually entail copying the entire underlying * array. * &lt;li&gt;Iterators do not support the mutative &lt;tt&gt;remove&lt;/tt&gt; operation. * &lt;li&gt;Traversal via iterators is fast and cannot encounter * interference from other threads. Iterators rely on * unchanging snapshots of the array at the time the iterators were * constructed. * &lt;/ul&gt; * * &lt;p&gt; &lt;b&gt;Sample Usage.&lt;/b&gt; The following code sketch uses a * copy-on-write set to maintain a set of Handler objects that * perform some action upon state updates. * * &lt;pre&gt; {@code * class Handler { void handle(); ... } * * class X { * private final CopyOnWriteArraySet&lt;Handler&gt; handlers * = new CopyOnWriteArraySet&lt;Handler&gt;(); * public void addHandler(Handler h) { handlers.add(h); } * * private long internalState; * private synchronized void changeState() { internalState = ...; } * * public void update() { * changeState(); * for (Handler handler : handlers) * handler.handle(); * } * }}&lt;/pre&gt; * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @see CopyOnWriteArrayList * @since 1.5 * @author Doug Lea * @param &lt;E&gt; the type of elements held in this collection */ public class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements java.io.Serializable { private static final long serialVersionUID = 5457747651344034263L; private final CopyOnWriteArrayList&lt;E&gt; al; /** * Creates an empty set. */ public CopyOnWriteArraySet() { al = new CopyOnWriteArrayList&lt;E&gt;(); } /** * Creates a set containing all of the elements of the specified * collection. * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection is null */ public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c) { al = new CopyOnWriteArrayList&lt;E&gt;(); al.addAllAbsent(c); } /** * Returns the number of elements in this set. * * @return the number of elements in this set */ public int size() { return al.size(); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements */ public boolean isEmpty() { return al.isEmpty(); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set * contains an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this set is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element */ public boolean contains(Object o) { return al.contains(o); } /** * Returns an array containing all of the elements in this set. * If this set makes any guarantees as to what order its elements * are returned by its iterator, this method must return the * elements in the same order. * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it * are maintained by this set. (In other words, this method must * allocate a new array even if this set is backed by an array). * The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all the elements in this set */ public Object[] toArray() { return al.toArray(); } /** * Returns an array containing all of the elements in this set; the * runtime type of the returned array is that of the specified array. * If the set fits in the specified array, it is returned therein. * Otherwise, a new array is allocated with the runtime type of the * specified array and the size of this set. * * &lt;p&gt;If this set fits in the specified array with room to spare * (i.e., the array has more elements than this set), the element in * the array immediately following the end of the set is set to * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of this * set &lt;i&gt;only&lt;/i&gt; if the caller knows that this set does not contain * any null elements.) * * &lt;p&gt;If this set makes any guarantees as to what order its elements * are returned by its iterator, this method must return the elements * in the same order. * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose &lt;tt&gt;x&lt;/tt&gt; is a set known to contain only strings. * The following code can be used to dump the set into a newly allocated * array of &lt;tt&gt;String&lt;/tt&gt;: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that &lt;tt&gt;toArray(new Object[0])&lt;/tt&gt; is identical in function to * &lt;tt&gt;toArray()&lt;/tt&gt;. * * @param a the array into which the elements of this set are to be * stored, if it is big enough; otherwise, a new array of the same * runtime type is allocated for this purpose. * @return an array containing all the elements in this set * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in this * set * @throws NullPointerException if the specified array is null */ public &lt;T&gt; T[] toArray(T[] a) { return al.toArray(a); } /** * Removes all of the elements from this set. * The set will be empty after this call returns. */ public void clear() { al.clear(); } /** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this set contained the specified element */ public boolean remove(Object o) { return al.remove(o); } /** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * the set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */ public boolean add(E e) { return al.addIfAbsent(e); } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains all of the elements of the * specified collection. If the specified collection is also a set, this * method returns &lt;tt&gt;true&lt;/tt&gt; if it is a &lt;i&gt;subset&lt;/i&gt; of this set. * * @param c collection to be checked for containment in this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains all of the elements of the * specified collection * @throws NullPointerException if the specified collection is null * @see #contains(Object) */ public boolean containsAll(Collection&lt;?&gt; c) { return al.containsAll(c); } /** * Adds all of the elements in the specified collection to this set if * they&apos;re not already present. If the specified collection is also a * set, the &lt;tt&gt;addAll&lt;/tt&gt; operation effectively modifies this set so * that its value is the &lt;i&gt;union&lt;/i&gt; of the two sets. The behavior of * this operation is undefined if the specified collection is modified * while the operation is in progress. * * @param c collection containing elements to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set changed as a result of the call * @throws NullPointerException if the specified collection is null * @see #add(Object) */ public boolean addAll(Collection&lt;? extends E&gt; c) { return al.addAllAbsent(c) &gt; 0; } /** * Removes from this set all of its elements that are contained in the * specified collection. If the specified collection is also a set, * this operation effectively modifies this set so that its value is the * &lt;i&gt;asymmetric set difference&lt;/i&gt; of the two sets. * * @param c collection containing elements to be removed from this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set changed as a result of the call * @throws ClassCastException if the class of an element of this set * is incompatible with the specified collection (optional) * @throws NullPointerException if this set contains a null element and the * specified collection does not permit null elements (optional), * or if the specified collection is null * @see #remove(Object) */ public boolean removeAll(Collection&lt;?&gt; c) { return al.removeAll(c); } /** * Retains only the elements in this set that are contained in the * specified collection. In other words, removes from this set all of * its elements that are not contained in the specified collection. If * the specified collection is also a set, this operation effectively * modifies this set so that its value is the &lt;i&gt;intersection&lt;/i&gt; of the * two sets. * * @param c collection containing elements to be retained in this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set changed as a result of the call * @throws ClassCastException if the class of an element of this set * is incompatible with the specified collection (optional) * @throws NullPointerException if this set contains a null element and the * specified collection does not permit null elements (optional), * or if the specified collection is null * @see #remove(Object) */ public boolean retainAll(Collection&lt;?&gt; c) { return al.retainAll(c); } /** * Returns an iterator over the elements contained in this set * in the order in which these elements were added. * * &lt;p&gt;The returned iterator provides a snapshot of the state of the set * when the iterator was constructed. No synchronization is needed while * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the * &lt;tt&gt;remove&lt;/tt&gt; method. * * @return an iterator over the elements in this set */ public Iterator&lt;E&gt; iterator() { return al.iterator(); } /** * Compares the specified object with this set for equality. * Returns {@code true} if the specified object is the same object * as this object, or if it is also a {@link Set} and the elements * returned by an {@linkplain List#iterator() iterator} over the * specified set are the same as the elements returned by an * iterator over this set. More formally, the two iterators are * considered to return the same elements if they return the same * number of elements and for every element {@code e1} returned by * the iterator over the specified set, there is an element * {@code e2} returned by the iterator over this set such that * {@code (e1==null ? e2==null : e1.equals(e2))}. * * @param o object to be compared for equality with this set * @return {@code true} if the specified object is equal to this set */ public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Set)) return false; Set&lt;?&gt; set = (Set&lt;?&gt;)(o); Iterator&lt;?&gt; it = set.iterator(); // Uses O(n^2) algorithm that is only appropriate // for small sets, which CopyOnWriteArraySets should be. // Use a single snapshot of underlying array Object[] elements = al.getArray(); int len = elements.length; // Mark matched elements to avoid re-checking boolean[] matched = new boolean[len]; int k = 0; outer: while (it.hasNext()) { if (++k &gt; len) return false; Object x = it.next(); for (int i = 0; i &lt; len; ++i) { if (!matched[i] &amp;&amp; eq(x, elements[i])) { matched[i] = true; continue outer; } } return false; } return k == len; } /** * Test for equality, coping with nulls. */ private static boolean eq(Object o1, Object o2) { return (o1 == null ? o2 == null : o1.equals(o2)); } } CopyOnWriteArraySet是通过CopyOnWriteArrayList实现的，它的API基本上都是通过调用CopyOnWriteArrayList的API来实现的。相信对CopyOnWriteArrayList了解的话，对CopyOnWriteArraySet的了解是水到渠成的事；所以，这里就不再对CopyOnWriteArraySet的代码进行详细的解析了。若对CopyOnWriteArrayList不了解，请参考“[Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList][link_juc_col02]”。 5. CopyOnWriteArraySet示例下面，我们通过一个例子去对比HashSet和CopyOnWriteArraySet。 import java.util.*; import java.util.concurrent.*; /* * CopyOnWriteArraySet是“线程安全”的集合，而HashSet是非线程安全的。 * * 下面是“多个线程同时操作并且遍历集合set”的示例 * (01) 当set是CopyOnWriteArraySet对象时，程序能正常运行。 * (02) 当set是HashSet对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class CopyOnWriteArraySetTest1 { // TODO: set是HashSet对象时，程序会出错。 //private static Set&lt;String&gt; set = new HashSet&lt;String&gt;(); private static Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对set进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String value = null; Iterator iter = set.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 10) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName() + &quot;-&quot; + (i%6); set.add(val); // 通过“Iterator”遍历set。 printAll(); } } } } (某一次)运行结果： ta-1, tb-1, ta-1, tb-1, ta-1, tb-1, ta-1, ta-2, tb-1, ta-1, ta-2, tb-1, tb-2, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, tb-4, ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, tb-5, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-5, ta-0, tb-0, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, ta-4, tb-5, tb-4, ta-0, ta-5, tb-0, tb-5, ta-1, ta-0, tb-1, tb-0, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, tb-5, ta-0, tb-0, ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, ta-4, tb-4, ta-5, tb-5, ta-0, tb-0, 结果说明：由于set是集合对象，因此它不会包含重复的元素。如果将源码中的set改成HashSet对象时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”02之 CopyOnWriteArrayList","date":"2016-11-11T18:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”02之 CopyOnWriteArrayList/","text":"本章是”JUC系列”的CopyOnWriteArrayList篇。接下来，会先对CopyOnWriteArrayList进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解CopyOnWriteArrayList。 目录1. CopyOnWriteArrayList介绍2. CopyOnWriteArrayList原理和数据结构3. CopyOnWriteArrayList函数列表4. CopyOnWriteArrayList源码分析(JDK1.7.0_40版本)&nbsp;&nbsp;&nbsp;&nbsp; 4.1. 创建&nbsp;&nbsp;&nbsp;&nbsp; 4.2 添加&nbsp;&nbsp;&nbsp;&nbsp; 4.3 获取&nbsp;&nbsp;&nbsp;&nbsp; 4.4 删除&nbsp;&nbsp;&nbsp;&nbsp; 4.5 遍历5. CopyOnWriteArrayList示例 1. CopyOnWriteArrayList介绍它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的时，它具有以下特性：(01). 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。(02). 它是线程安全的。(03). 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。(04). 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作。(05). 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 建议：在学习CopyOnWriteArraySet之前，先通过”[Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例”对ArrayList进行了解][link_java_collection_03]！ 2. CopyOnWriteArrayList原理和数据结构CopyOnWriteArrayList的数据结构，如下图所示： img 说明：(01). CopyOnWriteArrayList实现了List接口，因此它是一个队列。(02). CopyOnWriteArrayList包含了成员lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。(03). CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。 下面从“动态数组”和“线程安全”两个方面进一步对CopyOnWriteArrayList的原理进行说明。 第一， CopyOnWriteArrayList的“动态数组”机制&nbsp;&nbsp;&nbsp;&nbsp; 它内部有个“volatile数组”(array)来保持数据。在“添加/修改/删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile数组”。这就是它叫做CopyOnWriteArrayList的原因！&nbsp;&nbsp;&nbsp;&nbsp; CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，效率比较高。第二，CopyOnWriteArrayList的“线程安全”机制&nbsp;&nbsp;&nbsp;&nbsp; 是通过volatile和互斥锁来实现的。&nbsp;&nbsp;&nbsp;&nbsp; (01) CopyOnWriteArrayList是通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读取到的数据总是最新的”这个机制的保证。&nbsp;&nbsp;&nbsp;&nbsp; (02) CopyOnWriteArrayList通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥锁”；这样，就达到了保护数据的目的。 3. CopyOnWriteArrayList函数列表// 创建一个空列表。 CopyOnWriteArrayList() // 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。 CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) // CopyOnWriteArrayList(E[] toCopyIn) 创建一个保存给定数组的副本的列表。 // 将指定元素添加到此列表的尾部。 boolean add(E e) // 在此列表的指定位置上插入指定元素。 void add(int index, E element) // 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。 boolean addAll(Collection&lt;? extends E&gt; c) // 从指定位置开始，将指定 collection 的所有元素插入此列表。 boolean addAll(int index, Collection&lt;? extends E&gt; c) // 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。 int addAllAbsent(Collection&lt;? extends E&gt; c) // 添加元素（如果不存在）。 boolean addIfAbsent(E e) // 从此列表移除所有元素。 void clear() // 返回此列表的浅表副本。 Object clone() // 如果此列表包含指定的元素，则返回 true。 boolean contains(Object o) // 如果此列表包含指定 collection 的所有元素，则返回 true。 boolean containsAll(Collection&lt;?&gt; c) // 比较指定对象与此列表的相等性。 boolean equals(Object o) // 返回列表中指定位置的元素。 E get(int index) // 返回此列表的哈希码值。 int hashCode() // 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。 int indexOf(E e, int index) // 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int indexOf(Object o) // 如果此列表不包含任何元素，则返回 true。 boolean isEmpty() // 返回以恰当顺序在此列表元素上进行迭代的迭代器。 Iterator&lt;E&gt; iterator() // 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。 int lastIndexOf(E e, int index) // 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 int lastIndexOf(Object o) // 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator&lt;E&gt; listIterator() // 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。 ListIterator&lt;E&gt; listIterator(int index) // 移除此列表指定位置上的元素。 E remove(int index) // 从此列表移除第一次出现的指定元素（如果存在）。 boolean remove(Object o) // 从此列表移除所有包含在指定 collection 中的元素。 boolean removeAll(Collection&lt;?&gt; c) // 只保留此列表中包含在指定 collection 中的元素。 boolean retainAll(Collection&lt;?&gt; c) // 用指定的元素替代此列表指定位置上的元素。 E set(int index, E element) // 返回此列表中的元素数。 int size() // 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。 List&lt;E&gt; subList(int fromIndex, int toIndex) // 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。 Object[] toArray() // 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 &lt;T&gt; T[] toArray(T[] a) // 返回此列表的字符串表示形式。 String toString() 4. CopyOnWriteArrayList源码分析(JDK1.7.0_40版本)JDK1.7.0_40版本中CopyOnWriteArrayList.java的完整源码如下： package java.util.concurrent; import java.util.*; import java.util.concurrent.locks.*; import sun.misc.Unsafe; /** * A thread-safe variant of {@link java.util.ArrayList} in which all mutative * operations (&lt;tt&gt;add&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, and so on) are implemented by * making a fresh copy of the underlying array. * * &lt;p&gt; This is ordinarily too costly, but may be &lt;em&gt;more&lt;/em&gt; efficient * than alternatives when traversal operations vastly outnumber * mutations, and is useful when you cannot or don&apos;t want to * synchronize traversals, yet need to preclude interference among * concurrent threads. The &quot;snapshot&quot; style iterator method uses a * reference to the state of the array at the point that the iterator * was created. This array never changes during the lifetime of the * iterator, so interference is impossible and the iterator is * guaranteed not to throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt;. * The iterator will not reflect additions, removals, or changes to * the list since the iterator was created. Element-changing * operations on iterators themselves (&lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, and * &lt;tt&gt;add&lt;/tt&gt;) are not supported. These methods throw * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;. * * &lt;p&gt;All elements are permitted, including &lt;tt&gt;null&lt;/tt&gt;. * * &lt;p&gt;Memory consistency effects: As with other concurrent * collections, actions in a thread prior to placing an object into a * {@code CopyOnWriteArrayList} * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt; * actions subsequent to the access or removal of that element from * the {@code CopyOnWriteArrayList} in another thread. * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @since 1.5 * @author Doug Lea * @param &lt;E&gt; the type of elements held in this collection */ public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8673264195747942595L; /** The lock protecting all mutators */ transient final ReentrantLock lock = new ReentrantLock(); /** The array, accessed only via getArray/setArray. */ private volatile transient Object[] array; /** * Gets the array. Non-private so as to also be accessible * from CopyOnWriteArraySet class. */ final Object[] getArray() { return array; } /** * Sets the array. */ final void setArray(Object[] a) { array = a; } /** * Creates an empty list. */ public CopyOnWriteArrayList() { setArray(new Object[0]); } /** * Creates a list containing the elements of the specified * collection, in the order they are returned by the collection&apos;s * iterator. * * @param c the collection of initially held elements * @throws NullPointerException if the specified collection is null */ public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) { Object[] elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); setArray(elements); } /** * Creates a list holding a copy of the given array. * * @param toCopyIn the array (a copy of this array is used as the * internal array) * @throws NullPointerException if the specified array is null */ public CopyOnWriteArrayList(E[] toCopyIn) { setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); } /** * Returns the number of elements in this list. * * @return the number of elements in this list */ public int size() { return getArray().length; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements */ public boolean isEmpty() { return size() == 0; } /** * Test for equality, coping with nulls. */ private static boolean eq(Object o1, Object o2) { return (o1 == null ? o2 == null : o1.equals(o2)); } /** * static version of indexOf, to allow repeated calls without * needing to re-acquire array each time. * @param o element to search for * @param elements the array * @param index first index to search * @param fence one past last index to search * @return index of element, or -1 if absent */ private static int indexOf(Object o, Object[] elements, int index, int fence) { if (o == null) { for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; } else { for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; } return -1; } /** * static version of lastIndexOf. * @param o element to search for * @param elements the array * @param index first index to search * @return index of element, or -1 if absent */ private static int lastIndexOf(Object o, Object[] elements, int index) { if (o == null) { for (int i = index; i &gt;= 0; i--) if (elements[i] == null) return i; } else { for (int i = index; i &gt;= 0; i--) if (o.equals(elements[i])) return i; } return -1; } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */ public boolean contains(Object o) { Object[] elements = getArray(); return indexOf(o, elements, 0, elements.length) &gt;= 0; } /** * {@inheritDoc} */ public int indexOf(Object o) { Object[] elements = getArray(); return indexOf(o, elements, 0, elements.length); } /** * Returns the index of the first occurrence of the specified element in * this list, searching forwards from &lt;tt&gt;index&lt;/tt&gt;, or returns -1 if * the element is not found. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(i&amp;nbsp;&amp;gt;=&amp;nbsp;index&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(e==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;e.equals(get(i))))&lt;/tt&gt;, * or -1 if there is no such index. * * @param e element to search for * @param index index to start searching from * @return the index of the first occurrence of the element in * this list at position &lt;tt&gt;index&lt;/tt&gt; or later in the list; * &lt;tt&gt;-1&lt;/tt&gt; if the element is not found. * @throws IndexOutOfBoundsException if the specified index is negative */ public int indexOf(E e, int index) { Object[] elements = getArray(); return indexOf(e, elements, index, elements.length); } /** * {@inheritDoc} */ public int lastIndexOf(Object o) { Object[] elements = getArray(); return lastIndexOf(o, elements, elements.length - 1); } /** * Returns the index of the last occurrence of the specified element in * this list, searching backwards from &lt;tt&gt;index&lt;/tt&gt;, or returns -1 if * the element is not found. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(i&amp;nbsp;&amp;lt;=&amp;nbsp;index&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(e==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;e.equals(get(i))))&lt;/tt&gt;, * or -1 if there is no such index. * * @param e element to search for * @param index index to start searching backwards from * @return the index of the last occurrence of the element at position * less than or equal to &lt;tt&gt;index&lt;/tt&gt; in this list; * -1 if the element is not found. * @throws IndexOutOfBoundsException if the specified index is greater * than or equal to the current size of this list */ public int lastIndexOf(E e, int index) { Object[] elements = getArray(); return lastIndexOf(e, elements, index); } /** * Returns a shallow copy of this list. (The elements themselves * are not copied.) * * @return a clone of this list */ public Object clone() { try { CopyOnWriteArrayList c = (CopyOnWriteArrayList)(super.clone()); c.resetLock(); return c; } catch (CloneNotSupportedException e) { // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); } } /** * Returns an array containing all of the elements in this list * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * maintained by this list. (In other words, this method must allocate * a new array). The caller is thus free to modify the returned array. * * &lt;p&gt;This method acts as bridge between array-based and collection-based * APIs. * * @return an array containing all the elements in this list */ public Object[] toArray() { Object[] elements = getArray(); return Arrays.copyOf(elements, elements.length); } /** * Returns an array containing all of the elements in this list in * proper sequence (from first to last element); the runtime type of * the returned array is that of the specified array. If the list fits * in the specified array, it is returned therein. Otherwise, a new * array is allocated with the runtime type of the specified array and * the size of this list. * * &lt;p&gt;If this list fits in the specified array with room to spare * (i.e., the array has more elements than this list), the element in * the array immediately following the end of the list is set to * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of this * list &lt;i&gt;only&lt;/i&gt; if the caller knows that this list does not contain * any null elements.) * * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * under certain circumstances, be used to save allocation costs. * * &lt;p&gt;Suppose &lt;tt&gt;x&lt;/tt&gt; is a list known to contain only strings. * The following code can be used to dump the list into a newly * allocated array of &lt;tt&gt;String&lt;/tt&gt;: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that &lt;tt&gt;toArray(new Object[0])&lt;/tt&gt; is identical in function to * &lt;tt&gt;toArray()&lt;/tt&gt;. * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing all the elements in this list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T a[]) { Object[] elements = getArray(); int len = elements.length; if (a.length &lt; len) return (T[]) Arrays.copyOf(elements, len, a.getClass()); else { System.arraycopy(elements, 0, a, 0, len); if (a.length &gt; len) a[len] = null; return a; } } // Positional Access Operations @SuppressWarnings(&quot;unchecked&quot;) private E get(Object[] a, int index) { return (E) a[index]; } /** * {@inheritDoc} * * @throws IndexOutOfBoundsException {@inheritDoc} */ public E get(int index) { return get(getArray(), index); } /** * Replaces the element at the specified position in this list with the * specified element. * * @throws IndexOutOfBoundsException {@inheritDoc} */ public E set(int index, E element) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) { int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); } else { // Not quite a no-op; ensures volatile write semantics setArray(elements); } return oldValue; } finally { lock.unlock(); } } /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */ public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+len); Object[] newElements; int numMoved = len - index; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + 1); else { newElements = new Object[len + 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index, newElements, index + 1, numMoved); } newElements[index] = element; setArray(newElements); } finally { lock.unlock(); } } /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else { Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); } return oldValue; } finally { lock.unlock(); } } /** * Removes the first occurrence of the specified element from this list, * if it is present. If this list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (len != 0) { // Copy while searching for element to remove // This wins in the normal case of element being present int newlen = len - 1; Object[] newElements = new Object[newlen]; for (int i = 0; i &lt; newlen; ++i) { if (eq(o, elements[i])) { // found one; copy remaining and exit for (int k = i + 1; k &lt; len; ++k) newElements[k-1] = elements[k]; setArray(newElements); return true; } else newElements[i] = elements[i]; } // special handling for last cell if (eq(o, elements[newlen])) { setArray(newElements); return true; } } return false; } finally { lock.unlock(); } } /** * Removes from this list all of the elements whose index is between * &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, and &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &lt;tt&gt;(toIndex - fromIndex)&lt;/tt&gt; elements. * (If &lt;tt&gt;toIndex==fromIndex&lt;/tt&gt;, this operation has no effect.) * * @param fromIndex index of first element to be removed * @param toIndex index after last element to be removed * @throws IndexOutOfBoundsException if fromIndex or toIndex out of range * ({@code{fromIndex &lt; 0 || toIndex &gt; size() || toIndex &lt; fromIndex}) */ private void removeRange(int fromIndex, int toIndex) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (fromIndex &lt; 0 || toIndex &gt; len || toIndex &lt; fromIndex) throw new IndexOutOfBoundsException(); int newlen = len - (toIndex - fromIndex); int numMoved = len - toIndex; if (numMoved == 0) setArray(Arrays.copyOf(elements, newlen)); else { Object[] newElements = new Object[newlen]; System.arraycopy(elements, 0, newElements, 0, fromIndex); System.arraycopy(elements, toIndex, newElements, fromIndex, numMoved); setArray(newElements); } } finally { lock.unlock(); } } /** * Append the element if not present. * * @param e element to be added to this list, if absent * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added */ public boolean addIfAbsent(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { // Copy while checking if already present. // This wins in the most common case where it is not present Object[] elements = getArray(); int len = elements.length; Object[] newElements = new Object[len + 1]; for (int i = 0; i &lt; len; ++i) { if (eq(e, elements[i])) return false; // exit, throwing away copy else newElements[i] = elements[i]; } newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains all of the elements of the * specified collection. * * @param c collection to be checked for containment in this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains all of the elements of the * specified collection * @throws NullPointerException if the specified collection is null * @see #contains(Object) */ public boolean containsAll(Collection&lt;?&gt; c) { Object[] elements = getArray(); int len = elements.length; for (Object e : c) { if (indexOf(e, elements, 0, len) &lt; 0) return false; } return true; } /** * Removes from this list all of its elements that are contained in * the specified collection. This is a particularly expensive operation * in this class because of the need for an internal temporary array. * * @param c collection containing elements to be removed from this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see #remove(Object) */ public boolean removeAll(Collection&lt;?&gt; c) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (len != 0) { // temp array holds those elements we know we want to keep int newlen = 0; Object[] temp = new Object[len]; for (int i = 0; i &lt; len; ++i) { Object element = elements[i]; if (!c.contains(element)) temp[newlen++] = element; } if (newlen != len) { setArray(Arrays.copyOf(temp, newlen)); return true; } } return false; } finally { lock.unlock(); } } /** * Retains only the elements in this list that are contained in the * specified collection. In other words, removes from this list all of * its elements that are not contained in the specified collection. * * @param c collection containing elements to be retained in this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see #remove(Object) */ public boolean retainAll(Collection&lt;?&gt; c) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (len != 0) { // temp array holds those elements we know we want to keep int newlen = 0; Object[] temp = new Object[len]; for (int i = 0; i &lt; len; ++i) { Object element = elements[i]; if (c.contains(element)) temp[newlen++] = element; } if (newlen != len) { setArray(Arrays.copyOf(temp, newlen)); return true; } } return false; } finally { lock.unlock(); } } /** * Appends all of the elements in the specified collection that * are not already contained in this list, to the end of * this list, in the order that they are returned by the * specified collection&apos;s iterator. * * @param c collection containing elements to be added to this list * @return the number of elements added * @throws NullPointerException if the specified collection is null * @see #addIfAbsent(Object) */ public int addAllAbsent(Collection&lt;? extends E&gt; c) { Object[] cs = c.toArray(); if (cs.length == 0) return 0; Object[] uniq = new Object[cs.length]; final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; int added = 0; for (int i = 0; i &lt; cs.length; ++i) { // scan for duplicates Object e = cs[i]; if (indexOf(e, elements, 0, len) &lt; 0 &amp;&amp; indexOf(e, uniq, 0, added) &lt; 0) uniq[added++] = e; } if (added &gt; 0) { Object[] newElements = Arrays.copyOf(elements, len + added); System.arraycopy(uniq, 0, newElements, len, added); setArray(newElements); } return added; } finally { lock.unlock(); } } /** * Removes all of the elements from this list. * The list will be empty after this call returns. */ public void clear() { final ReentrantLock lock = this.lock; lock.lock(); try { setArray(new Object[0]); } finally { lock.unlock(); } } /** * Appends all of the elements in the specified collection to the end * of this list, in the order that they are returned by the specified * collection&apos;s iterator. * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null * @see #add(Object) */ public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] cs = c.toArray(); if (cs.length == 0) return false; final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + cs.length); System.arraycopy(cs, 0, newElements, len, cs.length); setArray(newElements); return true; } finally { lock.unlock(); } } /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in this list in the order that they are returned by the * specified collection&apos;s iterator. * * @param index index at which to insert the first element * from the specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException {@inheritDoc} * @throws NullPointerException if the specified collection is null * @see #add(int,Object) */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) { Object[] cs = c.toArray(); final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+len); if (cs.length == 0) return false; int numMoved = len - index; Object[] newElements; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + cs.length); else { newElements = new Object[len + cs.length]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index, newElements, index + cs.length, numMoved); } System.arraycopy(cs, 0, newElements, index, cs.length); setArray(newElements); return true; } finally { lock.unlock(); } } /** * Saves the state of the list to a stream (that is, serializes it). * * @serialData The length of the array backing the list is emitted * (int), followed by all of its elements (each an Object) * in the proper order. * @param s the stream */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ s.defaultWriteObject(); Object[] elements = getArray(); // Write out array length s.writeInt(elements.length); // Write out all elements in the proper order. for (Object element : elements) s.writeObject(element); } /** * Reconstitutes the list from a stream (that is, deserializes it). * * @param s the stream */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // bind to new lock resetLock(); // Read in array length and allocate array int len = s.readInt(); Object[] elements = new Object[len]; // Read in all elements in the proper order. for (int i = 0; i &lt; len; i++) elements[i] = s.readObject(); setArray(elements); } /** * Returns a string representation of this list. The string * representation consists of the string representations of the list&apos;s * elements in the order they are returned by its iterator, enclosed in * square brackets (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;). Adjacent elements are separated by * the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (comma and space). Elements are * converted to strings as by {@link String#valueOf(Object)}. * * @return a string representation of this list */ public String toString() { return Arrays.toString(getArray()); } /** * Compares the specified object with this list for equality. * Returns {@code true} if the specified object is the same object * as this object, or if it is also a {@link List} and the sequence * of elements returned by an {@linkplain List#iterator() iterator} * over the specified list is the same as the sequence returned by * an iterator over this list. The two sequences are considered to * be the same if they have the same length and corresponding * elements at the same position in the sequence are &lt;em&gt;equal&lt;/em&gt;. * Two elements {@code e1} and {@code e2} are considered * &lt;em&gt;equal&lt;/em&gt; if {@code (e1==null ? e2==null : e1.equals(e2))}. * * @param o the object to be compared for equality with this list * @return {@code true} if the specified object is equal to this list */ public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof List)) return false; List&lt;?&gt; list = (List&lt;?&gt;)(o); Iterator&lt;?&gt; it = list.iterator(); Object[] elements = getArray(); int len = elements.length; for (int i = 0; i &lt; len; ++i) if (!it.hasNext() || !eq(elements[i], it.next())) return false; if (it.hasNext()) return false; return true; } /** * Returns the hash code value for this list. * * &lt;p&gt;This implementation uses the definition in {@link List#hashCode}. * * @return the hash code value for this list */ public int hashCode() { int hashCode = 1; Object[] elements = getArray(); int len = elements.length; for (int i = 0; i &lt; len; ++i) { Object obj = elements[i]; hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode()); } return hashCode; } /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator provides a snapshot of the state of the list * when the iterator was constructed. No synchronization is needed while * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the * &lt;tt&gt;remove&lt;/tt&gt; method. * * @return an iterator over the elements in this list in proper sequence */ public Iterator&lt;E&gt; iterator() { return new COWIterator&lt;E&gt;(getArray(), 0); } /** * {@inheritDoc} * * &lt;p&gt;The returned iterator provides a snapshot of the state of the list * when the iterator was constructed. No synchronization is needed while * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the * &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt; or &lt;tt&gt;add&lt;/tt&gt; methods. */ public ListIterator&lt;E&gt; listIterator() { return new COWIterator&lt;E&gt;(getArray(), 0); } /** * {@inheritDoc} * * &lt;p&gt;The returned iterator provides a snapshot of the state of the list * when the iterator was constructed. No synchronization is needed while * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the * &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt; or &lt;tt&gt;add&lt;/tt&gt; methods. * * @throws IndexOutOfBoundsException {@inheritDoc} */ public ListIterator&lt;E&gt; listIterator(final int index) { Object[] elements = getArray(); int len = elements.length; if (index&lt;0 || index&gt;len) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new COWIterator&lt;E&gt;(elements, index); } private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; { /** Snapshot of the array */ private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ private int cursor; private COWIterator(Object[] elements, int initialCursor) { cursor = initialCursor; snapshot = elements; } public boolean hasNext() { return cursor &lt; snapshot.length; } public boolean hasPrevious() { return cursor &gt; 0; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; } @SuppressWarnings(&quot;unchecked&quot;) public E previous() { if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor-1; } /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; &lt;tt&gt;remove&lt;/tt&gt; * is not supported by this iterator. */ public void remove() { throw new UnsupportedOperationException(); } /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; &lt;tt&gt;set&lt;/tt&gt; * is not supported by this iterator. */ public void set(E e) { throw new UnsupportedOperationException(); } /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; &lt;tt&gt;add&lt;/tt&gt; * is not supported by this iterator. */ public void add(E e) { throw new UnsupportedOperationException(); } } /** * Returns a view of the portion of this list between * &lt;tt&gt;fromIndex&lt;/tt&gt;, inclusive, and &lt;tt&gt;toIndex&lt;/tt&gt;, exclusive. * The returned list is backed by this list, so changes in the * returned list are reflected in this list. * * &lt;p&gt;The semantics of the list returned by this method become * undefined if the backing list (i.e., this list) is modified in * any way other than via the returned list. * * @param fromIndex low endpoint (inclusive) of the subList * @param toIndex high endpoint (exclusive) of the subList * @return a view of the specified range within this list * @throws IndexOutOfBoundsException {@inheritDoc} */ public List&lt;E&gt; subList(int fromIndex, int toIndex) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; if (fromIndex &lt; 0 || toIndex &gt; len || fromIndex &gt; toIndex) throw new IndexOutOfBoundsException(); return new COWSubList&lt;E&gt;(this, fromIndex, toIndex); } finally { lock.unlock(); } } /** * Sublist for CopyOnWriteArrayList. * This class extends AbstractList merely for convenience, to * avoid having to define addAll, etc. This doesn&apos;t hurt, but * is wasteful. This class does not need or use modCount * mechanics in AbstractList, but does need to check for * concurrent modification using similar mechanics. On each * operation, the array that we expect the backing list to use * is checked and updated. Since we do this for all of the * base operations invoked by those defined in AbstractList, * all is well. While inefficient, this is not worth * improving. The kinds of list operations inherited from * AbstractList are already so slow on COW sublists that * adding a bit more space/time doesn&apos;t seem even noticeable. */ private static class COWSubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess { private final CopyOnWriteArrayList&lt;E&gt; l; private final int offset; private int size; private Object[] expectedArray; // only call this holding l&apos;s lock COWSubList(CopyOnWriteArrayList&lt;E&gt; list, int fromIndex, int toIndex) { l = list; expectedArray = l.getArray(); offset = fromIndex; size = toIndex - fromIndex; } // only call this holding l&apos;s lock private void checkForComodification() { if (l.getArray() != expectedArray) throw new ConcurrentModificationException(); } // only call this holding l&apos;s lock private void rangeCheck(int index) { if (index&lt;0 || index&gt;=size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;,Size: &quot;+size); } public E set(int index, E element) { final ReentrantLock lock = l.lock; lock.lock(); try { rangeCheck(index); checkForComodification(); E x = l.set(index+offset, element); expectedArray = l.getArray(); return x; } finally { lock.unlock(); } } public E get(int index) { final ReentrantLock lock = l.lock; lock.lock(); try { rangeCheck(index); checkForComodification(); return l.get(index+offset); } finally { lock.unlock(); } } public int size() { final ReentrantLock lock = l.lock; lock.lock(); try { checkForComodification(); return size; } finally { lock.unlock(); } } public void add(int index, E element) { final ReentrantLock lock = l.lock; lock.lock(); try { checkForComodification(); if (index&lt;0 || index&gt;size) throw new IndexOutOfBoundsException(); l.add(index+offset, element); expectedArray = l.getArray(); size++; } finally { lock.unlock(); } } public void clear() { final ReentrantLock lock = l.lock; lock.lock(); try { checkForComodification(); l.removeRange(offset, offset+size); expectedArray = l.getArray(); size = 0; } finally { lock.unlock(); } } public E remove(int index) { final ReentrantLock lock = l.lock; lock.lock(); try { rangeCheck(index); checkForComodification(); E result = l.remove(index+offset); expectedArray = l.getArray(); size--; return result; } finally { lock.unlock(); } } public boolean remove(Object o) { int index = indexOf(o); if (index == -1) return false; remove(index); return true; } public Iterator&lt;E&gt; iterator() { final ReentrantLock lock = l.lock; lock.lock(); try { checkForComodification(); return new COWSubListIterator&lt;E&gt;(l, 0, offset, size); } finally { lock.unlock(); } } public ListIterator&lt;E&gt; listIterator(final int index) { final ReentrantLock lock = l.lock; lock.lock(); try { checkForComodification(); if (index&lt;0 || index&gt;size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); return new COWSubListIterator&lt;E&gt;(l, index, offset, size); } finally { lock.unlock(); } } public List&lt;E&gt; subList(int fromIndex, int toIndex) { final ReentrantLock lock = l.lock; lock.lock(); try { checkForComodification(); if (fromIndex&lt;0 || toIndex&gt;size) throw new IndexOutOfBoundsException(); return new COWSubList&lt;E&gt;(l, fromIndex + offset, toIndex + offset); } finally { lock.unlock(); } } } private static class COWSubListIterator&lt;E&gt; implements ListIterator&lt;E&gt; { private final ListIterator&lt;E&gt; i; private final int index; private final int offset; private final int size; COWSubListIterator(List&lt;E&gt; l, int index, int offset, int size) { this.index = index; this.offset = offset; this.size = size; i = l.listIterator(index+offset); } public boolean hasNext() { return nextIndex() &lt; size; } public E next() { if (hasNext()) return i.next(); else throw new NoSuchElementException(); } public boolean hasPrevious() { return previousIndex() &gt;= 0; } public E previous() { if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); } public int nextIndex() { return i.nextIndex() - offset; } public int previousIndex() { return i.previousIndex() - offset; } public void remove() { throw new UnsupportedOperationException(); } public void set(E e) { throw new UnsupportedOperationException(); } public void add(E e) { throw new UnsupportedOperationException(); } } // Support for resetting lock while deserializing private void resetLock() { UNSAFE.putObjectVolatile(this, lockOffset, new ReentrantLock()); } private static final sun.misc.Unsafe UNSAFE; private static final long lockOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = CopyOnWriteArrayList.class; lockOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;lock&quot;)); } catch (Exception e) { throw new Error(e); } } } 下面我们从“创建，添加，删除，获取，遍历”这5个方面去分析CopyOnWriteArrayList的原理。 4.1. 创建CopyOnWriteArrayList共3个构造函数。它们的源码如下： public CopyOnWriteArrayList() { setArray(new Object[0]); } public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) { Object[] elements = c.toArray(); if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); setArray(elements); } public CopyOnWriteArrayList(E[] toCopyIn) { setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); } 说明：这3个构造函数都调用了setArray()，setArray()的源码如下： private volatile transient Object[] array; final Object[] getArray() { return array; } final void setArray(Object[] a) { array = a; } 说明：setArray()的作用是给array赋值；其中，array是volatile transient Object[]类型，即array是“volatile数组”。关于volatile关键字，我们知道“volatile能让变量变得可见”，即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。正在由于这种特性，每次更新了“volatile数组”之后，其它线程都能看到对它所做的更新。关于transient关键字，它是在序列化中才起作用，transient变量不会被自动序列化。transient不是本文关注的重点，了解即可。关于transient的更多内容，请参考：[http://www.cnblogs.com/skywang12345/p/io_06.html][http://www.cnblogs.com/skywang12345/p/io_06.html] 4.2 添加以add(E e)为例，来对“CopyOnWriteArrayList的添加操作”进行说明。下面是add(E e)的代码： public boolean add(E e) { final ReentrantLock lock = this.lock; // 获取“锁” lock.lock(); try { // 获取原始”volatile数组“中的数据和数据长度。 Object[] elements = getArray(); int len = elements.length; // 新建一个数组newElements，并将原始数据拷贝到newElements中； // newElements数组的长度=“原始数组的长度”+1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将“新增加的元素”保存到newElements中。 newElements[len] = e; // 将newElements赋值给”volatile数组“。 setArray(newElements); return true; } finally { // 释放“锁” lock.unlock(); } } 说明：add(E e)的作用就是将数据e添加到”volatile数组“中。它的实现方式是，新建一个数组，接着将原始的”volatile数组“的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile数组“。在add(E e)中有两点需要关注。&nbsp;&nbsp;&nbsp;&nbsp; 第一，在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock的定义如下： transient final ReentrantLock lock = new ReentrantLock(); 关于ReentrantLock的更多内容，可以参考：Java多线程系列–“JUC锁”02之 互斥锁ReentrantLock&nbsp;&nbsp;&nbsp;&nbsp; 第二，操作完毕时，会通过setArray()来更新”volatile数组“。而且，前面我们提过”即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。 4.3 获取以get(int index)为例，来对“CopyOnWriteArrayList的删除操作”进行说明。下面是get(int index)的代码： public E get(int index) { return get(getArray(), index); } private E get(Object[] a, int index) { return (E) a[index]; } 说明：get(int index)的实现很简单，就是返回”volatile数组“中的第index个元素。 4.4 删除以remove(int index)为例，来对“CopyOnWriteArrayList的删除操作”进行说明。下面是remove(int index)的代码： public E remove(int index) { final ReentrantLock lock = this.lock; // 获取“锁” lock.lock(); try { // 获取原始”volatile数组“中的数据和数据长度。 Object[] elements = getArray(); int len = elements.length; // 获取elements数组中的第index个数据。 E oldValue = get(elements, index); int numMoved = len - index - 1; // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。 // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组“。 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else { Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); } return oldValue; } finally { // 释放“锁” lock.unlock(); } } 说明：remove(int index)的作用就是将”volatile数组“中第index个元素删除。它的实现方式是，如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组“。和add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是“；并且”在操作完成时，会通过将数据更新到volatile数组中“。 4.5 遍历以iterator()为例，来对“CopyOnWriteArrayList的遍历操作”进行说明。下面是iterator()的代码： public Iterator&lt;E&gt; iterator() { return new COWIterator&lt;E&gt;(getArray(), 0); } 说明：iterator()会返回COWIterator对象。 COWIterator实现额ListIterator接口，它的源码如下： private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; { private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) { cursor = initialCursor; snapshot = elements; } public boolean hasNext() { return cursor &lt; snapshot.length; } public boolean hasPrevious() { return cursor &gt; 0; } // 获取下一个元素 @SuppressWarnings(&quot;unchecked&quot;) public E next() { if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; } // 获取上一个元素 @SuppressWarnings(&quot;unchecked&quot;) public E previous() { if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; } public int nextIndex() { return cursor; } public int previousIndex() { return cursor-1; } public void remove() { throw new UnsupportedOperationException(); } public void set(E e) { throw new UnsupportedOperationException(); } public void add(E e) { throw new UnsupportedOperationException(); } } 说明：COWIterator不支持修改元素的操作。例如，对于remove(),set(),add()等操作，COWIterator都会抛出异常！另外，需要提到的一点是，CopyOnWriteArrayList返回迭代器不会抛出ConcurrentModificationException异常，即它不是fail-fast机制的！关于fail-fast机制，可以参考“[Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)][link_java_collection_04]”。 5. CopyOnWriteArrayList示例下面，我们通过一个例子去对比ArrayList和CopyOnWriteArrayList。 import java.util.*; import java.util.concurrent.*; /* * CopyOnWriteArrayList是“线程安全”的动态数组，而ArrayList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历list”的示例 * (01) 当list是CopyOnWriteArrayList对象时，程序能正常运行。 * (02) 当list是ArrayList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class CopyOnWriteArrayListTest1 { // TODO: list是ArrayList对象时，程序会出错。 //private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); public static void main(String[] args) { // 同时启动两个线程对list进行操作！ new MyThread(&quot;ta&quot;).start(); new MyThread(&quot;tb&quot;).start(); } private static void printAll() { String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+&quot;, &quot;); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ &lt; 6) { // “线程名” + &quot;-&quot; + &quot;序号&quot; String val = Thread.currentThread().getName()+&quot;-&quot;+i; list.add(val); // 通过“Iterator”遍历List。 printAll(); } } } } (某一次)运行结果： ta-1, tb-1, ta-1, tb-1, ta-1, ta-1, tb-1, tb-1, tb-2, tb-2, ta-1, ta-2, tb-1, ta-1, tb-2, tb-1, ta-2, tb-2, tb-3, ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, ta-1, ta-2, tb-1, tb-3, tb-2, ta-3, ta-2, tb-4, tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, tb-4, ta-2, ta-4, tb-3, tb-5, ta-3, ta-1, tb-4, tb-1, ta-4, tb-2, tb-5, ta-2, ta-5, tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, tb-5, tb-3, ta-5, ta-3, tb-6, tb-4, ta-4, tb-5, ta-5, tb-6, ta-6, 结果说明：如果将源码中的list改成ArrayList对象时，程序会产生ConcurrentModificationException异常。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“JUC集合”01之 框架","date":"2016-11-11T17:00:00.000Z","path":"2016/11/12/java-source-analysis-multi-thread-series/Java多线程系列--“JUC集合”01之 框架/","text":"之前，在”Java 集合系列目录(Category)”中，讲解了Java集合包中的各个类。接下来，将展开对JUC包中的集合进行学习。在学习之前，先温习一下”Java集合包”。 目录1. Java集合包2. JUC中的集合类 1. Java集合包在“Java 集合系列01之 总体框架”中，介绍java集合的架构。主体内容包括Collection集合和Map类；而Collection集合又可以划分为List(队列)和Set(集合)。 1.1 List的实现类主要有: LinkedList, ArrayList, Vector, Stack。(01) LinkedList是双向链表实现的双端队列；它不是线程安全的，只适用于单线程。(02) ArrayList是数组实现的队列，它是一个动态数组；它也不是线程安全的，只适用于单线程。(03) Vector是数组实现的矢量队列，它也一个动态数组；不过和ArrayList不同的是，Vector是线程安全的，它支持并发。(04) Stack是Vector实现的栈；和Vector一样，它也是线程安全的。 1.2 Set的实现类主要有: HastSet和TreeSet。(01) HashSet是一个没有重复元素的集合，它通过HashMap实现的；HashSet不是线程安全的，只适用于单线程。(02) TreeSet也是一个没有重复元素的集合，不过和HashSet不同的是，TreeSet中的元素是有序的；它是通过TreeMap实现的；TreeSet也不是线程安全的，只适用于单线程。 1.3 Map的实现类主要有: HashMap，WeakHashMap, Hashtable和TreeMap。(01) HashMap是存储“键-值对”的哈希表；它不是线程安全的，只适用于单线程。(02) WeakHashMap是也是哈希表；和HashMap不同的是，HashMap的“键”是强引用类型，而WeakHashMap的“键”是弱引用类型，也就是说当WeakHashMap 中的某个键不再正常使用时，会被从WeakHashMap中被自动移除。WeakHashMap也不是线程安全的，只适用于单线程。(03) Hashtable也是哈希表；和HashMap不同的是，Hashtable是线程安全的，支持并发。(04) TreeMap也是哈希表，不过TreeMap中的“键-值对”是有序的，它是通过R-B Tree(红黑树)实现的；TreeMap不是线程安全的，只适用于单线程。更多关于这些集合类的介绍，可以参考“[Java 集合系列目录(Category)][link_java_collection_00]”。 为了方便，我们将前面介绍集合类统称为”java集合包“。java集合包大多是“非线程安全的”，虽然可以通过Collections工具类中的方法获取java集合包对应的同步类，但是这些同步类的并发效率并不是很高。为了更好的支持高并发任务，并发大师Doug Lea在JUC(java.util.concurrent)包中添加了java集合包中单线程类的对应的支持高并发的类。例如，ArrayList对应的高并发类是CopyOnWriteArrayList，HashMap对应的高并发类是ConcurrentHashMap，等等。 JUC包在添加”java集合包“对应的高并发类时，为了保持API接口的一致性，使用了”Java集合包“中的框架。例如，CopyOnWriteArrayList实现了“Java集合包”中的List接口，HashMap继承了“java集合包”中的AbstractMap类，等等。得益于“JUC包使用了Java集合包中的类”，如果我们了解了Java集合包中的类的思想之后，理解JUC包中的类也相对容易；理解时，最大的难点是，对JUC包是如何添加对“高并发”的支持的！ 2. JUC中的集合类下面，我们先了解JUC包中集合类的框架；为了方便讲诉，我将JUC包中的集合类划分为3部分来进行说明。在简单的了解JUC包中集合类的框架之后，后面的章节再逐步对各个类进行介绍。 2.1 List和SetJUC集合包中的List和Set实现类包括: CopyOnWriteArrayList, CopyOnWriteArraySet和ConcurrentSkipListSet。ConcurrentSkipListSet稍后在说明Map时再说明，CopyOnWriteArrayList 和 CopyOnWriteArraySet的框架如下图所示： img (01) CopyOnWriteArrayList相当于线程安全的ArrayList，它实现了List接口。CopyOnWriteArrayList是支持高并发的。(02) CopyOnWriteArraySet相当于线程安全的HashSet，它继承于AbstractSet类。CopyOnWriteArraySet内部包含一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。 2.2 MapJUC集合包中Map的实现类包括: ConcurrentHashMap和ConcurrentSkipListMap。它们的框架如下图所示： img (01) ConcurrentHashMap是线程安全的哈希表(相当于线程安全的HashMap)；它继承于AbstractMap类，并且实现ConcurrentMap接口。ConcurrentHashMap是通过“锁分段”来实现的，它支持并发。(02) ConcurrentSkipListMap是线程安全的有序的哈希表(相当于线程安全的TreeMap); 它继承于AbstractMap类，并且实现ConcurrentNavigableMap接口。ConcurrentSkipListMap是通过“跳表”来实现的，它支持并发。(03) ConcurrentSkipListSet是线程安全的有序的集合(相当于线程安全的TreeSet)；它继承于AbstractSet，并实现了NavigableSet接口。ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它也支持并发。 2.3 QueueJUC集合包中Queue的实现类包括: ArrayBlockingQueue, LinkedBlockingQueue, LinkedBlockingDeque, ConcurrentLinkedQueue和ConcurrentLinkedDeque。它们的框架如下图所示： img (01) ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。(02) LinkedBlockingQueue是单向链表实现的(指定大小)阻塞队列，该队列按 FIFO（先进先出）排序元素。(03) LinkedBlockingDeque是双向链表实现的(指定大小)双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式。(04) ConcurrentLinkedQueue是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。(05) ConcurrentLinkedDeque是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。 接下来，将逐个对JUC包中的集合类进行学习。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"},{"name":"JUC集合","slug":"JUC集合","permalink":"https://smuwjs.github.io/tags/JUC集合/"}]},{"title":"Java多线程系列--“基础篇”11之 生产消费者问题","date":"2016-11-10T16:00:00.000Z","path":"2016/11/11/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”11之 生产消费者问题/","text":"本章，会对“生产/消费者问题”进行讨论。 目录1. 生产/消费者模型2. 生产/消费者实现 1. 生产/消费者模型生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下：(01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。(02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。(03) 当消费者发现仓储没产品可消费时候会通知生产者生产。(04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。 2. 生产/消费者实现下面通过wait()/notify()方式实现该模型(后面在学习了线程池相关内容之后，再通过其它方式实现生产/消费者模型)。源码如下： // Demo1.java // 仓库 class Depot { private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 public Depot(int capacity) { this.capacity = capacity; this.size = 0; } public synchronized void produce(int val) { try { // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) { // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) wait(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf(&quot;%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\\n&quot;, Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 notifyAll(); } } catch (InterruptedException e) { } } public synchronized void consume(int val) { try { // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) { // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) wait(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf(&quot;%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\\n&quot;, Thread.currentThread().getName(), val, left, dec, size); notifyAll(); } } catch (InterruptedException e) { } } public String toString() { return &quot;capacity:&quot;+capacity+&quot;, actual size:&quot;+size; } } // 生产者 class Producer { private Depot depot; public Producer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) { new Thread() { public void run() { depot.produce(val); } }.start(); } } // 消费者 class Customer { private Depot depot; public Customer(Depot depot) { this.depot = depot; } // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) { new Thread() { public void run() { depot.consume(val); } }.start(); } } public class Demo1 { public static void main(String[] args) { Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); } } 说明：(01) Producer是“生产者”类，它与“仓库(depot)”关联。当调用“生产者”的produce()方法时，它会新建一个线程并向“仓库”中生产产品。(02) Customer是“消费者”类，它与“仓库(depot)”关联。当调用“消费者”的consume()方法时，它会新建一个线程并消费“仓库”中的产品。(03) Depot是“仓库”类，仓库中记录“仓库的容量(capacity)”以及“仓库中当前产品数目(size)”。&nbsp;&nbsp;&nbsp;&nbsp; “仓库”类的生产方法produce()和消费方法consume()方法都是synchronized方法，进入synchronized方法体，意味着这个线程获取到了该“仓库”对象的同步锁。这也就是说，同一时间，生产者和消费者线程只能有一个能运行。通过同步锁，实现了对“残酷”的互斥访问。&nbsp;&nbsp;&nbsp;&nbsp; 对于生产方法produce()而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“消费者线程”，即我们所说的“通知消费者进行消费”。&nbsp;&nbsp;&nbsp;&nbsp; 对于消费方法consume()而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“生产者线程”，即我们所说的“通知生产者进行生产”。 (某一次)运行结果： Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60 Thread-4 produce(110) --&gt; left= 70, inc= 40, size=100 Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10 Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0 Thread-1 produce(120) --&gt; left= 20, inc=100, size=100 Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0 Thread-4 produce(110) --&gt; left= 0, inc= 70, size= 70 Thread-3 consume(150) &lt;-- left= 0, dec= 40, size= 30 Thread-1 produce(120) --&gt; left= 0, inc= 20, size= 50","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”10之 线程优先级和守护线程","date":"2016-11-09T16:00:00.000Z","path":"2016/11/10/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”10之 线程优先级和守护线程/","text":"本章，会对守护线程和线程优先级进行介绍。 目录1. 线程优先级的介绍2. 线程优先级的示例3. 守护线程的示例 1. 线程优先级的介绍java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。 java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。 JDK 中关于线程优先级和守护线程的介绍如下： Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads. 大致意思是： 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：(01) 调用了exit()方法，并且exit()有权限被正常执行。(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。 2. 线程优先级的示例我们先看看优先级的示例 class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ for (int i=0; i&lt;5; i++) { System.out.println(Thread.currentThread().getName() +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot; +&quot;, loop &quot;+i); } } }; public class Demo { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() +&quot;(&quot;+Thread.currentThread().getPriority()+ &quot;)&quot;); Thread t1=new MyThread(&quot;t1&quot;); // 新建t1 Thread t2=new MyThread(&quot;t2&quot;); // 新建t2 t1.setPriority(1); // 设置t1的优先级为1 t2.setPriority(10); // 设置t2的优先级为10 t1.start(); // 启动t1 t2.start(); // 启动t2 } } 运行结果： main(5) t1(1), loop 0 t2(10), loop 0 t1(1), loop 1 t2(10), loop 1 t1(1), loop 2 t2(10), loop 2 t1(1), loop 3 t2(10), loop 3 t1(1), loop 4 t2(10), loop 4 结果说明：(01) 主线程main的优先级是5。(02) t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。 3. 守护线程的示例下面是守护线程的示例。 // Demo.java class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ try { for (int i=0; i&lt;5; i++) { Thread.sleep(3); System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i); } } catch (InterruptedException e) { } } }; class MyDaemon extends Thread{ public MyDaemon(String name) { super(name); } public void run(){ try { for (int i=0; i&lt;10000; i++) { Thread.sleep(1); System.out.println(this.getName() +&quot;(isDaemon=&quot;+this.isDaemon()+ &quot;)&quot; +&quot;, loop &quot;+i); } } catch (InterruptedException e) { } } } public class Demo { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() +&quot;(isDaemon=&quot;+Thread.currentThread().isDaemon()+ &quot;)&quot;); Thread t1=new MyThread(&quot;t1&quot;); // 新建t1 Thread t2=new MyDaemon(&quot;t2&quot;); // 新建t2 t2.setDaemon(true); // 设置t2为守护线程 t1.start(); // 启动t1 t2.start(); // 启动t2 } } 运行结果： main(isDaemon=false) t2(isDaemon=true), loop 0 t2(isDaemon=true), loop 1 t1(isDaemon=false), loop 0 t2(isDaemon=true), loop 2 t2(isDaemon=true), loop 3 t1(isDaemon=false), loop 1 t2(isDaemon=true), loop 4 t2(isDaemon=true), loop 5 t2(isDaemon=true), loop 6 t1(isDaemon=false), loop 2 t2(isDaemon=true), loop 7 t2(isDaemon=true), loop 8 t2(isDaemon=true), loop 9 t1(isDaemon=false), loop 3 t2(isDaemon=true), loop 10 t2(isDaemon=true), loop 11 t1(isDaemon=false), loop 4 t2(isDaemon=true), loop 12 结果说明：(01) 主线程main是用户线程，它创建的子线程t1也是用户线程。(02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”09之 interrupt()和线程终止方式","date":"2016-11-08T16:00:00.000Z","path":"2016/11/09/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”09之 interrupt()和线程终止方式/","text":"本章，会对线程的interrupt()中断和终止方式进行介绍。 目录1. interrupt()说明2. 终止线程的方式&nbsp;&nbsp;&nbsp;&nbsp; 2.1 终止处于“阻塞状态”的线程&nbsp;&nbsp;&nbsp;&nbsp; 2.2 终止处于“运行状态”的线程3. 终止线程的示例4. interrupted() 和 isInterrupted()的区别 1. interrupt()说明在介绍终止线程的方式之前，有必要先对interrupt()进行了解。关于interrupt()，java的djk文档描述如下：http://docs.oracle.com/javase/7/docs/api/ Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown. If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException. If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked. If none of the previous conditions hold then this thread’s interrupt status will be set. Interrupting a thread that is not alive need not have any effect. 大致意思是： interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。 2. 终止线程的方式Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。 2.1 终止处于“阻塞状态”的线程通常，我们通过“中断”方式终止处于“阻塞状态”的线程。当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下： @Override public void run() { try { while (true) { // 执行任务... } } catch (InterruptedException ie) { // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ } } 说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下： @Override public void run() { while (true) { try { // 执行任务... } catch (InterruptedException ie) { // InterruptedException在while(true)循环体内。 // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出 break; } } } 说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。 2.2 终止处于“运行状态”的线程通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。 (01) 通过“中断标记”终止线程。形式如下： @Override public void run() { while (!isInterrupted()) { // 执行任务... } } 说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。 (02) 通过“额外添加标记”。形式如下： private volatile boolean flag= true; protected void stopTask() { flag = false; } @Override public void run() { while (flag) { // 执行任务... } } 说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。 综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下： @Override public void run() { try { // 1. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) { // 执行任务... } } catch (InterruptedException ie) { // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 } } 3. 终止线程的示例interrupt()常常被用来终止“阻塞状态”线程。参考下面示例： // Demo1.java的源码 class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { try { int i=0; while (!isInterrupted()) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); } } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); } } } public class Demo1 { public static void main(String[] args) { try { Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行结果： t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) catch InterruptedException. t1 (TERMINATED) is interrupted now. 结果说明：(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。 我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。 // Demo2.java的源码 class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { int i=0; while (!isInterrupted()) { try { Thread.sleep(100); // 休眠100ms } catch (InterruptedException ie) { System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); } i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); } } } public class Demo2 { public static void main(String[] args) { try { Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行结果： t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) catch InterruptedException. t1 (RUNNABLE) loop 3 t1 (RUNNABLE) loop 4 t1 (RUNNABLE) loop 5 t1 (TIMED_WAITING) is interrupted now. t1 (RUNNABLE) loop 6 t1 (RUNNABLE) loop 7 t1 (RUNNABLE) loop 8 t1 (RUNNABLE) loop 9 ... 结果说明：程序进入了死循环！为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。 下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例： // Demo3.java的源码 class MyThread extends Thread { private volatile boolean flag= true; public void stopTask() { flag = false; } public MyThread(String name) { super(name); } @Override public void run() { synchronized(this) { try { int i=0; while (flag) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+&quot; (&quot;+this.getState()+&quot;) loop &quot; + i); } } catch (InterruptedException ie) { System.out.println(Thread.currentThread().getName() +&quot; (&quot;+this.getState()+&quot;) catch InterruptedException.&quot;); } } } } public class Demo3 { public static void main(String[] args) { try { MyThread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is new.&quot;); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is started.&quot;); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted.&quot;); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +&quot; (&quot;+t1.getState()+&quot;) is interrupted now.&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } 运行结果： t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) loop 3 t1 (TERMINATED) is interrupted now. 4. interrupted() 和 isInterrupted()的区别最后谈谈 interrupted() 和 isInterrupted()。interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”08之 join()","date":"2016-11-07T16:00:00.000Z","path":"2016/11/08/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”08之 join()/","text":"本章，会对Thread中join()方法进行介绍。 目录1. join()介绍2. join()源码分析(基于JDK1.7.0_40)3. join()示例 1. join()介绍join() 定义在Thread.java中。 join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解： // 主线程 public class Father extends Thread { public void run() { Son s = new Son(); s.start(); s.join(); ... } } // 子线程 public class Son extends Thread { public void run() { ... } } 说明：上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！ 2. join()源码分析(基于JDK1.7.0_40)public final void join() throws InterruptedException { join(0); } public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(&quot;timeout value is negative&quot;); } if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } 说明：从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；即只要子线程是活的，主线程就不停的等待。我们根据上面解释join()作用时的代码来理解join()的用法！ 问题：虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？ 答案：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！ 3. join()示例在理解join()的作用之后，接下来通过示例查看join()的用法。 // JoinTest.java的源码 public class JoinTest{ public static void main(String[] args){ try { ThreadA t1 = new ThreadA(&quot;t1&quot;); // 新建“线程t1” t1.start(); // 启动“线程t1” t1.join(); // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成” System.out.printf(&quot;%s finish\\n&quot;, Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ System.out.printf(&quot;%s start\\n&quot;, this.getName()); // 延时操作 for(int i=0; i &lt;1000000; i++) ; System.out.printf(&quot;%s finish\\n&quot;, this.getName()); } } } 运行结果： t1 start t1 finish main finish 结果说明：运行流程如图(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”07之 线程休眠","date":"2016-11-06T16:00:00.000Z","path":"2016/11/07/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”07之 线程休眠/","text":"本章，会对Thread中sleep()方法进行介绍。 目录1. sleep()介绍2. sleep()示例3. sleep() 与 wait()的比较 1. sleep()介绍sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。 2. sleep()示例下面通过一个简单示例演示sleep()的用法。 // SleepTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run() { try { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class SleepTest{ public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); t1.start(); } } 运行结果： t1: 0 t1: 1 t1: 2 t1: 3 t1: 4 t1: 5 t1: 6 t1: 7 t1: 8 t1: 9 结果说明：程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。 3. sleep() 与 wait()的比较我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 下面通过示例演示sleep()是不会释放锁的。 // SleepLockTest.java的源码 public class SleepLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 synchronized (obj) { try { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } } } } } 运行结果： t1: 0 t1: 1 t1: 2 t1: 3 t1: 4 t1: 5 t1: 6 t1: 7 t1: 8 t1: 9 t2: 0 t2: 1 t2: 2 t2: 3 t2: 4 t2: 5 t2: 6 t2: 7 t2: 8 t2: 9 结果说明：主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！ 注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。下面是注释调synchronized(obj) 之后的源码： // SleepLockTest.java的源码(注释掉synchronized(obj)) public class SleepLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 // synchronized (obj) { try { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s: %d\\n&quot;, this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } // } } } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”06之 线程让步","date":"2016-11-05T16:00:00.000Z","path":"2016/11/06/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”06之 线程让步/","text":"本章，会对Thread中的线程让步方法yield()进行介绍。 目录1. yield()介绍2. yield()示例3. yield() 与 wait()的比较 1. yield()介绍yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ 2. yield()示例下面，通过示例查看它的用法。 // YieldTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run(){ for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); } } } public class YieldTest{ public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } } (某一次的)运行结果: t1 [5]:0 t2 [5]:0 t1 [5]:1 t1 [5]:2 t1 [5]:3 t1 [5]:4 t1 [5]:5 t1 [5]:6 t1 [5]:7 t1 [5]:8 t1 [5]:9 t2 [5]:1 t2 [5]:2 t2 [5]:3 t2 [5]:4 t2 [5]:5 t2 [5]:6 t2 [5]:7 t2 [5]:8 t2 [5]:9 结果说明：“线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。 3. yield() 与 wait()的比较我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。 下面通过示例演示yield()是不会释放锁的。 // YieldLockTest.java 的源码 public class YieldLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 synchronized (obj) { for(int i=0; i &lt;10; i++){ System.out.printf(&quot;%s [%d]:%d\\n&quot;, this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); } } } } } (某一次)运行结果： t1 [5]:0 t1 [5]:1 t1 [5]:2 t1 [5]:3 t1 [5]:4 t1 [5]:5 t1 [5]:6 t1 [5]:7 t1 [5]:8 t1 [5]:9 t2 [5]:0 t2 [5]:1 t2 [5]:2 t2 [5]:3 t2 [5]:4 t2 [5]:5 t2 [5]:6 t2 [5]:7 t2 [5]:8 t2 [5]:9 结果说明：主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”05之 线程等待与唤醒","date":"2016-11-04T16:00:00.000Z","path":"2016/11/05/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”05之 线程等待与唤醒/","text":"本章，会对线程等待/唤醒方法进行介绍。 目录1. wait(), notify(), notifyAll()等方法介绍2. wait()和notify()示例3. wait(long timeout)和notify()4. wait() 和 notifyAll()5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中 1. wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下： API接口 API说明 notify() 唤醒在此对象监视器上等待的单个线程。 notifyAll() 唤醒在此对象监视器上等待的所有线程。 wait() 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout) 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout, int nanos) 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 2. wait()和notify()示例下面通过示例演示”wait()和notify()配合使用的情形”。 // WaitTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { System.out.println(Thread.currentThread().getName()+&quot; call notify()&quot;); // 唤醒当前的wait线程 notify(); } } } public class WaitTest { public static void main(String[] args) { ThreadA t1 = new ThreadA(&quot;t1&quot;); synchronized(t1) { try { // 启动“线程t1” System.out.println(Thread.currentThread().getName()+&quot; start t1&quot;); t1.start(); // 主线程等待t1通过notify()唤醒。 System.out.println(Thread.currentThread().getName()+&quot; wait()&quot;); t1.wait(); System.out.println(Thread.currentThread().getName()+&quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } 运行结果: main start t1 main wait() t1 call notify() main continue 结果说明：如下图，说明了“主线程”和“线程t1”的流程。(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。 img 对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？在解答该问题前，我们先看看jdk文档中关于wait的一段介绍： Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.In other words, this method behaves exactly as if it simply performs the call wait(0).The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution. 中文意思大概是： 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！ 3. wait(long timeout)和notify()wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。 // WaitTimeoutTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { System.out.println(Thread.currentThread().getName() + &quot; run &quot;); // 死循环，不断运行。 while(true) ; } } public class WaitTimeoutTest { public static void main(String[] args) { ThreadA t1 = new ThreadA(&quot;t1&quot;); synchronized(t1) { try { // 启动“线程t1” System.out.println(Thread.currentThread().getName() + &quot; start t1&quot;); t1.start(); // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。 System.out.println(Thread.currentThread().getName() + &quot; call wait &quot;); t1.wait(3000); System.out.println(Thread.currentThread().getName() + &quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } 运行结果： main start t1 main call wait t1 run // 大约3秒之后...输出“main continue” main continue 结果说明：如下图，说明了“主线程”和“线程t1”的流程。(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。(02) 主线程main执行t1.start()启动“线程t1”。(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。(04) “线程t1”运行之后，进入了死循环，一直不断的运行。(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。 img 4. wait() 和 notifyAll()通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。 下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。 public class NotifyAllTest { private static Object obj = new Object(); public static void main(String[] args) { ThreadA t1 = new ThreadA(&quot;t1&quot;); ThreadA t2 = new ThreadA(&quot;t2&quot;); ThreadA t3 = new ThreadA(&quot;t3&quot;); t1.start(); t2.start(); t3.start(); try { System.out.println(Thread.currentThread().getName()+&quot; sleep(3000)&quot;); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(obj) { // 主线程等待唤醒。 System.out.println(Thread.currentThread().getName()+&quot; notifyAll()&quot;); obj.notifyAll(); } } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run() { synchronized (obj) { try { // 打印输出结果 System.out.println(Thread.currentThread().getName() + &quot; wait&quot;); // 唤醒当前的wait线程 obj.wait(); // 打印输出结果 System.out.println(Thread.currentThread().getName() + &quot; continue&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 运行结果： t1 wait main sleep(3000) t3 wait t2 wait main notifyAll() t2 continue t3 continue t1 continue 结果说明：参考下面的流程图。(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！ img 5. 为什么notify(), wait()等函数定义在Object中，而不是Thread中Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。 wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。 负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。 总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”04之 synchronized关键字","date":"2016-11-03T16:00:00.000Z","path":"2016/11/04/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”04之 synchronized关键字/","text":"本章，会对synchronized关键字进行介绍。 目录1. synchronized原理2. synchronized基本规则3. synchronized方法 和 synchronized代码块4. 实例锁 和 全局锁 1. synchronized原理在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。 当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。 不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。 2. synchronized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 第一条当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。下面是“synchronized代码块”对应的演示程序。 class MyRunable implements Runnable { @Override public void run() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i); } } catch (InterruptedException ie) { } } } } public class Demo1_1 { public static void main(String[] args) { Runnable demo = new MyRunable(); // 新建“Runnable对象” Thread t1 = new Thread(demo, &quot;t1&quot;); // 新建“线程t1”, t1是基于demo这个Runnable对象 Thread t2 = new Thread(demo, &quot;t2&quot;); // 新建“线程t2”, t2是基于demo这个Runnable对象 t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” } } 运行结果： t1 loop 0 t1 loop 1 t1 loop 2 t1 loop 3 t1 loop 4 t2 loop 0 t2 loop 1 t2 loop 2 t2 loop 3 t2 loop 4 结果说明：run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。 如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下： class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; loop &quot; + i); } } catch (InterruptedException ie) { } } } } public class Demo1_2 { public static void main(String[] args) { Thread t1 = new MyThread(&quot;t1&quot;); // 新建“线程t1” Thread t2 = new MyThread(&quot;t2&quot;); // 新建“线程t2” t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” } } 代码说明：比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！ 那么，Demo1_2的执行流程是不是和Demo1_1一样呢？运行结果： t1 loop 0 t2 loop 0 t1 loop 1 t2 loop 1 t1 loop 2 t2 loop 2 t1 loop 3 t2 loop 3 t1 loop 4 t2 loop 4 结果说明：如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。 第二条当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。下面是“synchronized代码块”对应的演示程序。 class Count { // 含有synchronized同步块的方法 public void synMethod() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } // 非同步的方法 public void nonSynMethod() { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } public class Demo2 { public static void main(String[] args) { final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() { @Override public void run() { count.synMethod(); } }, &quot;t1&quot;); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() { @Override public void run() { count.nonSynMethod(); } }, &quot;t2&quot;); t1.start(); // 启动t1 t2.start(); // 启动t2 } } 运行结果： t1 synMethod loop 0 t2 nonSynMethod loop 0 t1 synMethod loop 1 t2 nonSynMethod loop 1 t1 synMethod loop 2 t2 nonSynMethod loop 2 t1 synMethod loop 3 t2 nonSynMethod loop 3 t1 synMethod loop 4 t2 nonSynMethod loop 4 结果说明：主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。 第三条当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下： class Count { // 含有synchronized同步块的方法 public void synMethod() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + &quot; synMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } // 也包含synchronized同步块的方法 public void nonSynMethod() { synchronized(this) { try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); System.out.println(Thread.currentThread().getName() + &quot; nonSynMethod loop &quot; + i); } } catch (InterruptedException ie) { } } } } public class Demo3 { public static void main(String[] args) { final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() { @Override public void run() { count.synMethod(); } }, &quot;t1&quot;); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() { @Override public void run() { count.nonSynMethod(); } }, &quot;t2&quot;); t1.start(); // 启动t1 t2.start(); // 启动t2 } } 运行结果： t1 synMethod loop 0 t1 synMethod loop 1 t1 synMethod loop 2 t1 synMethod loop 3 t1 synMethod loop 4 t2 nonSynMethod loop 0 t2 nonSynMethod loop 1 t2 nonSynMethod loop 2 t2 nonSynMethod loop 3 t2 nonSynMethod loop 4 结果说明：主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。 3. synchronized方法 和 synchronized代码块“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。 synchronized方法示例 public synchronized void foo1() { System.out.println(&quot;synchronized methoed&quot;); } synchronized代码块 public void foo2() { synchronized (this) { System.out.println(&quot;synchronized methoed&quot;); } } synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。 synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示： // Demo4.java的源码 public class Demo4 { public synchronized void synMethod() { for(int i=0; i&lt;1000000; i++) ; } public void synBlock() { synchronized( this ) { for(int i=0; i&lt;1000000; i++) ; } } public static void main(String[] args) { Demo4 demo = new Demo4(); long start, diff; start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synMethod(); // 调用“synchronized方法” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println(&quot;synMethod() : &quot;+ diff); start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synBlock(); // 调用“synchronized方法块” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println(&quot;synBlock() : &quot;+ diff); } } (某一次)执行结果： synMethod() : 11 synBlock() : 3 4. 实例锁 和 全局锁实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。 &nbsp;&nbsp;&nbsp;&nbsp; 实例锁对应的就是synchronized关键字。全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 &nbsp;&nbsp;&nbsp;&nbsp; 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。 关于“实例锁”和“全局锁”有一个很形象的例子： pulbic class Something { public synchronized void isSyncA(){} public synchronized void isSyncB(){} public static synchronized void cSyncA(){} public static synchronized void cSyncB(){} } 假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。(01) x.isSyncA()与x.isSyncB()(02) x.isSyncA()与y.isSyncA()(03) x.cSyncA()与y.cSyncB()(04) x.isSyncA()与Something.cSyncA() (01) 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！ // LockTest1.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest1 { Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() private void test1() { // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() { @Override public void run() { x.isSyncA(); } }, &quot;t11&quot;); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() { @Override public void run() { x.isSyncB(); } }, &quot;t12&quot;); t11.start(); // 启动t11 t12.start(); // 启动t12 } public static void main(String[] args) { LockTest1 demo = new LockTest1(); demo.test1(); } } 运行结果： t11 : isSyncA t11 : isSyncA t11 : isSyncA t11 : isSyncA t11 : isSyncA t12 : isSyncB t12 : isSyncB t12 : isSyncB t12 : isSyncB t12 : isSyncB (02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。 // LockTest2.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest2 { Something x = new Something(); Something y = new Something(); // 比较(02) x.isSyncA()与y.isSyncA() private void test2() { // 新建t21, t21会调用 x.isSyncA() Thread t21 = new Thread( new Runnable() { @Override public void run() { x.isSyncA(); } }, &quot;t21&quot;); // 新建t22, t22会调用 x.isSyncB() Thread t22 = new Thread( new Runnable() { @Override public void run() { y.isSyncA(); } }, &quot;t22&quot;); t21.start(); // 启动t21 t22.start(); // 启动t22 } public static void main(String[] args) { LockTest2 demo = new LockTest2(); demo.test2(); } } 运行结果： t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA t21 : isSyncA t22 : isSyncA (03) 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。 // LockTest3.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest3 { Something x = new Something(); Something y = new Something(); // 比较(03) x.cSyncA()与y.cSyncB() private void test3() { // 新建t31, t31会调用 x.isSyncA() Thread t31 = new Thread( new Runnable() { @Override public void run() { x.cSyncA(); } }, &quot;t31&quot;); // 新建t32, t32会调用 x.isSyncB() Thread t32 = new Thread( new Runnable() { @Override public void run() { y.cSyncB(); } }, &quot;t32&quot;); t31.start(); // 启动t31 t32.start(); // 启动t32 } public static void main(String[] args) { LockTest3 demo = new LockTest3(); demo.test3(); } } 运行结果： t31 : cSyncA t31 : cSyncA t31 : cSyncA t31 : cSyncA t31 : cSyncA t32 : cSyncB t32 : cSyncB t32 : cSyncB t32 : cSyncB t32 : cSyncB (04) 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。 // LockTest4.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncA&quot;); } }catch (InterruptedException ie) { } } public synchronized void isSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : isSyncB&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncA(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncA&quot;); } }catch (InterruptedException ie) { } } public static synchronized void cSyncB(){ try { for (int i = 0; i &lt; 5; i++) { Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+&quot; : cSyncB&quot;); } }catch (InterruptedException ie) { } } } public class LockTest4 { Something x = new Something(); Something y = new Something(); // 比较(04) x.isSyncA()与Something.cSyncA() private void test4() { // 新建t41, t41会调用 x.isSyncA() Thread t41 = new Thread( new Runnable() { @Override public void run() { x.isSyncA(); } }, &quot;t41&quot;); // 新建t42, t42会调用 x.isSyncB() Thread t42 = new Thread( new Runnable() { @Override public void run() { Something.cSyncA(); } }, &quot;t42&quot;); t41.start(); // 启动t41 t42.start(); // 启动t42 } public static void main(String[] args) { LockTest4 demo = new LockTest4(); demo.test4(); } } 运行结果： t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA t41 : isSyncA t42 : cSyncA","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”03之  Thread中start()和run()的区别","date":"2016-11-02T16:00:00.000Z","path":"2016/11/03/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”03之  Thread中start()和run()的区别/","text":"Thread类包含start()和run()方法，它们的区别是什么？本章将对此作出解答。 目录1. start() 和 run()的区别说明2. start() 和 run()的区别示例3. start() 和 run()相关源码(基于JDK1.7.0_40) 1. start() 和 run()的区别说明start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。run() : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！ 下面以代码来进行说明。 class MyThread extends Thread{ public void run(){ ... } }; MyThread mythread = new MyThread(); mythread.start()会启动一个新线程，并在新线程中运行run()方法。而mythread.run()则会直接在当前线程中运行run()方法，并不会启动一个新线程来运行run()。 2. start() 和 run()的区别示例下面，通过一个简单示例演示它们之间的区别。源码如下： // Demo.java 的源码 class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ System.out.println(Thread.currentThread().getName()+&quot; is running&quot;); } }; public class Demo { public static void main(String[] args) { Thread mythread=new MyThread(&quot;mythread&quot;); System.out.println(Thread.currentThread().getName()+&quot; call mythread.run()&quot;); mythread.run(); System.out.println(Thread.currentThread().getName()+&quot; call mythread.start()&quot;); mythread.start(); } } 运行结果： main call mythread.run() main is running main call mythread.start() mythread is running 结果说明：(01) Thread.currentThread().getName()是用于获取“当前线程”的名字。当前线程是指正在cpu中调度执行的线程。(02) mythread.run()是在“主线程main”中调用的，该run()方法直接运行在“主线程main”上。(03) mythread.start()会启动“线程mythread”，“线程mythread”启动之后，会调用run()方法；此时的run()方法是运行在“线程mythread”上。 3. start() 和 run()相关源码(基于JDK1.7.0_40)Thread.java中start()方法的源码如下： public synchronized void start() { // 如果线程不是&quot;就绪状态&quot;，则抛出异常！ if (threadStatus != 0) throw new IllegalThreadStateException(); // 将线程添加到ThreadGroup中 group.add(this); boolean started = false; try { // 通过start0()启动线程 start0(); // 设置started标记 started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } 说明：start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。 private native void start0(); Thread.java中run()的代码如下： public void run() { if (target != null) { target.run(); } } 说明：target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”02之 常用的实现多线程的两种方式","date":"2016-11-01T16:00:00.000Z","path":"2016/11/02/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”02之 常用的实现多线程的两种方式/","text":"本章，我们学习“常用的实现多线程的2种方式”：Thread 和 Runnable。之所以说是常用的，是因为通过还可以通过java.util.concurrent包中的线程池来实现多线程。关于线程池的内容，我们以后会详细介绍；现在，先对的Thread和Runnable进行了解。 目录1. Thread和Runnable简介2. Thread和Runnable的异同点3. Thread和Runnable的多线程示例 1. Thread和Runnable简介Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下： public interface Runnable { public abstract void run(); } Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。 Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下： public class Thread implements Runnable {} Thread的作用，实现多线程。 2. Thread和Runnable的异同点Thread 和 Runnable 的相同点：都是“多线程的实现方式”。 Thread 和 Runnable 的不同点：Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。 通常，建议通过“Runnable”实现多线程！ 3. Thread和Runnable的多线程示例3.1 Thread的多线程示例下面通过示例更好的理解Thread和Runnable，借鉴网上一个例子比较具有说服性的例子。 // ThreadTest.java 源码 class MyThread extends Thread{ private int ticket=10; public void run(){ for(int i=0;i&lt;20;i++){ if(this.ticket&gt;0){ System.out.println(this.getName()+&quot; 卖票：ticket&quot;+this.ticket--); } } } }; public class ThreadTest { public static void main(String[] args) { // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1=new MyThread(); MyThread t2=new MyThread(); MyThread t3=new MyThread(); t1.start(); t2.start(); t3.start(); } } 运行结果： Thread-0 卖票：ticket10 Thread-1 卖票：ticket10 Thread-2 卖票：ticket10 Thread-1 卖票：ticket9 Thread-0 卖票：ticket9 Thread-1 卖票：ticket8 Thread-2 卖票：ticket9 Thread-1 卖票：ticket7 Thread-0 卖票：ticket8 Thread-1 卖票：ticket6 Thread-2 卖票：ticket8 Thread-1 卖票：ticket5 Thread-0 卖票：ticket7 Thread-1 卖票：ticket4 Thread-2 卖票：ticket7 Thread-1 卖票：ticket3 Thread-0 卖票：ticket6 Thread-1 卖票：ticket2 Thread-2 卖票：ticket6 Thread-2 卖票：ticket5 Thread-2 卖票：ticket4 Thread-1 卖票：ticket1 Thread-0 卖票：ticket5 Thread-2 卖票：ticket3 Thread-0 卖票：ticket4 Thread-2 卖票：ticket2 Thread-0 卖票：ticket3 Thread-2 卖票：ticket1 Thread-0 卖票：ticket2 Thread-0 卖票：ticket1 结果说明：(01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。(02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。 3.2 Runnable的多线程示例下面，我们对上面的程序进行修改。通过Runnable实现一个接口，从而实现多线程。 // RunnableTest.java 源码 class MyThread implements Runnable{ private int ticket=10; public void run(){ for(int i=0;i&lt;20;i++){ if(this.ticket&gt;0){ System.out.println(Thread.currentThread().getName()+&quot; 卖票：ticket&quot;+this.ticket--); } } } }; public class RunnableTest { public static void main(String[] args) { MyThread mt=new MyThread(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1=new Thread(mt); Thread t2=new Thread(mt); Thread t3=new Thread(mt); t1.start(); t2.start(); t3.start(); } } 运行结果： Thread-0 卖票：ticket10 Thread-2 卖票：ticket8 Thread-1 卖票：ticket9 Thread-2 卖票：ticket6 Thread-0 卖票：ticket7 Thread-2 卖票：ticket4 Thread-1 卖票：ticket5 Thread-2 卖票：ticket2 Thread-0 卖票：ticket3 Thread-1 卖票：ticket1 结果说明：(01) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。(02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"Java多线程系列--“基础篇”01之 基本概念","date":"2016-10-31T16:00:00.000Z","path":"2016/11/01/java-source-analysis-multi-thread-series/Java多线程系列--“基础篇”01之 基本概念/","text":"多线程是Java中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对“JDK中新增JUC包”之前的Java多线程内容的讲解，涉及到的内容包括，Object类中的wait(), notify()等接口；Thread类中的接口；synchronized关键字。 注：JUC包是指，Java.util.concurrent包，它是由Java大师Doug Lea完成并在JDK1.5版本添加到Java中的。 在进入后面章节的学习之前，先对了解一些多线程的相关概念。 线程状态图 img 说明：线程共包括以下5种状态。 新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：&nbsp;&nbsp;&nbsp;&nbsp; (01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。&nbsp;&nbsp;&nbsp;&nbsp; (02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。&nbsp;&nbsp;&nbsp;&nbsp; (03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。这些内容我们会在后面的章节中逐个进行学习。Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。在后面详细介绍wait(),notify()等方法时，我们会分析为什么“wait(), notify()等方法要定义在Object类，而不是Thread类中”。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java多线程系列","slug":"Java多线程系列","permalink":"https://smuwjs.github.io/tags/Java多线程系列/"}]},{"title":"java io系列26之 RandomAccessFile详解","date":"2016-10-25T16:00:00.000Z","path":"2016/10/26/java-source-analysis-io-series/java io系列26之 RandomAccessFile详解/","text":"目录1. RandomAccessFile2. RandomAccessFile 模式说明3. 演示程序 1. RandomAccessFileRandomAccessFile 是随机访问文件(包括读/写)的类。它支持对文件随机访问的读取和写入，即我们可以从指定的位置读取/写入文件数据。 需要注意的是，RandomAccessFile 虽然属于java.io包，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。 FileInputStream 只能对文件进行读操作，而FileOutputStream 只能对文件进行写操作；但是，RandomAccessFile 同时支持文件的读和写，并且它支持随机访问。 RandomAccessFile 函数列表 RandomAccessFile(File file, String mode) RandomAccessFile(String fileName, String mode) void close() synchronized final FileChannel getChannel() final FileDescriptor getFD() long getFilePointer() long length() int read(byte[] buffer, int byteOffset, int byteCount) int read(byte[] buffer) int read() final boolean readBoolean() final byte readByte() final char readChar() final double readDouble() final float readFloat() final void readFully(byte[] dst) final void readFully(byte[] dst, int offset, int byteCount) final int readInt() final String readLine() final long readLong() final short readShort() final String readUTF() final int readUnsignedByte() final int readUnsignedShort() void seek(long offset) void setLength(long newLength) int skipBytes(int count) void write(int oneByte) void write(byte[] buffer, int byteOffset, int byteCount) void write(byte[] buffer) final void writeBoolean(boolean val) final void writeByte(int val) final void writeBytes(String str) final void writeChar(int val) final void writeChars(String str) final void writeDouble(double val) final void writeFloat(float val) final void writeInt(int val) final void writeLong(long val) final void writeShort(int val) final void writeUTF(String str) 2. RandomAccessFile 模式说明RandomAccessFile共有4种模式：”r”, “rw”, “rws”和”rwd”。 “r” 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。“rw” 打开以便读取和写入。“rws” 打开以便读取和写入。相对于 “rw”，”rws” 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。“rwd” 打开以便读取和写入，相对于 “rw”，”rwd” 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。 说明： (01) 什么是“元数据”，即metadata？ 英文解释如下： The definition of metadata is “data about other data.” With a file system, the data is contained in its files and directories, and the metadata tracks information about each of these objects: Is it a regular file, a directory, or a link? What is its size, creation date, last modified date, file owner, group owner, and access permissions? 大致意思是：metadata是“关于数据的数据”。在文件系统中，数据被包含在文件和文件夹中；metadata信息包括：“数据是一个文件，一个目录还是一个链接”，“数据的创建时间(简称ctime)”，“最后一次修改时间(简称mtime)”，“数据拥有者”，“数据拥有群组”，“访问权限”等等。 (02) “rw”, “rws”, “rwd” 的区别。 当操作的文件是存储在本地的基础存储设备上时(如硬盘, NandFlash等)，”rws” 或 “rwd”, “rw” 才有区别。当模式是 “rws” 并且 操作的是基础存储设备上的文件；那么，每次“更改文件内容[如write()写入数据]” 或 “修改文件元数据(如文件的mtime)”时，都会将这些改变同步到基础存储设备上。当模式是 “rwd” 并且 操作的是基础存储设备上的文件；那么，每次“更改文件内容[如write()写入数据]”时，都会将这些改变同步到基础存储设备上。当模式是 “rw” 并且 操作的是基础存储设备上的文件；那么，关闭文件时，会将“文件内容的修改”同步到基础存储设备上。至于，“更改文件内容”时，是否会立即同步，取决于系统底层实现。 3. 演示程序源码如下： import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.PrintStream;; import java.io.RandomAccessFile; import java.io.IOException; /** * RandomAccessFile 测试程序 * * 运行结果(输出如下)： * c1=a * c2=b * buf=9876543210 * * 此外, * (01) 在源文件所在目录生成了file.txt。 * (02) 注意RandomAccessFile写入boolean, byte, char, int,所占的字符个数。 * * @author skywang */ public class RandomAccessFileTest { private static final String FileName = &quot;file.txt&quot;; public static void main(String[] args) { // 若文件“file.txt”存在，则删除该文件。 File file = new File(FileName); if (file.exists()) file.delete(); testCreateWrite(); testAppendWrite(); testRead(); } /** * 若“file.txt”不存在的话，则新建文件，并向文件中写入内容 */ private static void testCreateWrite() { try { // 创建文件“file.txt”对应File对象 File file = new File(FileName); // 创建文件“file.txt”对应的RandomAccessFile对象 RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;); // 向“文件中”写入26个字母+回车 raf.writeChars(&quot;abcdefghijklmnopqrstuvwxyz\\n&quot;); // 向“文件中”写入&quot;9876543210&quot;+回车 raf.writeChars(&quot;9876543210\\n&quot;); raf.close(); } catch(IOException e) { e.printStackTrace(); } } /** * 向文件末尾追加内容 */ private static void testAppendWrite() { try { // 创建文件“file.txt”对应File对象 File file = new File(FileName); // 创建文件“file.txt”对应的RandomAccessFile对象 RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;); // 获取文件长度 long fileLen = raf.length(); // 将位置定位到“文件末尾” raf.seek(fileLen); // 以下向raf文件中写数据 raf.writeBoolean(true); // 占1个字节 raf.writeByte(0x41); // 占1个字节 raf.writeChar(&apos;a&apos;); // 占2个字节 raf.writeShort(0x3c3c); // 占2个字节 raf.writeInt(0x75); // 占4个字节 raf.writeLong(0x1234567890123456L); // 占8个字节 raf.writeFloat(4.7f); // 占4个字节 raf.writeDouble(8.256);// 占8个字节 raf.writeUTF(&quot;UTF严&quot;); // UTF-8格式写入 raf.writeChar(&apos;\\n&apos;); // 占2个字符。“换行符” raf.close(); } catch(IOException e) { e.printStackTrace(); } } /** * 通过RandomAccessFile读取文件 */ private static void testRead() { try { // 创建文件“file.txt”对应File对象 File file = new File(FileName); // 创建文件“file.txt”对应的RandomAccessFile对象，以只读方式打开 RandomAccessFile raf = new RandomAccessFile(file, &quot;r&quot;); // 读取一个字符 char c1 = raf.readChar(); System.out.println(&quot;c1=&quot;+c1); // 读取一个字符 char c2 = raf.readChar(); System.out.println(&quot;c2=&quot;+c2); // 跳过54个字节。 raf.seek(54); // 测试read(byte[] buffer, int byteOffset, int byteCount) byte[] buf = new byte[20]; raf.read(buf, 0, buf.length); System.out.println(&quot;buf=&quot;+(new String(buf))); raf.close(); } catch(IOException e) { e.printStackTrace(); } } } 运行结果： c1=a c2=b buf=9876543210 结果说明：程序会在源文件所在目录生成file.txt；file.txt的内容如下： img file.txt对应的16进制内容如下： img","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列25之 PrintWriter详解","date":"2016-10-24T16:00:00.000Z","path":"2016/10/25/java-source-analysis-io-series/java io系列25之 PrintWriter详解/","text":"目录1. PrintWriter 介绍2. PrintWriter 源码3. 示例代码 1. PrintWriter 介绍PrintWriter 是字符类型的打印输出流，它继承于Writer。 PrintStream 用于向文本输出流打印对象的格式化表示形式。它实现在 PrintStream 中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。 PrintWriter 函数列表 PrintWriter(OutputStream out) PrintWriter(OutputStream out, boolean autoFlush) PrintWriter(Writer wr) PrintWriter(Writer wr, boolean autoFlush) PrintWriter(File file) PrintWriter(File file, String csn) PrintWriter(String fileName) PrintWriter(String fileName, String csn) PrintWriter append(char c) PrintWriter append(CharSequence csq, int start, int end) PrintWriter append(CharSequence csq) boolean checkError() void close() void flush() PrintWriter format(Locale l, String format, Object... args) PrintWriter format(String format, Object... args) void print(float fnum) void print(double dnum) void print(String str) void print(Object obj) void print(char ch) void print(char[] charArray) void print(long lnum) void print(int inum) void print(boolean bool) PrintWriter printf(Locale l, String format, Object... args) PrintWriter printf(String format, Object... args) void println() void println(float f) void println(int i) void println(long l) void println(Object obj) void println(char[] chars) void println(String str) void println(char c) void println(double d) void println(boolean b) void write(char[] buf, int offset, int count) void write(int oneChar) void write(char[] buf) void write(String str, int offset, int count) void write(String str) 2. PrintWriter 源码package java.io; import java.util.Objects; import java.util.Formatter; import java.util.Locale; import java.nio.charset.Charset; import java.nio.charset.IllegalCharsetNameException; import java.nio.charset.UnsupportedCharsetException; public class PrintWriter extends Writer { protected Writer out; // 自动flush // 所谓“自动flush”，就是每次执行print(), println(), write()函数，都会调用flush()函数； // 而“不自动flush”，则需要我们手动调用flush()接口。 private final boolean autoFlush; // PrintWriter是否右产生异常。当PrintWriter有异常产生时，会被本身捕获，并设置trouble为true private boolean trouble = false; // 用于格式化的对象 private Formatter formatter; private PrintStream psOut = null; // 行分割符 private final String lineSeparator; // 获取csn(字符集名字)对应的Chaset private static Charset toCharset(String csn) throws UnsupportedEncodingException { Objects.requireNonNull(csn, &quot;charsetName&quot;); try { return Charset.forName(csn); } catch (IllegalCharsetNameException|UnsupportedCharsetException unused) { // UnsupportedEncodingException should be thrown throw new UnsupportedEncodingException(csn); } } // 将“Writer对象out”作为PrintWriter的输出流，默认不会自动flush，并且采用默认字符集。 public PrintWriter (Writer out) { this(out, false); } // 将“Writer对象out”作为PrintWriter的输出流，autoFlush的flush模式，并且采用默认字符集。 public PrintWriter(Writer out, boolean autoFlush) { super(out); this.out = out; this.autoFlush = autoFlush; lineSeparator = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction(&quot;line.separator&quot;)); } // 将“输出流对象out”作为PrintWriter的输出流，不自动flush，并且采用默认字符集。 public PrintWriter(OutputStream out) { this(out, false); } // 将“输出流对象out”作为PrintWriter的输出流，autoFlush的flush模式，并且采用默认字符集。 public PrintWriter(OutputStream out, boolean autoFlush) { // new OutputStreamWriter(out)：将“字节类型的输出流”转换为“字符类型的输出流” // new BufferedWriter(...): 为输出流提供缓冲功能。 this(new BufferedWriter(new OutputStreamWriter(out)), autoFlush); // save print stream for error propagation if (out instanceof java.io.PrintStream) { psOut = (PrintStream) out; } } // 创建fileName对应的OutputStreamWriter，进而创建BufferedWriter对象；然后将该BufferedWriter作为PrintWriter的输出流，不自动flush，采用默认字符集。 public PrintWriter(String fileName) throws FileNotFoundException { this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))), false); } // 创建fileName对应的OutputStreamWriter，进而创建BufferedWriter对象；然后将该BufferedWriter作为PrintWriter的输出流，不自动flush，采用字符集charset。 private PrintWriter(Charset charset, File file) throws FileNotFoundException { this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset)), false); } // 创建fileName对应的OutputStreamWriter，进而创建BufferedWriter对象；然后将该BufferedWriter作为PrintWriter的输出流，不自动flush，采用csn字符集。 public PrintWriter(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException { this(toCharset(csn), new File(fileName)); } // 创建file对应的OutputStreamWriter，进而创建BufferedWriter对象；然后将该BufferedWriter作为PrintWriter的输出流，不自动flush，采用默认字符集。 public PrintWriter(File file) throws FileNotFoundException { this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file))), false); } // 创建file对应的OutputStreamWriter，进而创建BufferedWriter对象；然后将该BufferedWriter作为PrintWriter的输出流，不自动flush，采用csn字符集。 public PrintWriter(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException { this(toCharset(csn), file); } private void ensureOpen() throws IOException { if (out == null) throw new IOException(&quot;Stream closed&quot;); } // flush“PrintWriter输出流中的数据”。 public void flush() { try { synchronized (lock) { ensureOpen(); out.flush(); } } catch (IOException x) { trouble = true; } } public void close() { try { synchronized (lock) { if (out == null) return; out.close(); out = null; } } catch (IOException x) { trouble = true; } } // flush“PrintWriter输出流缓冲中的数据”，并检查错误 public boolean checkError() { if (out != null) { flush(); } if (out instanceof java.io.PrintWriter) { PrintWriter pw = (PrintWriter) out; return pw.checkError(); } else if (psOut != null) { return psOut.checkError(); } return trouble; } protected void setError() { trouble = true; } protected void clearError() { trouble = false; } // 将字符c写入到“PrintWriter输出流”中。c虽然是int类型，但实际只会写入一个字符 public void write(int c) { try { synchronized (lock) { ensureOpen(); out.write(c); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“buf中从off开始的len个字符”写入到“PrintWriter输出流”中。 public void write(char buf[], int off, int len) { try { synchronized (lock) { ensureOpen(); out.write(buf, off, len); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“buf中的全部数据”写入到“PrintWriter输出流”中。 public void write(char buf[]) { write(buf, 0, buf.length); } // 将“字符串s中从off开始的len个字符”写入到“PrintWriter输出流”中。 public void write(String s, int off, int len) { try { synchronized (lock) { ensureOpen(); out.write(s, off, len); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“字符串s”写入到“PrintWriter输出流”中。 public void write(String s) { write(s, 0, s.length()); } // 将“换行符”写入到“PrintWriter输出流”中。 private void newLine() { try { synchronized (lock) { ensureOpen(); out.write(lineSeparator); if (autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“boolean数据对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(boolean b) { write(b ? &quot;true&quot; : &quot;false&quot;); } // 将“字符c对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(char c) { write(c); } // 将“int数据i对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(int i) { write(String.valueOf(i)); } // 将“long型数据l对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(long l) { write(String.valueOf(l)); } // 将“float数据f对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(float f) { write(String.valueOf(f)); } // 将“double数据d对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(double d) { write(String.valueOf(d)); } // 将“字符数组s”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(char s[]) { write(s); } // 将“字符串数据s”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(String s) { if (s == null) { s = &quot;null&quot;; } write(s); } // 将“对象obj对应的字符串”写入到“PrintWriter输出流”中，print实际调用的是write函数 public void print(Object obj) { write(String.valueOf(obj)); } // 将“换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println() { newLine(); } // 将“boolean数据对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(boolean x) { synchronized (lock) { print(x); println(); } } // 将“字符x对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(char x) { synchronized (lock) { print(x); println(); } } // 将“int数据对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(int x) { synchronized (lock) { print(x); println(); } } // 将“long数据对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(long x) { synchronized (lock) { print(x); println(); } } // 将“float数据对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(float x) { synchronized (lock) { print(x); println(); } } // 将“double数据对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(double x) { synchronized (lock) { print(x); println(); } } // 将“字符数组x+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(char x[]) { synchronized (lock) { print(x); println(); } } // 将“字符串x+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(String x) { synchronized (lock) { print(x); println(); } } // 将“对象o对应的字符串+换行符”写入到“PrintWriter输出流”中，println实际调用的是write函数 public void println(Object x) { String s = String.valueOf(x); synchronized (lock) { print(s); println(); } } // 将“数据args”根据“默认Locale值(区域属性)”按照format格式化，并写入到“PrintWriter输出流”中 public PrintWriter printf(String format, Object ... args) { return format(format, args); } // 将“数据args”根据“Locale值(区域属性)”按照format格式化，并写入到“PrintWriter输出流”中 public PrintWriter printf(Locale l, String format, Object ... args) { return format(l, format, args); } // 根据“默认的Locale值(区域属性)”来格式化数据 public PrintWriter format(String format, Object ... args) { try { synchronized (lock) { ensureOpen(); if ((formatter == null) || (formatter.locale() != Locale.getDefault())) formatter = new Formatter(this); formatter.format(Locale.getDefault(), format, args); if (autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } return this; } // 根据“Locale值(区域属性)”来格式化数据 public PrintWriter format(Locale l, String format, Object ... args) { try { synchronized (lock) { ensureOpen(); if ((formatter == null) || (formatter.locale() != l)) formatter = new Formatter(this, l); formatter.format(l, format, args); if (autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } return this; } // 将“字符序列的全部字符”追加到“PrintWriter输出流中” public PrintWriter append(CharSequence csq) { if (csq == null) write(&quot;null&quot;); else write(csq.toString()); return this; } // 将“字符序列从start(包括)到end(不包括)的全部字符”追加到“PrintWriter输出流中” public PrintWriter append(CharSequence csq, int start, int end) { CharSequence cs = (csq == null ? &quot;null&quot; : csq); write(cs.subSequence(start, end).toString()); return this; } // 将“字符c”追加到“PrintWriter输出流中” public PrintWriter append(char c) { write(c); return this; } } 3. 示例代码关于PrintWriter中API的详细用法，参考示例代码(PrintWriterTest.java)： import java.io.PrintWriter; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; /** * PrintWriter 的示例程序 * * @author skywang */ public class PrintWriterTest { public static void main(String[] args) { // 下面3个函数的作用都是一样：都是将字母“abcde”写入到文件“file.txt”中。 // 任选一个执行即可！ testPrintWriterConstrutor1() ; //testPrintWriterConstrutor2() ; //testPrintWriterConstrutor3() ; // 测试write(), print(), println(), printf()等接口。 testPrintWriterAPIS() ; } /** * PrintWriter(OutputStream out) 的测试函数 * * 函数的作用，就是将字母“abcde”写入到文件“file.txt”中 */ private static void testPrintWriterConstrutor1() { final char[] arr={&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }; try { // 创建文件“file.txt”的File对象 File file = new File(&quot;file.txt&quot;); // 创建文件对应FileOutputStream PrintWriter out = new PrintWriter( new FileOutputStream(file)); // 将“字节数组arr”全部写入到输出流中 out.write(arr); // 关闭输出流 out.close(); } catch (IOException e) { e.printStackTrace(); } } /** * PrintWriter(File file) 的测试函数 * * 函数的作用，就是将字母“abcde”写入到文件“file.txt”中 */ private static void testPrintWriterConstrutor2() { final char[] arr={&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }; try { File file = new File(&quot;file.txt&quot;); PrintWriter out = new PrintWriter(file); out.write(arr); out.close(); } catch (IOException e) { e.printStackTrace(); } } /** * PrintWriter(String fileName) 的测试函数 * * 函数的作用，就是将字母“abcde”写入到文件“file.txt”中 */ private static void testPrintWriterConstrutor3() { final char[] arr={&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }; try { PrintWriter out = new PrintWriter(&quot;file.txt&quot;); out.write(arr); out.close(); } catch (IOException e) { e.printStackTrace(); } } /** * 测试write(), print(), println(), printf()等接口。 */ private static void testPrintWriterAPIS() { final char[] arr={&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; }; try { // 创建文件对应FileOutputStream PrintWriter out = new PrintWriter(&quot;other.txt&quot;); // 将字符串“hello PrintWriter”+回车符，写入到输出流中 out.println(&quot;hello PrintWriter&quot;); // 将0x41写入到输出流中 // 0x41对应ASCII码的字母&apos;A&apos;，也就是写入字符&apos;A&apos; out.write(0x41); // 将字符串&quot;65&quot;写入到输出流中。 // out.print(0x41); 等价于 out.write(String.valueOf(0x41)); out.print(0x41); // 将字符&apos;B&apos;追加到输出流中 out.append(&apos;B&apos;).append(&quot;CDEF&quot;); // 将&quot;CDE is 5&quot; + 回车 写入到输出流中 String str = &quot;GHI&quot;; int num = 5; out.printf(&quot;%s is %d\\n&quot;, str, num); out.close(); } catch (IOException e) { e.printStackTrace(); } } } 运行上面的代码，会在源码所在目录生成两个文件“file.txt”和“other.txt”。 file.txt的内容如下： abcde other.txt的内容如下： hello PrintWriter A65BCDEFGHI is 5","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列24之 BufferedWriter详解","date":"2016-10-23T16:00:00.000Z","path":"2016/10/24/java-source-analysis-io-series/java io系列24之 BufferedWriter详解/","text":"目录1. BufferedWriter 介绍2. BufferedWriter 源码分析(基于jdk1.7.40)3. 示例代码 1. BufferedWriter 介绍BufferedWriter 是缓冲字符输出流。它继承于Writer。BufferedWriter 的作用是为其他字符输出流添加一些缓冲功能。 BufferedWriter 函数列表 // 构造函数 BufferedWriter(Writer out) BufferedWriter(Writer out, int sz) void close() // 关闭此流，但要先刷新它。 void flush() // 刷新该流的缓冲。 void newLine() // 写入一个行分隔符。 void write(char[] cbuf, int off, int len) // 写入字符数组的某一部分。 void write(int c) // 写入单个字符。 void write(String s, int off, int len) // 写入字符串的某一部分。 2. BufferedWriter 源码分析(基于jdk1.7.40)package java.io; public class BufferedWriter extends Writer { // 输出流对象 private Writer out; // 保存“缓冲输出流”数据的字符数组 private char cb[]; // nChars 是cb缓冲区中字符的总的个数 // nextChar 是下一个要读取的字符在cb缓冲区中的位置 private int nChars, nextChar; // 默认字符缓冲区大小 private static int defaultCharBufferSize = 8192; // 行分割符 private String lineSeparator; // 构造函数，传入“Writer对象”，默认缓冲区大小是8k public BufferedWriter(Writer out) { this(out, defaultCharBufferSize); } // 构造函数，传入“Writer对象”，指定缓冲区大小是sz public BufferedWriter(Writer out, int sz) { super(out); if (sz &lt;= 0) throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); this.out = out; cb = new char[sz]; nChars = sz; nextChar = 0; lineSeparator = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction(&quot;line.separator&quot;)); } // 确保“BufferedWriter”是打开状态 private void ensureOpen() throws IOException { if (out == null) throw new IOException(&quot;Stream closed&quot;); } // 对缓冲区执行flush()操作，将缓冲区的数据写入到Writer中 void flushBuffer() throws IOException { synchronized (lock) { ensureOpen(); if (nextChar == 0) return; out.write(cb, 0, nextChar); nextChar = 0; } } // 将c写入到缓冲区中。先将c转换为char，然后将其写入到缓冲区。 public void write(int c) throws IOException { synchronized (lock) { ensureOpen(); // 若缓冲区满了，则清空缓冲，将缓冲数据写入到输出流中。 if (nextChar &gt;= nChars) flushBuffer(); cb[nextChar++] = (char) c; } } // 返回a，b中较小的数 private int min(int a, int b) { if (a &lt; b) return a; return b; } // 将字符数组cbuf写入到缓冲中，从cbuf的off位置开始写入，写入长度是len。 public void write(char cbuf[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) || ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } if (len &gt;= nChars) { /* If the request length exceeds the size of the output buffer, flush the buffer and then write the data directly. In this way buffered streams will cascade harmlessly. */ flushBuffer(); out.write(cbuf, off, len); return; } int b = off, t = off + len; while (b &lt; t) { int d = min(nChars - nextChar, t - b); System.arraycopy(cbuf, b, cb, nextChar, d); b += d; nextChar += d; if (nextChar &gt;= nChars) flushBuffer(); } } } // 将字符串s写入到缓冲中，从s的off位置开始写入，写入长度是len。 public void write(String s, int off, int len) throws IOException { synchronized (lock) { ensureOpen(); int b = off, t = off + len; while (b &lt; t) { int d = min(nChars - nextChar, t - b); s.getChars(b, b + d, cb, nextChar); b += d; nextChar += d; if (nextChar &gt;= nChars) flushBuffer(); } } } // 将换行符写入到缓冲中 public void newLine() throws IOException { write(lineSeparator); } // 清空缓冲区数据 public void flush() throws IOException { synchronized (lock) { flushBuffer(); out.flush(); } } public void close() throws IOException { synchronized (lock) { if (out == null) { return; } try { flushBuffer(); } finally { out.close(); out = null; cb = null; } } } } 说明： BufferedWriter的源码非常简单，这里就BufferedWriter的思想进行简单说明：BufferedWriter通过字符数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。 3. 示例代码关于BufferedWriter中API的详细用法，参考示例代码(BufferedWriterTest.java)： import java.io.BufferedWriter; import java.io.File; import java.io.OutputStream; import java.io.FileWriter; import java.io.IOException; import java.io.FileNotFoundException; import java.lang.SecurityException; import java.util.Scanner; /** * BufferedWriter 测试程序 * * @author skywang */ public class BufferedWriterTest { private static final int LEN = 5; // 对应英文字母“abcdefghijklmnopqrstuvwxyz” //private static final char[] ArrayLetters = &quot;abcdefghijklmnopqrstuvwxyz&quot;; private static final char[] ArrayLetters = new char[] {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;}; public static void main(String[] args) { testBufferedWriter() ; } /** * BufferedWriter的API测试函数 */ private static void testBufferedWriter() { // 创建“文件输出流”对应的BufferedWriter // 它对应缓冲区的大小是16，即缓冲区的数据&gt;=16时，会自动将缓冲区的内容写入到输出流。 try { File file = new File(&quot;bufferwriter.txt&quot;); BufferedWriter out = new BufferedWriter( new FileWriter(file)); // 将ArrayLetters数组的前10个字符写入到输出流中 out.write(ArrayLetters, 0, 10); // 将“换行符\\n”写入到输出流中 out.write(&apos;\\n&apos;); out.flush(); //readUserInput() ; out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } /** * 读取用户输入 */ private static void readUserInput() { System.out.println(&quot;please input a text:&quot;); Scanner reader=new Scanner(System.in); // 等待一个输入 String str = reader.next(); System.out.printf(&quot;the input is : %s\\n&quot;, str); } } 运行结果： 生成文件“bufferwriter.txt”，文件的内容是“abcdefghij”。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列23之 BufferedReader详解","date":"2016-10-22T16:00:00.000Z","path":"2016/10/23/java-source-analysis-io-series/java io系列23之 BufferedReader详解/","text":"目录1. BufferedReader 介绍2. BufferedReader 源码分析(基于jdk1.7.40)3. 示例代码 1. BufferedReader 介绍BufferedReader 是缓冲字符输入流。它继承于Reader。BufferedReader 的作用是为其他字符输入流添加一些缓冲功能。 BufferedReader 函数列表 BufferedReader(Reader in) BufferedReader(Reader in, int size) void close() void mark(int markLimit) boolean markSupported() int read() int read(char[] buffer, int offset, int length) String readLine() boolean ready() void reset() long skip(long charCount) 2. BufferedReader 源码分析(基于jdk1.7.40)package java.io; public class BufferedReader extends Reader { private Reader in; // 字符缓冲区 private char cb[]; // nChars 是cb缓冲区中字符的总的个数 // nextChar 是下一个要读取的字符在cb缓冲区中的位置 private int nChars, nextChar; // 表示“标记无效”。它与UNMARKED的区别是： // (01) UNMARKED 是压根就没有设置过标记。 // (02) 而INVALIDATED是设置了标记，但是被标记位置太长，导致标记无效！ private static final int INVALIDATED = -2; // 表示没有设置“标记” private static final int UNMARKED = -1; // “标记” private int markedChar = UNMARKED; // “标记”能标记位置的最大长度 private int readAheadLimit = 0; /* Valid only when markedChar &gt; 0 */ // skipLF(即skip Line Feed)是“是否忽略换行符”标记 private boolean skipLF = false; // 设置“标记”时，保存的skipLF的值 private boolean markedSkipLF = false; // 默认字符缓冲区大小 private static int defaultCharBufferSize = 8192; // 默认每一行的字符个数 private static int defaultExpectedLineLength = 80; // 创建“Reader”对应的BufferedReader对象，sz是BufferedReader的缓冲区大小 public BufferedReader(Reader in, int sz) { super(in); if (sz &lt;= 0) throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); this.in = in; cb = new char[sz]; nextChar = nChars = 0; } // 创建“Reader”对应的BufferedReader对象，默认的BufferedReader缓冲区大小是8k public BufferedReader(Reader in) { this(in, defaultCharBufferSize); } // 确保“BufferedReader”是打开状态 private void ensureOpen() throws IOException { if (in == null) throw new IOException(&quot;Stream closed&quot;); } // 填充缓冲区函数。有以下两种情况被调用： // (01) 缓冲区没有数据时，通过fill()可以向缓冲区填充数据。 // (02) 缓冲区数据被读完，需更新时，通过fill()可以更新缓冲区的数据。 private void fill() throws IOException { // dst表示“cb中填充数据的起始位置”。 int dst; if (markedChar &lt;= UNMARKED) { // 没有标记的情况，则设dst=0。 dst = 0; } else { // delta表示“当前标记的长度”，它等于“下一个被读取字符的位置”减去“标记的位置”的差值； int delta = nextChar - markedChar; if (delta &gt;= readAheadLimit) { // 若“当前标记的长度”超过了“标记上限(readAheadLimit)”， // 则丢弃标记！ markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; } else { if (readAheadLimit &lt;= cb.length) { // 若“当前标记的长度”没有超过了“标记上限(readAheadLimit)”， // 并且“标记上限(readAheadLimit)”小于/等于“缓冲的长度”； // 则先将“下一个要被读取的位置，距离我们标记的置符的距离”间的字符保存到cb中。 System.arraycopy(cb, markedChar, cb, 0, delta); markedChar = 0; dst = delta; } else { // 若“当前标记的长度”没有超过了“标记上限(readAheadLimit)”， // 并且“标记上限(readAheadLimit)”大于“缓冲的长度”； // 则重新设置缓冲区大小，并将“下一个要被读取的位置，距离我们标记的置符的距离”间的字符保存到cb中。 char ncb[] = new char[readAheadLimit]; System.arraycopy(cb, markedChar, ncb, 0, delta); cb = ncb; markedChar = 0; dst = delta; } // 更新nextChar和nChars nextChar = nChars = delta; } } int n; do { // 从“in”中读取数据，并存储到字符数组cb中； // 从cb的dst位置开始存储，读取的字符个数是cb.length - dst // n是实际读取的字符个数；若n==0(即一个也没读到)，则继续读取！ n = in.read(cb, dst, cb.length - dst); } while (n == 0); // 如果从“in”中读到了数据，则设置nChars(cb中字符的数目)=dst+n， // 并且nextChar(下一个被读取的字符的位置)=dst。 if (n &gt; 0) { nChars = dst + n; nextChar = dst; } } // 从BufferedReader中读取一个字符，该字符以int的方式返回 public int read() throws IOException { synchronized (lock) { ensureOpen(); for (;;) { // 若“缓冲区的数据已经被读完”， // 则先通过fill()更新缓冲区数据 if (nextChar &gt;= nChars) { fill(); if (nextChar &gt;= nChars) return -1; } // 若要“忽略换行符”， // 则对下一个字符是否是换行符进行处理。 if (skipLF) { skipLF = false; if (cb[nextChar] == &apos;\\n&apos;) { nextChar++; continue; } } // 返回下一个字符 return cb[nextChar++]; } } } // 将缓冲区中的数据写入到数组cbuf中。off是数组cbuf中的写入起始位置，len是写入长度 private int read1(char[] cbuf, int off, int len) throws IOException { // 若“缓冲区的数据已经被读完”，则更新缓冲区数据。 if (nextChar &gt;= nChars) { if (len &gt;= cb.length &amp;&amp; markedChar &lt;= UNMARKED &amp;&amp; !skipLF) { return in.read(cbuf, off, len); } fill(); } // 若更新数据之后，没有任何变化；则退出。 if (nextChar &gt;= nChars) return -1; // 若要“忽略换行符”，则进行相应处理 if (skipLF) { skipLF = false; if (cb[nextChar] == &apos;\\n&apos;) { nextChar++; if (nextChar &gt;= nChars) fill(); if (nextChar &gt;= nChars) return -1; } } // 拷贝字符操作 int n = Math.min(len, nChars - nextChar); System.arraycopy(cb, nextChar, cbuf, off, n); nextChar += n; return n; } // 对read1()的封装，添加了“同步处理”和“阻塞式读取”等功能 public int read(char cbuf[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) || ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } int n = read1(cbuf, off, len); if (n &lt;= 0) return n; while ((n &lt; len) &amp;&amp; in.ready()) { int n1 = read1(cbuf, off + n, len - n); if (n1 &lt;= 0) break; n += n1; } return n; } } // 读取一行数据。ignoreLF是“是否忽略换行符” String readLine(boolean ignoreLF) throws IOException { StringBuffer s = null; int startChar; synchronized (lock) { ensureOpen(); boolean omitLF = ignoreLF || skipLF; bufferLoop: for (;;) { if (nextChar &gt;= nChars) fill(); if (nextChar &gt;= nChars) { /* EOF */ if (s != null &amp;&amp; s.length() &gt; 0) return s.toString(); else return null; } boolean eol = false; char c = 0; int i; /* Skip a leftover &apos;\\n&apos;, if necessary */ if (omitLF &amp;&amp; (cb[nextChar] == &apos;\\n&apos;)) nextChar++; skipLF = false; omitLF = false; charLoop: for (i = nextChar; i &lt; nChars; i++) { c = cb[i]; if ((c == &apos;\\n&apos;) || (c == &apos;\\r&apos;)) { eol = true; break charLoop; } } startChar = nextChar; nextChar = i; if (eol) { String str; if (s == null) { str = new String(cb, startChar, i - startChar); } else { s.append(cb, startChar, i - startChar); str = s.toString(); } nextChar++; if (c == &apos;\\r&apos;) { skipLF = true; } return str; } if (s == null) s = new StringBuffer(defaultExpectedLineLength); s.append(cb, startChar, i - startChar); } } } // 读取一行数据。不忽略换行符 public String readLine() throws IOException { return readLine(false); } // 跳过n个字符 public long skip(long n) throws IOException { if (n &lt; 0L) { throw new IllegalArgumentException(&quot;skip value is negative&quot;); } synchronized (lock) { ensureOpen(); long r = n; while (r &gt; 0) { if (nextChar &gt;= nChars) fill(); if (nextChar &gt;= nChars) /* EOF */ break; if (skipLF) { skipLF = false; if (cb[nextChar] == &apos;\\n&apos;) { nextChar++; } } long d = nChars - nextChar; if (r &lt;= d) { nextChar += r; r = 0; break; } else { r -= d; nextChar = nChars; } } return n - r; } } // “下一个字符”是否可读 public boolean ready() throws IOException { synchronized (lock) { ensureOpen(); // 若忽略换行符为true； // 则判断下一个符号是否是换行符，若是的话，则忽略 if (skipLF) { if (nextChar &gt;= nChars &amp;&amp; in.ready()) { fill(); } if (nextChar &lt; nChars) { if (cb[nextChar] == &apos;\\n&apos;) nextChar++; skipLF = false; } } return (nextChar &lt; nChars) || in.ready(); } } // 始终返回true。因为BufferedReader支持mark(), reset() public boolean markSupported() { return true; } // 标记当前BufferedReader的下一个要读取位置。关于readAheadLimit的作用，参考后面的说明。 public void mark(int readAheadLimit) throws IOException { if (readAheadLimit &lt; 0) { throw new IllegalArgumentException(&quot;Read-ahead limit &lt; 0&quot;); } synchronized (lock) { ensureOpen(); // 设置readAheadLimit this.readAheadLimit = readAheadLimit; // 保存下一个要读取的位置 markedChar = nextChar; // 保存“是否忽略换行符”标记 markedSkipLF = skipLF; } } // 重置BufferedReader的下一个要读取位置， // 将其还原到mark()中所保存的位置。 public void reset() throws IOException { synchronized (lock) { ensureOpen(); if (markedChar &lt; 0) throw new IOException((markedChar == INVALIDATED) ? &quot;Mark invalid&quot; : &quot;Stream not marked&quot;); nextChar = markedChar; skipLF = markedSkipLF; } } public void close() throws IOException { synchronized (lock) { if (in == null) return; in.close(); in = null; cb = null; } } } 说明： 想读懂BufferReader的源码，就要先理解它的思想。BufferReader的作用是为其它Reader提供缓冲功能。创建BufferReader时，我们会通过它的构造函数指定某个Reader为参数。BufferReader会将该Reader中的数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从Reader中读取下一部分的数据。 为什么需要缓冲呢？原因很简单，效率问题！缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘或NandFlash中；而我们知道，从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。那干嘛不干脆一次性将全部数据都读取到缓冲中呢？第一，读取全部的数据所需要的时间可能会很长。第二，内存价格很贵，容量不想硬盘那么大。 下面，我就BufferReader中最重要的函数fill()进行说明。其它的函数很容易理解，我就不详细介绍了，大家可以参考源码中的注释进行理解。我们先看看fill()的源码： private void fill() throws IOException { int dst; if (markedChar &lt;= UNMARKED) { /* No mark */ dst = 0; } else { /* Marked */ int delta = nextChar - markedChar; if (delta &gt;= readAheadLimit) { /* Gone past read-ahead limit: Invalidate mark */ markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; } else { if (readAheadLimit &lt;= cb.length) { /* Shuffle in the current buffer */ System.arraycopy(cb, markedChar, cb, 0, delta); markedChar = 0; dst = delta; } else { /* Reallocate buffer to accommodate read-ahead limit */ char ncb[] = new char[readAheadLimit]; System.arraycopy(cb, markedChar, ncb, 0, delta); cb = ncb; markedChar = 0; dst = delta; } nextChar = nChars = delta; } } int n; do { n = in.read(cb, dst, cb.length - dst); } while (n == 0); if (n &gt; 0) { nChars = dst + n; nextChar = dst; } } 根据fill()中的if…else…，我将fill()分为4种情况进行说明。 情况1：读取完缓冲区的数据，并且缓冲区没有被标记 执行流程如下，(01) 其它函数调用 fill()，来更新缓冲区的数据(02) fill() 执行代码 if (markedChar &lt;= UNMARKED) { … } 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { int dst; if (markedChar &lt;= UNMARKED) { /* No mark */ dst = 0; } int n; do { n = in.read(cb, dst, cb.length - dst); } while (n == 0); if (n &gt; 0) { nChars = dst + n; nextChar = dst; } } 说明： 这种情况发生的情况是 — — Reader中有很长的数据，我们每次从中读取一部分数据到缓冲中进行操作。每次当我们读取完缓冲中的数据之后，并且此时BufferedReader没有被标记；那么，就接着从Reader(BufferReader提供缓冲功能的Reader)中读取下一部分的数据到缓冲中。其中，判断是否读完缓冲区中的数据，是通过“比较nextChar和nChars之间大小”来判断的。其中，nChars 是缓冲区中字符的总的个数，而 nextChar 是缓冲区中下一个要读取的字符的位置。判断BufferedReader有没有被标记，是通过“markedChar”来判断的。理解这个思想之后，我们再对这种情况下的fill()的代码进行分析，就特别容易理解了。 (01) if (markedChar &lt;= UNMARKED) 它的作用是判断“BufferedReader是否被标记”。若被标记，则dst=0。(02) in.read(cb, dst, cb.length - dst) 等价于 in.read(cb, 0, cb.length)，意思是从Reader对象in中读取cb.length个数据，并存储到缓冲区cb中，而且从缓冲区cb的位置0开始存储。该函数返回值等于n，也就是n表示实际读取的字符个数。若n=0(即没有读取到数据)，则继续读取，直到读到数据为止。(03) nChars=dst+n 等价于 nChars=n；意味着，更新缓冲区数据cb之后，设置nChars(缓冲区的数据个数)为n。(04) nextChar=dst 等价于 nextChar=0；意味着，更新缓冲区数据cb之后，设置nextChar(缓冲区中下一个会被读取的字符的索引值)为0。 情况2：读取完缓冲区的数据，缓冲区的标记位置&gt;0，并且“当前标记的长度”超过“标记上限(readAheadLimit)” 执行流程如下，(01) 其它函数调用 fill()，来更新缓冲区的数据(02) fill() 执行代码 if (delta &gt;= readAheadLimit) { … } 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { int dst; if (markedChar &gt; UNMARKED) { int delta = nextChar - markedChar; if (delta &gt;= readAheadLimit) { markedChar = INVALIDATED; readAheadLimit = 0; dst = 0; } } int n; do { n = in.read(cb, dst, cb.length - dst); } while (n == 0); if (n &gt; 0) { nChars = dst + n; nextChar = dst; } } 说明：这种情况发生的情况是 — — BufferedReader中有很长的数据，我们每次从中读取一部分数据到缓冲区中进行操作。当我们读取完缓冲区中的数据之后，并且此时，BufferedReader存在标记时，同时，“当前标记的长度”大于“标记上限”；那么，就发生情况2。此时，我们会丢弃“标记”并更新缓冲区。(01) delta = nextChar - markedChar；其中，delta就是“当前标记的长度”，它是“下一个被读取字符的位置”减去“被标记的位置”的差值。(02) if (delta &gt;= readAheadLimit)；其中，当delta &gt;= readAheadLimit，就意味着，“当前标记的长度”&gt;=“标记上限”。为什么要有标记上限，即readAheadLimit的值到底有何意义呢？ 我们标记一个位置之后，更新缓冲区的时候，被标记的位置会被保存；当我们不停的更新缓冲区的时候，被标记的位置会被不停的放大。然后内存的容量是有效的，我们不可能不限制长度的存储标记。所以，需要readAheadLimit来限制标记长度！(03) in.read(cb, dst, cb.length - dst) 等价于 in.read(cb, 0, cb.length)，意思是从Reader对象in中读取cb.length个数据，并存储到缓冲区cb中，而且从缓冲区cb的位置0开始存储。该函数返回值等于n，也就是n表示实际读取的字符个数。若n=0(即没有读取到数据)，则继续读取，直到读到数据为止。(04) nChars=dst+n 等价于 nChars=n；意味着，更新缓冲区数据cb之后，设置nChars(缓冲区的数据个数)为n。(05) nextChar=dst 等价于 nextChar=0；意味着，更新缓冲区数据cb之后，设置nextChar(缓冲区中下一个会被读取的字符的索引值)为0。 情况3：读取完缓冲区的数据，缓冲区的标记位置&gt;0，“当前标记的长度”没超过“标记上限(readAheadLimit)”，并且“标记上限(readAheadLimit)”小于/等于“缓冲的长度”； 执行流程如下，(01) 其它函数调用 fill()，来更新缓冲区的数据(02) fill() 执行代码 if (readAheadLimit &lt;= cb.length) { … } 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { int dst; if (markedChar &gt; UNMARKED) { int delta = nextChar - markedChar; if ((delta &lt; readAheadLimit) &amp;&amp; (readAheadLimit &lt;= cb.length) ) { System.arraycopy(cb, markedChar, cb, 0, delta); markedChar = 0; dst = delta; nextChar = nChars = delta; } } int n; do { n = in.read(cb, dst, cb.length - dst); } while (n == 0); if (n &gt; 0) { nChars = dst + n; nextChar = dst; } } 说明：这种情况发生的情况是 — — BufferedReader中有很长的数据，我们每次从中读取一部分数据到缓冲区中进行操作。当我们读取完缓冲区中的数据之后，并且此时，BufferedReader存在标记时，同时，“当前标记的长度”小于“标记上限”，并且“标记上限”小于/等于“缓冲区长度”；那么，就发生情况3。此时，我们保留“被标记的位置”(即，保留被标记位置开始的数据)，并更新缓冲区(将新增的数据，追加到保留的数据之后)。 情况4：读取完缓冲区的数据，缓冲区的标记位置&gt;0，“当前标记的长度”没超过“标记上限(readAheadLimit)”，并且“标记上限(readAheadLimit)”大于“缓冲的长度”； 执行流程如下，(01) 其它函数调用 fill()，来更新缓冲区的数据(02) fill() 执行代码 else { char ncb[] = new char[readAheadLimit]; … } 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { int dst; if (markedChar &gt; UNMARKED) { int delta = nextChar - markedChar; if ((delta &lt; readAheadLimit) &amp;&amp; (readAheadLimit &gt; cb.length) ) { char ncb[] = new char[readAheadLimit]; System.arraycopy(cb, markedChar, ncb, 0, delta); cb = ncb; markedChar = 0; dst = delta; nextChar = nChars = delta; } } int n; do { n = in.read(cb, dst, cb.length - dst); } while (n == 0); if (n &gt; 0) { nChars = dst + n; nextChar = dst; } } 说明：这种情况发生的情况是 — — BufferedReader中有很长的数据，我们每次从中读取一部分数据到缓冲区中进行操作。当我们读取完缓冲区中的数据之后，并且此时，BufferedReader存在标记时，同时，“当前标记的长度”小于“标记上限”，并且“标记上限”大于“缓冲区长度”；那么，就发生情况4。此时，我们要先更新缓冲区的大小，然后再保留“被标记的位置”(即，保留被标记位置开始的数据)，并更新缓冲区数据(将新增的数据，追加到保留的数据之后)。 3. 示例代码关于BufferedReader中API的详细用法，参考示例代码(BufferedReaderTest.java)： import java.io.BufferedReader; import java.io.ByteArrayInputStream; import java.io.File; import java.io.InputStream; import java.io.FileReader; import java.io.IOException; import java.io.FileNotFoundException; import java.lang.SecurityException; /** * BufferedReader 测试程序 * * @author skywang */ public class BufferedReaderTest { private static final int LEN = 5; public static void main(String[] args) { testBufferedReader() ; } /** * BufferedReader的API测试函数 */ private static void testBufferedReader() { // 创建BufferedReader字符流，内容是ArrayLetters数组 try { File file = new File(&quot;bufferedreader.txt&quot;); BufferedReader in = new BufferedReader( new FileReader(file)); // 从字符流中读取5个字符。“abcde” for (int i=0; i&lt;LEN; i++) { // 若能继续读取下一个字符，则读取下一个字符 if (in.ready()) { // 读取“字符流的下一个字符” int tmp = in.read(); System.out.printf(&quot;%d : %c\\n&quot;, i, tmp); } } // 若“该字符流”不支持标记功能，则直接退出 if (!in.markSupported()) { System.out.println(&quot;make not supported!&quot;); return ; } // 标记“当前索引位置”，即标记第6个位置的元素--“f” // 1024对应marklimit in.mark(1024); // 跳过22个字符。 in.skip(22); // 读取5个字符 char[] buf = new char[LEN]; in.read(buf, 0, LEN); System.out.printf(&quot;buf=%s\\n&quot;, String.valueOf(buf)); // 读取该行剩余的数据 System.out.printf(&quot;readLine=%s\\n&quot;, in.readLine()); // 重置“输入流的索引”为mark()所标记的位置，即重置到“f”处。 in.reset(); // 从“重置后的字符流”中读取5个字符到buf中。即读取“fghij” in.read(buf, 0, LEN); System.out.printf(&quot;buf=%s\\n&quot;, String.valueOf(buf)); in.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } 程序中读取的bufferedreader.txt的内容如下： abcdefghijklmnopqrstuvwxyz 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ 运行结果： 0 : a 1 : b 2 : c 3 : d 4 : e buf=01234 readLine=56789 buf=fghij","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列22之 FileReader和FileWriter详解","date":"2016-10-21T16:00:00.000Z","path":"2016/10/22/java-source-analysis-io-series/java io系列22之 FileReader和FileWriter详解/","text":"目录1. FileReader和FileWriter 介绍2. FileReader和FileWriter源码分析3. 示例程序 1. FileReader和FileWriter 介绍FileReader 是用于读取字符流的类，它继承于InputStreamReader。要读取原始字节流，请考虑使用 FileInputStream。FileWriter 是用于写入字符流的类，它继承于OutputStreamWriter。要写入原始字节流，请考虑使用 FileOutputStream。 2. FileReader和FileWriter源码分析2.1 FileReader 源码(基于jdk1.7.40)package java.io; public class FileReader extends InputStreamReader { public FileReader(String fileName) throws FileNotFoundException { super(new FileInputStream(fil java io系列21之 InputStreamReader和OutputStreamWritereName)); } public FileReader(File file) throws FileNotFoundException { super(new FileInputStream(file)); } public FileReader(FileDescriptor fd) { super(new FileInputStream(fd)); } } 从中，我们可以看出FileReader是基于InputStreamReader实现的。 2.2 FileWriter 源码(基于jdk1.7.40)package java.io; public class FileWriter extends OutputStreamWriter { public FileWriter(String fileName) throws IOException { super(new FileOutputStream(fileName)); } public FileWriter(String fileName, boolean append) throws IOException { super(new FileOutputStream(fileName, append)); } public FileWriter(File file) throws IOException { super(new FileOutputStream(file)); } public FileWriter(File file, boolean append) throws IOException { super(new FileOutputStream(file, append)); } public FileWriter(FileDescriptor fd) { super(new FileOutputStream(fd)); } } 从中，我们可以看出FileWriter是基于OutputStreamWriter实现的。 3. 示例程序import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileWriter;; import java.io.FileReader; import java.io.IOException; /** * FileReader 和 FileWriter 测试程序 * * @author skywang */ public class FileReaderWriterTest { private static final String FileName = &quot;file.txt&quot;; private static final String CharsetName = &quot;utf-8&quot;; public static void main(String[] args) { testWrite(); testRead(); } /** * OutputStreamWriter 演示函数 * */ private static void testWrite() { try { // 创建文件“file.txt”对应File对象 File file = new File(FileName); // 创建FileOutputStream对应FileWriter：将字节流转换为字符流，即写入out1的数据会自动由字节转换为字符。 FileWriter out1 = new FileWriter(file); // 写入10个汉字 out1.write(&quot;字节流转为字符流示例&quot;); // 向“文件中”写入&quot;0123456789&quot;+换行符 out1.write(&quot;0123456789\\n&quot;); out1.close(); } catch(IOException e) { e.printStackTrace(); } } /** * InputStreamReader 演示程序 */ private static void testRead() { try { // 方法1：新建FileInputStream对象 // 新建文件“file.txt”对应File对象 File file = new File(FileName); FileReader in1 = new FileReader(file); // 测试read()，从中读取一个字符 char c1 = (char)in1.read(); System.out.println(&quot;c1=&quot;+c1); // 测试skip(long byteCount)，跳过4个字符 in1.skip(6); // 测试read(char[] cbuf, int off, int len) char[] buf = new char[10]; in1.read(buf, 0, buf.length); System.out.println(&quot;buf=&quot;+(new String(buf))); in1.close(); } catch(IOException e) { e.printStackTrace(); } } } 运行结果： c1=字 buf=流示例0123456","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列21之 InputStreamReader和OutputStreamWriter详解","date":"2016-10-20T16:00:00.000Z","path":"2016/10/21/java-source-analysis-io-series/java io系列21之 InputStreamReader和OutputStreamWriter详解/","text":"目录1. InputStreamReader和OutputStreamWriter 介绍2. InputStreamReader和OutputStreamWriter源码分析3. 示例程序 1. InputStreamReader和OutputStreamWriter 介绍InputStreamReader和OutputStreamWriter 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符。 InputStreamReader 的作用是将“字节输入流”转换成“字符输入流”。它继承于Reader。OutputStreamWriter 的作用是将“字节输出流”转换成“字符输出流”。它继承于Writer。 2. InputStreamReader和OutputStreamWriter源码分析2.1 InputStreamReader 源码(基于jdk1.7.40)package java.io; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import sun.nio.cs.StreamDecoder; // 将“字节输入流”转换成“字符输入流” public class InputStreamReader extends Reader { private final StreamDecoder sd; // 根据in创建InputStreamReader，使用默认的编码 public InputStreamReader(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object } catch (UnsupportedEncodingException e) { // The default encoding should always be available throw new Error(e); } } // 根据in创建InputStreamReader，使用编码charsetName(编码名) public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException { super(in); if (charsetName == null) throw new NullPointerException(&quot;charsetName&quot;); sd = StreamDecoder.forInputStreamReader(in, this, charsetName); } // 根据in创建InputStreamReader，使用编码cs public InputStreamReader(InputStream in, Charset cs) { super(in); if (cs == null) throw new NullPointerException(&quot;charset&quot;); sd = StreamDecoder.forInputStreamReader(in, this, cs); } // 根据in创建InputStreamReader，使用解码器dec public InputStreamReader(InputStream in, CharsetDecoder dec) { super(in); if (dec == null) throw new NullPointerException(&quot;charset decoder&quot;); sd = StreamDecoder.forInputStreamReader(in, this, dec); } // 获取解码器 public String getEncoding() { return sd.getEncoding(); } // 读取并返回一个字符 public int read() throws IOException { return sd.read(); } // 将InputStreamReader中的数据写入cbuf中，从cbuf的offset位置开始写入，写入长度是length public int read(char cbuf[], int offset, int length) throws IOException { return sd.read(cbuf, offset, length); } // 能否从InputStreamReader中读取数据 public boolean ready() throws IOException { return sd.ready(); } // 关闭InputStreamReader public void close() throws IOException { sd.close(); } } 2.2 OutputStreamWriter 源码(基于jdk1.7.40)package java.io; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; import sun.nio.cs.StreamEncoder; // 将“字节输出流”转换成“字符输出流” public class OutputStreamWriter extends Writer { private final StreamEncoder se; // 根据out创建OutputStreamWriter，使用编码charsetName(编码名) public OutputStreamWriter(OutputStream out, String charsetName) throws UnsupportedEncodingException { super(out); if (charsetName == null) throw new NullPointerException(&quot;charsetName&quot;); se = StreamEncoder.forOutputStreamWriter(out, this, charsetName); } // 根据out创建OutputStreamWriter，使用默认的编码 public OutputStreamWriter(OutputStream out) { super(out); try { se = StreamEncoder.forOutputStreamWriter(out, this, (String)null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } // 根据out创建OutputStreamWriter，使用编码cs public OutputStreamWriter(OutputStream out, Charset cs) { super(out); if (cs == null) throw new NullPointerException(&quot;charset&quot;); se = StreamEncoder.forOutputStreamWriter(out, this, cs); } // 根据out创建OutputStreamWriter，使用编码器enc public OutputStreamWriter(OutputStream out, CharsetEncoder enc) { super(out); if (enc == null) throw new NullPointerException(&quot;charset encoder&quot;); se = StreamEncoder.forOutputStreamWriter(out, this, enc); }java io系列01之 &quot;目录&quot; // 获取编码器enc public String getEncoding() { return se.getEncoding(); } // 刷新缓冲区 void flushBuffer() throws IOException { se.flushBuffer(); } // 将单个字符写入到OutputStreamWriter中 public void write(int c) throws IOException { se.write(c); } // 将字符数组cbuf从off开始的数据写入到OutputStreamWriter中，写入长度是len public void write(char cbuf[], int off, int len) throws IOException { se.write(cbuf, off, len); } // 将字符串str从off开始的数据写入到OutputStreamWriter中，写入长度是len public void write(String str, int off, int len) throws IOException { se.write(str, off, len); }java io系列01之 &quot;目录&quot; // 刷新“输出流” // 它与flushBuffer()的区别是：flushBuffer()只会刷新缓冲，而flush()是刷新流，flush()包括了flushBuffer。 public void flush() throws IOException { se.flush(); } // 关闭“输出流” public void close() throws IOException { se.close(); } } 说明：OutputStreamWriter 作用和原理都比较简单。作用就是将“字节输出流”转换成“字符输出流”。它的原理是，我们创建“字符输出流”对象时，会指定“字节输出流”以及“字符编码”。 3. 示例程序InputStreamReader和OutputStreamWriter的使用示例，参考源码(StreamConverter.java)： import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.OutputStreamWriter;; import java.io.InputStreamReader; import java.io.IOException; /** * InputStreamReader 和 OutputStreamWriter 测试程序 * * @author skywang */ public class StreamConverter { private static final String FileName = &quot;file.txt&quot;; private static final String CharsetName = &quot;utf-8&quot;; //private static final String CharsetName = &quot;gb2312&quot;; public static void main(String[] args) { testWrite(); testRead(); } /** * OutputStreamWriter 演示函数 * */ private static void testWrite() { try { // 创建文件“file.txt”对应File对象 File file = new File(FileName); // 创建FileOutputStream对应OutputStreamWriter：将字节流转换为字符流，即写入out1的数据会自动由字节转换为字符。 OutputStreamWriter out1 = new OutputStreamWriter(new FileOutputStream(file), CharsetName); // 写入10个汉字 out1.write(&quot;字节流转为字符流示例&quot;); // 向“文件中”写入&quot;0123456789&quot;+换行符 out1.write(&quot;0123456789\\n&quot;); out1.close(); } catch(IOException e) { e.printStackTrace(); } } /** * InputStreamReader 演示程序 */ private static void testRead() { try { // 方法1：新建FileInputStream对象 // 新建文件“file.txt”对应File对象 File file = new File(FileName); InputStreamReader in1 = new InputStreamReader(new FileInputStream(file), CharsetName); // 测试read()，从中读取一个字符 char c1 = (char)in1.read(); System.out.println(&quot;c1=&quot;+c1); // 测试skip(long byteCount)，跳过4个字符 in1.skip(6); // 测试read(char[] cbuf, int off, int len) char[] buf = new char[10]; in1.read(buf, 0, buf.length); System.out.println(&quot;buf=&quot;+(new String(buf))); in1.close(); } catch(IOException e) { e.printStackTrace(); } } } 运行结果： c1=字 buf=流示例0123456 结果说明：(01) testWrite() 的作用是将“内容写入到输出流”。写入的时候，会将写入的内容转换utf-8编码并写入。(02) testRead() 的作用是将“内容读取到输入流”。读取的时候，会将内容转换成utf-8的内容转换成字节并读出来。 生成的文件utf-8的file.txt的16进制效果图如下： img 将StreamConverter.java中的CharsetName修改为”gb2312”。运行程序，生产的file.txt的16进制效果图如下： img","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列20之 PipedReader和PipedWriter详解","date":"2016-10-19T16:00:00.000Z","path":"2016/10/20/java-source-analysis-io-series/java io系列20之 PipedReader和PipedWriter详解/","text":"本章，我们学习PipedReader和PipedWriter。它们和“PipedInputStream和PipedOutputStream”一样，都可以用于管道通信。 目录1. PipedWriter和PipedReader介绍2. PipedWriter和PipedReader源码分析3. 示例 1. PipedWriter和PipedReader介绍PipedWriter 是字符管道输出流，它继承于Writer。PipedReader 是字符管道输入流，它继承于Writer。PipedWriter和PipedReader的作用是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedReader配套使用。 2. PipedWriter和PipedReader源码分析2.1 PipedWriter 源码(基于jdk1.7.40)package java.io; public class PipedWriter extends Writer { // 与PipedWriter通信的PipedReader对象 private PipedReader sink; // PipedWriter的关闭标记 private boolean closed = false; // 构造函数，指定配对的PipedReader public PipedWriter(PipedReader snk) throws IOException { connect(snk); } // 构造函数 public PipedWriter() { } // 将“PipedWriter” 和 “PipedReader”连接。 public synchronized void connect(PipedReader snk) throws IOException { if (snk == null) { throw new NullPointerException(); } else if (sink != null || snk.connected) { throw new IOException(&quot;Already connected&quot;); } else if (snk.closedByReader || closed) { throw new IOException(&quot;Pipe closed&quot;); } sink = snk; snk.in = -1; snk.out = 0; // 设置“PipedReader”和“PipedWriter”为已连接状态 // connected是PipedReader中定义的，用于表示“PipedReader和PipedWriter”是否已经连接 snk.connected = true; } // 将一个字符c写入“PipedWriter”中。 // 将c写入“PipedWriter”之后，它会将c传输给“PipedReader” public void write(int c) throws IOException { if (sink == null) { throw new IOException(&quot;Pipe not connected&quot;); } sink.receive(c); } // 将字符数组b写入“PipedWriter”中。 // 将数组b写入“PipedWriter”之后，它会将其传输给“PipedReader” public void write(char cbuf[], int off, int len) throws IOException { if (sink == null) { throw new IOException(&quot;Pipe not connected&quot;); } else if ((off | len | (off + len) | (cbuf.length - (off + len))) &lt; 0) { throw new IndexOutOfBoundsException(); } sink.receive(cbuf, off, len); } // 清空“PipedWriter”。 // 这里会调用“PipedReader”的notifyAll()； // 目的是让“PipedReader”放弃对当前资源的占有，让其它的等待线程(等待读取PipedWriter的线程)读取“PipedWriter”的值。 public synchronized void flush() throws IOException { if (sink != null) { if (sink.closedByReader || closed) { throw new IOException(&quot;Pipe closed&quot;); } synchronized (sink) { sink.notifyAll(); } } } // 关闭“PipedWriter”。 // 关闭之后，会调用receivedLast()通知“PipedReader”它已经关闭。 public void close() throws IOException { closed = true; if (sink != null) { sink.receivedLast(); } } } 2.2 PipedReader 源码(基于jdk1.7.40)package java.io; public class PipedReader extends Reader { // “PipedWriter”是否关闭的标记 boolean closedByWriter = false; // “PipedReader”是否关闭的标记 boolean closedByReader = false; // “PipedReader”与“PipedWriter”是否连接的标记 // 它在PipedWriter的connect()连接函数中被设置为true boolean connected = false; Thread readSide; // 读取“管道”数据的线程 Thread writeSide; // 向“管道”写入数据的线程 // “管道”的默认大小 private static final int DEFAULT_PIPE_SIZE = 1024; // 缓冲区 char buffer[]; //下一个写入字符的位置。in==out代表满，说明“写入的数据”全部被读取了。 int in = -1; //下一个读取字符的位置。in==out代表满，说明“写入的数据”全部被读取了。 int out = 0; // 构造函数：指定与“PipedReader”关联的“PipedWriter” public PipedReader(PipedWriter src) throws IOException { this(src, DEFAULT_PIPE_SIZE); } // 构造函数：指定与“PipedReader”关联的“PipedWriter”，以及“缓冲区大小” public PipedReader(PipedWriter src, int pipeSize) throws IOException { initPipe(pipeSize); connect(src); } // 构造函数：默认缓冲区大小是1024字符 public PipedReader() { initPipe(DEFAULT_PIPE_SIZE); } // 构造函数：指定缓冲区大小是pipeSize public PipedReader(int pipeSize) { initPipe(pipeSize); } // 初始化“管道”：新建缓冲区大小 private void initPipe(int pipeSize) { if (pipeSize &lt;= 0) { throw new IllegalArgumentException(&quot;Pipe size &lt;= 0&quot;); } buffer = new char[pipeSize]; } // 将“PipedReader”和“PipedWriter”绑定。 // 实际上，这里调用的是PipedWriter的connect()函数 public void connect(PipedWriter src) throws IOException { src.connect(this); } // 接收int类型的数据b。 // 它只会在PipedWriter的write(int b)中会被调用 synchronized void receive(int c) throws IOException { // 检查管道状态 if (!connected) { throw new IOException(&quot;Pipe not connected&quot;); } else if (closedByWriter || closedByReader) { throw new IOException(&quot;Pipe closed&quot;); } else if (readSide != null &amp;&amp; !readSide.isAlive()) { throw new IOException(&quot;Read end dead&quot;); } // 获取“写入管道”的线程 writeSide = Thread.currentThread(); // 如果“管道中被读取的数据，等于写入管道的数据”时， // 则每隔1000ms检查“管道状态”，并唤醒管道操作：若有“读取管道数据线程被阻塞”，则唤醒该线程。 while (in == out) { if ((readSide != null) &amp;&amp; !readSide.isAlive()) { throw new IOException(&quot;Pipe broken&quot;); } /* full: kick any waiting readers */ notifyAll(); try { wait(1000); } catch (InterruptedException ex) { throw new java.io.InterruptedIOException(); } } if (in &lt; 0) { in = 0; out = 0; } buffer[in++] = (char) c; if (in &gt;= buffer.length) { in = 0; } } // 接收字符数组b。 synchronized void receive(char c[], int off, int len) throws IOException { while (--len &gt;= 0) { receive(c[off++]); } } // 当PipedWriter被关闭时，被调用 synchronized void receivedLast() { closedByWriter = true; notifyAll(); } // 从管道(的缓冲)中读取一个字符，并将其转换成int类型 public synchronized int read() throws IOException { if (!connected) { throw new IOException(&quot;Pipe not connected&quot;); } else if (closedByReader) { throw new IOException(&quot;Pipe closed&quot;); } else if (writeSide != null &amp;&amp; !writeSide.isAlive() &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) { throw new IOException(&quot;Write end dead&quot;); } readSide = Thread.currentThread(); int trials = 2; while (in &lt; 0) { if (closedByWriter) { /* closed by writer, return EOF */ return -1; } if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) { throw new IOException(&quot;Pipe broken&quot;); } /* might be a writer waiting */ notifyAll(); try { wait(1000); } catch (InterruptedException ex) { throw new java.io.InterruptedIOException(); } } int ret = buffer[out++]; if (out &gt;= buffer.length) { out = 0; } if (in == out) { /* now empty */ in = -1; } return ret; } // 从管道(的缓冲)中读取数据，并将其存入到数组b中 public synchronized int read(char cbuf[], int off, int len) throws IOException { if (!connected) { throw new IOException(&quot;Pipe not connected&quot;); } else if (closedByReader) { throw new IOException(&quot;Pipe closed&quot;); } else if (writeSide != null &amp;&amp; !writeSide.isAlive() &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) { throw new IOException(&quot;Write end dead&quot;); } if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) || ((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } /* possibly wait on the first character */ int c = read(); if (c &lt; 0) { return -1; } cbuf[off] = (char)c; int rlen = 1; while ((in &gt;= 0) &amp;&amp; (--len &gt; 0)) { cbuf[off + rlen] = buffer[out++]; rlen++; if (out &gt;= buffer.length) { out = 0; } if (in == out) { /* now empty */ in = -1; } } return rlen; } // 是否能从管道中读取下一个数据 public synchronized boolean ready() throws IOException { if (!connected) { throw new IOException(&quot;Pipe not connected&quot;); } else if (closedByReader) { throw new IOException(&quot;Pipe closed&quot;); } else if (writeSide != null &amp;&amp; !writeSide.isAlive() &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) { throw new IOException(&quot;Write end dead&quot;); } if (in &lt; 0) { return false; } else { return true; } } // 关闭PipedReader public void close() throws IOException { in = -1; closedByReader = true; } } 3. 示例下面，我们看看多线程中通过PipedWriter和PipedReader通信的例子。例子中包括3个类：Receiver.java, Sender.java 和 PipeTest.java Receiver.java的代码如下： import java.io.IOException; import java.io.PipedReader; @SuppressWarnings(&quot;all&quot;) /** * 接收者线程 */ public class Receiver extends Thread { // 管道输入流对象。 // 它和“管道输出流(PipedWriter)”对象绑定， // 从而可以接收“管道输出流”的数据，再让用户读取。 private PipedReader in = new PipedReader(); // 获得“管道输入流对象” public PipedReader getReader(){ return in; } @Override public void run(){ readMessageOnce() ; //readMessageContinued() ; } // 从“管道输入流”中读取1次数据 public void readMessageOnce(){ // 虽然buf的大小是2048个字符，但最多只会从“管道输入流”中读取1024个字符。 // 因为，“管道输入流”的缓冲区大小默认只有1024个字符。 char[] buf = new char[2048]; try { int len = in.read(buf); System.out.println(new String(buf,0,len)); in.close(); } catch (IOException e) { e.printStackTrace(); } } // 从“管道输入流”读取&gt;1024个字符时，就停止读取 public void readMessageContinued(){ int total=0; while(true) { char[] buf = new char[1024]; try { int len = in.read(buf); total += len; System.out.println(new String(buf,0,len)); // 若读取的字符总数&gt;1024，则退出循环。 if (total &gt; 1024) break; } catch (IOException e) { e.printStackTrace(); } } try { in.close(); } catch (IOException e) { e.printStackTrace(); } } } Sender.java的代码如下： import java.io.IOException; import java.io.PipedWriter; @SuppressWarnings(&quot;all&quot;) /** * 发送者线程 */ public class Sender extends Thread { // 管道输出流对象。 // 它和“管道输入流(PipedReader)”对象绑定， // 从而可以将数据发送给“管道输入流”的数据，然后用户可以从“管道输入流”读取数据。 private PipedWriter out = new PipedWriter(); // 获得“管道输出流”对象 public PipedWriter getWriter(){ return out; } @Override public void run(){ writeShortMessage(); //writeLongMessage(); } // 向“管道输出流”中写入一则较简短的消息：&quot;this is a short message&quot; private void writeShortMessage() { String strInfo = &quot;this is a short message&quot; ; try { out.write(strInfo.toCharArray()); out.close(); } catch (IOException e) { e.printStackTrace(); } } // 向“管道输出流”中写入一则较长的消息 private void writeLongMessage() { StringBuilder sb = new StringBuilder(); // 通过for循环写入1020个字符 for (int i=0; i&lt;102; i++) sb.append(&quot;0123456789&quot;); // 再写入26个字符。 sb.append(&quot;abcdefghijklmnopqrstuvwxyz&quot;); // str的总长度是1020+26=1046个字符 String str = sb.toString(); try { // 将1046个字符写入到“管道输出流”中 out.write(str); out.close(); } catch (IOException e) { e.printStackTrace(); } } } PipeTest.java的代码如下： import java.io.PipedReader; import java.io.PipedWriter; import java.io.IOException; @SuppressWarnings(&quot;all&quot;) /** * 管道输入流和管道输出流的交互程序 */ public class PipeTest { public static void main(String[] args) { Sender t1 = new Sender(); Receiver t2 = new Receiver(); PipedWriter out = t1.getWriter(); PipedReader in = t2.getReader(); try { //管道连接。下面2句话的本质是一样。 //out.connect(in); in.connect(out); /** * Thread类的START方法： * 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 * 结果是两个线程并发地运行；当前线程（从调用返回给 start 方法）和另一个线程（执行其 run 方法）。 * 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 */ t1.start(); t2.start(); } catch (IOException e) { e.printStackTrace(); } } } 运行结果： this is a short message 结果说明：(01) in.connect(out);它的作用是将“管道输入流”和“管道输出流”关联起来。查看PipedWriter.java和PipedReader.java中connect()的源码；我们知道 out.connect(in); 等价于 in.connect(out); (02) t1.start(); // 启动“Sender”线程 t2.start(); // 启动“Receiver”线程 先查看Sender.java的源码，线程启动后执行run()函数；在Sender.java的run()中，调用writeShortMessage();writeShortMessage();的作用就是向“管道输出流”中写入数据”this is a short message” ；这条数据会被“管道输入流”接收到。下面看看这是如何实现的。先看write(char char的源码。PipedWriter.java继承于Writer.java；Writer.java中write(char c[])的源码如下： public void write(char cbuf[]) throws IOException { write(cbuf, 0, cbuf.length); } 实际上write(char c[])是调用的PipedWriter.java中的write(char c[], int off, int len)函数。查看write(char c[], int off, int len)的源码，我们发现：它会调用 sink.receive(cbuf, off, len); 进一步查看receive(char c[], int off, int len)的定义，我们知道sink.receive(cbuf, off, len)的作用就是：将“管道输出流”中的数据保存到“管道输入流”的缓冲中。而“管道输入流”的缓冲区buffer的默认大小是1024个字符。 至此，我们知道：t1.start()启动Sender线程，而Sender线程会将数据”this is a short message”写入到“管道输出流”；而“管道输出流”又会将该数据传输给“管道输入流”，即而保存在“管道输入流”的缓冲中。 接下来，我们看看“用户如何从‘管道输入流’的缓冲中读取数据”。这实际上就是Receiver线程的动作。t2.start() 会启动Receiver线程，从而执行Receiver.java的run()函数。查看Receiver.java的源码，我们知道run()调用了readMessageOnce()。而readMessageOnce()就是调用in.read(buf)从“管道输入流in”中读取数据，并保存到buf中。通过上面的分析，我们已经知道“管道输入流in”的缓冲中的数据是”this is a short message”；因此，buf的数据就是”this is a short message”。 为了加深对管道的理解。我们接着进行下面两个小试验。 试验一：修改Sender.java 将 public void run(){ writeShortMessage(); //writeLongMessage(); } 修改为 public void run(){ //writeShortMessage(); writeLongMessage(); } 运行程序。运行结果如下： img 从中，我们看出，程序运行出错！抛出异常 java.io.IOException: Pipe closed 为什么会这样呢？ 我分析一下程序流程。(01) 在PipeTest中，通过in.connect(out)将输入和输出管道连接起来；然后，启动两个线程。t1.start()启动了线程Sender，t2.start()启动了线程Receiver。(02) Sender线程启动后，通过writeLongMessage()写入数据到“输出管道”，out.write(str.toCharArray())共写入了1046个字符。而根据PipedWriter的源码，PipedWriter的write()函数会调用PipedReader的receive()函数。而观察PipedReader的receive()函数，我们知道，PipedReader会将接受的数据存储缓冲区。仔细观察receive()函数，有如下代码： while (in == out) { if ((readSide != null) &amp;&amp; !readSide.isAlive()) { throw new IOException(&quot;Pipe broken&quot;); } /* full: kick any waiting readers */ notifyAll(); try { wait(1000); } catch (InterruptedException ex) { throw new java.io.InterruptedIOException(); } } 而in和out的初始值分别是in=-1, out=0；结合上面的while(in==out)。我们知道，它的含义就是，每往管道中写入一个字符，就达到了in==out这个条件。然后，就调用notifyAll()，唤醒“读取管道的线程”。 也就是，每往管道中写入一个字符，都会阻塞式的等待其它线程读取。然而，PipedReader的缓冲区的默认大小是1024！但是，此时要写入的数据却有1046！所以，一次性最多只能写入1024个字符。 (03) Receiver线程启动后，会调用readMessageOnce()读取管道输入流。读取1024个字符会，会调用close()关闭，管道。 由(02)和(03)的分析可知，Sender要往管道写入1046个字符。其中，前1024个字符(缓冲区容量是1024)能正常写入，并且每写入一个就读取一个。当写入1025个字符时，依然是依次的调用PipedWriter.java中的write()；然后，write()中调用PipedReader.java中的receive()；在PipedReader.java中，最终又会调用到receive(int c)函数。 而此时，管道输入流已经被关闭，也就是closedByReader为true，所以抛出throw new IOException(“Pipe closed”)。 我们对“试验一”继续进行修改，解决该问题。 试验二： 在“试验一”的基础上继续修改Receiver.java将 public void run(){ readMessageOnce() ; //readMessageContinued() ; } 修改为 public void run(){ //readMessageOnce() ; readMessageContinued() ; } 此时，程序能正常运行。运行结果为： 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 012345678901234567890123456789abcd efghijklmnopqrstuvwxyz","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列19之 CharArrayWriter详解","date":"2016-10-18T16:00:00.000Z","path":"2016/10/19/java-source-analysis-io-series/java io系列19之 CharArrayWriter详解/","text":"本章，我们学习CharArrayWriter。学习时，我们先对CharArrayWriter有个大致了解，然后深入了解一下它的源码，最后通过示例来掌握它的用法。 目录1. CharArrayWriter 介绍2. Writer和CharArrayWriter源码分析3. 示例代码 1. CharArrayWriter 介绍CharArrayReader 用于写入数据符，它继承于Writer。操作的数据是以字符为单位！ CharArrayWriter 函数列表 CharArrayWriter() CharArrayWriter(int initialSize) CharArrayWriter append(CharSequence csq, int start, int end) CharArrayWriter append(char c) CharArrayWriter append(CharSequence csq) void close() void flush() void reset() int size() char[] toCharArray() String toString() void write(char[] buffer, int offset, int len) void write(int oneChar) void write(String str, int offset, int count) void writeTo(Writer out) 2. Writer和CharArrayWriter源码分析Writer是CharArrayWriter的父类，我们先看看Writer的源码，然后再学CharArrayWriter的源码。 2.1 Writer源码分析(基于jdk1.7.40)package java.io; public abstract class Writer implements Appendable, Closeable, Flushable { private char[] writeBuffer; private final int writeBufferSize = 1024; protected Object lock; protected Writer() { this.lock = this; } protected Writer(Object lock) { if (lock == null) { throw new NullPointerException(); } this.lock = lock; } public void write(int c) throws IOException { synchronized (lock) { if (writeBuffer == null){ writeBuffer = new char[writeBufferSize]; } writeBuffer[0] = (char) c; write(writeBuffer, 0, 1); } } public void write(char cbuf[]) throws IOException { write(cbuf, 0, cbuf.length); } abstract public void write(char cbuf[], int off, int len) throws IOException; public void write(String str) throws IOException { write(str, 0, str.length()); } public void write(String str, int off, int len) throws IOException { synchronized (lock) { char cbuf[]; if (len &lt;= writeBufferSize) { if (writeBuffer == null) { writeBuffer = new char[writeBufferSize]; } cbuf = writeBuffer; } else { // Don&apos;t permanently allocate very large buffers. cbuf = new char[len]; } str.getChars(off, (off + len), cbuf, 0); write(cbuf, 0, len); } } public Writer append(CharSequence csq) throws IOException { if (csq == null) write(&quot;null&quot;); else write(csq.toString()); return this; } public Writer append(CharSequence csq, int start, int end) throws IOException { CharSequence cs = (csq == null ? &quot;null&quot; : csq); write(cs.subSequence(start, end).toString()); return this; } public Writer append(char c) throws IOException { write(c); return this; } abstract public void flush() throws IOException; abstract public void close() throws IOException; } 2.2 CharArrayWriter 源码分析(基于jdk1.7.40)package java.io; import java.util.Arrays; public class CharArrayWriter extends Writer { // 字符数组缓冲 protected char buf[]; // 下一个字符的写入位置 protected int count; // 构造函数：默认缓冲区大小是32 public CharArrayWriter() { this(32); } // 构造函数：指定缓冲区大小是initialSize public CharArrayWriter(int initialSize) { if (initialSize &lt; 0) { throw new IllegalArgumentException(&quot;Negative initial size: &quot; + initialSize); } buf = new char[initialSize]; } // 写入一个字符c到CharArrayWriter中 public void write(int c) { synchronized (lock) { int newcount = count + 1; if (newcount &gt; buf.length) { buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount)); } buf[count] = (char)c; count = newcount; } } // 写入字符数组c到CharArrayWriter中。off是“字符数组b中的起始写入位置”，len是写入的长度 public void write(char c[], int off, int len) { if ((off &lt; 0) || (off &gt; c.length) || (len &lt; 0) || ((off + len) &gt; c.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } synchronized (lock) { int newcount = count + len; if (newcount &gt; buf.length) { buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount)); } System.arraycopy(c, off, buf, count, len); count = newcount; } } // 写入字符串str到CharArrayWriter中。off是“字符串的起始写入位置”，len是写入的长度 public void write(String str, int off, int len) { synchronized (lock) { int newcount = count + len; if (newcount &gt; buf.length) { buf = Arrays.copyOf(buf, Math.max(buf.length &lt;&lt; 1, newcount)); } str.getChars(off, off + len, buf, count); count = newcount; } } // 将CharArrayWriter写入到“Writer对象out”中 public void writeTo(Writer out) throws IOException { synchronized (lock) { out.write(buf, 0, count); } } // 将csq写入到CharArrayWriter中 // 注意：该函数返回CharArrayWriter对象 public CharArrayWriter append(CharSequence csq) { String s = (csq == null ? &quot;null&quot; : csq.toString()); write(s, 0, s.length()); return this; } // 将csq从start开始(包括)到end结束(不包括)的数据，写入到CharArrayWriter中。 // 注意：该函数返回CharArrayWriter对象！ public CharArrayWriter append(CharSequence csq, int start, int end) { String s = (csq == null ? &quot;null&quot; : csq).subSequence(start, end).toString(); write(s, 0, s.length()); return this; } // 将字符c追加到CharArrayWriter中！ // 注意：它与write(int c)的区别。append(char c)会返回CharArrayWriter对象。 public CharArrayWriter append(char c) { write(c); return this; } // 重置 public void reset() { count = 0; } // 将CharArrayWriter的全部数据对应的char[]返回 public char toCharArray()[] { synchronized (lock) { return Arrays.copyOf(buf, count); } } // 返回CharArrayWriter的大小 public int size() { return count; } public String toString() { synchronized (lock) { return new String(buf, 0, count); } } public void flush() { } public void close() { } } 说明： CharArrayWriter实际上是将数据写入到“字符数组”中去。(01) 通过CharArrayWriter()创建的CharArrayWriter对应的字符数组大小是32。(02) 通过CharArrayWriter(int size) 创建的CharArrayWriter对应的字符数组大小是size。(03) write(int oneChar)的作用将int类型的oneChar换成char类型，然后写入到CharArrayWriter中。(04) write(char[] buffer, int offset, int len) 是将字符数组buffer写入到输出流中，offset是从buffer中读取数据的起始偏移位置，len是读取的长度。(05) write(String str, int offset, int count) 是将字符串str写入到输出流中，offset是从str中读取数据的起始位置，count是读取的长度。(06) append(char c)的作用将char类型的c写入到CharArrayWriter中，然后返回CharArrayWriter对象。&nbsp;&nbsp;&nbsp;&nbsp; 注意：append(char c)与write(int c)都是将单个字符写入到CharArrayWriter中。它们的区别是，append(char c)会返回CharArrayWriter对象，但是write(int c)返回void。(07) append(CharSequence csq, int start, int end)的作用将csq从start开始(包括)到end结束(不包括)的数据，写入到CharArrayWriter中。&nbsp;&nbsp;&nbsp;&nbsp; 注意：该函数返回CharArrayWriter对象！(08) append(CharSequence csq)的作用将csq写入到CharArrayWriter中。&nbsp;&nbsp;&nbsp;&nbsp; 注意：该函数返回CharArrayWriter对象！(09) writeTo(OutputStream out) 将该“字符数组输出流”的数据全部写入到“输出流out”中。 3. 示例代码关于CharArrayWriter中API的详细用法，参考示例代码(CharArrayWriterTest.java)： import java.io.CharArrayReader; import java.io.CharArrayWriter; import java.io.IOException; /** * CharArrayWriter 测试程序 * * @author skywang */ public class CharArrayWriterTest { private static final int LEN = 5; // 对应英文字母“abcdefghijklmnopqrstuvwxyz” private static final char[] ArrayLetters = new char[] {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;}; public static void main(String[] args) { tesCharArrayWriter() ; } /** * CharArrayWriter的API测试函数 */ private static void tesCharArrayWriter() { try { // 创建CharArrayWriter字符流 CharArrayWriter caw = new CharArrayWriter(); // 写入“A”个字符 caw.write(&apos;A&apos;); // 写入字符串“BC”个字符 caw.write(&quot;BC&quot;); //System.out.printf(&quot;caw=%s\\n&quot;, caw); // 将ArrayLetters数组中从“3”开始的后5个字符(defgh)写入到caw中。 caw.write(ArrayLetters, 3, 5); //System.out.printf(&quot;caw=%s\\n&quot;, caw); // (01) 写入字符0 // (02) 然后接着写入“123456789” // (03) 再接着写入ArrayLetters中第8-12个字符(ijkl) caw.append(&apos;0&apos;).append(&quot;123456789&quot;).append(String.valueOf(ArrayLetters), 8, 12); System.out.printf(&quot;caw=%s\\n&quot;, caw); // 计算长度 int size = caw.size(); System.out.printf(&quot;size=%s\\n&quot;, size); // 转换成byte[]数组 char[] buf = caw.toCharArray(); System.out.printf(&quot;buf=%s\\n&quot;, String.valueOf(buf)); // 将caw写入到另一个输出流中 CharArrayWriter caw2 = new CharArrayWriter(); caw.writeTo(caw2); System.out.printf(&quot;caw2=%s\\n&quot;, caw2); } catch (IOException e) { e.printStackTrace(); } } } 运行结果： caw=ABCdefgh0123456789ijkl size=22 buf=ABCdefgh0123456789ijkl caw2=ABCdefgh0123456789ijkl","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列18之 CharArrayReader详解","date":"2016-10-17T16:00:00.000Z","path":"2016/10/18/java-source-analysis-io-series/java io系列18之 CharArrayReader详解/","text":"从本章开始，我们开始对“字符流”进行学习。首先，要学习的是CharArrayReader。学习时，我们先对CharArrayReader有个大致了解，然后深入了解一下它的源码，最后通过示例来掌握它的用法。 目录1. CharArrayReader 介绍2. Reader和CharArrayReader源码分析3. 示例代码 1. CharArrayReader 介绍CharArrayReader 是字符数组输入流。它和ByteArrayInputStream类似，只不过ByteArrayInputStream是字节数组输入流，而CharArray是字符数组输入流。CharArrayReader 是用于读取字符数组，它继承于Reader。操作的数据是以字符为单位！ CharArrayReader 函数列表 CharArrayReader(char[] buf) CharArrayReader(char[] buf, int offset, int length) void close() void mark(int readLimit) boolean markSupported() int read() int read(char[] buffer, int offset, int len) boolean ready() void reset() long skip(long charCount) 2. Reader和CharArrayReader源码分析Reader是CharArrayReader的父类，我们先看看Reader的源码，然后再学CharArrayReader的源码。 2.1 Reader源码分析(基于jdk1.7.40)package java.io; public abstract class Reader implements Readable, Closeable { protected Object lock; protected Reader() { this.lock = this; } protected Reader(Object lock) { if (lock == null) { throw new NullPointerException(); } this.lock = lock; } public int read(java.nio.CharBuffer target) throws IOException { int len = target.remaining(); char[] cbuf = new char[len]; int n = read(cbuf, 0, len); if (n &gt; 0) target.put(cbuf, 0, n); return n; } public int read() throws IOException { char cb[] = new char[1]; if (read(cb, 0, 1) == -1) return -1; else return cb[0]; } public int read(char cbuf[]) throws IOException { return read(cbuf, 0, cbuf.length); } abstract public int read(char cbuf[], int off, int len) throws IOException; private static final int maxSkipBufferSize = 8192; private char skipBuffer[] = null; public long skip(long n) throws IOException { if (n &lt; 0L) throw new IllegalArgumentException(&quot;skip value is negative&quot;); int nn = (int) Math.min(n, maxSkipBufferSize); synchronized (lock) { if ((skipBuffer == null) || (skipBuffer.length &lt; nn)) skipBuffer = new char[nn]; long r = n; while (r &gt; 0) { int nc = read(skipBuffer, 0, (int)Math.min(r, nn)); if (nc == -1) break; r -= nc; } return n - r; } } public boolean ready() throws IOException { return false; } public boolean markSupported() { return false; } public void mark(int readAheadLimit) throws IOException { throw new IOException(&quot;mark() not supported&quot;); } public void reset() throws IOException { throw new IOException(&quot;reset() not supported&quot;); } abstract public void close() throws IOException; } 2.2 CharArrayReader 源码分析(基于jdk1.7.40)package java.io; public class CharArrayReader extends Reader { // 字符数组缓冲 protected char buf[]; // 下一个被获取的字符的位置 protected int pos; // 被标记的位置 protected int markedPos = 0; // 字符缓冲的长度 protected int count; // 构造函数 public CharArrayReader(char buf[]) { this.buf = buf; this.pos = 0; this.count = buf.length; } // 构造函数 public CharArrayReader(char buf[], int offset, int length) { if ((offset &lt; 0) || (offset &gt; buf.length) || (length &lt; 0) || ((offset + length) &lt; 0)) { throw new IllegalArgumentException(); } this.buf = buf; this.pos = offset; this.count = Math.min(offset + length, buf.length); this.markedPos = offset; } // 判断“CharArrayReader是否有效”。 // 若字符缓冲为null，则认为其无效。 private void ensureOpen() throws IOException { if (buf == null) throw new IOException(&quot;Stream closed&quot;); } // 读取下一个字符。即返回字符缓冲区中下一位置的值。 // 注意：读取的是字符！ public int read() throws IOException { synchronized (lock) { ensureOpen(); if (pos &gt;= count) return -1; else return buf[pos++]; } } // 读取数据，并保存到字符数组b中从off开始的位置中，len是读取长度。 public int read(char b[], int off, int len) throws IOException { synchronized (lock) { ensureOpen(); if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } if (pos &gt;= count) { return -1; } if (pos + len &gt; count) { len = count - pos; } if (len &lt;= 0) { return 0; } System.arraycopy(buf, pos, b, off, len); pos += len; return len; } } // 跳过n个字符 public long skip(long n) throws IOException { synchronized (lock) { ensureOpen(); if (pos + n &gt; count) { n = count - pos; } if (n &lt; 0) { return 0; } pos += n; return n; } } // 判断“是否能读取下一个字符”。能的话，返回true。 public boolean ready() throws IOException { synchronized (lock) { ensureOpen(); return (count - pos) &gt; 0; } } public boolean markSupported() { return true; } // 保存当前位置。readAheadLimit在此处没有任何实际意义 // mark()必须和reset()配合使用才有意义！ public void mark(int readAheadLimit) throws IOException { synchronized (lock) { ensureOpen(); markedPos = pos; } } // 重置“下一个读取位置”为“mark所标记的位置” public void reset() throws IOException { synchronized (lock) { ensureOpen(); pos = markedPos; } } public void close() { buf = null; } } 说明：CharArrayReader实际上是通过“字符数组”去保存数据。 (01) 通过 CharArrayReader(char[] buf) 或 CharArrayReader(char[] buf, int offset, int length) ，我们可以根据buf数组来创建CharArrayReader对象。(02) read()的作用是从CharArrayReader中“读取下一个字符”。(03) read(char[] buffer, int offset, int len)的作用是从CharArrayReader读取字符数据，并写入到字符数组buffer中。offset是将字符写入到buffer的起始位置，len是写入的字符的长度。(04) markSupported()是判断CharArrayReader是否支持“标记功能”。它始终返回true。(05) mark(int readlimit)的作用是记录标记位置。记录标记位置之后，某一时刻调用reset()则将“CharArrayReader下一个被读取的位置”重置到“mark(int readlimit)所标记的位置”；也就是说，reset()之后再读取CharArrayReader时，是从mark(int readlimit)所标记的位置开始读取。 3. 示例代码关于CharArrayReader中API的详细用法，参考示例代码(CharArrayReaderTest.java)： /** * CharArrayReader 演示程序 * * @author skywang */ import java.io.CharArrayReader; import java.io.CharArrayWriter; import java.io.IOException; public class CharArrayReaderTest { private static final int LEN = 5; // 对应英文字母“abcdefghijklmnopqrstuvwxyz” private static final char[] ArrayLetters = new char[] {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;}; public static void main(String[] args) { tesCharArrayReader() ; } /** * CharArrayReader的API测试函数 */ private static void tesCharArrayReader() { try { // 创建CharArrayReader字符流，内容是ArrayLetters数组 CharArrayReader car = new CharArrayReader(ArrayLetters); // 从字符数组流中读取5个字符 for (int i=0; i&lt;LEN; i++) { // 若能继续读取下一个字符，则读取下一个字符 if (car.ready() == true) { // 读取“字符流的下一个字符” char tmp = (char)car.read(); System.out.printf(&quot;%d : %c\\n&quot;, i, tmp); } } // 若“该字符流”不支持标记功能，则直接退出 if (!car.markSupported()) { System.out.println(&quot;make not supported!&quot;); return ; } // 标记“字符流中下一个被读取的位置”。即--标记“f”，因为因为前面已经读取了5个字符，所以下一个被读取的位置是第6个字符” // (01), CharArrayReader类的mark(0)函数中的“参数0”是没有实际意义的。 // (02), mark()与reset()是配套的，reset()会将“字符流中下一个被读取的位置”重置为“mark()中所保存的位置” car.mark(0); // 跳过5个字符。跳过5个字符后，字符流中下一个被读取的值应该是“k”。 car.skip(5); // 从字符流中读取5个数据。即读取“klmno” char[] buf = new char[LEN]; car.read(buf, 0, LEN); System.out.printf(&quot;buf=%s\\n&quot;, String.valueOf(buf)); // 重置“字符流”：即，将“字符流中下一个被读取的位置”重置到“mark()所标记的位置”，即f。 car.reset(); // 从“重置后的字符流”中读取5个字符到buf中。即读取“fghij” car.read(buf, 0, LEN); System.out.printf(&quot;buf=%s\\n&quot;, String.valueOf(buf)); } catch (IOException e) { e.printStackTrace(); } } } 运行结果： 0 : a 1 : b 2 : c 3 : d 4 : e buf=klmno buf=fghij","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列17之 System.out.println详解","date":"2016-10-16T16:00:00.000Z","path":"2016/10/17/java-source-analysis-io-series/java io系列17之 System.out.println详解/","text":"我们初学java的第一个程序是”hello world” public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); } } 上面程序到底是怎么在屏幕上输出“hello world”的呢？这就是本来要讲解的内容，即System.out.println(“hello world”)的原理。 我们先看看System.out.println的流程。先看看System.java中out的定义，源码如下： public final class System { ... public final static PrintStream out = null; ... } 从中，我们发现，(01) out是System.java的静态变量。(02) 而且out是PrintStream对象，PrintStream.java中有许多重载的println()方法。 OK，我们知道了out是PrintStream对象。接下来，看它是如何被初始化的，它是怎么和屏幕输出关联的？ 我们还是一步步来分析，首先看看System.java的initializeSystemClass()方法。 initializeSystemClass()的源码如下 private static void initializeSystemClass() { props = new Properties(); initProperties(props); // initialized by the VM sun.misc.VM.saveAndRemoveProperties(props); lineSeparator = props.getProperty(&quot;line.separator&quot;); sun.misc.Version.init(); FileInputStream fdIn = new FileInputStream(FileDescriptor.in); FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out); FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err); setIn0(new BufferedInputStream(fdIn)); setOut0(new PrintStream(new BufferedOutputStream(fdOut, 128), true)); setErr0(new PrintStream(new BufferedOutputStream(fdErr, 128), true)); loadLibrary(&quot;zip&quot;); Terminator.setup(); sun.misc.VM.initializeOSEnvironment(); Thread current = Thread.currentThread(); current.getThreadGroup().add(current); setJavaLangAccess(); sun.misc.VM.booted(); } 我们只需要关注下面的代码部分：即 FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out); ... setOut0(new PrintStream(new BufferedOutputStream(fdOut, 128), true)); 将这两句话细分，可以划分为以下几步：第1步 FileDescriptor fd = FileDescriptor.out;第2步 FileOutputStream fdOut = new FileOutputStream(fd);第3步 BufferedOutputStream bufOut = new BufferedOutputStream(fdOut, 128);第4步 PrintStream ps = new PrintStream(bufout, true);第5步 setOut0(ps); 说明：(01) 第1步，获取FileDescriptor.java中的静态成员out，out是一个FileDescriptor对象，它实际上是“标准输出(屏幕)”的标识符。关于FileDescriptor的详细介绍，可以参考博文“java io系列09之 FileDescriptor总结”。FileDescriptor.java中与FileDescriptor.out相关代码如下： public final class FileDescriptor { private int fd; public static final FileDescriptor out = new FileDescriptor(1); private FileDescriptor(int fd) { this.fd = fd; useCount = new AtomicInteger(); } ... } (02) 创建“标准输出(屏幕)”对应的“文件输出流”。(03) 创建“文件输出流”对应的“缓冲输出流”。目的是为“文件输出流”添加“缓冲”功能。(04) 创建“缓冲输出流”对应的“打印输出流”。目的是为“缓冲输出流”提供方便的打印接口，如print(), println(), printf()；使其能方便快捷的进行打印输出。(05) 执行setOut0(ps); 接下来，解析第5步的setOut0(ps)。查看System.java中setOut0()的声明，如下： private static native void setOut0(PrintStream out); 从中，我们发现setOut0()是一个native本地方法。通过openjdk，我们可以找到它对应的源码，如下： JNIEXPORT void JNICALL Java_java_lang_System_setOut0(JNIEnv *env, jclass cla, jobject stream) { jfieldID fid = (*env)-&gt;GetStaticFieldID(env,cla,&quot;out&quot;,&quot;Ljava/io/PrintStream;&quot;); if (fid == 0) return; (*env)-&gt;SetStaticObjectField(env,cla,fid,stream); } 说明：这是个JNI函数，我们来对它进行简单的分析。(01) 函数名 JNIEXPORT void JNICALL Java_java_lang_System_setOut0(JNIEnv *env, jclass cla, jobject stream) 这是JNI的静态注册方法，Java_java_lang_System_setOut0(JNIEnv *env, jclass cla, jobject stream)会和System.java中的setOut0(PrintStream out)关联；而且，参数stream 对应参数out。简单来说，我们调用setOut0()，实际上是调用的Java_java_lang_System_setOut0()。 (02) jfieldID fid = (*env)-&gt;GetStaticFieldID(env,cla,&quot;out&quot;,&quot;Ljava/io/PrintStream;&quot;); 这句话的作用是获取System.java的静态成员out的jfieldID，”Ljava/io/PrintStream;”是说明out是java.io.PrintStream对象。获取out的jfieldID的作用，是我们需要通过操作“out的jfielID”来改变out的值。 (03) (*env)-&gt;SetStaticObjectField(env,cla,fid,stream); 这句话的作用是，设置fid(fid就是out的jfieldID)对应的静态成员的值为stream。stream是我们传给Java_java_lang_System_setOut0()的参数，也就是传给setOut0的参数。 总结上面的内容。我们知道，setOut0(PrintStream ps)的作用，就是将ps设置为System.java的out静态变量。 前面，已经说过FileDescriptor.out就是机器的“标准输出(屏幕)”的文件标识符。我们可以通俗的将文件标识符就理解为，FileDescriptor.out就是代表的“标准输出”。因此，在initializeSystemClass()中，上面的5步就是将“FileDescriptor.out”封装了起来。封装后的System.in既有缓冲功能；又有便利的操作接口，如print(), println(), printf()。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列16之 PrintStream详解","date":"2016-10-15T16:00:00.000Z","path":"2016/10/16/java-source-analysis-io-series/java io系列16之 PrintStream详解/","text":"本章介绍PrintStream以及 它与DataOutputStream的区别。我们先对PrintStream有个大致认识，然后再深入学习它的源码，最后通过示例加深对它的了解。 目录1. PrintStream 介绍2. PrintStream 源码分析(基于jdk1.7.40)3. PrintStream和DataOutputStream异同点4. 示例代码 1. PrintStream 介绍PrintStream 是打印输出流，它继承于FilterOutputStream。 PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。另外，PrintStream 提供了自动flush 和 字符集设置功能。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。 PrintStream 函数列表 // 构造函数 // 将“输出流out”作为PrintStream的输出流，不会自动flush，并且采用默认字符集 // 所谓“自动flush”，就是每次执行print(), println(), write()函数，都会调用flush()函数； // 而“不自动flush”，则需要我们手动调用flush()接口。 PrintStream(OutputStream out) // 将“输出流out”作为PrintStream的输出流，自动flush，并且采用默认字符集。 PrintStream(OutputStream out, boolean autoFlush) // 将“输出流out”作为PrintStream的输出流，自动flush，采用charsetName字符集。 PrintStream(OutputStream out, boolean autoFlush, String charsetName) // 创建file对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用默认字符集。 PrintStream(File file) // 创建file对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用charsetName字符集。 PrintStream(File file, String charsetName) // 创建fileName对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用默认字符集。 PrintStream(String fileName) // 创建fileName对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用charsetName字符集。 PrintStream(String fileName, String charsetName) // 将“字符c”追加到“PrintStream输出流中” PrintStream append(char c) // 将“字符序列从start(包括)到end(不包括)的全部字符”追加到“PrintStream输出流中” PrintStream append(CharSequence charSequence, int start, int end) // 将“字符序列的全部字符”追加到“PrintStream输出流中” PrintStream append(CharSequence charSequence) // flush“PrintStream输出流缓冲中的数据”，并检查错误 boolean checkError() // 关闭“PrintStream输出流” synchronized void close() // flush“PrintStream输出流缓冲中的数据”。 // 例如，PrintStream装饰的是FileOutputStream，则调用flush时会将数据写入到文件中 synchronized void flush() // 根据“Locale值(区域属性)”来格式化数据 PrintStream format(Locale l, String format, Object... args) // 根据“默认的Locale值(区域属性)”来格式化数据 PrintStream format(String format, Object... args) // 将“float数据f对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(float f) // 将“double数据d对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(double d) // 将“字符串数据str”写入到“PrintStream输出流”中，print实际调用的是write函数 synchronized void print(String str) // 将“对象o对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(Object o) // 将“字符c对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(char c) // 将“字符数组chars对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(char[] chars) // 将“long型数据l对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(long l) // 将“int数据i对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(int i) // 将“boolean数据b对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 void print(boolean b) // 将“数据args”根据“Locale值(区域属性)”按照format格式化，并写入到“PrintStream输出流”中 PrintStream printf(Locale l, String format, Object... args) // 将“数据args”根据“默认Locale值(区域属性)”按照format格式化，并写入到“PrintStream输出流”中 PrintStream printf(String format, Object... args) // 将“换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println() // 将“float数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(float f) // 将“int数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(int i) // 将“long数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(long l) // 将“对象o对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(Object o) // 将“字符数组chars对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(char[] chars) // 将“字符串str+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 synchronized void println(String str) // 将“字符c对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(char c) // 将“double数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(double d) // 将“boolean数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 void println(boolean b) // 将数据oneByte写入到“PrintStream输出流”中。oneByte虽然是int类型，但实际只会写入一个字节 synchronized void write(int oneByte) // 将“buffer中从offset开始的length个字节”写入到“PrintStream输出流”中。 void write(byte[] buffer, int offset, int length) 注意：print()和println()都是将其中参数转换成字符串之后，再写入到输入流。 例如， print(0x61); 等价于 write(String.valueOf(0x61)); 上面语句是将字符串”97”写入到输出流。0x61对应十进制数是97。 write(0x61) 上面语句是将字符’a’写入到输出流。因为0x61对应的ASCII码的字母’a’。 查看下面的代码，我们能对这些函数有更清晰的认识！ 2. PrintStream 源码分析(基于jdk1.7.40)package java.io; import java.util.Formatter; import java.util.Locale; import java.nio.charset.Charset; import java.nio.charset.IllegalCharsetNameException; import java.nio.charset.UnsupportedCharsetException; public class PrintStream extends FilterOutputStream implements Appendable, Closeable { // 自动flush // 所谓“自动flush”，就是每次执行print(), println(), write()函数，都会调用flush()函数； // 而“不自动flush”，则需要我们手动调用flush()接口。 private final boolean autoFlush; // PrintStream是否右产生异常。当PrintStream有异常产生时，会被本身捕获，并设置trouble为true private boolean trouble = false; // 用于格式化的对象 private Formatter formatter; // BufferedWriter对象，用于实现“PrintStream支持字符集”。 // 因为PrintStream是OutputStream的子类，所以它本身不支持字符串； // 但是BufferedWriter支持字符集，因此可以通过OutputStreamWriter创建PrintStream对应的BufferedWriter对象，从而支持字符集。 private BufferedWriter textOut; private OutputStreamWriter charOut; private static &lt;T&gt; T requireNonNull(T obj, String message) { if (obj == null) throw new NullPointerException(message); return obj; } // 返回csn对应的字符集对象 private static Charset toCharset(String csn) throws UnsupportedEncodingException { requireNonNull(csn, &quot;charsetName&quot;); try { return Charset.forName(csn); } catch (IllegalCharsetNameException|UnsupportedCharsetException unused) { // UnsupportedEncodingException should be thrown throw new UnsupportedEncodingException(csn); } } // 将“输出流out”作为PrintStream的输出流，autoFlush的flush模式，并且采用默认字符集。 private PrintStream(boolean autoFlush, OutputStream out) { super(out); this.autoFlush = autoFlush; this.charOut = new OutputStreamWriter(this); this.textOut = new BufferedWriter(charOut); } // 将“输出流out”作为PrintStream的输出流，自动flush，采用charsetName字符集。 private PrintStream(boolean autoFlush, OutputStream out, Charset charset) { super(out); this.autoFlush = autoFlush; this.charOut = new OutputStreamWriter(this, charset); this.textOut = new BufferedWriter(charOut); } // 将“输出流out”作为PrintStream的输出流，自动flush，采用charsetName字符集。 private PrintStream(boolean autoFlush, Charset charset, OutputStream out) throws UnsupportedEncodingException { this(autoFlush, out, charset); } // 将“输出流out”作为PrintStream的输出流，不会自动flush，并且采用默认字符集 public PrintStream(OutputStream out) { this(out, false); } // 将“输出流out”作为PrintStream的输出流，自动flush，并且采用默认字符集。 public PrintStream(OutputStream out, boolean autoFlush) { this(autoFlush, requireNonNull(out, &quot;Null output stream&quot;)); } // 将“输出流out”作为PrintStream的输出流，自动flush，采用charsetName字符集。 public PrintStream(OutputStream out, boolean autoFlush, String encoding) throws UnsupportedEncodingException { this(autoFlush, requireNonNull(out, &quot;Null output stream&quot;), toCharset(encoding)); } // 创建fileName对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用默认字符集。 public PrintStream(String fileName) throws FileNotFoundException { this(false, new FileOutputStream(fileName)); } // 创建fileName对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用charsetName字符集。 public PrintStream(String fileName, String csn) throws FileNotFoundException, UnsupportedEncodingException { // ensure charset is checked before the file is opened this(false, toCharset(csn), new FileOutputStream(fileName)); } // 创建file对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用默认字符集。 public PrintStream(File file) throws FileNotFoundException { this(false, new FileOutputStream(file)); } // 创建file对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用csn字符集。 public PrintStream(File file, String csn) throws FileNotFoundException, UnsupportedEncodingException { // ensure charset is checked before the file is opened this(false, toCharset(csn), new FileOutputStream(file)); } private void ensureOpen() throws IOException { if (out == null) throw new IOException(&quot;Stream closed&quot;); } // flush“PrintStream输出流缓冲中的数据”。 // 例如，PrintStream装饰的是FileOutputStream，则调用flush时会将数据写入到文件中 public void flush() { synchronized (this) { try { ensureOpen(); out.flush(); } catch (IOException x) { trouble = true; } } } private boolean closing = false; /* To avoid recursive closing */ // 关闭PrintStream public void close() { synchronized (this) { if (! closing) { closing = true; try { textOut.close(); out.close(); } catch (IOException x) { trouble = true; } textOut = null; charOut = null; out = null; } } } // flush“PrintStream输出流缓冲中的数据”，并检查错误 public boolean checkError() { if (out != null) flush(); if (out instanceof java.io.PrintStream) { PrintStream ps = (PrintStream) out; return ps.checkError(); } return trouble; } protected void setError() { trouble = true; } protected void clearError() { trouble = false; } // 将数据b写入到“PrintStream输出流”中。b虽然是int类型，但实际只会写入一个字节 public void write(int b) { try { synchronized (this) { ensureOpen(); out.write(b); if ((b == &apos;\\n&apos;) &amp;&amp; autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“buf中从off开始的length个字节”写入到“PrintStream输出流”中。 public void write(byte buf[], int off, int len) { try { synchronized (this) { ensureOpen(); out.write(buf, off, len); if (autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“buf中的全部数据”写入到“PrintStream输出流”中。 private void write(char buf[]) { try { synchronized (this) { ensureOpen(); textOut.write(buf); textOut.flushBuffer(); charOut.flushBuffer(); if (autoFlush) { for (int i = 0; i &lt; buf.length; i++) if (buf[i] == &apos;\\n&apos;) out.flush(); } } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“字符串s”写入到“PrintStream输出流”中。 private void write(String s) { try { synchronized (this) { ensureOpen(); textOut.write(s); textOut.flushBuffer(); charOut.flushBuffer(); if (autoFlush &amp;&amp; (s.indexOf(&apos;\\n&apos;) &gt;= 0)) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“换行符”写入到“PrintStream输出流”中。 private void newLine() { try { synchronized (this) { ensureOpen(); textOut.newLine(); textOut.flushBuffer(); charOut.flushBuffer(); if (autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } // 将“boolean数据对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(boolean b) { write(b ? &quot;true&quot; : &quot;false&quot;); } // 将“字符c对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(char c) { write(String.valueOf(c)); } // 将“int数据i对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(int i) { write(String.valueOf(i)); } // 将“long型数据l对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(long l) { write(String.valueOf(l)); } // 将“float数据f对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(float f) { write(String.valueOf(f)); } // 将“double数据d对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(double d) { write(String.valueOf(d)); } // 将“字符数组s”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(char s[]) { write(s); } // 将“字符串数据s”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(String s) { if (s == null) { s = &quot;null&quot;; } write(s); } // 将“对象obj对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数 public void print(Object obj) { write(String.valueOf(obj)); } // 将“换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println() { newLine(); } // 将“boolean数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(boolean x) { synchronized (this) { print(x); newLine(); } } // 将“字符x对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(char x) { synchronized (this) { print(x); newLine(); } } // 将“int数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(int x) { synchronized (this) { print(x); newLine(); } } // 将“long数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(long x) { synchronized (this) { print(x); newLine(); } } // 将“float数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(float x) { synchronized (this) { print(x); newLine(); } } // 将“double数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(double x) { synchronized (this) { print(x); newLine(); } } // 将“字符数组x+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(char x[]) { synchronized (this) { print(x); newLine(); } } // 将“字符串x+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(String x) { synchronized (this) { print(x); newLine(); } } // 将“对象o对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数 public void println(Object x) { String s = String.valueOf(x); synchronized (this) { print(s); newLine(); } } // 将“数据args”根据“默认Locale值(区域属性)”按照format格式化，并写入到“PrintStream输出流”中 public PrintStream printf(String format, Object ... args) { return format(format, args); } // 将“数据args”根据“Locale值(区域属性)”按照format格式化，并写入到“PrintStream输出流”中 public PrintStream printf(Locale l, String format, Object ... args) { return format(l, format, args); } // 根据“默认的Locale值(区域属性)”来格式化数据 public PrintStream format(String format, Object ... args) { try { synchronized (this) { ensureOpen(); if ((formatter == null) || (formatter.locale() != Locale.getDefault())) formatter = new Formatter((Appendable) this); formatter.format(Locale.getDefault(), format, args); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } return this; } // 根据“Locale值(区域属性)”来格式化数据 public PrintStream format(Locale l, String format, Object ... args) { try { synchronized (this) { ensureOpen(); if ((formatter == null) || (formatter.locale() != l)) formatter = new Formatter(this, l); formatter.format(l, format, args); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } return this; } // 将“字符序列的全部字符”追加到“PrintStream输出流中” public PrintStream append(CharSequence csq) { if (csq == null) print(&quot;null&quot;); else print(csq.toString()); return this; } // 将“字符序列从start(包括)到end(不包括)的全部字符”追加到“PrintStream输出流中” public PrintStream append(CharSequence csq, int start, int end) { CharSequence cs = (csq == null ? &quot;null&quot; : csq); write(cs.subSequence(start, end).toString()); return this; } // 将“字符c”追加到“PrintStream输出流中” public PrintStream append(char c) { print(c); return this; } } 说明：PrintStream的源码比较简单，请上文的注释进行阅读。若有不明白的地方，建议先看看后面的PrintStream使用示例；待搞清它的作用和用法之后，再来阅读源码。 3. PrintStream和DataOutputStream异同点相同点 都是继承与FileOutputStream，用于包装其它输出流。 不同点 (01) PrintStream和DataOutputStream 都可以将数据格式化输出；但它们在“输出字符串”时的编码不同。 PrintStream是输出时采用的是用户指定的编码(创建PrintStream时指定的)，若没有指定，则采用系统默认的字符编码。而DataOutputStream则采用的是UTF-8。 关于UTF-8的字符编码可以参考“字符编码(ASCII，Unicode和UTF-8) 和 大小端” 关于DataOutputStream的更多内容，可以参考“java io系列15之 DataOutputStream(数据输出流)的认知、源码和示例” (02) 它们的写入数据时的异常处理机制不同。 DataOutputStream在通过write()向“输出流”中写入数据时，若产生IOException，会抛出。 而PrintStream在通过write()向“输出流”中写入数据时，若产生IOException，则会在write()中进行捕获处理；并设置trouble标记(用于表示产生了异常)为true。用户可以通过checkError()返回trouble值，从而检查输出流中是否产生了异常。 (03) 构造函数不同 DataOutputStream的构造函数只有一个：DataOutputStream(OutputStream out)。即它只支持以输出流out作为“DataOutputStream的输出流”。 而PrintStream的构造函数有许多：和DataOutputStream一样，支持以输出流out作为“PrintStream输出流”的构造函数；还支持以“File对象”或者“String类型的文件名对象”的构造函数。 而且，在PrintStream的构造函数中，能“指定字符集”和“是否支持自动flush()操作”。 (04) 目的不同 DataOutputStream的作用是装饰其它的输出流，它和DataInputStream配合使用：允许应用程序以与机器无关的方式从底层输入流中读写java数据类型。 而PrintStream的作用虽然也是装饰其他输出流，但是它的目的不是以与机器无关的方式从底层读写java数据类型；而是为其它输出流提供打印各种数据值表示形式，使其它输出流能方便的通过print(), println()或printf()等输出各种格式的数据。 4. 示例代码关于PrintStream中API的详细用法，参考示例代码(PrintStreamTest.java)： import java.io.PrintStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; /** * PrintStream 的示例程序 * * @author skywang */ public class PrintStreamTest { public static void main(String[] args) { // 下面3个函数的作用都是一样：都是将字母“abcde”写入到文件“file.txt”中。 // 任选一个执行即可！ testPrintStreamConstrutor1() ; //testPrintStreamConstrutor2() ; //testPrintStreamConstrutor3() ; // 测试write(), print(), println(), printf()等接口。 testPrintStreamAPIS() ; } /** * PrintStream(OutputStream out) 的测试函数 * * 函数的作用，就是将字母“abcde”写入到文件“file.txt”中 */ private static void testPrintStreamConstrutor1() { // 0x61对应ASCII码的字母&apos;a&apos;，0x62对应ASCII码的字母&apos;b&apos;, ... final byte[] arr={0x61, 0x62, 0x63, 0x64, 0x65 }; // abced try { // 创建文件“file.txt”的File对象 File file = new File(&quot;file.txt&quot;); // 创建文件对应FileOutputStream PrintStream out = new PrintStream( new FileOutputStream(file)); // 将“字节数组arr”全部写入到输出流中 out.write(arr); // 关闭输出流 out.close(); } catch (IOException e) { e.printStackTrace(); } } /** * PrintStream(File file) 的测试函数 * * 函数的作用，就是将字母“abcde”写入到文件“file.txt”中 */ private static void testPrintStreamConstrutor2() { final byte[] arr={0x61, 0x62, 0x63, 0x64, 0x65 }; try { File file = new File(&quot;file.txt&quot;); PrintStream out = new PrintStream(file); out.write(arr); out.close(); } catch (IOException e) { e.printStackTrace(); } } /** * PrintStream(String fileName) 的测试函数 * * 函数的作用，就是将字母“abcde”写入到文件“file.txt”中 */ private static void testPrintStreamConstrutor3() { final byte[] arr={0x61, 0x62, 0x63, 0x64, 0x65 }; try { PrintStream out = new PrintStream(&quot;file.txt&quot;); out.write(arr); out.close(); } catch (IOException e) { e.printStackTrace(); } } /** * 测试write(), print(), println(), printf()等接口。 */ private static void testPrintStreamAPIS() { // 0x61对应ASCII码的字母&apos;a&apos;，0x62对应ASCII码的字母&apos;b&apos;, ... final byte[] arr={0x61, 0x62, 0x63, 0x64, 0x65 }; // abced try { // 创建文件对应FileOutputStream PrintStream out = new PrintStream(&quot;other.txt&quot;); // 将字符串“hello PrintStream”+回车符，写入到输出流中 out.println(&quot;hello PrintStream&quot;); // 将0x41写入到输出流中 // 0x41对应ASCII码的字母&apos;A&apos;，也就是写入字符&apos;A&apos; out.write(0x41); // 将字符串&quot;65&quot;写入到输出流中。 // out.print(0x41); 等价于 out.write(String.valueOf(0x41)); out.print(0x41); // 将字符&apos;B&apos;追加到输出流中 out.append(&apos;B&apos;); // 将&quot;CDE is 5&quot; + 回车 写入到输出流中 String str = &quot;CDE&quot;; int num = 5; out.printf(&quot;%s is %d\\n&quot;, str, num); out.close(); } catch (IOException e) { e.printStackTrace(); } } } 运行上面的代码，会在源码所在目录生成两个文件“file.txt”和“other.txt”。 file.txt的内容如下： abcde other.txt的内容如下： hello PrintStream A65BCDE is 5","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列15之 DataOutputStream详解","date":"2016-10-14T16:00:00.000Z","path":"2016/10/15/java-source-analysis-io-series/java io系列15之 DataOutputStream详解/","text":"本章介绍DataOutputStream。我们先对DataOutputStream有个大致认识，然后再深入学习它的源码，最后通过示例加深对它的了解。 目录1. DataOutputStream 介绍2. DataOutputStream 源码分析(基于jdk1.7.40)3. 示例代码 1. DataOutputStream 介绍DataOutputStream 是数据输出流。它继承于FilterOutputStream。 DataOutputStream 是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。 2. DataOutputStream 源码分析(基于jdk1.7.40)package java.io; public class DataOutputStream extends FilterOutputStream implements DataOutput { // “数据输出流”的字节数 protected int written; // “数据输出流”对应的字节数组 private byte[] bytearr = null; // 构造函数 public DataOutputStream(OutputStream out) { super(out); } // 增加“输出值” private void incCount(int value) { int temp = written + value; if (temp &lt; 0) { temp = Integer.MAX_VALUE; } written = temp; } // 将int类型的值写入到“数据输出流”中 public synchronized void write(int b) throws IOException { out.write(b); incCount(1); } // 将字节数组b从off开始的len个字节，都写入到“数据输出流”中 public synchronized void write(byte b[], int off, int len) throws IOException { out.write(b, off, len); incCount(len); } // 清空缓冲，即将缓冲中的数据都写入到输出流中 public void flush() throws IOException { out.flush(); } // 将boolean类型的值写入到“数据输出流”中 public final void writeBoolean(boolean v) throws IOException { out.write(v ? 1 : 0); incCount(1); } // 将byte类型的值写入到“数据输出流”中 public final void writeByte(int v) throws IOException { out.write(v); incCount(1); } // 将short类型的值写入到“数据输出流”中 // 注意：short占2个字节 public final void writeShort(int v) throws IOException { // 写入 short高8位 对应的字节 out.write((v &gt;&gt;&gt; 8) &amp; 0xFF); // 写入 short低8位 对应的字节 out.write((v &gt;&gt;&gt; 0) &amp; 0xFF); incCount(2); } // 将char类型的值写入到“数据输出流”中 // 注意：char占2个字节 public final void writeChar(int v) throws IOException { // 写入 char高8位 对应的字节 out.write((v &gt;&gt;&gt; 8) &amp; 0xFF); // 写入 char低8位 对应的字节 out.write((v &gt;&gt;&gt; 0) &amp; 0xFF); incCount(2); } // 将int类型的值写入到“数据输出流”中 // 注意：int占4个字节 public final void writeInt(int v) throws IOException { out.write((v &gt;&gt;&gt; 24) &amp; 0xFF); out.write((v &gt;&gt;&gt; 16) &amp; 0xFF); out.write((v &gt;&gt;&gt; 8) &amp; 0xFF); out.write((v &gt;&gt;&gt; 0) &amp; 0xFF); incCount(4); } private byte writeBuffer[] = new byte[8]; // 将long类型的值写入到“数据输出流”中 // 注意：long占8个字节 public final void writeLong(long v) throws IOException { writeBuffer[0] = (byte)(v &gt;&gt;&gt; 56); writeBuffer[1] = (byte)(v &gt;&gt;&gt; 48); writeBuffer[2] = (byte)(v &gt;&gt;&gt; 40); writeBuffer[3] = (byte)(v &gt;&gt;&gt; 32); writeBuffer[4] = (byte)(v &gt;&gt;&gt; 24); writeBuffer[5] = (byte)(v &gt;&gt;&gt; 16); writeBuffer[6] = (byte)(v &gt;&gt;&gt; 8); writeBuffer[7] = (byte)(v &gt;&gt;&gt; 0); out.write(writeBuffer, 0, 8); incCount(8); } // 将float类型的值写入到“数据输出流”中 public final void writeFloat(float v) throws IOException { writeInt(Float.floatToIntBits(v)); } // 将double类型的值写入到“数据输出流”中 public final void writeDouble(double v) throws IOException { writeLong(Double.doubleToLongBits(v)); } // 将String类型的值写入到“数据输出流”中 // 实际写入时，是将String对应的每个字符转换成byte数据后写入输出流中。 public final void writeBytes(String s) throws IOException { int len = s.length(); for (int i = 0 ; i &lt; len ; i++) { out.write((byte)s.charAt(i)); } incCount(len); } // 将String类型的值写入到“数据输出流”中 // 实际写入时，是将String对应的每个字符转换成char数据后写入输出流中。 public final void writeChars(String s) throws IOException { int len = s.length(); for (int i = 0 ; i &lt; len ; i++) { int v = s.charAt(i); out.write((v &gt;&gt;&gt; 8) &amp; 0xFF); out.write((v &gt;&gt;&gt; 0) &amp; 0xFF); } incCount(len * 2); } // 将UTF-8类型的值写入到“数据输出流”中 public final void writeUTF(String str) throws IOException { writeUTF(str, this); } // 将String数据以UTF-8类型的形式写入到“输出流out”中 static int writeUTF(String str, DataOutput out) throws IOException { //获取String的长度 int strlen = str.length(); int utflen = 0; int c, count = 0; // 由于UTF-8是1～4个字节不等； // 这里，根据UTF-8首字节的范围，判断UTF-8是几个字节的。 for (int i = 0; i &lt; strlen; i++) { c = str.charAt(i); if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) { utflen++; } else if (c &gt; 0x07FF) { utflen += 3; } else { utflen += 2; } } if (utflen &gt; 65535) throw new UTFDataFormatException( &quot;encoded string too long: &quot; + utflen + &quot; bytes&quot;); // 新建“字节数组bytearr” byte[] bytearr = null; if (out instanceof DataOutputStream) { DataOutputStream dos = (DataOutputStream)out; if(dos.bytearr == null || (dos.bytearr.length &lt; (utflen+2))) dos.bytearr = new byte[(utflen*2) + 2]; bytearr = dos.bytearr; } else { bytearr = new byte[utflen+2]; } // “字节数组”的前2个字节保存的是“UTF-8数据的长度” bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 8) &amp; 0xFF); bytearr[count++] = (byte) ((utflen &gt;&gt;&gt; 0) &amp; 0xFF); // 对UTF-8中的单字节数据进行预处理 int i=0; for (i=0; i&lt;strlen; i++) { c = str.charAt(i); if (!((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F))) break; bytearr[count++] = (byte) c; } // 对预处理后的数据，接着进行处理 for (;i &lt; strlen; i++){ c = str.charAt(i); // UTF-8数据是1个字节的情况 if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F)) { bytearr[count++] = (byte) c; } else if (c &gt; 0x07FF) { // UTF-8数据是3个字节的情况 bytearr[count++] = (byte) (0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)); bytearr[count++] = (byte) (0x80 | ((c &gt;&gt; 6) &amp; 0x3F)); bytearr[count++] = (byte) (0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); } else { // UTF-8数据是2个字节的情况 bytearr[count++] = (byte) (0xC0 | ((c &gt;&gt; 6) &amp; 0x1F)); bytearr[count++] = (byte) (0x80 | ((c &gt;&gt; 0) &amp; 0x3F)); } } // 将字节数组写入到“数据输出流”中 out.write(bytearr, 0, utflen+2); return utflen + 2; } public final int size() { return written; } } 3. 示例代码关于DataOutStream中API的详细用法，参考示例代码(DataInputStreamTest.java)： import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.ByteArrayInputStream; import java.io.File; import java.io.InputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.FileNotFoundException; import java.lang.SecurityException; /** * DataInputStream 和 DataOutputStream测试程序 * * @author skywang */ public class DataInputStreamTest { private static final int LEN = 5; public static void main(String[] args) { // 测试DataOutputStream，将数据写入到输出流中。 testDataOutputStream() ; // 测试DataInputStream，从上面的输出流结果中读取数据。 testDataInputStream() ; } /** * DataOutputStream的API测试函数 */ private static void testDataOutputStream() { try { File file = new File(&quot;file.txt&quot;); DataOutputStream out = new DataOutputStream( new FileOutputStream(file)); out.writeBoolean(true); out.writeByte((byte)0x41); out.writeChar((char)0x4243); out.writeShort((short)0x4445); out.writeInt(0x12345678); out.writeLong(0x0FEDCBA987654321L); out.writeUTF(&quot;abcdefghijklmnopqrstuvwxyz严12&quot;); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } /** * DataInputStream的API测试函数 */ private static void testDataInputStream() { try { File file = new File(&quot;file.txt&quot;); DataInputStream in = new DataInputStream( new FileInputStream(file)); System.out.printf(&quot;byteToHexString(0x8F):0x%s\\n&quot;, byteToHexString((byte)0x8F)); System.out.printf(&quot;charToHexString(0x8FCF):0x%s\\n&quot;, charToHexString((char)0x8FCF)); System.out.printf(&quot;readBoolean():%s\\n&quot;, in.readBoolean()); System.out.printf(&quot;readByte():0x%s\\n&quot;, byteToHexString(in.readByte())); System.out.printf(&quot;readChar():0x%s\\n&quot;, charToHexString(in.readChar())); System.out.printf(&quot;readShort():0x%s\\n&quot;, shortToHexString(in.readShort())); System.out.printf(&quot;readInt():0x%s\\n&quot;, Integer.toHexString(in.readInt())); System.out.printf(&quot;readLong():0x%s\\n&quot;, Long.toHexString(in.readLong())); System.out.printf(&quot;readUTF():%s\\n&quot;, in.readUTF()); in.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } // 打印byte对应的16进制的字符串 private static String byteToHexString(byte val) { return Integer.toHexString(val &amp; 0xff); } // 打印char对应的16进制的字符串 private static String charToHexString(char val) { return Integer.toHexString(val); } // 打印short对应的16进制的字符串 private static String shortToHexString(short val) { return Integer.toHexString(val &amp; 0xffff); } } 运行结果： byteToHexString(0x8F):0x8f charToHexString(0x8FCF):0x8fcf readBoolean():true readByte():0x41 readChar():0x4243 readShort():0x4445 readInt():0x12345678 readLong():0xfedcba987654321 readUTF():abcdefghijklmnopqrstuvwxyz严12","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列14之 DataInputStream详解","date":"2016-10-13T16:00:00.000Z","path":"2016/10/14/java-source-analysis-io-series/java io系列14之 DataInputStream详解/","text":"本章介绍DataInputStream。我们先对DataInputStream有个大致认识，然后再深入学习它的源码，最后通过示例加深对它的了解。 目录1. DataInputStream 介绍2. DataInputStream.java源码分析(基于jdk1.7.40)3. 示例代码 1. DataInputStream 介绍DataInputStream 是数据输入流。它继承于FilterInputStream。 DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。应用程序可以使用DataOutputStream(数据输出流)写入由DataInputStream(数据输入流)读取的数据。 DataInputStream 函数列表 DataInputStream(InputStream in) final int read(byte[] buffer, int offset, int length) final int read(byte[] buffer) final boolean readBoolean() final byte readByte() final char readChar() final double readDouble() final float readFloat() final void readFully(byte[] dst) final void readFully(byte[] dst, int offset, int byteCount) final int readInt() final String readLine() final long readLong() final short readShort() final static String readUTF(DataInput in) final String readUTF() final int readUnsignedByte() final int readUnsignedShort() final int skipBytes(int count) 2. DataInputStream.java源码分析(基于jdk1.7.40)package java.io; public class DataInputStream extends FilterInputStream implements DataInput { // 构造函数。 public DataInputStream(InputStream in) { super(in); } private byte bytearr[] = new byte[80]; private char chararr[] = new char[80]; // 从“数据输入流”中读取一个字节 public final int read(byte b[]) throws IOException { return in.read(b, 0, b.length); } // 从“数据输入流”中读取数据并存储到字节数组b中。 // off是字节数组b中开始存储元素的起始位置。 // len是读取字节的个数。 public final int read(byte b[], int off, int len) throws IOException { return in.read(b, off, len); } // 从“数据输入流”中读取数据并填满字节数组b中；没有填满数组b则一直读取，直到填满位置。 // 从字节数组b的位置0开始存储，并且读取的字节个数等于b的长度。 public final void readFully(byte b[]) throws IOException { readFully(b, 0, b.length); } // 从“数据输入流”中读取数据并存储到字节数组b中；若没读取len个字节，直到一直读取直到读取完len个字节为止。 public final void readFully(byte b[], int off, int len) throws IOException { if (len &lt; 0) throw new IndexOutOfBoundsException(); int n = 0; while (n &lt; len) { int count = in.read(b, off + n, len - n); if (count &lt; 0) throw new EOFException(); n += count; } } // 跳过n个字节 public final int skipBytes(int n) throws IOException { int total = 0; int cur = 0; while ((total&lt;n) &amp;&amp; ((cur = (int) in.skip(n-total)) &gt; 0)) { total += cur; } return total; } // 从“数据输入流”中读取boolean类型的值 public final boolean readBoolean() throws IOException { int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return (ch != 0); } // 从“数据输入流”中读取Byte类型的值 public final byte readByte() throws IOException { int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return (byte)(ch); } // 从“数据输入流”中读取“无符号的Byte类型”的值，即读取值为正数的byte值 public final int readUnsignedByte() throws IOException { int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return ch; } // 从“数据输入流”中读取“short类型”的值 public final short readShort() throws IOException { int ch1 = in.read(); int ch2 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (short)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0)); } // 从“数据输入流”中读取“无符号的short类型”的值 public final int readUnsignedShort() throws IOException { int ch1 = in.read(); int ch2 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0); } // 从“数据输入流”中读取“char类型”的值 public final char readChar() throws IOException { int ch1 = in.read(); int ch2 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (char)((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0)); } // 从“数据输入流”中读取“int类型”的值 public final int readInt() throws IOException { int ch1 = in.read(); int ch2 = in.read(); int ch3 = in.read(); int ch4 = in.read(); if ((ch1 | ch2 | ch3 | ch4) &lt; 0) throw new EOFException(); return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0)); } private byte readBuffer[] = new byte[8]; // 从“数据输入流”中读取“long类型”的值 public final long readLong() throws IOException { readFully(readBuffer, 0, 8); return (((long)readBuffer[0] &lt;&lt; 56) + ((long)(readBuffer[1] &amp; 255) &lt;&lt; 48) + ((long)(readBuffer[2] &amp; 255) &lt;&lt; 40) + ((long)(readBuffer[3] &amp; 255) &lt;&lt; 32) + ((long)(readBuffer[4] &amp; 255) &lt;&lt; 24) + ((readBuffer[5] &amp; 255) &lt;&lt; 16) + ((readBuffer[6] &amp; 255) &lt;&lt; 8) + ((readBuffer[7] &amp; 255) &lt;&lt; 0)); } // 从“数据输入流”中读取“float类型”的值 public final float readFloat() throws IOException { return Float.intBitsToFloat(readInt()); } // 从“数据输入流”中读取“double类型”的值 public final double readDouble() throws IOException { return Double.longBitsToDouble(readLong()); } private char lineBuffer[]; @Deprecated public final String readLine() throws IOException { char buf[] = lineBuffer; if (buf == null) { buf = lineBuffer = new char[128]; } int room = buf.length; int offset = 0; int c; loop: while (true) { switch (c = in.read()) { case -1: case &apos;\\n&apos;: break loop; case &apos;\\r&apos;: int c2 = in.read(); if ((c2 != &apos;\\n&apos;) &amp;&amp; (c2 != -1)) { if (!(in instanceof PushbackInputStream)) { this.in = new PushbackInputStream(in); } ((PushbackInputStream)in).unread(c2); } break loop; default: if (--room &lt; 0) { buf = new char[offset + 128]; room = buf.length - offset - 1; System.arraycopy(lineBuffer, 0, buf, 0, offset); lineBuffer = buf; } buf[offset++] = (char) c; break; } } if ((c == -1) &amp;&amp; (offset == 0)) { return null; } return String.copyValueOf(buf, 0, offset); } // 从“数据输入流”中读取“UTF类型”的值 public final String readUTF() throws IOException { return readUTF(this); } public final static String readUTF(DataInput in) throws IOException { // 从“数据输入流”中读取“无符号的short类型”的值： // 注意：UTF-8输入流的前2个字节是数据的长度 int utflen = in.readUnsignedShort(); byte[] bytearr = null; char[] chararr = null; // 如果in本身是“数据输入流”， // 则，设置字节数组bytearr = &quot;数据输入流&quot;的成员bytearr // 设置字符数组chararr = &quot;数据输入流&quot;的成员chararr // 否则的话，新建数组bytearr和chararr if (in instanceof DataInputStream) { DataInputStream dis = (DataInputStream)in; if (dis.bytearr.length &lt; utflen){ dis.bytearr = new byte[utflen*2]; dis.chararr = new char[utflen*2]; } chararr = dis.chararr; bytearr = dis.bytearr; } else { bytearr = new byte[utflen]; chararr = new char[utflen]; } int c, char2, char3; int count = 0; int chararr_count=0; // 从“数据输入流”中读取数据并存储到字节数组bytearr中；从bytearr的位置0开始存储，存储长度为utflen。 // 注意，这里是存储到字节数组！而且读取的是全部的数据。 in.readFully(bytearr, 0, utflen); // 将“字节数组bytearr”中的数据 拷贝到 “字符数组chararr”中 // 注意：这里相当于“预处理的输入流中单字节的符号”，因为UTF-8是1-4个字节可变的。 while (count &lt; utflen) { // 将每个字节转换成int值 c = (int) bytearr[count] &amp; 0xff; // UTF-8的单字节数据的值都不会超过127；所以，超过127，则退出。 if (c &gt; 127) break; count++; // 将c保存到“字符数组chararr”中 chararr[chararr_count++]=(char)c; } // 处理完输入流中单字节的符号之后，接下来我们继续处理。 while (count &lt; utflen) { // 下面语句执行了2步操作。 // (01) 将字节由 “byte类型” 转换成 “int类型”。 // 例如， “11001010” 转换成int之后，是 “00000000 00000000 00000000 11001010” // (02) 将 “int类型” 的数据左移4位 // 例如， “00000000 00000000 00000000 11001010” 左移4位之后，变成 “00000000 00000000 00000000 00001100” c = (int) bytearr[count] &amp; 0xff; switch (c &gt;&gt; 4) { // 若 UTF-8 是单字节，即 bytearr[count] 对应是 “0xxxxxxx” 形式； // 则 bytearr[count] 对应的int类型的c的取值范围是 0-7。 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: /* 0xxxxxxx*/ count++; chararr[chararr_count++]=(char)c; break; // 若 UTF-8 是双字节，即 bytearr[count] 对应是 “110xxxxx 10xxxxxx” 形式中的第一个，即“110xxxxx” // 则 bytearr[count] 对应的int类型的c的取值范围是 12-13。 case 12: case 13: /* 110x xxxx 10xx xxxx*/ count += 2; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-1]; if ((char2 &amp; 0xC0) != 0x80) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); break; // 若 UTF-8 是三字节，即 bytearr[count] 对应是 “1110xxxx 10xxxxxx 10xxxxxx” 形式中的第一个，即“1110xxxx” // 则 bytearr[count] 对应的int类型的c的取值是14 。 case 14: /* 1110 xxxx 10xx xxxx 10xx xxxx */ count += 3; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-2]; char3 = (int) bytearr[count-1]; if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80)) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + (count-1)); chararr[chararr_count++]=(char)(((c &amp; 0x0F) &lt;&lt; 12) | ((char2 &amp; 0x3F) &lt;&lt; 6) | ((char3 &amp; 0x3F) &lt;&lt; 0)); break; // 若 UTF-8 是四字节，即 bytearr[count] 对应是 “11110xxx 10xxxxxx 10xxxxxx 10xxxxxx” 形式中的第一个，即“11110xxx” // 则 bytearr[count] 对应的int类型的c的取值是15 default: /* 10xx xxxx, 1111 xxxx */ throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); } } // The number of chars produced may be less than utflen return new String(chararr, 0, chararr_count); } } 说明：DataInputStream 的作用就是“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。应用程序可以使用数据输出流写入稍后由数据输入流读取的数据。”DataInputStream 中比较难以理解的函数就只有 readUTF(DataInput in)；下面，对这个函数进行详细的介绍，其它的函数请参考源码中的注释。 readUTF(DataInput in)源码如下： public final static String readUTF(DataInput in) throws IOException { // 从“数据输入流”中读取“无符号的short类型”的值： // 注意：UTF-8输入流的前2个字节是数据的长度 int utflen = in.readUnsignedShort(); byte[] bytearr = null; char[] chararr = null; // 如果in本身是“数据输入流”， // 则，设置字节数组bytearr = &quot;数据输入流&quot;的成员bytearr // 设置字符数组chararr = &quot;数据输入流&quot;的成员chararr // 否则的话，新建数组bytearr和chararr if (in instanceof DataInputStream) { DataInputStream dis = (DataInputStream)in; if (dis.bytearr.length &lt; utflen){ dis.bytearr = new byte[utflen*2]; dis.chararr = new char[utflen*2]; } chararr = dis.chararr; bytearr = dis.bytearr; } else { bytearr = new byte[utflen]; chararr = new char[utflen]; } int c, char2, char3; int count = 0; int chararr_count=0; // 从“数据输入流”中读取数据并存储到字节数组bytearr中；从bytearr的位置0开始存储，存储长度为utflen。 // 注意，这里是存储到字节数组！而且读取的是全部的数据。 in.readFully(bytearr, 0, utflen); // 将“字节数组bytearr”中的数据 拷贝到 “字符数组chararr”中 // 注意：这里相当于“预处理的输入流中单字节的符号”，因为UTF-8是1-4个字节可变的。 while (count &lt; utflen) { // 将每个字节转换成int值 c = (int) bytearr[count] &amp; 0xff; // UTF-8的每个字节的值都不会超过127；所以，超过127，则退出。 if (c &gt; 127) break; count++; // 将c保存到“字符数组chararr”中 chararr[chararr_count++]=(char)c; } // 处理完输入流中单字节的符号之后，接下来我们继续处理。 while (count &lt; utflen) { // 下面语句执行了2步操作。 // (01) 将字节由 “byte类型” 转换成 “int类型”。 // 例如， “11001010” 转换成int之后，是 “00000000 00000000 00000000 11001010” // (02) 将 “int类型” 的数据左移4位 // 例如， “00000000 00000000 00000000 11001010” 左移4位之后，变成 “00000000 00000000 00000000 00001100” c = (int) bytearr[count] &amp; 0xff; switch (c &gt;&gt; 4) { // 若 UTF-8 是单字节，即 bytearr[count] 对应是 “0xxxxxxx” 形式； // 则 bytearr[count] 对应的int类型的c的取值范围是 0-7。 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: /* 0xxxxxxx*/ count++; chararr[chararr_count++]=(char)c; break; // 若 UTF-8 是双字节，即 bytearr[count] 对应是 “110xxxxx 10xxxxxx” 形式中的第一个，即“110xxxxx” // 则 bytearr[count] 对应的int类型的c的取值范围是 12-13。 case 12: case 13: /* 110x xxxx 10xx xxxx*/ count += 2; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-1]; if ((char2 &amp; 0xC0) != 0x80) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); break; // 若 UTF-8 是三字节，即 bytearr[count] 对应是 “1110xxxx 10xxxxxx 10xxxxxx” 形式中的第一个，即“1110xxxx” // 则 bytearr[count] 对应的int类型的c的取值是14 。 case 14: /* 1110 xxxx 10xx xxxx 10xx xxxx */ count += 3; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-2]; char3 = (int) bytearr[count-1]; if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80)) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + (count-1)); chararr[chararr_count++]=(char)(((c &amp; 0x0F) &lt;&lt; 12) | ((char2 &amp; 0x3F) &lt;&lt; 6) | ((char3 &amp; 0x3F) &lt;&lt; 0)); break; // 若 UTF-8 是四字节，即 bytearr[count] 对应是 “11110xxx 10xxxxxx 10xxxxxx 10xxxxxx” 形式中的第一个，即“11110xxx” // 则 bytearr[count] 对应的int类型的c的取值是15 default: /* 10xx xxxx, 1111 xxxx */ throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); } } // The number of chars produced may be less than utflen return new String(chararr, 0, chararr_count); } 说明：(01) readUTF()的作用，是从输入流中读取UTF-8编码的数据，并以String字符串的形式返回。(02) 知道了readUTF()的作用之后，下面开始介绍readUTF()的流程： 第1步，读取出输入流中的UTF-8数据的长度。代码如下： int utflen = in.readUnsignedShort(); UTF-8数据的长度包含在它的前两个字节当中；我们通过readUnsignedShort()读取出前两个字节对应的正整数就是UTF-8数据的长度。 第2步，创建2个数组：字节数组bytearr 和 字符数组chararr。代码如下： if (in instanceof DataInputStream) { DataInputStream dis = (DataInputStream)in; if (dis.bytearr.length &lt; utflen){ dis.bytearr = new byte[utflen*2]; dis.chararr = new char[utflen*2]; } chararr = dis.chararr; bytearr = dis.bytearr; } else { bytearr = new byte[utflen]; chararr = new char[utflen]; } 首先，判断该输入流本身是不是DataInputStream，即数据输入流；若是的话，则，设置字节数组bytearr = “数据输入流”的成员bytearr；设置字符数组chararr = “数据输入流”的成员chararr。否则的话，新建数组bytearr和chararr。 第3步，将UTF-8数据全部读取到“字节数组bytearr”中。代码如下： in.readFully(bytearr, 0, utflen); 注意: 这里是存储到字节数组，而不是字符数组！而且读取的是全部的数据。 第4步，对UTF-8中的单字节数据进行预处理。代码如下： while (count &lt; utflen) { // 将每个字节转换成int值 c = (int) bytearr[count] &amp; 0xff; // UTF-8的单字节数据的值都不会超过127；所以，超过127，则退出。 if (c &gt; 127) break; count++; // 将c保存到“字符数组chararr”中 chararr[chararr_count++]=(char)c; } UTF-8的数据是变长的，可以是1-4个字节；在readUTF()中，我们最终是将全部的UTF-8数据保存到“字符数组(而不是字节数组)”中，再将其转换为String字符串。由于UTF-8的单字节和ASCII相同，所以这里就将它们进行预处理，直接保存到“字符数组chararr”中。对于其它的UTF-8数据，则在后面进行处理。 第5步，对“第4步 预处理”之后的数据，接着进行处理。代码如下： // 处理完输入流中单字节的符号之后，接下来我们继续处理。 while (count &lt; utflen) { // 下面语句执行了2步操作。 // (01) 将字节由 “byte类型” 转换成 “int类型”。 // 例如， “11001010” 转换成int之后，是 “00000000 00000000 00000000 11001010” // (02) 将 “int类型” 的数据左移4位 // 例如， “00000000 00000000 00000000 11001010” 左移4位之后，变成 “00000000 00000000 00000000 00001100” c = (int) bytearr[count] &amp; 0xff; switch (c &gt;&gt; 4) { // 若 UTF-8 是单字节，即 bytearr[count] 对应是 “0xxxxxxx” 形式； // 则 bytearr[count] 对应的int类型的c的取值范围是 0-7。 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: /* 0xxxxxxx*/ count++; chararr[chararr_count++]=(char)c; break; // 若 UTF-8 是双字节，即 bytearr[count] 对应是 “110xxxxx 10xxxxxx” 形式中的第一个，即“110xxxxx” // 则 bytearr[count] 对应的int类型的c的取值范围是 12-13。 case 12: case 13: /* 110x xxxx 10xx xxxx*/ count += 2; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-1]; if ((char2 &amp; 0xC0) != 0x80) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); break; // 若 UTF-8 是三字节，即 bytearr[count] 对应是 “1110xxxx 10xxxxxx 10xxxxxx” 形式中的第一个，即“1110xxxx” // 则 bytearr[count] 对应的int类型的c的取值是14 。 case 14: /* 1110 xxxx 10xx xxxx 10xx xxxx */ count += 3; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-2]; char3 = (int) bytearr[count-1]; if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80)) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + (count-1)); chararr[chararr_count++]=(char)(((c &amp; 0x0F) &lt;&lt; 12) | ((char2 &amp; 0x3F) &lt;&lt; 6) | ((char3 &amp; 0x3F) &lt;&lt; 0)); break; // 若 UTF-8 是四字节，即 bytearr[count] 对应是 “11110xxx 10xxxxxx 10xxxxxx 10xxxxxx” 形式中的第一个，即“11110xxx” // 则 bytearr[count] 对应的int类型的c的取值是15 default: /* 10xx xxxx, 1111 xxxx */ throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); } } (a) 我们将下面的两条语句一起进行说明 c = (int) bytearr[count] &amp; 0xff; switch (c &gt;&gt; 4) { ... } 首先，我们必须要理解 为什么要这么做(执行上面2条语句)呢？原因很简单，这么做的目的就是为了区分UTF-8数据是几位的；因为UTF-8的数据是1～4字节不等。 我们先看看UTF-8在1～4位情况下的格式。 --------------------+--------------------------------------------- 1字节 UTF-8的通用格式 | 0xxxxxxx 2字节 UTF-8的通用格式 | 110xxxxx 10xxxxxx 3字节 UTF-8的通用格式 | 1110xxxx 10xxxxxx 10xxxxxx 4字节 UTF-8的通用格式 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 执行 c = (int) bytearr[count] &amp; 0xff; 和 c&gt;&gt;4 这2项操作之后，上面的数据变成 --------------------+--------------------------------------------- 1字节 UTF-8的变换后对应的int类型值 | 00000000 00000000 00000000 00000xxx (范围是0~7) 2字节 UTF-8的变换后对应的int类型值 | 00000000 00000000 00000000 0000110x (范围是12~13) 3字节 UTF-8的变换后对应的int类型值 | 00000000 00000000 00000000 00001110 (范围是14) 4字节 UTF-8的变换后对应的int类型值 | 00000000 00000000 00000000 00001111 (范围是15) 为什么会是这样呢？ 我们以“2字节 UTF-8的通用格式”来说明。它的通用格式是 “110xxxxx 10xxxxxx”，我们在操作时，只会操作第1个字节，即只会操作“110xxxxx”(a.1) 在执行 c = (int) bytearr[count] &amp; 0xff; 时，首先将 bytearr[count] 转换成int。 “110xxxxx” 转成int类型之后，变成 “11111111 11111111 11111111 110xxxxx” 因为“110xxxxx”是负数(第1为是1)，所以转换成int类型时多出来的位补1。 (a.2) 接着 c = (int) bytearr[count] &amp; 0xff; 中，会将 “转换成int类型后的bytearr[count]” 与 “0xff”进行 逻辑与(即&amp;) 操作。结果如下： “00000000 00000000 00000000 110xxxxx” (a.3) 执行 c&gt;&gt;4 时，会将上面的结果左移4位。得到的结果如下： “00000000 00000000 00000000 0000110x” (b) 上面的理解之后，swicth (c&gt;&gt;4) { … } 其中的省略号部分就相当容易理解了。 我们还是以“2字节 UTF-8的通用格式”来说明。它会执行 case 12 和 case 13；源码如下： count += 2; if (count &gt; utflen) throw new UTFDataFormatException( &quot;malformed input: partial character at end&quot;); char2 = (int) bytearr[count-1]; if ((char2 &amp; 0xC0) != 0x80) throw new UTFDataFormatException( &quot;malformed input around byte &quot; + count); chararr[chararr_count++]=(char)(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); (b.1) 由于这种情况对应的UTF-8数据是“2字节”的，因此，执行count+2；直接跳过2个字节。(b.2) 由于chararr的元素是字符类型，而一个字符正好占2个字节；因为正好将(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); 的结果转换成char，然后保存在chararr数组中。 第6步，将字符数组转换成String字符串，并返回。代码如下： return new String(chararr, 0, chararr_count); 3. 示例代码关于DataInputStream中API的详细用法，参考示例代码(DataInputStreamTest.java)： import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.ByteArrayInputStream; import java.io.File; import java.io.InputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.FileNotFoundException; import java.lang.SecurityException; /** * DataInputStream 和 DataOutputStream测试程序 * * @author skywang */ public class DataInputStreamTest { private static final int LEN = 5; public static void main(String[] args) { // 测试DataOutputStream，将数据写入到输出流中。 testDataOutputStream() ; // 测试DataInputStream，从上面的输出流结果中读取数据。 testDataInputStream() ; } /** * DataOutputStream的API测试函数 */ private static void testDataOutputStream() { try { File file = new File(&quot;file.txt&quot;); DataOutputStream out = new DataOutputStream( new FileOutputStream(file)); out.writeBoolean(true); out.writeByte((byte)0x41); out.writeChar((char)0x4243); out.writeShort((short)0x4445); out.writeInt(0x12345678); out.writeLong(0x0FEDCBA987654321L); out.writeUTF(&quot;abcdefghijklmnopqrstuvwxyz严12&quot;); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } /** * DataInputStream的API测试函数 */ private static void testDataInputStream() { try { File file = new File(&quot;file.txt&quot;); DataInputStream in = new DataInputStream( new FileInputStream(file)); System.out.printf(&quot;byteToHexString(0x8F):0x%s\\n&quot;, byteToHexString((byte)0x8F)); System.out.printf(&quot;charToHexString(0x8FCF):0x%s\\n&quot;, charToHexString((char)0x8FCF)); System.out.printf(&quot;readBoolean():%s\\n&quot;, in.readBoolean()); System.out.printf(&quot;readByte():0x%s\\n&quot;, byteToHexString(in.readByte())); System.out.printf(&quot;readChar():0x%s\\n&quot;, charToHexString(in.readChar())); System.out.printf(&quot;readShort():0x%s\\n&quot;, shortToHexString(in.readShort())); System.out.printf(&quot;readInt():0x%s\\n&quot;, Integer.toHexString(in.readInt())); System.out.printf(&quot;readLong():0x%s\\n&quot;, Long.toHexString(in.readLong())); System.out.printf(&quot;readUTF():%s\\n&quot;, in.readUTF()); in.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } // 打印byte对应的16进制的字符串 private static String byteToHexString(byte val) { return Integer.toHexString(val &amp; 0xff); } // 打印char对应的16进制的字符串 private static String charToHexString(char val) { return Integer.toHexString(val); } // 打印short对应的16进制的字符串 private static String shortToHexString(short val) { return Integer.toHexString(val &amp; 0xffff); } } 运行结果： byteToHexString(0x8F):0x8f charToHexString(0x8FCF):0x8fcf readBoolean():true readByte():0x41 readChar():0x4243 readShort():0x4445 readInt():0x12345678 readLong():0xfedcba987654321 readUTF():abcdefghijklmnopqrstuvwxyz严12 结果说明： (01) 查看file.txt文本。16进制的数据显示如下： img 001f 对应的int值是31。它表示的含义是后面的UTF-8数据的长度。字符串“abcdefghijklmnopqrstuvwxyz严12”中字母“ab…xyz”的长度是26，“严”对应的UTF-8数据长度是3；“12”长度是2。总的长度=26+3+2=31。 (02) 返回byte对应的16进制的字符串 源码如下： private static String byteToHexString(byte val) { return Integer.toHexString(val &amp; 0xff); } 想想为什么代码是： return Integer.toHexString(val &amp; 0xff); 而不是 return Integer.toHexString(val); 我们先看看 byteToHexString((byte)0x8F); 在上面两种情况下的输出结果。 return Integer.toHexString(val &amp; 0xff); 对应的输出是“0xffffff8f”return Integer.toHexString(val); 对应的输出是“0x8f” 为什么会这样呢？ 原因其实很简单，就是“byte类型转换成int类型”导致的问题。byte类型的0x8F是一个负数，它对应的2进制是10001111；将一个负数的byte转换成int类型时，执行的是有符号转型(新增位都填充符号位的数字)。0x8F的符号位是1，因为将它转换成int时，填充“1”；转型后的结果(2进制)是11111111 11111111 11111111 10001111，对应的16进制为0xffffff8f。因为当我们执行Integer.toHexString(val);时，返回的就是0xffffff8f。在Integer.toHexString(val &amp; 0xff)中，相当于0xffffff8f &amp; 0xff，得到的结果是0x8f。 (03) 返回char和short对应的16进制的字符串 “返回char对应的16进制的字符串”对应的源码如下： private static String charToHexString(char val) { return Integer.toHexString(val); } “返回short对应的16进制的字符串”对应源码如下： private static String shortToHexString(short val) { return Integer.toHexString(val &amp; 0xffff); } 比较上面的两个函数，为什么一个是 “val” ，而另一个是 “val &amp; 0xffff”？通过(02)的分析，我们类似的推出为什么 “返回short对应的16进制的字符串” 要执行“val &amp; 0xffff”。但是，为什么 “返回char对应的16进制的字符串” 要执行 “val” 即可。原因也很简单，java中char是无符号类型，占两个字节。将char转换为int类型，执行的是无符号转型，新增为都填充0。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列13之 BufferedOutputStream详解","date":"2016-10-12T16:00:00.000Z","path":"2016/10/13/java-source-analysis-io-series/java io系列13之 BufferedOutputStream详解/","text":"目录1. BufferedOutputStream 介绍2. BufferedOutputStream 源码分析(基于jdk1.7.40) 3. 示例代码 1. BufferedOutputStream 介绍BufferedOutputStream 是缓冲输出流。它继承于FilterOutputStream。 BufferedOutputStream 的作用是为另一个输出流提供“缓冲功能”。 BufferedOutputStream 函数列表 BufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out, int size) synchronized void close() synchronized void flush() synchronized void write(byte[] buffer, int offset, int length) synchronized void write(int oneByte) 2. BufferedOutputStream 源码分析(基于jdk1.7.40)package java.io; public class BufferedOutputStream extends FilterOutputStream { // 保存“缓冲输出流”数据的字节数组 protected byte buf[]; // 缓冲中数据的大小 protected int count; // 构造函数：新建字节数组大小为8192的“缓冲输出流” public BufferedOutputStream(OutputStream out) { this(out, 8192); } // 构造函数：新建字节数组大小为size的“缓冲输出流” public BufferedOutputStream(OutputStream out, int size) { super(out); if (size &lt;= 0) { throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); } buf = new byte[size]; } // 将缓冲数据都写入到输出流中 private void flushBuffer() throws IOException { if (count &gt; 0) { out.write(buf, 0, count); count = 0; } } // 将“数据b(转换成字节类型)”写入到输出流中 public synchronized void write(int b) throws IOException { // 若缓冲已满，则先将缓冲数据写入到输出流中。 if (count &gt;= buf.length) { flushBuffer(); } // 将“数据b”写入到缓冲中 buf[count++] = (byte)b; } public synchronized void write(byte b[], int off, int len) throws IOException { // 若“写入长度”大于“缓冲区大小”，则先将缓冲中的数据写入到输出流，然后直接将数组b写入到输出流中 if (len &gt;= buf.length) { flushBuffer(); out.write(b, off, len); return; } // 若“剩余的缓冲空间 不足以 存储即将写入的数据”，则先将缓冲中的数据写入到输出流中 if (len &gt; buf.length - count) { flushBuffer(); } System.arraycopy(b, off, buf, count, len); count += len; } // 将“缓冲数据”写入到输出流中 public synchronized void flush() throws IOException { flushBuffer(); out.flush(); } } 说明： BufferedOutputStream的源码非常简单，这里就BufferedOutputStream的思想进行简单说明：BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。 3. 示例代码关于BufferedOutputStream中API的详细用法，参考示例代码(BufferedOutputStreamTest.java)： import java.io.BufferedOutputStream; import java.io.File; import java.io.OutputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.FileNotFoundException; import java.lang.SecurityException; import java.util.Scanner; /** * BufferedOutputStream 测试程序 * * @author skywang */ public class BufferedOutputStreamTest { private static final int LEN = 5; // 对应英文字母“abcddefghijklmnopqrsttuvwxyz” private static final byte[] ArrayLetters = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A }; public static void main(String[] args) { testBufferedOutputStream() ; } /** * BufferedOutputStream的API测试函数 */ private static void testBufferedOutputStream() { // 创建“文件输出流”对应的BufferedOutputStream // 它对应缓冲区的大小是16，即缓冲区的数据&gt;=16时，会自动将缓冲区的内容写入到输出流。 try { File file = new File(&quot;out.txt&quot;); OutputStream out = new BufferedOutputStream( new FileOutputStream(file), 16); // 将ArrayLetters数组的前10个字节写入到输出流中 out.write(ArrayLetters, 0, 10); // 将“换行符\\n”写入到输出流中 out.write(&apos;\\n&apos;); // TODO! //out.flush(); readUserInput() ; out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } /** * 读取用户输入 */ private static void readUserInput() { System.out.println(&quot;please input a text:&quot;); Scanner reader=new Scanner(System.in); // 等待一个输入 String str = reader.next(); System.out.printf(&quot;the input is : %s\\n&quot;, str); } } 运行结果 生成文件“out.txt”，文件的内容是“abcdefghij”。 分步测试：分别按照下面3种步骤测试程序,来查看缓冲区大小以及flush()的作用。 第1种：原始程序 (01) 运行程序。在程序等待用户输入时，查看“out.txt”的文本内容；发现：内容为空。(02) 运行程序。在用户输入之后，查看“out.txt”的文本内容；发现：内容为“abcdefghij”。从中，我们发现(01)和(02)的结果不同；之所以(01)中的out.txt内容为空，是因为out.txt对应的缓冲区大小是16字节，而我们只写入了11个字节，所以，它不会执行清空缓冲操作(即，将缓冲数据写入到输出流中)。而(02)对应out.txt的内容是“abcdefghij”，是因为执行了out.close()，它会关闭输出流；在关闭输出流之前，会将缓冲区的数据写入到输出流中。 注意：重新测试时，要先删除out.txt。 第2种：在readUserInput()前添加如下语句 out.flush(); 这句话的作用，是将“缓冲区的内容”写入到输出流中。(01) 运行程序。在程序等待用户输入时，查看“out.txt”的文本内容；发现：内容为“abcdefghij”。(02) 运行程序。在用户输入之后，查看“out.txt”的文本内容；发现：内容为“abcdefghij”。从中，我们发现(01)和(02)结果一样，对应out.txt的内容都是“abcdefghij”。这是因为执行了flush()操作，它的作用是将缓冲区的数据写入到输出流中。 注意：重新测试时，要先删除out.txt！ 第3种：在第1种的基础上，将 out.write(ArrayLetters, 0, 10); 修改为 out.write(ArrayLetters, 0, 20); (01) 运行程序。在程序等待用户输入时，查看“out.txt”的文本内容；发现：内容为“abcdefghijklmnopqrst”(不含回车)。(02) 运行程序。在用户输入之后，查看“out.txt”的文本内容；发现：内容为“abcdefghijklmnopqrst”(含回车)。从中，我们发现(01)运行结果是“abcdefghijklmnopqrst”(不含回车)。这是因为，缓冲区的大小是16，而我们通过out.write(ArrayLetters, 0, 20)写入了20个字节，超过了缓冲区的大小；这时，会直接将全部的输入都写入都输出流中，而不经过缓冲区。(03)运行结果是“abcdefghijklmnopqrst”(含回车)，这是因为执行out.close()时，将回车符号’\\n’写入了输出流中。 注意：重新测试时，要先删除out.txt！","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列12之 BufferedInputStream详解","date":"2016-10-11T16:00:00.000Z","path":"2016/10/12/java-source-analysis-io-series/java io系列12之 BufferedInputStream详解/","text":"目录1. BufferedInputStream 介绍2. BufferedInputStream 源码分析(基于jdk1.7.40)3. 示例代码 1. BufferedInputStream 介绍BufferedInputStream 是缓冲输入流。它继承于FilterInputStream。 BufferedInputStream 的作用是为另一个输入流添加一些功能，例如，提供“缓冲功能”以及支持“mark()标记”和“reset()重置方法”。BufferedInputStream 本质上是通过一个内部缓冲区数组实现的。例如，在新建某输入流对应的BufferedInputStream后，当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。 BufferedInputStream 函数列表 BufferedInputStream(InputStream in) BufferedInputStream(InputStream in, int size) synchronized int available() void close() synchronized void mark(int readlimit) boolean markSupported() synchronized int read() synchronized int read(byte[] buffer, int offset, int byteCount) synchronized void reset() synchronized long skip(long byteCount) 2. BufferedInputStream 源码分析(基于jdk1.7.40)package java.io; import java.util.concurrent.atomic.AtomicReferenceFieldUpdater; public class BufferedInputStream extends FilterInputStream { // 默认的缓冲大小是8192字节 // BufferedInputStream 会根据“缓冲区大小”来逐次的填充缓冲区； // 即，BufferedInputStream填充缓冲区，用户读取缓冲区，读完之后，BufferedInputStream会再次填充缓冲区。如此循环，直到读完数据... private static int defaultBufferSize = 8192; // 缓冲数组 protected volatile byte buf[]; // 缓存数组的原子更新器。 // 该成员变量与buf数组的volatile关键字共同组成了buf数组的原子更新功能实现， // 即，在多线程中操作BufferedInputStream对象时，buf和bufUpdater都具有原子性(不同的线程访问到的数据都是相同的) private static final AtomicReferenceFieldUpdater&lt;BufferedInputStream, byte[]&gt; bufUpdater = AtomicReferenceFieldUpdater.newUpdater (BufferedInputStream.class, byte[].class, &quot;buf&quot;); // 当前缓冲区的有效字节数。 // 注意，这里是指缓冲区的有效字节数，而不是输入流中的有效字节数。 protected int count; // 当前缓冲区的位置索引 // 注意，这里是指缓冲区的位置索引，而不是输入流中的位置索引。 protected int pos; // 当前缓冲区的标记位置 // markpos和reset()配合使用才有意义。操作步骤： // (01) 通过mark() 函数，保存pos的值到markpos中。 // (02) 通过reset() 函数，会将pos的值重置为markpos。接着通过read()读取数据时，就会从mark()保存的位置开始读取。 protected int markpos = -1; // marklimit是标记的最大值。 // 关于marklimit的原理，我们在后面的fill()函数分析中会详细说明。这对理解BufferedInputStream相当重要。 protected int marklimit; // 获取输入流 private InputStream getInIfOpen() throws IOException { InputStream input = in; if (input == null) throw new IOException(&quot;Stream closed&quot;); return input; } // 获取缓冲 private byte[] getBufIfOpen() throws IOException { byte[] buffer = buf; if (buffer == null) throw new IOException(&quot;Stream closed&quot;); return buffer; } // 构造函数：新建一个缓冲区大小为8192的BufferedInputStream public BufferedInputStream(InputStream in) { this(in, defaultBufferSize); } // 构造函数：新建指定缓冲区大小的BufferedInputStream public BufferedInputStream(InputStream in, int size) { super(in); if (size &lt;= 0) { throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); } buf = new byte[size]; } // 从“输入流”中读取数据，并填充到缓冲区中。 // 后面会对该函数进行详细说明！ private void fill() throws IOException { byte[] buffer = getBufIfOpen(); if (markpos &lt; 0) pos = 0; /* no mark: throw away the buffer */ else if (pos &gt;= buffer.length) /* no room left in buffer */ if (markpos &gt; 0) { /* can throw away early part of the buffer */ int sz = pos - markpos; System.arraycopy(buffer, markpos, buffer, 0, sz); pos = sz; markpos = 0; } else if (buffer.length &gt;= marklimit) { markpos = -1; /* buffer got too big, invalidate mark */ pos = 0; /* drop buffer contents */ } else { /* grow buffer */ int nsz = pos * 2; if (nsz &gt; marklimit) nsz = marklimit; byte nbuf[] = new byte[nsz]; System.arraycopy(buffer, 0, nbuf, 0, pos); if (!bufUpdater.compareAndSet(this, buffer, nbuf)) { throw new IOException(&quot;Stream closed&quot;); } buffer = nbuf; } count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } // 读取下一个字节 public synchronized int read() throws IOException { // 若已经读完缓冲区中的数据，则调用fill()从输入流读取下一部分数据来填充缓冲区 if (pos &gt;= count) { fill(); if (pos &gt;= count) return -1; } // 从缓冲区中读取指定的字节 return getBufIfOpen()[pos++] &amp; 0xff; } // 将缓冲区中的数据写入到字节数组b中。off是字节数组b的起始位置，len是写入长度 private int read1(byte[] b, int off, int len) throws IOException { int avail = count - pos; if (avail &lt;= 0) { // 加速机制。 // 如果读取的长度大于缓冲区的长度 并且没有markpos， // 则直接从原始输入流中进行读取，从而避免无谓的COPY（从原始输入流至缓冲区，读取缓冲区全部数据，清空缓冲区， // 重新填入原始输入流数据） if (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; 0) { return getInIfOpen().read(b, off, len); } // 若已经读完缓冲区中的数据，则调用fill()从输入流读取下一部分数据来填充缓冲区 fill(); avail = count - pos; if (avail &lt;= 0) return -1; } int cnt = (avail &lt; len) ? avail : len; System.arraycopy(getBufIfOpen(), pos, b, off, cnt); pos += cnt; return cnt; } // 将缓冲区中的数据写入到字节数组b中。off是字节数组b的起始位置，len是写入长度 public synchronized int read(byte b[], int off, int len) throws IOException { getBufIfOpen(); // Check for closed stream if ((off | len | (off + len) | (b.length - (off + len))) &lt; 0) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } // 读取到指定长度的数据才返回 int n = 0; for (;;) { int nread = read1(b, off + n, len - n); if (nread &lt;= 0) return (n == 0) ? nread : n; n += nread; if (n &gt;= len) return n; // if not closed but no bytes available, return InputStream input = in; if (input != null &amp;&amp; input.available() &lt;= 0) return n; } } // 忽略n个字节 public synchronized long skip(long n) throws IOException { getBufIfOpen(); // Check for closed stream if (n &lt;= 0) { return 0; } long avail = count - pos; if (avail &lt;= 0) { // If no mark position set then don&apos;t keep in buffer if (markpos &lt;0) return getInIfOpen().skip(n); // Fill in buffer to save bytes for reset fill(); avail = count - pos; if (avail &lt;= 0) return 0; } long skipped = (avail &lt; n) ? avail : n; pos += skipped; return skipped; } // 下一个字节是否存可读 public synchronized int available() throws IOException { int n = count - pos; int avail = getInIfOpen().available(); return n &gt; (Integer.MAX_VALUE - avail) ? Integer.MAX_VALUE : n + avail; } // 标记“缓冲区”中当前位置。 // readlimit是marklimit，关于marklimit的作用，参考后面的说明。 public synchronized void mark(int readlimit) { marklimit = readlimit; markpos = pos; } // 将“缓冲区”中当前位置重置到mark()所标记的位置 public synchronized void reset() throws IOException { getBufIfOpen(); // Cause exception if closed if (markpos &lt; 0) throw new IOException(&quot;Resetting to invalid mark&quot;); pos = markpos; } public boolean markSupported() { return true; } // 关闭输入流 public void close() throws IOException { byte[] buffer; while ( (buffer = buf) != null) { if (bufUpdater.compareAndSet(this, buffer, null)) { InputStream input = in; in = null; if (input != null) input.close(); return; } // Else retry in case a new buf was CASed in fill() } } } 说明：要想读懂BufferedInputStream的源码，就要先理解它的思想。BufferedInputStream的作用是为其它输入流提供缓冲功能。创建BufferedInputStream时，我们会通过它的构造函数指定某个输入流为参数。BufferedInputStream会将该输入流数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从输入流中读取下一部分的数据。 为什么需要缓冲呢？原因很简单，效率问题！缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘或NandFlash等存储介质中；而我们知道，从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。那干嘛不干脆一次性将全部数据都读取到缓冲中呢？第一，读取全部的数据所需要的时间可能会很长。第二，内存价格很贵，容量不像硬盘那么大。 下面，我就BufferedInputStream中最重要的函数fill()进行说明。其它的函数很容易理解，我就不详细介绍了，大家可以参考源码中的注释进行理解。 fill() 源码如下： private void fill() throws IOException { byte[] buffer = getBufIfOpen(); if (markpos &lt; 0) pos = 0; else if (pos &gt;= buffer.length) { if (markpos &gt; 0) { /* can throw away early part of the buffer */ int sz = pos - markpos; System.arraycopy(buffer, markpos, buffer, 0, sz); pos = sz; markpos = 0; } else if (buffer.length &gt;= marklimit) { markpos = -1; /* buffer got too big, invalidate mark */ pos = 0; /* drop buffer contents */ } else { /* grow buffer */ int nsz = pos * 2; if (nsz &gt; marklimit) nsz = marklimit; byte nbuf[] = new byte[nsz]; System.arraycopy(buffer, 0, nbuf, 0, pos); if (!bufUpdater.compareAndSet(this, buffer, nbuf)) { // Can&apos;t replace buf if there was an async close. // Note: This would need to be changed if fill() // is ever made accessible to multiple threads. // But for now, the only way CAS can fail is via close. // assert buf == null; throw new IOException(&quot;Stream closed&quot;); } buffer = nbuf; } } count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } 根据fill()中的if…else…，下面我们将fill分为5种情况进行说明。 情况1：读取完buffer中的数据，并且buffer没有被标记执行流程如下，(01) read() 函数中调用 fill()(02) fill() 中的 if (markpos &lt; 0) …为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { byte[] buffer = getBufIfOpen(); if (markpos &lt; 0) pos = 0; count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } 说明：这种情况发生的情况是 — — 输入流中有很长的数据，我们每次从中读取一部分数据到buffer中进行操作。每次当我们读取完buffer中的数据之后，并且此时输入流没有被标记；那么，就接着从输入流中读取下一部分的数据到buffer中。 判断是否读完buffer中的数据，是通过 if (pos &gt;= count) 来判断的； 判断输入流有没有被标记，是通过 if (markpos &lt; 0) 来判断的。 理解这个思想之后，我们再对这种情况下的fill()的代码进行分析，就特别容易理解了。(01) if (markpos &lt; 0) 它的作用是判断“输入流是否被标记”。若被标记，则markpos大于/等于0；否则markpos等于-1。(02) 在这种情况下：通过getInIfOpen()获取输入流，然后接着从输入流中读取buffer.length个字节到buffer中。(03) count = n + pos; 这是根据从输入流中读取的实际数据的多少，来更新buffer中数据的实际大小。 情况2：读取完buffer中的数据，buffer的标记位置&gt;0，并且buffer中没有多余的空间执行流程如下，(01) read() 函数中调用 fill()(02) fill() 中的 else if (pos &gt;= buffer.length) …(03) fill() 中的 if (markpos &gt; 0) … 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { byte[] buffer = getBufIfOpen(); if (markpos &gt;= 0 &amp;&amp; pos &gt;= buffer.length) { if (markpos &gt; 0) { int sz = pos - markpos; System.arraycopy(buffer, markpos, buffer, 0, sz); pos = sz; markpos = 0; } } count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } 说明：这种情况发生的情况是 — — 输入流中有很长的数据，我们每次从中读取一部分数据到buffer中进行操作。当我们读取完buffer中的数据之后，并且此时输入流存在标记时；那么，就发生情况2。此时，我们要保留“被标记位置”到“buffer末尾”的数据，然后再从输入流中读取下一部分的数据到buffer中。 其中，判断是否读完buffer中的数据，是通过 if (pos &gt;= count) 来判断的； 判断输入流有没有被标记，是通过 if (markpos &lt; 0) 来判断的。 判断buffer中没有多余的空间，是通过 if (pos &gt;= buffer.length) 来判断的。 理解这个思想之后，我们再对这种情况下的fill()代码进行分析，就特别容易理解了。(01) int sz = pos - markpos; 作用是“获取‘被标记位置’到‘buffer末尾’”的数据长度。(02) System.arraycopy(buffer, markpos, buffer, 0, sz); 作用是“将buffer中从markpos开始的数据”拷贝到buffer中(从位置0开始填充，填充长度是sz)。接着，将sz赋值给pos，即pos就是“被标记位置”到“buffer末尾”的数据长度。(03) int n = getInIfOpen().read(buffer, pos, buffer.length - pos); 从输入流中读取出“buffer.length - pos”的数据，然后填充到buffer中。(04) 通过第(02)和(03)步组合起来的buffer，就是包含了“原始buffer被标记位置到buffer末尾”的数据，也包含了“从输入流中新读取的数据”。 注意：执行过情况2之后，markpos的值由“大于0”变成了“等于0”！ 情况3：读取完buffer中的数据，buffer被标记位置=0，buffer中没有多余的空间，并且buffer.length&gt;=marklimit执行流程如下，(01) read() 函数中调用 fill()(02) fill() 中的 else if (pos &gt;= buffer.length) …(03) fill() 中的 else if (buffer.length &gt;= marklimit) … 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { byte[] buffer = getBufIfOpen(); if (markpos &gt;= 0 &amp;&amp; pos &gt;= buffer.length) { if ( (markpos &lt;= 0) &amp;&amp; (buffer.length &gt;= marklimit) ) { markpos = -1; /* buffer got too big, invalidate mark */ pos = 0; /* drop buffer contents */ } } count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } 说明：这种情况的处理非常简单。首先，就是“取消标记”，即 markpos = -1；然后，设置初始化位置为0，即pos=0；最后，再从输入流中读取下一部分数据到buffer中。 情况4：读取完buffer中的数据，buffer被标记位置=0，buffer中没有多余的空间，并且buffer.length&lt;marklimit执行流程如下，(01) read() 函数中调用 fill()(02) fill() 中的 else if (pos &gt;= buffer.length) …(03) fill() 中的 else { int nsz = pos * 2; … } 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { byte[] buffer = getBufIfOpen(); if (markpos &gt;= 0 &amp;&amp; pos &gt;= buffer.length) { if ( (markpos &lt;= 0) &amp;&amp; (buffer.length &lt; marklimit) ) { int nsz = pos * 2; if (nsz &gt; marklimit) nsz = marklimit; byte nbuf[] = new byte[nsz]; System.arraycopy(buffer, 0, nbuf, 0, pos); if (!bufUpdater.compareAndSet(this, buffer, nbuf)) { throw new IOException(&quot;Stream closed&quot;); } buffer = nbuf; } } count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } 说明：这种情况的处理非常简单。(01) 新建一个字节数组nbuf。nbuf的大小是“pos*2”和“marklimit”中较小的那个数。 int nsz = pos * 2; if (nsz &gt; marklimit) nsz = marklimit; byte nbuf[] = new byte[nsz]; (02) 接着，将buffer中的数据拷贝到新数组nbuf中。通过System.arraycopy(buffer, 0, nbuf, 0, pos)(03) 最后，从输入流读取部分新数据到buffer中。通过getInIfOpen().read(buffer, pos, buffer.length - pos); 注意：在这里，我们思考一个问题，“为什么需要marklimit，它的存在到底有什么意义？”我们结合“情况2”、“情况3”、“情况4”的情况来分析。 假设，marklimit是无限大的，而且我们设置了markpos。当我们从输入流中每读完一部分数据并读取下一部分数据时，都需要保存markpos所标记的数据；这就意味着，我们需要不断执行情况4中的操作，要将buffer的容量扩大……随着读取次数的增多，buffer会越来越大；这会导致我们占据的内存越来越大。所以，我们需要给出一个marklimit；当buffer&gt;=marklimit时，就不再保存markpos的值了。 情况5：除了上面4种情况之外的情况执行流程如下，(01) read() 函数中调用 fill()(02) fill() 中的 count = pos… 为了方便分析，我们将这种情况下fill()执行的操作等价于以下代码： private void fill() throws IOException { byte[] buffer = getBufIfOpen(); count = pos; int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; } 说明：这种情况的处理非常简单。直接从输入流读取部分新数据到buffer中。 3. 示例代码关于BufferedInputStream中API的详细用法，参考示例代码(BufferedInputStreamTest.java)： import java.io.BufferedInputStream; import java.io.ByteArrayInputStream; import java.io.File; import java.io.InputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.FileNotFoundException; import java.lang.SecurityException; /** * BufferedInputStream 测试程序 * * @author skywang */ public class BufferedInputStreamTest { private static final int LEN = 5; public static void main(String[] args) { testBufferedInputStream() ; } /** * BufferedInputStream的API测试函数 */ private static void testBufferedInputStream() { // 创建BufferedInputStream字节流，内容是ArrayLetters数组 try { File file = new File(&quot;bufferedinputstream.txt&quot;); InputStream in = new BufferedInputStream( new FileInputStream(file), 512); // 从字节流中读取5个字节。“abcde”，a对应0x61，b对应0x62，依次类推... for (int i=0; i&lt;LEN; i++) { // 若能继续读取下一个字节，则读取下一个字节 if (in.available() &gt;= 0) { // 读取“字节流的下一个字节” int tmp = in.read(); System.out.printf(&quot;%d : 0x%s\\n&quot;, i, Integer.toHexString(tmp)); } } // 若“该字节流”不支持标记功能，则直接退出 if (!in.markSupported()) { System.out.println(&quot;make not supported!&quot;); return ; } // 标记“当前索引位置”，即标记第6个位置的元素--“f” // 1024对应marklimit in.mark(1024); // 跳过22个字节。 in.skip(22); // 读取5个字节 byte[] buf = new byte[LEN]; in.read(buf, 0, LEN); // 将buf转换为String字符串。 String str1 = new String(buf); System.out.printf(&quot;str1=%s\\n&quot;, str1); // 重置“输入流的索引”为mark()所标记的位置，即重置到“f”处。 in.reset(); // 从“重置后的字节流”中读取5个字节到buf中。即读取“fghij” in.read(buf, 0, LEN); // 将buf转换为String字符串。 String str2 = new String(buf); System.out.printf(&quot;str2=%s\\n&quot;, str2); in.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } 程序中读取的bufferedinputstream.txt的内容如下： abcdefghijklmnopqrstuvwxyz 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ 运行结果： 0 : 0x61 1 : 0x62 2 : 0x63 3 : 0x64 4 : 0x65 str1=01234 str2=fghij","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列11之 FilterOutputStream详解","date":"2016-10-10T16:00:00.000Z","path":"2016/10/11/java-source-analysis-io-series/java io系列11之 FilterOutputStream详解/","text":"FilterOutputStream 介绍FilterOutputStream 的作用是用来“封装其它的输出流，并为它们提供额外的功能”。它主要包括BufferedOutputStream, DataOutputStream和PrintStream。 (01) BufferedOutputStream的作用就是为“输出流提供缓冲功能”。 (02) DataOutputStream 是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。 (03) PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 FilterOutputStream 源码(基于jdk1.7.40)package java.io; public class FilterOutputStream extends OutputStream { protected OutputStream out; public FilterOutputStream(OutputStream out) { this.out = out; } public void write(int b) throws IOException { out.write(b); } public void write(byte b[]) throws IOException { write(b, 0, b.length); } public void write(byte b[], int off, int len) throws IOException { if ((off | len | (b.length - (len + off)) | (off + len)) &lt; 0) throw new IndexOutOfBoundsException(); for (int i = 0 ; i &lt; len ; i++) { write(b[off + i]); } } public void flush() throws IOException { out.flush(); } public void close() throws IOException { try { flush(); } catch (IOException ignored) { } out.close(); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列10之 FilterInputStream详解","date":"2016-10-09T16:00:00.000Z","path":"2016/10/10/java-source-analysis-io-series/java io系列10之 FilterInputStream详解/","text":"FilterInputStream 介绍FilterInputStream 的作用是用来“封装其它的输入流，并为它们提供额外的功能”。它的常用的子类有BufferedInputStream和DataInputStream。 BufferedInputStream的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。 DataInputStream 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。应用程序可以使用DataOutputStream(数据输出流)写入由DataInputStream(数据输入流)读取的数据。 FilterInputStream 源码(基于jdk1.7.40)package java.io; public class FilterInputStream extends InputStream { protected volatile InputStream in; protected FilterInputStream(InputStream in) { this.in = in; } public int read() throws IOException { return in.read(); } public int read(byte b[]) throws IOException { return read(b, 0, b.length); } public int read(byte b[], int off, int len) throws IOException { return in.read(b, off, len); } public long skip(long n) throws IOException { return in.skip(n); } public int available() throws IOException { return in.available(); } public void close() throws IOException { in.close(); } public synchronized void mark(int readlimit) { in.mark(readlimit); } public synchronized void reset() throws IOException { in.reset(); } public boolean markSupported() { return in.markSupported(); } }","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列09之 FileDescriptor详解","date":"2016-10-08T16:00:00.000Z","path":"2016/10/09/java-source-analysis-io-series/java io系列09之 FileDescriptor详解/","text":"本章对FileDescriptor进行介绍 目录1. FileDescriptor 介绍2. 示例代码 1. FileDescriptor 介绍FileDescriptor 是“文件描述符”。FileDescriptor 可以被用来表示开放文件、开放套接字等。以FileDescriptor表示文件来说：当FileDescriptor表示某文件时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescriptor对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputStream，再对文件进行操作。 in, out, err介绍(01) in – 标准输入(键盘)的描述符(02) out – 标准输出(屏幕)的描述符(03) err – 标准错误输出(屏幕)的描述符 它们3个的原理和用法都类似，下面我们通过out来进行深入研究。 1.1 out 的作用和原理out是标准输出(屏幕)的描述符。但是它有什么作用呢？我们可以通俗理解，out就代表了标准输出(屏幕)。若我们要输出信息到屏幕上，即可通过out来进行操作；但是，out又没有提供输出信息到屏幕的接口(因为out本质是FileDescriptor对象，而FileDescriptor没有输出接口)。怎么办呢？很简单，我们创建out对应的“输出流对象”，然后通过“输出流”的write()等输出接口就可以将信息输出到屏幕上。如下代码： try { FileOutputStream out = new FileOutputStream(FileDescriptor.out); out.write(&apos;A&apos;); out.close(); } catch (IOException e) { } 执行上面的程序，会在屏幕上输出字母’A’。 为了方便我们操作，java早已为我们封装好了“能方便的在屏幕上输出信息的接口”：通过System.out，我们能方便的输出信息到屏幕上。因此，我们可以等价的将上面的程序转换为如下代码： System.out.print(&apos;A&apos;); 下面讲讲上面两段代码的原理查看看out的定义。它的定义在FileDescriptor.java中，相关源码如下： public final class FileDescriptor { private int fd; public static final FileDescriptor out = new FileDescriptor(1); private FileDescriptor(int fd) { this.fd = fd; useCount = new AtomicInteger(); } ... } 从中，可以看出(01) out就是一个FileDescriptor对象。它是通过构造函数FileDescriptor(int fd)创建的。(02) FileDescriptor(int fd)的操作：就是给fd对象(int类型)赋值，并新建一个使用计数变量useCount。fd对象是非常重要的一个变量，“fd=1”就代表了“标准输出”，“fd=0”就代表了“标准输入”，“fd=2”就代表了“标准错误输出”。 FileOutputStream out = new FileOutputStream(FileDescriptor.out); 就是利用构造函数FileOutputStream(FileDescriptor fdObj)来创建“Filed.out对应的FileOutputStream对象”。 关于System.out是如何定义的。可以参考”[深入了解System.out.println(“hello world”)][link_io_systemoutprintln] “ 通过上面的学习，我们知道，我们可以自定义标准的文件描述符[即，in(标准输入),out(标准输出),err(标准错误输出)]的流，从而完成输入/输出功能；但是，java已经为我们封装好了相应的接口，即我们可以更方便的System.in, System.out, System.err去使用它们。另外，我们也可以自定义“文件”、“Socket”等的文件描述符，进而对它们进行操作。参考下面示例代码中的testWrite(), testRead()等接口。 2. 示例代码源码如下(FileDescriptorTest.java)： import java.io.PrintStream; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; /** * FileDescriptor 测试程序 * * @author skywang */ public class FileDescriptorTest { private static final String FileName = &quot;file.txt&quot;; private static final String OutText = &quot;Hi FileDescriptor&quot;; public static void main(String[] args) { testWrite(); testRead(); testStandFD() ; //System.out.println(OutText); } /** * FileDescriptor.out 的测试程序 * * 该程序的效果 等价于 System.out.println(OutText); */ private static void testStandFD() { // 创建FileDescriptor.out 对应的PrintStream PrintStream out = new PrintStream( new FileOutputStream(FileDescriptor.out)); // 在屏幕上输出“Hi FileDescriptor” out.println(OutText); out.close(); } /** * FileDescriptor写入示例程序 * * (01) 为了说明，&quot;通过文件名创建FileOutputStream&quot;与“通过文件描述符创建FileOutputStream”对象是等效的 * (02) 该程序会在“该源文件”所在目录新建文件&quot;file.txt&quot;，并且文件内容是&quot;Aa&quot;。 */ private static void testWrite() { try { // 新建文件“file.txt”对应的FileOutputStream对象 FileOutputStream out1 = new FileOutputStream(FileName); // 获取文件“file.txt”对应的“文件描述符” FileDescriptor fdout = out1.getFD(); // 根据“文件描述符”创建“FileOutputStream”对象 FileOutputStream out2 = new FileOutputStream(fdout); out1.write(&apos;A&apos;); // 通过out1向“file.txt”中写入&apos;A&apos; out2.write(&apos;a&apos;); // 通过out2向“file.txt”中写入&apos;A&apos; if (fdout!=null) System.out.printf(&quot;fdout(%s) is %s\\n&quot;,fdout, fdout.valid()); out1.close(); out2.close(); } catch(IOException e) { e.printStackTrace(); } } /** * FileDescriptor读取示例程序 * * 为了说明，&quot;通过文件名创建FileInputStream&quot;与“通过文件描述符创建FileInputStream”对象是等效的 */ private static void testRead() { try { // 新建文件“file.txt”对应的FileInputStream对象 FileInputStream in1 = new FileInputStream(FileName); // 获取文件“file.txt”对应的“文件描述符” FileDescriptor fdin = in1.getFD(); // 根据“文件描述符”创建“FileInputStream”对象 FileInputStream in2 = new FileInputStream(fdin); System.out.println(&quot;in1.read():&quot;+(char)in1.read()); System.out.println(&quot;in2.read():&quot;+(char)in2.read()); if (fdin!=null) System.out.printf(&quot;fdin(%s) is %s\\n&quot;, fdin, fdin.valid()); in1.close(); in2.close(); } catch(IOException e) { e.printStackTrace(); } } } 运行结果： fdout(java.io.FileDescriptor@2b820dda) is true in1.read():A in2.read():a fdin(java.io.FileDescriptor@675b7986) is true Hi FileDescriptor","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列08之 File详解","date":"2016-10-07T16:00:00.000Z","path":"2016/10/08/java-source-analysis-io-series/java io系列08之 File详解/","text":"本文对File的API和常用方法进行介绍。 目录第1部分 File 介绍第2部分 File API使用示例 第1部分 File 介绍File 是“文件”和“目录路径名”的抽象表示形式。 File 直接继承于Object，实现了Serializable接口和Comparable接口。实现Serializable接口，意味着File对象支持序列化操作。而实现Comparable接口，意味着File对象之间可以比较大小；File能直接被存储在有序集合(如TreeSet、TreeMap中)。 File 函数列表 // 静态成员 public static final String pathSeparator // 路径分割符&quot;:&quot; public static final char pathSeparatorChar // 路径分割符&apos;:&apos; public static final String separator // 分隔符&quot;/&quot; public static final char separatorChar // 分隔符&apos;/&apos; // 构造函数 File(File dir, String name) File(String path) File(String dirPath, String name) File(URI uri) // 成员函数 boolean canExecute() // 测试应用程序是否可以执行此抽象路径名表示的文件。 boolean canRead() // 测试应用程序是否可以读取此抽象路径名表示的文件。 boolean canWrite() // 测试应用程序是否可以修改此抽象路径名表示的文件。 int compareTo(File pathname) // 按字母顺序比较两个抽象路径名。 boolean createNewFile() // 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 static File createTempFile(String prefix, String suffix) // 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。 static File createTempFile(String prefix, String suffix, File directory) // 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。 boolean delete() // 删除此抽象路径名表示的文件或目录。 void deleteOnExit() // 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。 boolean equals(Object obj) // 测试此抽象路径名与给定对象是否相等。 boolean exists() // 测试此抽象路径名表示的文件或目录是否存在。 File getAbsoluteFile() // 返回此抽象路径名的绝对路径名形式。 String getAbsolutePath() // 返回此抽象路径名的绝对路径名字符串。 File getCanonicalFile() // 返回此抽象路径名的规范形式。 String getCanonicalPath() // 返回此抽象路径名的规范路径名字符串。 long getFreeSpace() // 返回此抽象路径名指定的分区中未分配的字节数。 String getName() // 返回由此抽象路径名表示的文件或目录的名称。 String getParent() // 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。 File getParentFile() // 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。 String getPath() // 将此抽象路径名转换为一个路径名字符串。 long getTotalSpace() // 返回此抽象路径名指定的分区大小。 long getUsableSpace() // 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。 int hashCode() // 计算此抽象路径名的哈希码。 boolean isAbsolute() // 测试此抽象路径名是否为绝对路径名。 boolean isDirectory() // 测试此抽象路径名表示的文件是否是一个目录。 boolean isFile() // 测试此抽象路径名表示的文件是否是一个标准文件。 boolean isHidden() // 测试此抽象路径名指定的文件是否是一个隐藏文件。 long lastModified() // 返回此抽象路径名表示的文件最后一次被修改的时间。 long length() // 返回由此抽象路径名表示的文件的长度。 String[] list() // 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 String[] list(FilenameFilter filter) // 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。 File[] listFiles() // 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 File[] listFiles(FileFilter filter) // 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 File[] listFiles(FilenameFilter filter) // 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 static File[] listRoots() // 列出可用的文件系统根。 boolean mkdir() // 创建此抽象路径名指定的目录。 boolean mkdirs() // 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。 boolean renameTo(File dest) // 重新命名此抽象路径名表示的文件。 boolean setExecutable(boolean executable) // 设置此抽象路径名所有者执行权限的一个便捷方法。 boolean setExecutable(boolean executable, boolean ownerOnly) // 设置此抽象路径名的所有者或所有用户的执行权限。 boolean setLastModified(long time) // 设置此抽象路径名指定的文件或目录的最后一次修改时间。 boolean setReadable(boolean readable) // 设置此抽象路径名所有者读权限的一个便捷方法。 boolean setReadable(boolean readable, boolean ownerOnly) // 设置此抽象路径名的所有者或所有用户的读权限。 boolean setReadOnly() // 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。 boolean setWritable(boolean writable) // 设置此抽象路径名所有者写权限的一个便捷方法。 boolean setWritable(boolean writable, boolean ownerOnly) // 设置此抽象路径名的所有者或所有用户的写权限。 String toString() // 返回此抽象路径名的路径名字符串。 URI toURI() // 构造一个表示此抽象路径名的 file: URI。 URL toURL() // 已过时。 此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。 1. 新建目录的常用方法方法1：根据相对路径新建目录。 示例代码如下(在当前路径下新建目录“dir”)： File dir = new File(&quot;dir&quot;); dir.mkdir(); 方法2：根据绝对路径新建目录。 示例代码如下(新建目录“/home/skywang/dir”)： File dir = new File(&quot;/home/skywang/dir&quot;); dir.mkdirs(); 说明：上面是在linux系统下新建目录“/home/skywang/dir”的源码。在windows下面，若要新建目录“D:/dir”，源码如下： File dir = new File(&quot;D:/dir&quot;); dir.mkdir(); 方法3 URI uri = new URI(&quot;file:/home/skywang/dir&quot;); File dir = new File(uri); sub.mkdir(); 说明： 和“方法2”类似，只不过“方法2”中传入的是完整路径，而“方法3”中传入的是完整路径对应URI。 2. 新建子目录的几种常用方法例如，我们想要在当前目录的子目录“dir”下，再新建一个子目录。有一下几种方法: 方法1 File sub1 = new File(&quot;dir&quot;, &quot;sub1&quot;); sub1.mkdir(); 说明：上面的方法作用是，在当前目录下 “dir/sub1”。它能正常运行的前提是“sub1”的父目录“dir”已经存在！ 方法2 File sub2 = new File(dir, &quot;sub2&quot;); sub2.mkdir(); 说明：上面的方法作用是，在当前目录下 “dir/sub2”。它能正常运行的前提是“sub2”的父目录“dir”已经存在！ 方法3 File sub3 = new File(&quot;dir/sub3&quot;); sub3.mkdirs(); 说明：上面的方法作用是，在当前目录下 “dir/sub3”。它不需要dir已经存在，也能正常运行；若“sub3”的父母路不存在，mkdirs()方法会自动创建父目录。 方法4 File sub4 = new File(&quot;/home/skywang/dir/sub4&quot;); sub4.mkdirs(); 说明：上面的方法作用是，新建目录”/home/skywang/dir/sub3”。它不需要dir已经存在，也能正常运行；若“sub4”的父母路不存在，mkdirs()方法会自动创建父目录。 方法5 URI uri = new URI(&quot;file:/home/skywang/dir/sub5&quot;); File sub5 = new File(uri); sub5.mkdirs(); 说明： 和“方法4”类似，只不过“方法4”中传入的是完整路径，而“方法5”中传入的是完整路径对应URI。 3. 新建文件的几种常用方法例如，我们想要在当前目录的子目录“dir”下，新建一个文件。有一下几种方法 方法1 try { File dir = new File(&quot;dir&quot;); // 获取目录“dir”对应的File对象 File file1 = new File(dir, &quot;file1.txt&quot;); file1.createNewFile(); } catch (IOException e) { e.printStackTrace(); } 说明：上面代码作用是，在“dir”目录(相对路径)下新建文件“file1.txt”。 方法2 try { File file2 = new File(&quot;dir&quot;, &quot;file2.txt&quot;); file2.createNewFile(); } catch (IOException e) { e.printStackTrace(); } 说明：上面代码作用是，在“dir”目录(相对路径)下新建文件“file2.txt”。 方法3 try { File file3 = new File(&quot;/home/skywang/dir/file3.txt&quot;); file3.createNewFile(); } catch (IOException e) { e.printStackTrace(); } 说明：上面代码作用是，下新建文件“/home/skywang/dir/file3.txt”(绝对路径)。这是在linux下根据绝对路径的方法，在windows下可以通过以下代码新建文件”D:/dir/file4.txt”。 try { File file3 = new File(&quot;D:/dir/file4.txt&quot;); file3.createNewFile(); } catch (IOException e) { e.printStackTrace(); } 方法4 try { URI uri = new URI(&quot;file:/home/skywang/dir/file4.txt&quot;); File file4 = new File(uri); file4.createNewFile(); } catch (IOException e) { e.printStackTrace(); } 说明：和“方法3”类似，只不过“方法3”中传入的是完整路径，而“方法4”中传入的是完整路径对应URI。 第2部分 File API使用示例关于File中API的详细用法，参考示例代码(FileTest.java)： import java.io.File; import java.io.IOException; import java.net.URI; import java.util.Calendar; import java.text.SimpleDateFormat; public class FileTest { public static void main(String[] args) { testFileStaticFields() ; testFileDirAPIS() ; } public static void testFileStaticFields() { // 打印 路径分隔符&quot;:&quot; System.out.printf(&quot;File.pathSeparator=\\&quot;%s\\&quot;\\n&quot;, File.pathSeparator); // 打印 路径分隔符&apos;:&apos; System.out.printf(&quot;File.pathSeparatorChar=\\&quot;%c\\&quot;\\n&quot;, File.pathSeparatorChar); // 打印 分隔符&quot;/&quot; System.out.printf(&quot;File.separator=\\&quot;%s\\&quot;\\n&quot;, File.separator); // 打印 分隔符&apos;/&apos; System.out.printf(&quot;File.separatorChar=\\&quot;%c\\&quot;\\n&quot;, File.separatorChar); } public static void testFileDirAPIS() { try { // 新建目录 &quot;dir&quot; File dir = new File(&quot;dir&quot;); dir.mkdir(); // 方法1：新建目录 &quot;dir/sub1&quot;。父目录“dir”必须已经存在！ File sub1 = new File(&quot;dir&quot;, &quot;sub1&quot;); sub1.mkdir(); // 方法2：新建目录 &quot;dir/sub2&quot;。父目录“dir”必须已经存在！ File sub2 = new File(dir, &quot;sub2&quot;); sub2.mkdir(); // 方法3：新建目录 &quot;dir/sub3&quot;。mkdirs()会自动创建不存在的父目录。 File sub3 = new File(&quot;dir/sub3&quot;); sub3.mkdirs(); // 方法4：新建目录 &quot;dir/sub4&quot;。根据“绝对路径”创建，前面3个方法都是根据“相对路径”创建。 String dirPath = dir.getAbsolutePath(); // 获取“dir”的绝对路径 String sub4AbsPath = dirPath + File.separator + &quot;sub4&quot;; // File.separator是分隔符&quot;/&quot; File sub4 = new File(sub4AbsPath); sub4.mkdirs(); // 方法5：新建目录 &quot;dir/sub5&quot;。根据uri String uri_sub5_path = &quot;file:&quot;+ dirPath + File.separator + &quot;sub5&quot;; URI uri_sub5 = new URI(uri_sub5_path); File sub5 = new File(uri_sub5); sub5.mkdirs(); // 方法1：新建文件 &quot;dir/l1_normal.txt&quot; File l1_normal = new File(dir, &quot;l1_normal.txt&quot;); l1_normal.createNewFile(); // 方法2：新建文件 &quot;dir/.l1_hide.txt&quot;。 File l1_hide = new File(&quot;dir&quot;, &quot;.l1_hide.txt&quot;); // 在linux中, &quot;.&quot;开头的文件是隐藏文件。 l1_hide.createNewFile(); // 方法3：新建文件 &quot;dir/l1_abs.txt&quot;。 String dirAbsPah = dir.getAbsolutePath(); // 获取dir的绝对路径 String l1_abs_path = dirAbsPah+File.separator+&quot;l1_abs.txt&quot;; File l1_abs = new File(l1_abs_path); l1_abs.createNewFile(); //System.out.printf(&quot;l1_abs_path=%s\\n&quot;, l1_abs_path); //System.out.printf(&quot;l1_abs path=%s\\n&quot;, l1_abs.getAbsolutePath()); // 方法4：新建文件 &quot;dir/l1_uri.txt&quot;。根据URI新建文件 String uri_path = &quot;file:&quot;+ dirAbsPah + File.separator + &quot;l1_uri.txt&quot;; URI uri_l1 = new URI(uri_path); //System.out.printf(&quot;uri_l1=%s\\n&quot;, l1_abs.getAbsolutePath()); File l1_uri = new File(uri_l1); l1_uri.createNewFile(); // 新建文件 &quot;dir/sub/s1_normal&quot; File s1_normal = new File(sub1, &quot;s1_normal.txt&quot;); s1_normal.createNewFile(); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.exists()&quot;, s1_normal.exists()); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.getName()&quot;, s1_normal.getName()); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.getParent()&quot;, s1_normal.getParent()); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.getPath()&quot;, s1_normal.getPath()); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.getAbsolutePath()&quot;, s1_normal.getAbsolutePath()); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.getCanonicalPath()&quot;, s1_normal.getCanonicalPath()); System.out.printf(&quot;%30s = %s is \\&quot;%s\\&quot;\\n&quot;, &quot;s1_normal.lastModified()&quot;, s1_normal.lastModified(), getModifyTime(s1_normal.lastModified())); System.out.printf(&quot;%30s = %s\\n&quot;, &quot;s1_normal.toURI()&quot;, s1_normal.toURI()); // 列出“dir”目录下的“文件”和“文件夹”。 // 注意：dir.listFiles()只会遍历目录dir，而不会遍历dir的子目录！ System.out.println(&quot;---- list files and folders ----&quot;); File[] fs = dir.listFiles(); for (File f:fs) { String fname = f.getName(); String absStr = f.isAbsolute() ? &quot;[Absolute]&quot; : &quot;&quot;; String hidStr = f.isHidden() ? &quot;[Hidden]&quot; : &quot;&quot;; String dirStr = f.isDirectory() ? &quot;[Directory]&quot; : &quot;&quot;; String fileStr = f.isFile() ? &quot;[File]&quot; : &quot;&quot;; System.out.printf(&quot;%-30s %s%s%s%s\\n&quot;, fname, fileStr, dirStr, absStr, hidStr); } } catch (Exception e) { e.printStackTrace(); } } private static String getModifyTime(long millis) { // 获取Calendar对象 Calendar cal = Calendar.getInstance(); // 设置时间为 millis cal.setTimeInMillis(millis); // 获取格式化对象，它会按照&quot;yyyy-MM-dd HH:mm:ss&quot;格式化日期 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //System.out.printf(&quot;TIME %s\\n&quot;, str); return sdf.format(cal.getTime()); } } 运行结果(在ubuntu 12.04系统下的运行结果，而不是windows！)： File.pathSeparator=&quot;:&quot; File.pathSeparatorChar=&quot;:&quot; File.separator=&quot;/&quot; File.separatorChar=&quot;/&quot; s1_normal.exists() = true s1_normal.getName() = s1_normal.txt s1_normal.getParent() = dir/sub1 s1_normal.getPath() = dir/sub1/s1_normal.txt s1_normal.getAbsolutePath() = /home/skywang/wind_talker/workout/java/skywang/io/io/src/file/dir/sub1/s1_normal.txt s1_normal.getCanonicalPath() = /home/skywang/wind_talker/workout/java/skywang/io/io/src/file/dir/sub1/s1_normal.txt s1_normal.lastModified() = 1381730064000 is &quot;2013-10-14 13:54:24&quot; s1_normal.toURI() = file:/home/skywang/wind_talker/workout/java/skywang/io/io/src/file/dir/sub1/s1_normal.txt ---- list files and folders ---- l1_uri.txt [File] sub1 [Directory] l1_abs.txt [File] sub5 [Directory] sub4 [Directory] .l1_hide.txt [File][Hidden] sub3 [Directory] sub2 [Directory] l1_normal.txt [File] 结果说明：运行程序，会在源文件所在的目录新建目录”dir”及其子目录和子文件。如下图： img","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列07之 FileInputStream和FileOutputStream详解","date":"2016-10-06T16:00:00.000Z","path":"2016/10/07/java-source-analysis-io-series/java io系列07之 FileInputStream和FileOutputStream详解/","text":"本章介绍FileInputStream 和 FileOutputStream 目录1. FileInputStream 和 FileOutputStream 介绍2. 示例程序 1. FileInputStream 和 FileOutputStream 介绍FileInputStream 是文件输入流，它继承于InputStream。通常，我们使用FileInputStream从某个文件中获得输入字节。 FileOutputStream 是文件输出流，它继承于OutputStream。通常，我们使用FileOutputStream 将数据写入 File 或 FileDescriptor 的输出流。 关于File的介绍，可以参考文章“[java io之 File总结][link_io_file]” 。关于FileDescriptor的介绍，可以参考文章“[java io之 FileDescriptor总结][link_io_filedescriptor]”。 FileInputStream 函数接口 FileInputStream(File file) // 构造函数1：创建“File对象”对应的“文件输入流” FileInputStream(FileDescriptor fd) // 构造函数2：创建“文件描述符”对应的“文件输入流” FileInputStream(String path) // 构造函数3：创建“文件(路径为path)”对应的“文件输入流” int available() // 返回“剩余的可读取的字节数”或者“skip的字节数” void close() // 关闭“文件输入流” FileChannel getChannel() // 返回“FileChannel” final FileDescriptor getFD() // 返回“文件描述符” int read() // 返回“文件输入流”的下一个字节 int read(byte[] buffer, int byteOffset, int byteCount) // 读取“文件输入流”的数据并存在到buffer，从byteOffset开始存储，存储长度是byteCount。 long skip(long byteCount) // 跳过byteCount个字节 FileOutputStream 函数接口 FileOutputStream(File file) // 构造函数1：创建“File对象”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。 FileOutputStream(File file, boolean append) // 构造函数2：创建“File对象”对应的“文件输入流”；指定“追加模式”。 FileOutputStream(FileDescriptor fd) // 构造函数3：创建“文件描述符”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。 FileOutputStream(String path) // 构造函数4：创建“文件(路径为path)”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。 FileOutputStream(String path, boolean append) // 构造函数5：创建“文件(路径为path)”对应的“文件输入流”；指定“追加模式”。 void close() // 关闭“输出流” FileChannel getChannel() // 返回“FileChannel” final FileDescriptor getFD() // 返回“文件描述符” void write(byte[] buffer, int byteOffset, int byteCount) // 将buffer写入到“文件输出流”中，从buffer的byteOffset开始写，写入长度是byteCount。 void write(int oneByte) // 写入字节oneByte到“文件输出流”中 2. 示例程序关于FileInputStream和FileOutputStream的API用法，参考示例代码(FileStreamTest.java)： import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.PrintStream;; import java.io.IOException; /** * FileInputStream 和FileOutputStream 测试程序 * * @author skywang */ public class FileStreamTest { private static final String FileName = &quot;file.txt&quot;; public static void main(String[] args) { testWrite(); testRead(); } /** * FileOutputStream 演示函数 * * 运行结果： * 在源码所在目录生成文件&quot;file.txt&quot;，文件内容是“abcdefghijklmnopqrstuvwxyz0123456789” * * 加入，我们将 FileOutputStream fileOut2 = new FileOutputStream(file, true); * 修改为 FileOutputStream fileOut2 = new FileOutputStream(file, false); * 然后再执行程序，“file.txt”的内容变成&quot;0123456789&quot;。 * 原因是： * (01) FileOutputStream fileOut2 = new FileOutputStream(file, true); * 它是以“追加模式”将内容写入文件的。即写入的内容，追加到原始的内容之后。 * (02) FileOutputStream fileOut2 = new FileOutputStream(file, false); * 它是以“新建模式”将内容写入文件的。即删除文件原始的内容之后，再重新写入。 */ private static void testWrite() { try { // 创建文件“file.txt”对应File对象 File file = new File(FileName); // 创建文件“file.txt”对应的FileOutputStream对象，默认是关闭“追加模式” FileOutputStream fileOut1 = new FileOutputStream(file); // 创建FileOutputStream对应的PrintStream，方便操作。PrintStream的写入接口更便利 PrintStream out1 = new PrintStream(fileOut1); // 向“文件中”写入26个字母 out1.print(&quot;abcdefghijklmnopqrstuvwxyz&quot;); out1.close(); // 创建文件“file.txt”对应的FileOutputStream对象，打开“追加模式” FileOutputStream fileOut2 = new FileOutputStream(file, true); // 创建FileOutputStream对应的PrintStream，方便操作。PrintStream的写入接口更便利 PrintStream out2 = new PrintStream(fileOut2); // 向“文件中”写入&quot;0123456789&quot;+换行符 out2.println(&quot;0123456789&quot;); out2.close(); } catch(IOException e) { e.printStackTrace(); } } /** * FileInputStream 演示程序 */ private static void testRead() { try { // 方法1：新建FileInputStream对象 // 新建文件“file.txt”对应File对象 File file = new File(FileName); FileInputStream in1 = new FileInputStream(file); // 方法2：新建FileInputStream对象 FileInputStream in2 = new FileInputStream(FileName); // 方法3：新建FileInputStream对象 // 获取文件“file.txt”对应的“文件描述符” FileDescriptor fdin = in2.getFD(); // 根据“文件描述符”创建“FileInputStream”对象 FileInputStream in3 = new FileInputStream(fdin); // 测试read()，从中读取一个字节 char c1 = (char)in1.read(); System.out.println(&quot;c1=&quot;+c1); // 测试skip(long byteCount)，跳过4个字节 in1.skip(25); // 测试read(byte[] buffer, int byteOffset, int byteCount) byte[] buf = new byte[10]; in1.read(buf, 0, buf.length); System.out.println(&quot;buf=&quot;+(new String(buf))); // 创建“FileInputStream”对象对应的BufferedInputStream BufferedInputStream bufIn = new BufferedInputStream(in3); // 读取一个字节 char c2 = (char)bufIn.read(); System.out.println(&quot;c2=&quot;+c2); in1.close(); in2.close(); in3.close(); } catch(IOException e) { e.printStackTrace(); } } } 运行结果： c1=a buf=0123456789 c2=a 结果说明： 运行程序，会在源码所在位置新生成一个文件“file.txt”。它的内容是“abcdefghijklmnopqrstuvwxyz0123456789”。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列06之 序列化(Serializable和Externalizable)详解","date":"2016-10-05T16:00:00.000Z","path":"2016/10/06/java-source-analysis-io-series/java io系列06之 序列化(Serializable和Externalizable)详解/","text":"本章，我们对序列化进行深入的学习和探讨。学习内容，包括序列化的作用、用途、用法，以及对实现序列化的2种方式Serializable和Externalizable的深入研究。 目录1. 序列化是的作用和用途2. 演示程序13. 演示程序24. 演示程序35. 演示程序46. 演示程序57. Externalizable和完全定制序列化过程 1. 序列化是的作用和用途序列化，就是为了保存对象的状态；而与之对应的反序列化，则可以把保存的对象状态再读出来。简言之：序列化/反序列化，是Java提供一种专门用于的保存/恢复对象状态的机制。 一般在以下几种情况下，我们可能会用到序列化：a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；b）当你想用套接字在网络上传送对象的时候；c）当你想通过RMI传输对象的时候。 2. 演示程序1下面，我们先通过一则简单示例来查看序列化的用法。 源码如下(SerialTest1.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class SerialTest1 { private static final String TMP_FILE = &quot;.serialtest1.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象，Box实现了Serializable序列化接口 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类“支持序列化”。因为Box实现了Serializable接口。 * * 实际上，一个类只需要实现Serializable即可实现序列化，而不需要实现任何函数。 */ class Box implements Serializable { private int width; private int height; private String name; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 运行结果： testWrite box: [desk: (80, 48) ] testRead box: [desk: (80, 48) ] 源码说明： (01) 程序的作用很简单，就是演示：先将Box对象，通过对象输出流保存到文件中；之后，再通过对象输入流，将文件中保存的Box对象读取出来。 (02) Box类说明。Box是我们自定义的演示类，它被用于序列化的读写。Box实现了Serialable接口，因此它支持序列化操作；即，Box支持通过ObjectOutputStream去写入到输出流中，并且支持通过ObjectInputStream从输入流中读取出来。 (03) testWrite()函数说明。testWrite()的作用就是，新建一个Box对象，然后将该Box对象写入到文件中。&nbsp;&nbsp;&nbsp;&nbsp; 首先，新建文件TMP_FILE的文件输出流对象(即FileOutputStream对象)，再创建该文件输出流的对象输出流(即ObjectOutputStream对象)。&nbsp;&nbsp;&nbsp;&nbsp; a) 关于FileInputStream和FileOutputStream的内容，可以参考“java io系列07之 FileInputStream和FileOutputStream”。&nbsp;&nbsp;&nbsp;&nbsp; b) 关于ObjectInputStream和ObjectOutputStream的的更多知识，可以参考“java io系列05之 ObjectInputStream 和 ObjectOutputStream”&nbsp;&nbsp;&nbsp;&nbsp; 然后，新建Box对象。&nbsp;&nbsp;&nbsp;&nbsp; 最后，通过out.writeObject(box) 将box写入到对象输出流中。实际上，相当于将box写入到文件TMP_FILE中。 (04) testRead()函数说明。testRead()的作用就是，从文件中读出Box对象。&nbsp;&nbsp;&nbsp;&nbsp; 首先，新建文件TMP_FILE的文件输入流对象(即FileInputStream对象)，再创建该文件输入流的对象输入流(即ObjectInputStream对象)。&nbsp;&nbsp;&nbsp;&nbsp; 然后，通过in.readObject() 从对象输入流中读取出Box对象。实际上，相当于从文件TMP_FILE中读取Box对象。 通过上面的示例，我们知道：我们可以自定义类，让它支持序列化(即实现Serializable接口)，从而能支持对象的保存/恢复。若要支持序列化，除了“自定义实现Serializable接口的类”之外；java的“基本类型”和“java自带的实现了Serializable接口的类”，都支持序列化。我们通过下面的示例去查看一下。 3. 演示程序2源码如下(SerialTest2.java)： /** * “基本类型” 和 “java自带的实现Serializable接口的类” 对序列化的支持 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Map; import java.util.HashMap; import java.util.Iterator; public class SerialTest2 { private static final String TMP_FILE = &quot;.serialabletest2.txt&quot;; public static void main(String[] args) { testWrite(); testRead(); } /** * ObjectOutputStream 测试函数 */ private static void testWrite() { try { ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); out.writeBoolean(true); // 写入Boolean值 out.writeByte((byte)65);// 写入Byte值 out.writeChar(&apos;a&apos;); // 写入Char值 out.writeInt(20131015); // 写入Int值 out.writeFloat(3.14F); // 写入Float值 out.writeDouble(1.414D);// 写入Double值 // 写入HashMap对象 HashMap map = new HashMap(); map.put(&quot;one&quot;, &quot;red&quot;); map.put(&quot;two&quot;, &quot;green&quot;); map.put(&quot;three&quot;, &quot;blue&quot;); out.writeObject(map); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * ObjectInputStream 测试函数 */ private static void testRead() { try { ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); System.out.printf(&quot;boolean:%b\\n&quot; , in.readBoolean()); System.out.printf(&quot;byte:%d\\n&quot; , (in.readByte()&amp;0xff)); System.out.printf(&quot;char:%c\\n&quot; , in.readChar()); System.out.printf(&quot;int:%d\\n&quot; , in.readInt()); System.out.printf(&quot;float:%f\\n&quot; , in.readFloat()); System.out.printf(&quot;double:%f\\n&quot; , in.readDouble()); // 读取HashMap对象 HashMap map = (HashMap) in.readObject(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); System.out.printf(&quot;%-6s -- %s\\n&quot; , entry.getKey(), entry.getValue()); } in.close(); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： boolean:true byte:65 char:a int:20131015 float:3.140000 double:1.414000 two -- green one -- red three -- blue 源码说明： (01) 程序的作用很简单，就是演示：先将“基本类型数据”和“HashMap对象”，通过对象输出流保存到文件中；之后，再通过对象输入流，将这些保存的数据读取出来。 (02) testWrite()函数说明。testWrite()的作用就是，先将“基本类型数据”和“HashMap对象”，通过对象输出流保存到文件中。&nbsp;&nbsp;&nbsp;&nbsp; 首先，新建文件TMP_FILE的文件输出流对象(即FileOutputStream对象)，再创建该文件输出流的对象输出流(即ObjectOutputStream对象)。&nbsp;&nbsp;&nbsp;&nbsp; 然后，通过 writeBoolean(), writeByte(), … , writeDouble() 等一系列函数将“Boolean, byte, char, … , double等基本数据类型”写入到对象输出流中。实际上，相当于将这些内容写入到文件TMP_FILE中。&nbsp;&nbsp;&nbsp;&nbsp; 最后，新建HashMap对象map，并通过out.writeObject(map) 将map写入到对象输出流中。实际上，相当于map写入到文件TMP_FILE中。&nbsp;&nbsp;&nbsp;&nbsp; 关于HashMap的更多知识，可以参考“[Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例][link_java_collection_10]”。 (03) testRead()函数说明。testRead()的作用就是，从文件中读出testWrite()写入的对象。&nbsp;&nbsp;&nbsp;&nbsp; 首先，新建文件TMP_FILE的文件输入流对象(即FileInputStream对象)，再创建该文件输入流的对象输入流(即ObjectInputStream对象)。&nbsp;&nbsp;&nbsp;&nbsp; 然后，通过in.readObject() 从对象输入流中读取出testWrite()对象。实际上，相当于从文件TMP_FILE中读取出这些对象。 在前面，我们提到过：若要支持序列化，除了“自定义实现Serializable接口的类”之外；java的“基本类型”和“java自带的实现了Serializable接口的类”，都支持序列化。为了验证这句话，我们看看HashMap是否实现了Serializable接口。 HashMap是java.util包中定义的类，它的接口声明如下： public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {} 至此，我们对序列化的认识已经比较深入了：即知道了“序列化的作用和用法”，也知道了“基本类型”、“java自带的支持Serializable接口的类”和“自定义实现Serializable接口的类”都能支持序列化。应付序列化的简单使用应该足够了。但是，我们的目的是对序列化有更深层次的了解！更何况，写此文的作者(也就是区区在下)，应该比各位看官要累(既要写代码，又要总结，还得注意排版和用词，讲的通俗易懂，让各位看得轻松自在)；我这个菜鸟都能做到这些，何况对知识极其渴望的您呢？所以，请深吸一口气，然后继续…… 我们在介绍序列化定义时，说过“序列化/反序列化，是专门用于的保存/恢复对象状态的机制”。从中，我们知道：序列化/反序列化，只支持保存/恢复对象状态，即仅支持保存/恢复类的成员变量，但不支持保存类的成员方法！但是，序列化是不是对类的所有的成员变量的状态都能保存呢？ 答案当然是否定的！(01) 序列化对static和transient变量，是不会自动进行状态保存的。&nbsp;&nbsp;&nbsp;&nbsp; transient的作用就是，用transient声明的变量，不会被自动序列化。(02) 对于Socket, Thread类，不支持序列化。若实现序列化的接口中，有Thread成员；在对该类进行序列化操作时，编译会出错！&nbsp;&nbsp;&nbsp;&nbsp; 这主要是基于资源分配方面的原因。如果Socket，Thread类可以被序列化，但是被反序列化之后也无法对他们进行重新的资源分配；再者，也是没有必要这样实现。 下面，我们还是通过示例来查看“序列化对static和transient的处理”。 4. 演示程序3我们对前面的SerialTest1.java进行简单修改，得到源文件(SerialTest3.java)如下： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class SerialTest3 { private static final String TMP_FILE = &quot;.serialtest3.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象，Box实现了Serializable序列化接口 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类“支持序列化”。因为Box实现了Serializable接口。 * * 实际上，一个类只需要实现Serializable即可实现序列化，而不需要实现任何函数。 */ class Box implements Serializable { private static int width; private transient int height; private String name; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } SerialTest3.java 相比于 SerialTest1.java。仅仅对Box类中的 width 和 height 变量的定义进行了修改。SerialTest1.java 中width和height定义 private int width; private int height; SerialTest3.java 中width和height定义 private static int width; private transient int height; 在看后面的结果之前，我们建议大家对程序进行分析，先自己得出一个结论。 运行结果： testWrite box: [desk: (80, 48) ] testRead box: [desk: (80, 0) ] 结果分析： 我们前面说过，“序列化不对static和transient变量进行状态保存”。因此，testWrite()中保存Box对象时，不会保存width和height的值。这点是毋庸置疑的！但是，为什么testRead()中读取出来的Box对象的width=80，而height=0呢？先说，为什么height=0。因为Box对象中height是int类型，而int类型的默认值是0。再说，为什么width=80。这是因为height是static类型，而static类型就意味着所有的Box对象都共用一个height值；而在testWrite()中，我们已经将height初始化为80了。因此，我们通过序列化读取出来的Box对象的height值，也被就是80。 理解上面的内容之后，我们应该可以推断出下面的代码的运行结果。 源码如下(SerialTest4.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class SerialTest4 { private static final String TMP_FILE = &quot;.serialtest4.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象，Box实现了Serializable序列化接口 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); // 修改box的值 box = new Box(&quot;room&quot;, 100, 50); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类“支持序列化”。因为Box实现了Serializable接口。 * * 实际上，一个类只需要实现Serializable即可实现序列化，而不需要实现任何函数。 */ class Box implements Serializable { private static int width; private transient int height; private String name; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } SerialTest4.java 相比于 SerialTest3.java，在testWrite()中添加了一行代码box = new Box(“room”, 100, 50); 运行结果： testWrite box: [desk: (80, 48) ] testRead box: [desk: (100, 0) ] 现在，我们更加确认“序列化不对static和transient变量进行状态保存”。但是，若我们想要保存static或transient变量，能不能办到呢？当然可以！我们在类中重写两个方法writeObject()和readObject()即可。下面程序演示了如何手动保存static和transient变量。 5. 演示程序4我们对前面的SerialTest4.java进行简单修改，以达到：序列化存储static和transient变量的目的。 源码如下(SerialTest5.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.io.IOException; import java.lang.ClassNotFoundException; public class SerialTest5 { private static final String TMP_FILE = &quot;.serialtest5.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象，Box实现了Serializable序列化接口 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); // 修改box的值 box = new Box(&quot;room&quot;, 100, 50); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类“支持序列化”。因为Box实现了Serializable接口。 * * 实际上，一个类只需要实现Serializable即可实现序列化，而不需要实现任何函数。 */ class Box implements Serializable { private static int width; private transient int height; private String name; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } private void writeObject(ObjectOutputStream out) throws IOException{ out.defaultWriteObject();//使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 out.writeInt(height); out.writeInt(width); //System.out.println(&quot;Box--writeObject width=&quot;+width+&quot;, height=&quot;+height); } private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException{ in.defaultReadObject();//defaultReadObject()补充自动序列化 height = in.readInt(); width = in.readInt(); //System.out.println(&quot;Box---readObject width=&quot;+width+&quot;, height=&quot;+height); } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 运行结果： testWrite box: [desk: (80, 48) ] testRead box: [desk: (80, 48) ] 程序说明： “序列化不会自动保存static和transient变量”，因此我们若要保存它们，则需要通过writeObject()和readObject()去手动读写。(01) 通过writeObject()方法，写入要保存的变量。writeObject的原始定义是在ObjectOutputStream.java中，我们按照如下示例覆盖即可： private void writeObject(ObjectOutputStream out) throws IOException{ out.defaultWriteObject();// 使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 out.writeInt(ival); // 若要保存“int类型的值”，则使用writeInt() out.writeObject(obj); // 若要保存“Object对象”，则使用writeObject() } (02) 通过readObject()方法，读取之前保存的变量。readObject的原始定义是在ObjectInputStream.java中，我们按照如下示例覆盖即可： private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException{ in.defaultReadObject(); // 使定制的readObject()方法可以利用自动序列化中内置的逻辑。 int ival = in.readInt(); // 若要读取“int类型的值”，则使用readInt() Object obj = in.readObject(); // 若要读取“Object对象”，则使用readObject() } 至此，我们就介绍完了“序列化对static和transient变量的处理”。接下来，我们来研究“对于Socket, Thread类，不支持序列化”。还是通过示例来查看。 6. 演示程序5我们修改SerialTest5.java的源码，在Box类中添加一个Thread成员。 源码如下(SerialTest6.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.lang.Thread; import java.io.IOException; import java.lang.ClassNotFoundException; public class SerialTest6 { private static final String TMP_FILE = &quot;.serialtest6.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象，Box实现了Serializable序列化接口 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); // 修改box的值 box = new Box(&quot;room&quot;, 100, 50); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类“支持序列化”。因为Box实现了Serializable接口。 * * 实际上，一个类只需要实现Serializable即可实现序列化，而不需要实现任何函数。 */ class Box implements Serializable { private static int width; private transient int height; private String name; private Thread thread = new Thread() { @Override public void run() { System.out.println(&quot;Serializable thread&quot;); } }; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } private void writeObject(ObjectOutputStream out) throws IOException{ out.defaultWriteObject();//使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 out.writeInt(height); out.writeInt(width); //System.out.println(&quot;Box--writeObject width=&quot;+width+&quot;, height=&quot;+height); } private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException{ in.defaultReadObject();//defaultReadObject()补充自动序列化 height = in.readInt(); width = in.readInt(); //System.out.println(&quot;Box---readObject width=&quot;+width+&quot;, height=&quot;+height); } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 结果是，编译出错！事实证明，不能对Thread进行序列化。若希望程序能编译通过，我们对Thread变量添加static或transient修饰即可！如下，是对Thread添加transient修饰的源码(SerialTest7.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.lang.Thread; import java.io.IOException; import java.lang.ClassNotFoundException; public class SerialTest7 { private static final String TMP_FILE = &quot;.serialtest7.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象，Box实现了Serializable序列化接口 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); // 修改box的值 box = new Box(&quot;room&quot;, 100, 50); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类“支持序列化”。因为Box实现了Serializable接口。 * * 实际上，一个类只需要实现Serializable即可实现序列化，而不需要实现任何函数。 */ class Box implements Serializable { private static int width; private transient int height; private String name; private transient Thread thread = new Thread() { @Override public void run() { System.out.println(&quot;Serializable thread&quot;); } }; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } private void writeObject(ObjectOutputStream out) throws IOException{ out.defaultWriteObject();//使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 out.writeInt(height); out.writeInt(width); //System.out.println(&quot;Box--writeObject width=&quot;+width+&quot;, height=&quot;+height); } private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException{ in.defaultReadObject();//defaultReadObject()补充自动序列化 height = in.readInt(); width = in.readInt(); //System.out.println(&quot;Box---readObject width=&quot;+width+&quot;, height=&quot;+height); } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 至此，关于“Serializable接口”来实现序列化的内容，都说完了。为什么这么说？因为，实现序列化，除了Serializable之外，还有其它的方式，就是通过实现Externalizable来实现序列化。整理下心情，下面继续对Externalizable进行了解。 7. Externalizable和完全定制序列化过程如果一个类要完全负责自己的序列化，则实现Externalizable接口，而不是Serializable接口。 Externalizable接口定义包括两个方法writeExternal()与readExternal()。需要注意的是：声明类实现Externalizable接口会有重大的安全风险。writeExternal()与readExternal()方法声明为public，恶意类可以用这些方法读取和写入对象数据。如果对象包含敏感信息，则要格外小心。 下面，我们修改之前的SerialTest1.java测试程序；将其中的Box由“实现Serializable接口” 改为 “实现Externalizable接口”。修改后的源码如下( ExternalizableTest1.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectOutput; import java.io.ObjectInput; import java.io.Serializable; import java.io.Externalizable; import java.io.IOException; import java.lang.ClassNotFoundException; public class ExternalizableTest1 { private static final String TMP_FILE = &quot;.externalizabletest1.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类实现Externalizable接口 */ class Box implements Externalizable { private int width; private int height; private String name; public Box() { } public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } @Override public void writeExternal(ObjectOutput out) throws IOException { } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 运行结果： testWrite box: [desk: (80, 48) ] testRead box: [null: (0, 0) ] 说明： (01) 实现Externalizable接口的类，不会像实现Serializable接口那样，会自动将数据保存。(02) 实现Externalizable接口的类，必须实现writeExternal()和readExternal()接口！否则，程序无法正常编译！(03) 实现Externalizable接口的类，必须定义不带参数的构造函数！否则，程序无法正常编译！(04) writeExternal() 和 readExternal() 的方法都是public的，不是非常安全！ 接着，我们修改上面的ExternalizableTest1.java测试程序；实现Box类中的writeExternal()和readExternal()接口！修改后的源码如下( ExternalizableTest2.java)： /** * 序列化的演示测试程序 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectOutput; import java.io.ObjectInput; import java.io.Serializable; import java.io.Externalizable; import java.io.IOException; import java.lang.ClassNotFoundException; public class ExternalizableTest2 { private static final String TMP_FILE = &quot;.externalizabletest2.txt&quot;; public static void main(String[] args) { // 将“对象”通过序列化保存 testWrite(); // 将序列化的“对象”读出来 testRead(); } /** * 将Box对象通过序列化，保存到文件中 */ private static void testWrite() { try { // 获取文件TMP_FILE对应的对象输出流。 // ObjectOutputStream中，只能写入“基本数据”或“支持序列化的对象” ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); // 创建Box对象 Box box = new Box(&quot;desk&quot;, 80, 48); // 将box对象写入到对象输出流out中，即相当于将对象保存到文件TMP_FILE中 out.writeObject(box); // 打印“Box对象” System.out.println(&quot;testWrite box: &quot; + box); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * 从文件中读取出“序列化的Box对象” */ private static void testRead() { try { // 获取文件TMP_FILE对应的对象输入流。 ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); // 从对象输入流中，读取先前保存的box对象。 Box box = (Box) in.readObject(); // 打印“Box对象” System.out.println(&quot;testRead box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * Box类实现Externalizable接口 */ class Box implements Externalizable { private int width; private int height; private String name; public Box() { } public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(name); out.writeInt(width); out.writeInt(height); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { name = (String) in.readObject(); width = in.readInt(); height = in.readInt(); } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 运行结果： testWrite box: [desk: (80, 48) ] testRead box: [desk: (80, 48) ]","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列05之 ObjectInputStream和ObjectOutputStream详解","date":"2016-10-04T16:00:00.000Z","path":"2016/10/05/java-source-analysis-io-series/java io系列05之 ObjectInputStream和ObjectOutputStream详解/","text":"本章，我们学习ObjectInputStream 和 ObjectOutputStream 目录1. ObjectInputStream 和 ObjectOutputStream 介绍2. 演示程序 1. ObjectInputStream 和 ObjectOutputStream 介绍ObjectInputStream 和 ObjectOutputStream 的作用是，对基本数据和对象进行序列化操作支持。 创建“文件输出流”对应的ObjectOutputStream对象，该ObjectOutputStream对象能提供对“基本数据或对象”的持久存储；当我们需要读取这些存储的“基本数据或对象”时，可以创建“文件输入流”对应的ObjectInputStream，进而读取出这些“基本数据或对象”。 注意： 只有支持 java.io.Serializable 或 java.io.Externalizable 接口的对象才能被ObjectInputStream/ObjectOutputStream所操作！ ObjectOutputStream 函数列表 // 构造函数 ObjectOutputStream(OutputStream output) // public函数 void close() void defaultWriteObject() void flush() ObjectOutputStream.PutField putFields() void reset() void useProtocolVersion(int version) void write(int value) void write(byte[] buffer, int offset, int length) void writeBoolean(boolean value) void writeByte(int value) void writeBytes(String value) void writeChar(int value) void writeChars(String value) void writeDouble(double value) void writeFields() void writeFloat(float value) void writeInt(int value) void writeLong(long value) final void writeObject(Object object) void writeShort(int value) void writeUTF(String value) void writeUnshared(Object object) ObjectInputStream 函数列表 // 构造函数 ObjectInputStream(InputStream input) int available() void close() void defaultReadObject() int read(byte[] buffer, int offset, int length) int read() boolean readBoolean() byte readByte() char readChar() double readDouble() ObjectInputStream.GetField readFields() float readFloat() void readFully(byte[] dst) void readFully(byte[] dst, int offset, int byteCount) int readInt() String readLine() long readLong() final Object readObject() short readShort() String readUTF() Object readUnshared() int readUnsignedByte() int readUnsignedShort() synchronized void registerValidation(ObjectInputValidation object, int priority) int skipBytes(int length) 2. 演示程序源码如下(ObjectStreamTest.java)： /** * ObjectInputStream 和 ObjectOutputStream 测试程序 * * 注意：通过ObjectInputStream, ObjectOutputStream操作的对象，必须是实现了Serializable或Externalizable序列化接口的类的实例。 * * @author skywang */ import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Map; import java.util.HashMap; import java.util.Iterator; public class ObjectStreamTest { private static final String TMP_FILE = &quot;box.tmp&quot;; public static void main(String[] args) { testWrite(); testRead(); } /** * ObjectOutputStream 测试函数 */ private static void testWrite() { try { ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); out.writeBoolean(true); out.writeByte((byte)65); out.writeChar(&apos;a&apos;); out.writeInt(20131015); out.writeFloat(3.14F); out.writeDouble(1.414D); // 写入HashMap对象 HashMap map = new HashMap(); map.put(&quot;one&quot;, &quot;red&quot;); map.put(&quot;two&quot;, &quot;green&quot;); map.put(&quot;three&quot;, &quot;blue&quot;); out.writeObject(map); // 写入自定义的Box对象，Box实现了Serializable接口 Box box = new Box(&quot;desk&quot;, 80, 48); out.writeObject(box); out.close(); } catch (Exception ex) { ex.printStackTrace(); } } /** * ObjectInputStream 测试函数 */ private static void testRead() { try { ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); System.out.printf(&quot;boolean:%b\\n&quot; , in.readBoolean()); System.out.printf(&quot;byte:%d\\n&quot; , (in.readByte()&amp;0xff)); System.out.printf(&quot;char:%c\\n&quot; , in.readChar()); System.out.printf(&quot;int:%d\\n&quot; , in.readInt()); System.out.printf(&quot;float:%f\\n&quot; , in.readFloat()); System.out.printf(&quot;double:%f\\n&quot; , in.readDouble()); // 读取HashMap对象 HashMap map = (HashMap) in.readObject(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); System.out.printf(&quot;%-6s -- %s\\n&quot; , entry.getKey(), entry.getValue()); } // 读取Box对象，Box实现了Serializable接口 Box box = (Box) in.readObject(); System.out.println(&quot;box: &quot; + box); in.close(); } catch (Exception e) { e.printStackTrace(); } } } class Box implements Serializable { private int width; private int height; private String name; public Box(String name, int width, int height) { this.name = name; this.width = width; this.height = height; } @Override public String toString() { return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; } } 运行结果： boolean:true byte:65 char:a int:20131015 float:3.140000 double:1.414000 two -- green one -- red three -- blue box: [desk: (80, 48) ]","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列04之 管道(PipedOutputStream和PipedInputStream)详解","date":"2016-10-03T16:00:00.000Z","path":"2016/10/04/java-source-analysis-io-series/java io系列04之 管道(PipedOutputStream和PipedInputStream)详解/","text":"本章，我们对java 管道进行学习。 目录1. java 管道介绍2. PipedOutputStream和PipedInputStream源码分析3. 管道通信示例 1. java 管道介绍在java中，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。 它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。 2. PipedOutputStream和PipedInputStream源码分析下面介绍PipedOutputStream和PipedInputStream的源码。在阅读它们的源码之前，建议先看看源码后面的示例。待理解管道的作用和用法之后，再看源码，可能更容易理解。此外，由于在“java io系列03之 ByteArrayOutputStream的简介,源码分析和示例(包括OutputStream)”中已经对PipedOutputStream的父类OutputStream进行了介绍，这里就不再介绍OutputStream。在“java io系列02之 ByteArrayInputStream的简介,源码分析和示例(包括InputStream)”中已经对PipedInputStream的父类InputStream进行了介绍，这里也不再介绍InputStream。 1. PipedOutputStream 源码分析(基于jdk1.7.40)package java.io; import java.io.*; public class PipedOutputStream extends OutputStream { // 与PipedOutputStream通信的PipedInputStream对象 private PipedInputStream sink; // 构造函数，指定配对的PipedInputStream public PipedOutputStream(PipedInputStream snk) throws IOException { connect(snk); } // 构造函数 public PipedOutputStream() { } // 将“管道输出流” 和 “管道输入流”连接。 public synchronized void connect(PipedInputStream snk) throws IOException { if (snk == null) { throw new NullPointerException(); } else if (sink != null || snk.connected) { throw new IOException(&quot;Already connected&quot;); } // 设置“管道输入流” sink = snk; // 初始化“管道输入流”的读写位置 // int是PipedInputStream中定义的，代表“管道输入流”的读写位置 snk.in = -1; // 初始化“管道输出流”的读写位置。 // out是PipedInputStream中定义的，代表“管道输出流”的读写位置 snk.out = 0; // 设置“管道输入流”和“管道输出流”为已连接状态 // connected是PipedInputStream中定义的，用于表示“管道输入流与管道输出流”是否已经连接 snk.connected = true; } // 将int类型b写入“管道输出流”中。 // 将b写入“管道输出流”之后，它会将b传输给“管道输入流” public void write(int b) throws IOException { if (sink == null) { throw new IOException(&quot;Pipe not connected&quot;); } sink.receive(b); } // 将字节数组b写入“管道输出流”中。 // 将数组b写入“管道输出流”之后，它会将其传输给“管道输入流” public void write(byte b[], int off, int len) throws IOException { if (sink == null) { throw new IOException(&quot;Pipe not connected&quot;); } else if (b == null) { throw new NullPointerException(); } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } // “管道输入流”接收数据 sink.receive(b, off, len); } // 清空“管道输出流”。 // 这里会调用“管道输入流”的notifyAll()； // 目的是让“管道输入流”放弃对当前资源的占有，让其它的等待线程(等待读取管道输出流的线程)读取“管道输出流”的值。 public synchronized void flush() throws IOException { if (sink != null) { synchronized (sink) { sink.notifyAll(); } } } // 关闭“管道输出流”。 // 关闭之后，会调用receivedLast()通知“管道输入流”它已经关闭。 public void close() throws IOException { if (sink != null) { sink.receivedLast(); } } } 2. PipedInputStream 源码分析(基于jdk1.7.40)package java.io; public class PipedInputStream extends InputStream { // “管道输出流”是否关闭的标记 boolean closedByWriter = false; // “管道输入流”是否关闭的标记 volatile boolean closedByReader = false; // “管道输入流”与“管道输出流”是否连接的标记 // 它在PipedOutputStream的connect()连接函数中被设置为true boolean connected = false; Thread readSide; // 读取“管道”数据的线程 Thread writeSide; // 向“管道”写入数据的线程 // “管道”的默认大小 private static final int DEFAULT_PIPE_SIZE = 1024; protected static final int PIPE_SIZE = DEFAULT_PIPE_SIZE; // 缓冲区 protected byte buffer[]; //下一个写入字节的位置。in==out代表满，说明“写入的数据”全部被读取了。 protected int in = -1; //下一个读取字节的位置。in==out代表满，说明“写入的数据”全部被读取了。 protected int out = 0; // 构造函数：指定与“管道输入流”关联的“管道输出流” public PipedInputStream(PipedOutputStream src) throws IOException { this(src, DEFAULT_PIPE_SIZE); } // 构造函数：指定与“管道输入流”关联的“管道输出流”，以及“缓冲区大小” public PipedInputStream(PipedOutputStream src, int pipeSize) throws IOException { initPipe(pipeSize); connect(src); } // 构造函数：默认缓冲区大小是1024字节 public PipedInputStream() { initPipe(DEFAULT_PIPE_SIZE); } // 构造函数：指定缓冲区大小是pipeSize public PipedInputStream(int pipeSize) { initPipe(pipeSize); } // 初始化“管道”：新建缓冲区大小 private void initPipe(int pipeSize) { if (pipeSize &lt;= 0) { throw new IllegalArgumentException(&quot;Pipe Size &lt;= 0&quot;); } buffer = new byte[pipeSize]; } // 将“管道输入流”和“管道输出流”绑定。 // 实际上，这里调用的是PipedOutputStream的connect()函数 public void connect(PipedOutputStream src) throws IOException { src.connect(this); } // 接收int类型的数据b。 // 它只会在PipedOutputStream的write(int b)中会被调用 protected synchronized void receive(int b) throws IOException { // 检查管道状态 checkStateForReceive(); // 获取“写入管道”的线程 writeSide = Thread.currentThread(); // 若“写入管道”的数据正好全部被读取完，则等待。 if (in == out) awaitSpace(); if (in &lt; 0) { in = 0; out = 0; } // 将b保存到缓冲区 buffer[in++] = (byte)(b &amp; 0xFF); if (in &gt;= buffer.length) { in = 0; } } // 接收字节数组b。 synchronized void receive(byte b[], int off, int len) throws IOException { // 检查管道状态 checkStateForReceive(); // 获取“写入管道”的线程 writeSide = Thread.currentThread(); int bytesToTransfer = len; while (bytesToTransfer &gt; 0) { // 若“写入管道”的数据正好全部被读取完，则等待。 if (in == out) awaitSpace(); int nextTransferAmount = 0; // 如果“管道中被读取的数据，少于写入管道的数据”； // 则设置nextTransferAmount=“buffer.length - in” if (out &lt; in) { nextTransferAmount = buffer.length - in; } else if (in &lt; out) { // 如果“管道中被读取的数据，大于/等于写入管道的数据”，则执行后面的操作 // 若in==-1(即管道的写入数据等于被读取数据)，此时nextTransferAmount = buffer.length - in; // 否则，nextTransferAmount = out - in; if (in == -1) { in = out = 0; nextTransferAmount = buffer.length - in; } else { nextTransferAmount = out - in; } } if (nextTransferAmount &gt; bytesToTransfer) nextTransferAmount = bytesToTransfer; // assert断言的作用是，若nextTransferAmount &lt;= 0，则终止程序。 assert(nextTransferAmount &gt; 0); // 将数据写入到缓冲中 System.arraycopy(b, off, buffer, in, nextTransferAmount); bytesToTransfer -= nextTransferAmount; off += nextTransferAmount; in += nextTransferAmount; if (in &gt;= buffer.length) { in = 0; } } } // 检查管道状态 private void checkStateForReceive() throws IOException { if (!connected) { throw new IOException(&quot;Pipe not connected&quot;); } else if (closedByWriter || closedByReader) { throw new IOException(&quot;Pipe closed&quot;); } else if (readSide != null &amp;&amp; !readSide.isAlive()) { throw new IOException(&quot;Read end dead&quot;); } } // 等待。 // 若“写入管道”的数据正好全部被读取完(例如，管道缓冲满)，则执行awaitSpace()操作； // 它的目的是让“读取管道的线程”管道产生读取数据请求，从而才能继续的向“管道”中写入数据。 private void awaitSpace() throws IOException { // 如果“管道中被读取的数据，等于写入管道的数据”时， // 则每隔1000ms检查“管道状态”，并唤醒管道操作：若有“读取管道数据线程被阻塞”，则唤醒该线程。 while (in == out) { checkStateForReceive(); /* full: kick any waiting readers */ notifyAll(); try { wait(1000); } catch (InterruptedException ex) { throw new java.io.InterruptedIOException(); } } } // 当PipedOutputStream被关闭时，被调用 synchronized void receivedLast() { closedByWriter = true; notifyAll(); } // 从管道(的缓冲)中读取一个字节，并将其转换成int类型 public synchronized int read() throws IOException { if (!connected) { throw new IOException(&quot;Pipe not connected&quot;); } else if (closedByReader) { throw new IOException(&quot;Pipe closed&quot;); } else if (writeSide != null &amp;&amp; !writeSide.isAlive() &amp;&amp; !closedByWriter &amp;&amp; (in &lt; 0)) { throw new IOException(&quot;Write end dead&quot;); } readSide = Thread.currentThread(); int trials = 2; while (in &lt; 0) { if (closedByWriter) { /* closed by writer, return EOF */ return -1; } if ((writeSide != null) &amp;&amp; (!writeSide.isAlive()) &amp;&amp; (--trials &lt; 0)) { throw new IOException(&quot;Pipe broken&quot;); } /* might be a writer waiting */ notifyAll(); try { wait(1000); } catch (InterruptedException ex) { throw new java.io.InterruptedIOException(); } } int ret = buffer[out++] &amp; 0xFF; if (out &gt;= buffer.length) { out = 0; } if (in == out) { /* now empty */ in = -1; } return ret; } // 从管道(的缓冲)中读取数据，并将其存入到数组b中 public synchronized int read(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } /* possibly wait on the first character */ int c = read(); if (c &lt; 0) { return -1; } b[off] = (byte) c; int rlen = 1; while ((in &gt;= 0) &amp;&amp; (len &gt; 1)) { int available; if (in &gt; out) { available = Math.min((buffer.length - out), (in - out)); } else { available = buffer.length - out; } // A byte is read beforehand outside the loop if (available &gt; (len - 1)) { available = len - 1; } System.arraycopy(buffer, out, b, off + rlen, available); out += available; rlen += available; len -= available; if (out &gt;= buffer.length) { out = 0; } if (in == out) { /* now empty */ in = -1; } } return rlen; } // 返回不受阻塞地从此输入流中读取的字节数。 public synchronized int available() throws IOException { if(in &lt; 0) return 0; else if(in == out) return buffer.length; else if (in &gt; out) return in - out; else return in + buffer.length - out; } // 关闭管道输入流 public void close() throws IOException { closedByReader = true; synchronized (this) { in = -1; } } } 3. 管道通信示例下面，我们看看多线程中通过管道通信的例子。例子中包括3个类：Receiver.java, PipedStreamTest.java 和 Sender.java。 Receiver.java的代码如下： import java.io.IOException; import java.io.PipedInputStream; @SuppressWarnings(&quot;all&quot;) /** * 接收者线程 */ public class Receiver extends Thread { // 管道输入流对象。 // 它和“管道输出流(PipedOutputStream)”对象绑定， // 从而可以接收“管道输出流”的数据，再让用户读取。 private PipedInputStream in = new PipedInputStream(); // 获得“管道输入流”对象 public PipedInputStream getInputStream(){ return in; } @Override public void run(){ readMessageOnce() ; //readMessageContinued() ; } // 从“管道输入流”中读取1次数据 public void readMessageOnce(){ // 虽然buf的大小是2048个字节，但最多只会从“管道输入流”中读取1024个字节。 // 因为，“管道输入流”的缓冲区大小默认只有1024个字节。 byte[] buf = new byte[2048]; try { int len = in.read(buf); System.out.println(new String(buf,0,len)); in.close(); } catch (IOException e) { e.printStackTrace(); } } // 从“管道输入流”读取&gt;1024个字节时，就停止读取 public void readMessageContinued() { int total=0; while(true) { byte[] buf = new byte[1024]; try { int len = in.read(buf); total += len; System.out.println(new String(buf,0,len)); // 若读取的字节总数&gt;1024，则退出循环。 if (total &gt; 1024) break; } catch (IOException e) { e.printStackTrace(); } } try { in.close(); } catch (IOException e) { e.printStackTrace(); } } } Sender.java的代码如下： import java.io.IOException; import java.io.PipedOutputStream; @SuppressWarnings(&quot;all&quot;) /** * 发送者线程 */ public class Sender extends Thread { // 管道输出流对象。 // 它和“管道输入流(PipedInputStream)”对象绑定， // 从而可以将数据发送给“管道输入流”的数据，然后用户可以从“管道输入流”读取数据。 private PipedOutputStream out = new PipedOutputStream(); // 获得“管道输出流”对象 public PipedOutputStream getOutputStream(){ return out; } @Override public void run(){ writeShortMessage(); //writeLongMessage(); } // 向“管道输出流”中写入一则较简短的消息：&quot;this is a short message&quot; private void writeShortMessage() { String strInfo = &quot;this is a short message&quot; ; try { out.write(strInfo.getBytes()); out.close(); } catch (IOException e) { e.printStackTrace(); } } // 向“管道输出流”中写入一则较长的消息 private void writeLongMessage() { StringBuilder sb = new StringBuilder(); // 通过for循环写入1020个字节 for (int i=0; i&lt;102; i++) sb.append(&quot;0123456789&quot;); // 再写入26个字节。 sb.append(&quot;abcdefghijklmnopqrstuvwxyz&quot;); // str的总长度是1020+26=1046个字节 String str = sb.toString(); try { // 将1046个字节写入到“管道输出流”中 out.write(str.getBytes()); out.close(); } catch (IOException e) { e.printStackTrace(); } } } PipedStreamTest.java的代码如下： import java.io.PipedInputStream; import java.io.PipedOutputStream; import java.io.IOException; @SuppressWarnings(&quot;all&quot;) /** * 管道输入流和管道输出流的交互程序 */ public class PipedStreamTest { public static void main(String[] args) { Sender t1 = new Sender(); Receiver t2 = new Receiver(); PipedOutputStream out = t1.getOutputStream(); PipedInputStream in = t2.getInputStream(); try { //管道连接。下面2句话的本质是一样。 //out.connect(in); in.connect(out); /** * Thread类的START方法： * 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 * 结果是两个线程并发地运行；当前线程（从调用返回给 start 方法）和另一个线程（执行其 run 方法）。 * 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 */ t1.start(); t2.start(); } catch (IOException e) { e.printStackTrace(); } } } 运行结果： this is a short message 说明：(01) in.connect(out);将“管道输入流”和“管道输出流”关联起来。查看PipedOutputStream.java和PipedInputStream.java中connect()的源码；我们知道 out.connect(in); 等价于 in.connect(out); (02)t1.start(); // 启动“Sender”线程t2.start(); // 启动“Receiver”线程先查看Sender.java的源码，线程启动后执行run()函数；在Sender.java的run()中，调用writeShortMessage();writeShortMessage();的作用就是向“管道输出流”中写入数据”this is a short message” ；这条数据会被“管道输入流”接收到。下面看看这是如何实现的。先看write(byte b[])的源码，在OutputStream.java中定义。PipedOutputStream.java继承于OutputStream.java；OutputStream.java中write(byte b[])的源码如下： public void write(byte b[]) throws IOException { write(b, 0, b.length); } 实际上write(byte b[])是调用的PipedOutputStream.java中的write(byte b[], int off, int len)函数。查看write(byte b[], int off, int len)的源码，我们发现：它会调用 sink.receive(b, off, len); 进一步查看receive(byte b[], int off, int len)的定义，我们知道sink.receive(b, off, len)的作用就是：将“管道输出流”中的数据保存到“管道输入流”的缓冲中。而“管道输入流”的缓冲区buffer的默认大小是1024个字节。 至此，我们知道：t1.start()启动Sender线程，而Sender线程会将数据”this is a short message”写入到“管道输出流”；而“管道输出流”又会将该数据传输给“管道输入流”，即而保存在“管道输入流”的缓冲中。 接下来，我们看看“用户如何从‘管道输入流’的缓冲中读取数据”。这实际上就是Receiver线程的动作。t2.start() 会启动Receiver线程，从而执行Receiver.java的run()函数。查看Receiver.java的源码，我们知道run()调用了readMessageOnce()。而readMessageOnce()就是调用in.read(buf)从“管道输入流in”中读取数据，并保存到buf中。通过上面的分析，我们已经知道“管道输入流in”的缓冲中的数据是”this is a short message”；因此，buf的数据就是”this is a short message”。 为了加深对管道的理解。我们接着进行下面两个小试验。 试验一：修改Sender.java 将 public void run(){ writeShortMessage(); //writeLongMessage(); } 修改为 public void run(){ //writeShortMessage(); writeLongMessage(); } 运行程序。运行结果为： 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 012345678901234567890123456789abcd 这些数据是通过writeLongMessage()写入到“管道输出流”，然后传送给“管道输入流”，进而存储在“管道输入流”的缓冲中；再被用户从缓冲读取出来的数据。然后，观察writeLongMessage()的源码。我们可以发现，str的长度是1046个字节，然后运行结果只有1024个字节！为什么会这样呢？道理很简单：管道输入流的缓冲区默认大小是1024个字节。所以，最多只能写入1024个字节。 观察PipedInputStream.java的源码，我们能了解的更透彻。 private static final int DEFAULT_PIPE_SIZE = 1024; public PipedInputStream() { initPipe(DEFAULT_PIPE_SIZE); } 默认构造函数调用initPipe(DEFAULT_PIPE_SIZE)，它的源码如下： private void initPipe(int pipeSize) { if (pipeSize &lt;= 0) { throw new IllegalArgumentException(&quot;Pipe Size &lt;= 0&quot;); } buffer = new byte[pipeSize]; } 从中，我们可以知道缓冲区buffer的默认大小就是1024个字节。 试验二： 在“试验一”的基础上继续修改Receiver.java 将 public void run(){ readMessageOnce() ; //readMessageContinued() ; } 修改为 public void run(){ //readMessageOnce() ; readMessageContinued() ; } 运行程序。运行结果为： 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 012345678901234567890123456789abcd efghijklmnopqrstuvwxyz 这个结果才是writeLongMessage()写入到“输入缓冲区”的完整数据。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列03之 ByteArrayOutputStream详解","date":"2016-10-02T16:00:00.000Z","path":"2016/10/03/java-source-analysis-io-series/java io系列03之 ByteArrayOutputStream详解/","text":"前面学习ByteArrayInputStream，了解了“输入流”。接下来，我们学习与ByteArrayInputStream相对应的输出流，即ByteArrayOutputStream。本章，我们会先对ByteArrayOutputStream进行介绍，在了解了它的源码之后，再通过示例来掌握如何使用它。 目录1. ByteArrayOutputStream 介绍2. OutputStream和ByteArrayOutputStream源码分析3. 示例代码 1. ByteArrayOutputStream 介绍ByteArrayOutputStream 是字节数组输出流。它继承于OutputStream。 ByteArrayOutputStream 中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。 OutputStream 函数列表 我们来看看ByteArrayOutputStream的父类OutputStream的函数接口。 // 构造函数 OutputStream() void close() void flush() void write(byte[] buffer, int offset, int count) void write(byte[] buffer) abstract void write(int oneByte) ByteArrayOutputStream 函数列表 // 构造函数 ByteArrayOutputStream() ByteArrayOutputStream(int size) void close() synchronized void reset() int size() synchronized byte[] toByteArray() String toString(int hibyte) String toString(String charsetName) String toString() synchronized void write(byte[] buffer, int offset, int len) synchronized void write(int oneByte) synchronized void writeTo(OutputStream out) 2. OutputStream和ByteArrayOutputStream源码分析OutputStream是ByteArrayOutputStream的父类，我们先看看OutputStream的源码，然后再学ByteArrayOutputStream的源码。 1. OutputStream.java源码分析(基于jdk1.7.40)package java.io; public abstract class OutputStream implements Closeable, Flushable { // 将字节b写入到“输出流”中。 // 它在子类中实现！ public abstract void write(int b) throws IOException; // 写入字节数组b到“字节数组输出流”中。 public void write(byte b[]) throws IOException { write(b, 0, b.length); } // 写入字节数组b到“字节数组输出流”中，并且off是“数组b的起始位置”，len是写入的长度 public void write(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) &gt; b.length) || ((off + len) &lt; 0)) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return; } for (int i = 0 ; i &lt; len ; i++) { write(b[off + i]); } } public void flush() throws IOException { } public void close() throws IOException { } } 2. ByteArrayOutputStream 源码分析(基于jdk1.7.40)package java.io; import java.util.Arrays; public class ByteArrayOutputStream extends OutputStream { // 保存“字节数组输出流”数据的数组 protected byte buf[]; // “字节数组输出流”的计数 protected int count; // 构造函数：默认创建的字节数组大小是32。 public ByteArrayOutputStream() { this(32); } // 构造函数：创建指定数组大小的“字节数组输出流” public ByteArrayOutputStream(int size) { if (size &lt; 0) { throw new IllegalArgumentException(&quot;Negative initial size: &quot; + size); } buf = new byte[size]; } // 确认“容量”。 // 若“实际容量 &lt; minCapacity”，则增加“字节数组输出流”的容量 private void ensureCapacity(int minCapacity) { // overflow-conscious code if (minCapacity - buf.length &gt; 0) grow(minCapacity); } // 增加“容量”。 private void grow(int minCapacity) { int oldCapacity = buf.length; // “新容量”的初始化 = “旧容量”x2 int newCapacity = oldCapacity &lt;&lt; 1; // 比较“新容量”和“minCapacity”的大小，并选取其中较大的数为“新的容量”。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity &lt; 0) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; } buf = Arrays.copyOf(buf, newCapacity); } // 写入一个字节b到“字节数组输出流”中，并将计数+1 public synchronized void write(int b) { ensureCapacity(count + 1); buf[count] = (byte) b; count += 1; } // 写入字节数组b到“字节数组输出流”中。off是“写入字节数组b的起始位置”，len是写入的长度 public synchronized void write(byte b[], int off, int len) { if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) || ((off + len) - b.length &gt; 0)) { throw new IndexOutOfBoundsException(); } ensureCapacity(count + len); System.arraycopy(b, off, buf, count, len); count += len; } // 写入输出流outb到“字节数组输出流”中。 public synchronized void writeTo(OutputStream out) throws IOException { out.write(buf, 0, count); } // 重置“字节数组输出流”的计数。 public synchronized void reset() { count = 0; } // 将“字节数组输出流”转换成字节数组。 public synchronized byte toByteArray()[] { return Arrays.copyOf(buf, count); } // 返回“字节数组输出流”当前计数值 public synchronized int size() { return count; } public synchronized String toString() { return new String(buf, 0, count); } public synchronized String toString(String charsetName) throws UnsupportedEncodingException { return new String(buf, 0, count, charsetName); } @Deprecated public synchronized String toString(int hibyte) { return new String(buf, hibyte, 0, count); } public void close() throws IOException { } } 说明：ByteArrayOutputStream实际上是将字节数据写入到“字节数组”中去。(01) 通过ByteArrayOutputStream()创建的“字节数组输出流”对应的字节数组大小是32。(02) 通过ByteArrayOutputStream(int size) 创建“字节数组输出流”，它对应的字节数组大小是size。(03) write(int oneByte)的作用将int类型的oneByte换成byte类型，然后写入到输出流中。(04) write(byte[] buffer, int offset, int len) 是将字节数组buffer写入到输出流中，offset是从buffer中读取数据的起始偏移位置，len是读取的长度。(05) writeTo(OutputStream out) 将该“字节数组输出流”的数据全部写入到“输出流out”中。 3. 示例代码关于ByteArrayOutputStream中API的详细用法，参考示例代码(ByteArrayOutputStreamTest.java)： import java.io.IOException; import java.io.OutputStream; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; /** * ByteArrayOutputStream 测试程序 * * @author skywang */ public class ByteArrayOutputStreamTest { private static final int LEN = 5; // 对应英文字母“abcddefghijklmnopqrsttuvwxyz” private static final byte[] ArrayLetters = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A }; public static void main(String[] args) { //String tmp = new String(ArrayLetters); //System.out.println(&quot;ArrayLetters=&quot;+tmp); tesByteArrayOutputStream() ; } /** * ByteArrayOutputStream的API测试函数 */ private static void tesByteArrayOutputStream() { // 创建ByteArrayOutputStream字节流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 依次写入“A”、“B”、“C”三个字母。0x41对应A，0x42对应B，0x43对应C。 baos.write(0x41); baos.write(0x42); baos.write(0x43); System.out.printf(&quot;baos=%s\\n&quot;, baos); // 将ArrayLetters数组中从“3”开始的后5个字节写入到baos中。 // 即对应写入“0x64, 0x65, 0x66, 0x67, 0x68”，即“defgh” baos.write(ArrayLetters, 3, 5); System.out.printf(&quot;baos=%s\\n&quot;, baos); // 计算长度 int size = baos.size(); System.out.printf(&quot;size=%s\\n&quot;, size); // 转换成byte[]数组 byte[] buf = baos.toByteArray(); String str = new String(buf); System.out.printf(&quot;str=%s\\n&quot;, str); // 将baos写入到另一个输出流中 try { ByteArrayOutputStream baos2 = new ByteArrayOutputStream(); baos.writeTo((OutputStream)baos2); System.out.printf(&quot;baos2=%s\\n&quot;, baos2); } catch (IOException e) { e.printStackTrace(); } } } 运行结果： baos=ABC baos=ABCdefgh size=8 str=ABCdefgh baos2=ABCdefgh","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列02之 ByteArrayInputStream详解","date":"2016-10-01T16:00:00.000Z","path":"2016/10/02/java-source-analysis-io-series/java io系列02之 ByteArrayInputStream详解/","text":"我们以ByteArrayInputStream，拉开对字节类型的“输入流”的学习序幕。本章，我们会先对ByteArrayInputStream进行介绍，然后深入了解一下它的源码，最后通过示例来掌握它的用法。 目录1. ByteArrayInputStream 介绍2. InputStream和ByteArrayInputStream源码分析3. 示例代码 1. ByteArrayInputStream 介绍ByteArrayInputStream 是字节数组输入流。它继承于InputStream。 它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而ByteArrayInputStream本质就是通过字节数组来实现的。我们都知道，InputStream通过read()向外提供接口，供它们来读取字节数据；而ByteArrayInputStream 的内部额外的定义了一个计数器，它被用来跟踪 read() 方法要读取的下一个字节。 InputStream 函数列表 // 构造函数 InputStream() int available() void close() void mark(int readlimit) boolean markSupported() int read(byte[] buffer) abstract int read() int read(byte[] buffer, int offset, int length) synchronized void reset() long skip(long byteCount) ByteArrayInputStream 函数列表 // 构造函数 ByteArrayInputStream(byte[] buf) ByteArrayInputStream(byte[] buf, int offset, int length) synchronized int available() void close() synchronized void mark(int readlimit) boolean markSupported() synchronized int read() synchronized int read(byte[] buffer, int offset, int length) synchronized void reset() synchronized long skip(long byteCount) 2. InputStream和ByteArrayInputStream源码分析InputStream是ByteArrayInputStream的父类，我们先看看InputStream的源码，然后再学ByteArrayInputStream的源码。 1. InputStream.java源码分析(基于jdk1.7.40) package java.io; public abstract class InputStream implements Closeable { // 能skip的大小 private static final int MAX_SKIP_BUFFER_SIZE = 2048; // 从输入流中读取数据的下一个字节。 public abstract int read() throws IOException; // 将数据从输入流读入 byte 数组。 public int read(byte b[]) throws IOException { return read(b, 0, b.length); } // 将最多 len 个数据字节从此输入流读入 byte 数组。 public int read(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } int c = read(); if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i &lt; len ; i++) { c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; } // 跳过输入流中的n个字节 public long skip(long n) throws IOException { long remaining = n; int nr; if (n &lt;= 0) { return 0; } int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining); byte[] skipBuffer = new byte[size]; while (remaining &gt; 0) { nr = read(skipBuffer, 0, (int)Math.min(size, remaining)); if (nr &lt; 0) { break; } remaining -= nr; } return n - remaining; } public int available() throws IOException { return 0; } public void close() throws IOException {} public synchronized void mark(int readlimit) {} public synchronized void reset() throws IOException { throw new IOException(&quot;mark/reset not supported&quot;); } public boolean markSupported() { return false; } } 2. ByteArrayInputStream.java源码分析(基于jdk1.7.40) package java.io; public class ByteArrayInputStream extends InputStream { // 保存字节输入流数据的字节数组 protected byte buf[]; // 下一个会被读取的字节的索引 protected int pos; // 标记的索引 protected int mark = 0; // 字节流的长度 protected int count; // 构造函数：创建一个内容为buf的字节流 public ByteArrayInputStream(byte buf[]) { // 初始化“字节流对应的字节数组为buf” this.buf = buf; // 初始化“下一个要被读取的字节索引号为0” this.pos = 0; // 初始化“字节流的长度为buf的长度” this.count = buf.length; } // 构造函数：创建一个内容为buf的字节流，并且是从offset开始读取数据，读取的长度为length public ByteArrayInputStream(byte buf[], int offset, int length) { // 初始化“字节流对应的字节数组为buf” this.buf = buf; // 初始化“下一个要被读取的字节索引号为offset” this.pos = offset; // 初始化“字节流的长度” this.count = Math.min(offset + length, buf.length); // 初始化“标记的字节流读取位置” this.mark = offset; } // 读取下一个字节 public synchronized int read() { return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1; } // 将“字节流的数据写入到字节数组b中” // off是“字节数组b的偏移地址”，表示从数组b的off开始写入数据 // len是“写入的字节长度” public synchronized int read(byte b[], int off, int len) { if (b == null) { throw new NullPointerException(); } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) { throw new IndexOutOfBoundsException(); } if (pos &gt;= count) { return -1; } int avail = count - pos; if (len &gt; avail) { len = avail; } if (len &lt;= 0) { return 0; } System.arraycopy(buf, pos, b, off, len); pos += len; return len; } // 跳过“字节流”中的n个字节。 public synchronized long skip(long n) { long k = count - pos; if (n &lt; k) { k = n &lt; 0 ? 0 : n; } pos += k; return k; } // “能否读取字节流的下一个字节” public synchronized int available() { return count - pos; } // 是否支持“标签” public boolean markSupported() { return true; } // 保存当前位置。readAheadLimit在此处没有任何实际意义 public void mark(int readAheadLimit) { mark = pos; } // 重置“字节流的读取索引”为“mark所标记的位置” public synchronized void reset() { pos = mark; } public void close() throws IOException { } } 说明：ByteArrayInputStream实际上是通过“字节数组”去保存数据。(01) 通过ByteArrayInputStream(byte buf[]) 或 ByteArrayInputStream(byte buf[], int offset, int length) ，我们可以根据buf数组来创建字节流对象。(02) read()的作用是从字节流中“读取下一个字节”。(03) read(byte[] buffer, int offset, int length)的作用是从字节流读取字节数据，并写入到字节数组buffer中。offset是将字节写入到buffer的起始位置，length是写入的字节的长度。(04) markSupported()是判断字节流是否支持“标记功能”。它一直返回true。(05) mark(int readlimit)的作用是记录标记位置。记录标记位置之后，某一时刻调用reset()则将“字节流下一个被读取的位置”重置到“mark(int readlimit)所标记的位置”；也就是说，reset()之后再读取字节流时，是从mark(int readlimit)所标记的位置开始读取。 3. 示例代码关于ByteArrayInputStream中API的详细用法，参考示例代码(ByteArrayInputStreamTest.java)： import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; /** * ByteArrayInputStream 测试程序 * * @author skywang */ public class ByteArrayInputStreamTest { private static final int LEN = 5; // 对应英文字母“abcddefghijklmnopqrsttuvwxyz” private static final byte[] ArrayLetters = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A }; public static void main(String[] args) { String tmp = new String(ArrayLetters); System.out.println(&quot;ArrayLetters=&quot;+tmp); tesByteArrayInputStream() ; } /** * ByteArrayInputStream的API测试函数 */ private static void tesByteArrayInputStream() { // 创建ByteArrayInputStream字节流，内容是ArrayLetters数组 ByteArrayInputStream bais = new ByteArrayInputStream(ArrayLetters); // 从字节流中读取5个字节 for (int i=0; i&lt;LEN; i++) { // 若能继续读取下一个字节，则读取下一个字节 if (bais.available() &gt;= 0) { // 读取“字节流的下一个字节” int tmp = bais.read(); System.out.printf(&quot;%d : 0x%s\\n&quot;, i, Integer.toHexString(tmp)); } } // 若“该字节流”不支持标记功能，则直接退出 if (!bais.markSupported()) { System.out.println(&quot;make not supported!&quot;); return ; } // 标记“字节流中下一个被读取的位置”。即--标记“0x66”，因为因为前面已经读取了5个字节，所以下一个被读取的位置是第6个字节” // (01), ByteArrayInputStream类的mark(0)函数中的“参数0”是没有实际意义的。 // (02), mark()与reset()是配套的，reset()会将“字节流中下一个被读取的位置”重置为“mark()中所保存的位置” bais.mark(0); // 跳过5个字节。跳过5个字节后，字节流中下一个被读取的值应该是“0x6B”。 bais.skip(5); // 从字节流中读取5个数据。即读取“0x6B, 0x6C, 0x6D, 0x6E, 0x6F” byte[] buf = new byte[LEN]; bais.read(buf, 0, LEN); // 将buf转换为String字符串。“0x6B, 0x6C, 0x6D, 0x6E, 0x6F”对应字符是“klmno” String str1 = new String(buf); System.out.printf(&quot;str1=%s\\n&quot;, str1); // 重置“字节流”：即，将“字节流中下一个被读取的位置”重置到“mark()所标记的位置”，即0x66。 bais.reset(); // 从“重置后的字节流”中读取5个字节到buf中。即读取“0x66, 0x67, 0x68, 0x69, 0x6A” bais.read(buf, 0, LEN); // 将buf转换为String字符串。“0x66, 0x67, 0x68, 0x69, 0x6A”对应字符是“fghij” String str2 = new String(buf); System.out.printf(&quot;str2=%s\\n&quot;, str2); } } 运行结果： ArrayLetters=abcdefghijklmnopqrstuvwxyz 0 : 0x61 1 : 0x62 2 : 0x63 3 : 0x64 4 : 0x65 str1=klmno str2=fghij 结果说明： (01) ArrayLetters 是字节数组。0x61对应的ASCII码值是a，0x62对应的ASCII码值是b，依次类推…(02) ByteArrayInputStream bais = new ByteArrayInputStream(ArrayLetters); 这句话是创建“字节流bais”，它的内容就是ArrayLetters。(03) for (int i=0; i&lt;LEN; i++) ; 这个for循环的作用就是从字节流中读取5个字节。每次调用bais.read()就从字节流中读取一个字节。(04) bais.mark(0); 这句话就是“设置字节流的标记”，此时标记的位置对应的值是0x66。(05) bais.skip(5); 这句话是跳过5个字节。跳过5个字节后，对应的字节流中下一个被读取的字节的值是0x6B。(06) bais.read(buf, 0, LEN); 这句话是“从字节流中读取LEN个数据写入到buf中，0表示从buf的第0个位置开始写入”。(07) bais.reset(); 这句话是将“字节流中下一个被读取的位置”重置到“mark()所标记的位置”，即0x66。 学完了ByteArrayInputStream输入流。下面，我们学习与之对应的输出流ByteArrayOutputStream。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"java io系列01之 IO框架","date":"2016-09-30T16:00:00.000Z","path":"2016/10/01/java-source-analysis-io-series/java io系列01之 IO框架/","text":"关于java的io部分，以前学习过。当时学习的节奏是，首先了解io的相关介绍，再查看io的使用示例，最后才是打开API参考文档并参考文档通过写demo来学习。结果，当时是了解了API的使用方法；可是一段时间之后，只能零零碎碎的记得一些片段，再要自己讲出个所以然来，已经非常之艰难。之所以造成这种困境，我想主要是：一，学习的时候，理解的不够彻底，没有真正理解它的思想和框架。二，加之后来使用的较少，加速了遗忘的速度。在这里面，最根本的问题还是理解，使用的目的也是为了更加深入的理解。 最近，抽空整理以前所学的java基础。整理也就是重新学习的过程，在这个学习过程中，我一直尝试着站在一个更高的角度来看问题，将这些类和接口的原理和思想理解的更加透彻一些！在这里，将所学的东西分享出来，一是共同提高；再者，有不足的地方或好的建议，还希望各位读者能指出。谢谢！ 1. java io简介java io系统的设计初衷，就是为了实现“文件、控制台、网络设备”这些io设置的通信。例如，对于一个文件，我们可以打开文件，然后进行读取和写入。 在java 1.0中，java提供的类都是以字节(byte)为单位，例如，FileInputStream和FileOutputStream。而到了java 1.1，为了与国际化进行接轨，在java io中添加了许多以字符(Unicode)为单位进行操作的类。 在java io的称呼中，我们经常会提到“输入流”、“输出流”等等概念。首先，什么是流呢？所谓“流”，就是一种抽象的数据的总称，它的本质是能够进行传输。&nbsp;&nbsp;&nbsp;&nbsp; a) 按照“流”的数据流向，可以将其化分为：输入流和输出流。&nbsp;&nbsp;&nbsp;&nbsp; b) 按照“流”中处理数据的单位，可以将其区分为：字节流和字符流。在java中，字节是占1个Byte，即8位；而字符是占2个Byte，即16位。而且，需要注意的是，java的字节是有符号类型，而字符是无符号类型！ 2. java io框架有了上面的基本概念之后，我们看看java io的框架。 2.1 以字节为单位的输入流的框架图下面，是以字节为单位的输入流的框架图。 img 从中，我们可以看出。(01) InputStream 是以字节为单位的输入流的超类。InputStream提供了read()接口从输入流中读取字节数据。(02) ByteArrayInputStream 是字节数组输入流。它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而ByteArrayInputStream本质就是通过字节数组来实现的。(03) PipedInputStream 是管道输入流，它和PipedOutputStream一起使用，能实现多线程间的管道通信。(04) FilterInputStream 是过滤输入流。它是DataInputStream和BufferedInputStream的超类。(05) DataInputStream 是数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。(06) BufferedInputStream 是缓冲输入流。它的作用是为另一个输入流添加缓冲功能。(07) File 是“文件”和“目录路径名”的抽象表示形式。关于File，注意两点：&nbsp;&nbsp;&nbsp;&nbsp; a), File不仅仅只是表示文件，它也可以表示目录！&nbsp;&nbsp;&nbsp;&nbsp; b), File虽然在io保重定义，但是它的超类是Object，而不是InputStream。(08) FileDescriptor 是“文件描述符”。它可以被用来表示开放文件、开放套接字等。(09) FileInputStream 是文件输入流。它通常用于对文件进行读取操作。(10) ObjectInputStream 是对象输入流。它和ObjectOutputStream一起，用来提供对“基本数据或对象”的持久存储。 2.2 以字节为单位的输出流的框架图下面，是以字节为单位的输出流的框架图。 img 从中，我们可以看出。以字节为单位的输出流的公共父类是OutputStream。(01) OutputStream 是以字节为单位的输出流的超类。OutputStream提供了write()接口从输出流中读取字节数据。(02) ByteArrayOutputStream 是字节数组输出流。写入ByteArrayOutputStream的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。(03) PipedOutputStream 是管道输出流，它和PipedInputStream一起使用，能实现多线程间的管道通信。(04) FilterOutputStream 是过滤输出流。它是DataOutputStream，BufferedOutputStream和PrintStream的超类。(05) DataOutputStream 是数据输出流。它是用来装饰其它输出流，它“允许应用程序以与机器无关方式向底层写入基本 Java 数据类型”。(06) BufferedOutputStream 是缓冲输出流。它的作用是为另一个输出流添加缓冲功能。(07) PrintStream 是打印输出流。它是用来装饰其它输出流，能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。(08) FileOutputStream 是文件输出流。它通常用于向文件进行写入操作。(09) ObjectOutputStream 是对象输出流。它和ObjectInputStream一起，用来提供对“基本数据或对象”的持久存储。 2.3 以字节为单位的输入流和输出流关联的框架图输入流和输出流都有对应的关系，下面是将以字节为单位的输入流和输出流关联起来的图片。 img 2.4 以字符为单位的输入流的框架图下面，是以字符为单位的输入流的框架图。 img 从中，我们可以看出。以字符为单位的输入流的公共父类是Reader。(01) Reader 是以字符为单位的输入流的超类。它提供了read()接口来取字符数据。(02) CharArrayReader 是字符数组输入流。它用于读取字符数组，它继承于Reader。操作的数据是以字符为单位！(03) PipedReader 是字符类型的管道输入流。它和PipedWriter一起是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedReader配套使用。(04) FilterReader 是字符类型的过滤输入流。(05) BufferedReader 是字符缓冲输入流。它的作用是为另一个输入流添加缓冲功能。(06) InputStreamReader 是字节转字符的输入流。它是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(07) FileReader 是字符类型的文件输入流。它通常用于对文件进行读取操作。 2.5 以字符为单位的输出流的框架图下面，是以字符为单位的输出流的框架图。 img (01) Writer 是以字符为单位的输出流的超类。它提供了write()接口往其中写入数据。(02) CharArrayWriter 是字符数组输出流。它用于读取字符数组，它继承于Writer。操作的数据是以字符为单位！(03) PipedWriter 是字符类型的管道输出流。它和PipedReader一起是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedWriter配套使用。(04) FilterWriter 是字符类型的过滤输出流。(05) BufferedWriter 是字符缓冲输出流。它的作用是为另一个输出流添加缓冲功能。(06) OutputStreamWriter 是字节转字符的输出流。它是字节流通向字符流的桥梁：它使用指定的 charset 将字节转换为字符并写入。(07) FileWriter 是字符类型的文件输出流。它通常用于对文件进行读取操作。(08) PrintWriter 是字符类型的打印输出流。它是用来装饰其它输出流，能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。 2.6 以字符为单位的输入流和输出流关联的框架图下面是将以字符为单位的输入流和输出流关联起来的图片。 img 2.7 字节转换为字符流的框架图在java中，字节流能转换为字符流，下面是它们的转换关系图。 img 从中，我们可以看出。(01) FileReader继承于InputStreamReader，而InputStreamReader依赖于InputStream。具体表现在InputStreamReader的构造函数是以InputStream为参数。我们传入InputStream，在InputStreamReader内部通过转码，将字节转换成字符。(02) FileWriter继承于OutputStreamWriter，而OutputStreamWriter依赖于OutputStream。具体表现在OutputStreamWriter的构造函数是以OutputStream为参数。我们传入OutputStream，在OutputStreamWriter内部通过转码，将字节转换成字符。 2.8 字节和字符的输入流对应关系 img 2.9 字节和字符的输出流对应关系 img 认识了java io的总体框架之后。接下来，我们可以开始对其中的各个类进入学习，包括“它的作用和用法，源码的探索”等方面。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"},{"name":"Java IO系列","slug":"Java-IO系列","permalink":"https://smuwjs.github.io/tags/Java-IO系列/"}]},{"title":"Android Studio系列教程六--Gradle多渠道打包","date":"2016-09-11T17:01:06.000Z","path":"2016/09/12/android-studio-tutorial6/","text":"原文地址 由于国内Android市场众多渠道，为了统计每个渠道的下载及其它数据统计，就需要我们针对每个渠道单独打包，如果让你打几十个市场的包岂不烦死了，不过有了Gradle，这再也不是事了。 友盟多渠道打包废话不多说，以友盟统计为例，在AndroidManifest.xml里面会有这么一段： 123&lt;meta-data android:name=\"UMENG_CHANNEL\" android:value=\"Channel_ID\" /&gt; 里面的Channel_ID就是渠道标示。我们的目标就是在编译的时候这个值能够自动变化。 第一步 在AndroidManifest.xml里配置PlaceHolder 123&lt;meta-data android:name=\"UMENG_CHANNEL\" android:value=\"$&#123;UMENG_CHANNEL_VALUE&#125;\" /&gt; 第二步 在build.gradle设置productFlavors 12345678910111213141516android &#123; productFlavors &#123; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"xiaomi\"] &#125; _360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"_360\"] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"baidu\"] &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"wandoujia\"] &#125; &#125; &#125; 或者批量修改 123456789101112android &#123; productFlavors &#123; xiaomi &#123;&#125; _360 &#123;&#125; baidu &#123;&#125; wandoujia &#123;&#125; &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;&#125; 很简单清晰有没有？直接执行 ./gradlew assembleRelease ， 然后就可以静静的喝杯咖啡等待打包完成吧。 assemble结合Build Variants来创建task上一篇博客介绍了 assemble 这个命令，会结合 Build Type 创建自己的task，如: ./gradlew assembleDebug ./gradlew assembleRelease 除此之外 assemble 还能和 Product Flavor 结合创建新的任务，其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor ， 举个例子大家就明白了： 如果我们想打包wandoujia渠道的release版本，执行如下命令就好了： ./gradlew assembleWandoujiaRelease 如果我们只打wandoujia渠道版本，则： ./gradlew assembleWandoujia 此命令会生成wandoujia渠道的Release和Debug版本 同理我想打全部Release版本： ./gradlew assembleRelease 这条命令会把Product Flavor下的所有渠道的Release版本都打出来。 总之，assemble 命令创建task有如下用法： assemble： 允许直接构建一个Variant版本，例如assembleFlavor1Debug。 assemble： 允许构建指定Build Type的所有APK，例如assembleDebug将会构建Flavor1Debug和Flavor2Debug两个Variant版本。 assemble： 允许构建指定flavor的所有APK，例如assembleFlavor1将会构建Flavor1Debug和Flavor1Release两个Variant版本。 完整的gradle脚本最后福利大放送，来一份我在项目中使用的完整的gradle文件配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798apply plugin: 'com.android.application'def releaseTime() &#123; return new Date().format(\"yyyy-MM-dd\", TimeZone.getTimeZone(\"UTC\"))&#125;android &#123; compileSdkVersion 21 buildToolsVersion '21.1.2' defaultConfig &#123; applicationId \"com.boohee.*\" minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName \"1.0\" // dex突破65535的限制 multiDexEnabled true // 默认是umeng的渠道 manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"umeng\"] &#125; lintOptions &#123; abortOnError false &#125; signingConfigs &#123; debug &#123; // No debug config &#125; release &#123; storeFile file(\"../yourapp.keystore\") storePassword \"your password\" keyAlias \"your alias\" keyPassword \"your password\" &#125; &#125; buildTypes &#123; debug &#123; // 显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\" versionNameSuffix \"-debug\" minifyEnabled false zipAlignEnabled false shrinkResources false signingConfig signingConfigs.debug &#125; release &#123; // 不显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\" minifyEnabled true zipAlignEnabled true // 移除无用的resource文件 shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为boohee_v1.0_2015-01-15_wandoujia.apk def fileName = \"boohee_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; // 友盟多渠道打包 productFlavors &#123; wandoujia &#123;&#125; _360 &#123;&#125; baidu &#123;&#125; xiaomi &#123;&#125; tencent &#123;&#125; taobao &#123;&#125; ... &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:support-v4:21.0.3' compile 'com.jakewharton:butterknife:6.0.0' ...&#125; 大家有问题或疑问、建议欢迎博客留言，Android Studio的教程暂且到这里结束了，相信大家基本的都已会使用了，还有其他技巧与操作靠大家自己摸索了，之后有时间也会在博客上整理下一些Tips之类的，欢迎大家关注。","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://smuwjs.github.io/tags/AndroidStudio/"}]},{"title":"Android Studio系列教程五--Gradle命令详解与导入第三方包","date":"2016-09-11T17:01:05.000Z","path":"2016/09/12/android-studio-tutorial5/","text":"原文地址 Android Studio + Gradle的组合用起来非常方便，很多第三方开源项目也早都迁移到了Studio，为此今天就来介绍下查看、编译并导入第三方开源项目的方法。 Sublime + Terminal编译并查看源码首先来给大家介绍一种简便并且个人最喜欢的一种办法。很多时候我们在GitHub上看到一个不错的开源项目，一般有两种需求，阅读源码和查看运行效果，如果是单纯的查看源码我更喜欢用一些轻量级编辑器，如vim，sublime等，vim不是很熟练，所以个人一种都习惯用sublime来查看并阅读源码（实际开发还是Android Studio、Eclipse等IDE更有效率）；至于查看运行效果首先得需要apk，对于一些开源项目已提供apk下载，那就好办，直接安装到手机即可。 而对于一些没有提供apk下载的，则需要自己手动编译打包。 下面以9GAG为例来讲解下命令行Gradle编译的过程。 1、切换到9GAG项目的根目录，执行 ./gradlew -v 来查看下项目所用的Gradle版本 如果你是第一次执行会去下载Gradle，这个过程如果不翻墙非常慢，建议翻墙 iamge 紧接着下载成功会看到如下信息： 123456789101112------------------------------------------------------------Gradle 2.2.1------------------------------------------------------------Build time: 2014-11-24 09:45:35 UTCBuild number: noneRevision: 6fcb59c06f43a4e6b1bcb401f7686a8601a1fb4aGroovy: 2.3.6Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013JVM: 1.7.0_60 (Oracle Corporation 24.60-b09)OS: Mac OS X 10.9.5 x86_64 2、接着执行 ./gradlew clean 执行这个命令会去下载Gradle的一些依赖，下载成功并编译通过时会看到如下信息： 1234:app:clean UP-TO-DATE:extras:ShimmerAndroid:clean UP-TO-DATEBUILD SUCCESSFUL 3、最后执行 ./gradlew build 这个命令会直接编译并生成相应的apk文件，如果看到如下字样就代表build成功了 123BUILD SUCCESSFULTotal time: 31.456 secs 紧接着在 9GAG/app/build/outputs/apk 目录下会看到类似于app-debug-unaligned.apk, app-release-unsigned.apk等，看名字应该能理解意思，unaligned代表没有进行zip优化的，unsigned代表没有签名的。然后就可以直接安装apk查看运行效果了。 以上是我个人习惯的一种阅读第三方源码的习惯，关于上面提到的一些gradle命令大家应该还不理解，后面会一一进行说明的。 导入Android Studio但是如果你还是想导入Android Studio的话，下面就来简单介绍下导入Studio的方法以及一些注意事项。 1、选择File-&gt;Import Project, 选择本地9GAG项目的目录 iamge 2、第一次依然会下载Gradle，其实自己在命令行已经下载过了，但是这次依然还要下载一次（依然要翻墙），可能是个bug iamge 3、导入之后你需要注意以下几个地方 每个Module下的 build.gradle 下的buildToolsVersion，即9GAG/app/build.gradle 和 9GAG/extras/ShimmerAndroid/build.gradle , 可以打开 SDK Manager 查看本地你安装的 SDK Build-tools, 如下图，如果相应版本没有安装请先下载。 iamge 项目根目录下的 build.gradle 下gradle插件的版本，如 9GAG/build.gradle 的内容： classpath ‘com.android.tools.build:gradle:1.0.0’ Android Studio 1.0必须指定gradle插件1.0的版本 Gradle Wrapper的版本，在 9GAG/gradle/wrapper/gralde-wrapper.properties 文件里有如下内容： 123456#Thu Dec 18 16:02:24 CST 2014distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2.1-all.zip 上述内容制定了gradle的版本使用2.2.1，在Studio中如果你手动改了gradle插件的版本会有提示要不要更新Gradle Wrapper的版本。 如果以上几个地方确定版本是ok的，那么导入Android Studio应该没有问题，有些老的项目可能gradle版本比较老，仍然在使用一些老的语法，如果编译还通不过参考Android Studio系列教程四–Gradle基础更改成最新的语法。 Gradle常用命令上面大家接触了一些命令如 ./gradlew -v ./gradlew clean ./gradlew build, 这里注意是./gradlew, ./代表当前目录，gradlew代表 gradle wrapper，意思是gradle的一层包装，大家可以理解为在这个项目本地就封装了gradle，即gradle wrapper， 在9GAG/gradle/wrapper/gralde-wrapper.properties文件中声明了它指向的目录和版本。只要下载成功即可用grdlew wrapper的命令代替全局的gradle命令。 理解了gradle wrapper的概念，下面一些常用命令也就容易理解了。 ./gradlew -v 版本号 ./gradlew clean 清除9GAG/app目录下的build文件夹 ./gradlew build 检查依赖并编译打包 这里注意的是 ./gradlew build 命令把debug、release环境的包都打出来，如果正式发布只需要打Release的包，该怎么办呢，下面介绍一个很有用的命令 assemble, 如 ./gradlew assembleDebug 编译并打Debug包 ./gradlew assembleRelease 编译并打Release的包 除此之外，assemble还可以和productFlavors结合使用，具体在下一篇多渠道打包进一步解释。 ./gradlew installRelease Release模式打包并安装 ./gradlew uninstallRelease 卸载Release模式包 下一篇来介绍用Gradle进行方便的多渠道打包，以及项目中完整的Gradle配置。有问题或建议欢迎大家直接博客留言。","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://smuwjs.github.io/tags/AndroidStudio/"},{"name":"Gradle","slug":"Gradle","permalink":"https://smuwjs.github.io/tags/Gradle/"}]},{"title":"Android Studio系列教程四--Gradle基础","date":"2016-09-11T17:01:04.000Z","path":"2016/09/12/android-studio-tutorial4/","text":"原文地址 其实很早之前也写了一篇Gradle的基础博客，但是时间很久了，现在Gradle已经更新了很多，所以暂且结合Stduio 1.0正式版与最新的Gradle语法来详细讲解下，小伙伴们直接跟我一步步来学习吧。 什么是Gradle？Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。 安装Gradle在Android Studio系列教程一–下载与安装中新建项目成功后会下载Gradle，貌似这个过程不翻墙也是可以下载，但是访问特别慢，建议翻墙下载。那么下载的Gradle到什么地方呢？ Mac上会默认下载到 /Users/&lt;用户名&gt;/.gradle/wrapper/dists 目录 Win平台会默认下载到 C:\\Documents and Settings\\&lt;用户名&gt;.gradle\\wrapper\\dists 目录 你会看到这个目录下有个 gradle-x.xx-all 的文件夹, 如果下载实在太慢，但是又不想翻墙的话，可以自己手动到Gradle官网下载对应的版本，然后将下载的.zip文件(也可以解压)复制到上述的gradle-x.xx-all 文件夹下，不过还是建议让它直接下载的好。 Gradle 基本概念下面就以我的开源项目 9GAG 来详细讲解下和Gradle相关的知识, 和Gradle相关的几个文件一般有如下几个： iamge 红色标记部分从上到下咱们来一步步分析： 1. 9GAG/app/build.gradle这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件，我们来看下这个文件的内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 声明是Android程序apply plugin: 'com.android.application'android &#123; // 编译SDK的版本 compileSdkVersion 21 // build tools的版本 buildToolsVersion \"21.1.1\" defaultConfig &#123; // 应用的包名 applicationId \"me.storm.ninegag\" minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName \"1.0.0\" &#125; // java版本 compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_7 targetCompatibility JavaVersion.VERSION_1_7 &#125; buildTypes &#123; debug &#123; // debug模式 &#125; release &#123; // 是否进行混淆 minifyEnabled false // 混淆文件的位置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125; // 移除lint检查的error lintOptions &#123; abortOnError false &#125;&#125;dependencies &#123; // 编译libs目录下的所有jar包 compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:support-v4:21.0.2' compile 'com.etsy.android.grid:library:1.0.5' compile 'com.alexvasilkov:foldable-layout:1.0.1' // 编译extras目录下的ShimmerAndroid模块 compile project(':extras:ShimmerAndroid')&#125; 这里需要说明几点： 文件开头apply plugin是最新gradle版本的写法，以前的写法是apply plugin: ‘android’, 如果还是以前的写法，请改正过来。 buildToolsVersion这个需要你本地安装该版本才行，很多人导入新的第三方库，失败的原因之一是build version的版本不对，这个可以手动更改成你本地已有的版本或者打开 SDK Manager 去下载对应版本。 applicationId代表应用的包名，也是最新的写法，这里就不在多说了。 android 5.0开始默认安装jdk1.7才能编译，但是由于mac系统自带jdk的版本是1.6，所以需要手动下载jdk1.7并配置下，具体可以见我这篇博客Mac下安装和管理Java minifyEnabled也是最新的语法，很早之前是runProguard,这个也需要更新下。 proguardFiles这部分有两段，前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，免去了我们很多事，这个文件的目录在 &lt;sdk目录&gt;/tools/proguard/proguard-android.txt , 后一部分是我们项目里的自定义的混淆文件，目录就在 app/proguard-rules.txt , 如果你用Studio 1.0创建的新项目默认生成的文件名是 proguard-rules.pro , 这个名字没关系，在这个文件里你可以声明一些第三方依赖的一些混淆规则，由于是开源项目，9GAG里并未进行混淆，具体混淆的语法也不是本篇博客讨论的范围。最终混淆的结果是这两部分文件共同作用的。 compile project(‘:extras:ShimmerAndroid’)这一行是因为9GAG中存在其他Module，不知道Module的概念可以看下这篇博客Android Studio系列教程二–基本设置与运行, 总之你可以理解成Android Library，由于Gradle的普及以及远程仓库的完善，这种依赖渐渐的会变得非常不常见，但是你需要知道有这种依赖的。 以上文件里的内容只是基本配置，其实还有很多自定义部分，如自动打包debug，release，beta等环境，签名，多渠道打包等，后续会单独拿出来讲解。 2. 9GAG/extras/ShimmerAndroid/build.gradle每一个Module都需要有一个gradle配置文件，语法都是一样，唯一不同的是开头声明的是 apply plugin: ‘com.android.library’ 3. 9GAG/gradle这个目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容： 123456#Thu Dec 18 16:02:24 CST 2014distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2.1-all.zip 可以看到里面声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，这个文件里指明的gradle版本不对也是很多导包不成功的原因之一。 4. 9GAG/build.gradle这个文件是整个项目的gradle基础配置文件,我们来看看这里面的内容1234567891011121314151617// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 内容主要包含了两个方面：一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。 5. 9GAG/settings.gradle这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module，我们来看看9GAG该文件的内容： 1include ':app', ':extras:ShimmerAndroid' 文件中的 app, extras:ShimmerAndroid 都是module，如果还有其他module都需要按照如上格式加进去。 总结关于gradle的基础知识就介绍到这里，接下来会介绍一种我常用的快速方便的编译查看第三方开源项目的方法，如何导入Android Studio，Gradle常用基本命令，多渠道打包配置等。有疑问或者发现错误欢迎大家直接博客留言。","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://smuwjs.github.io/tags/AndroidStudio/"},{"name":"Gradle","slug":"Gradle","permalink":"https://smuwjs.github.io/tags/Gradle/"}]},{"title":"Android Studio系列教程三--快捷键","date":"2016-09-11T17:01:03.000Z","path":"2016/09/12/android-studio-tutorial3/","text":"原文地址 Android Studio 1.0正式版发布啦今天是个大日子，Android Studio 1.0 终于发布了正式版， 这对于Android开发者来说简直是喜大普奔的大消息啊，那么就果断来下载使用。 image 官方下载地址： http://developer.android.com/sdk/index.html 如果你之前已经使用其他版本的Studio，那么直接覆盖就好了，如果是第一次使用，那么参照Android Studio系列教程一进行安装配置。 于此同时一起更新的还有SDK Tools等，打开SDK Manager进行更新就OK。如果之前有在使用RC版本的Studio，更新覆盖之后应该会出错，那是因为Stuido 1.0默认使用1.0的Gradle插件，所以只需到项目根目录的 build.gradle 更新成如下代码然后同步下就OK了 image 快捷键对于很多Eclipse转过来的同学，不适应的最主要就是快捷键部分了，Studio默认的快捷键和Eclipse差别很大，但是Studio强大的地方在于通过设置你可以一直沿用Eclipse风格的快捷键，这样对于那些Eclipse过渡来的同学省了很多学习成本。 Preferences -&gt; Keymap 然后就可以选择你想要的快捷键，这里不止可以选择Eclipse，还可以选择 Emacs、Net Beans 等编辑器的快捷键 image 对于新手们或者对Eclipse没有好感的同学们，肯定想学习默认的Studio快捷键，下面整理了下常用的一些快捷键，更多的快捷键还需要大家自己去习惯适应。（我自己选择的是Mac OS X 10.5+） Action Mac OSX Win/Linux 注释代码(//) Cmd + / Ctrl + / 注释代码(/**/) Cmd + Option + / Ctrl + Shift + / 格式化代码 Cmd + Option + L Ctrl + Alt + L 清除无效包引用 Option + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 查找+替换 Cmd + R Ctrl + R 上下移动代码 Option + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 扩大缩小选中范围 Option + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Option + T Ctrl + Alt + T 快捷覆写方法 Cmd + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus,Minus Ctrl + Plus/Minus 折叠展开全部代码块 Cmd + Shift + Plus,Minus Ctrl + Shift + Plus,Minus 文件方法结构 Cmd + F12 Ctrl + F12 查找调用的位置 Ctrl + Option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U (PS: 以上快捷键没有在win平台尝试确认，欢迎反馈错误与补充) 自动导包最后再介绍一个最有用的设置，我们只有每次引用一些类的时候必须要导包，而Studio可以通过设置自动导包，简直太实用了. 到 Preferences -&gt; Editor -&gt; Auto Import -&gt; Java 把以下选项勾上就OK了 image 从此世界清静了。。。 至此Android Studio的基本使用相信大家都已经会了，从下一系列开始介绍Gradle语法以及基本配置与多渠道打包等，敬请期待！","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://smuwjs.github.io/tags/AndroidStudio/"}]},{"title":"Android Studio系列教程二--基本设置与运行","date":"2016-09-11T17:01:02.000Z","path":"2016/09/12/android-studio-tutorial2/","text":"原文地址 上面一篇博客，介绍了Studio的优点与1.0 RC的安装与上手体验，没想到google的更新速度这么快，已经出了RC 2版本，主要是修复一些bug。那么今天就带大家预览下Stduio的界面与基本功能。 项目结构当我们新建一个项目的目录结构默认是这样的 image 可以看到和Eclipse的目录结构有很大区别，Studio一个窗口只能有一个项目，而Eclipse则可以同时存在很多项目，如果你看着不习惯可以点击左上角进行切换 image 切换到“project”模式下的目录结构是这样的，我个人也更习惯这种格式 image 和Eclipse的区别有如下： 1、Studio中有Project和Module的概念，前面说到Studio中一个窗口只能有一个项目，即Project，代表一个workspace，但是一个Project可以包含多个Module，比如你项目引用的Android Library, Java Library等，这些都可以看做是一个Module; 2、上述目录中将java代码和资源文件（图片、布局文件等）全部归结为src，在src目录下有一个main的分组，同时划分出java和res两个文件夹，java文件夹则相当于Eclipse下的src文件夹，res目录结构则一样. 偏好设置进入后你也许发现字体大小或者样式不符合你的习惯，比如我是觉得代码太小看起来伤眼，Darcular主题默认的字体是12，我个人更习惯14的字体大小。没关系，到 Preferences (设置)页面搜索 Font 找到 Colors&amp;Fonts 下的 Font 选项，我们可以看到默认字体大小是12，但是无法修改，需要先保存才可以修改，点击 Save as 输入一个名字，比如 MyDarcular，然后就可以修改字体大小和字体样式了. image 点击确定之后再回到页面发现字体是变大了，但是Studio默认的一些字体大小如侧边栏等确没有变化，看起来很不协调，如下图 image 强迫症的你肯定无法忍受，没关系，这里也同样可以设置，到 Preferences -&gt; Appearance 修改如图所示就ok，这里同样不仅可以更改字体大小，也可以选择不同的字体,点击OK，这次页面字体就完全对你胃口了。 image 调整之后再看下效果 image 运行接下来运行程序，运行和 Eclipse 中比较像，点击菜单栏的绿色箭头直接运行 image Studio 默认安装会启动模拟器，如果想让安装到真机上可以配置一下。在下拉菜单中选择 Edit Configurations 选择提示或者是USB设备。 image image 常用功能在Studio菜单栏的右边有这样几个常用的功能，如图分别是 Gradle同步、AVD Manager、SDK Manager、DDMS image Gradle同步 在你项目运行或者更改Gradle配置的时候都要点击下这个按钮，会下载相应的依赖 AVD Manager 模拟器管理 SDK Manager 就是管理你的SDK版本 DDMS 即 Dalvik Debug Monitor Service，Dalvik调试监控服务。 创建模拟器建议在创建模拟器前把 SDK Manager 中的 Tools、Extras 都更新到最新。 点击 AVD Manager 按钮 image 点击图中的创建按钮 image 选择一个设备，这里我选择 Nexus 5，然后Next image 这里选择一个系统版本，这里以5.0为例，然后Next image 由于各位的屏幕尺寸不一样，建议这里Scale一栏选择Auto，然后点击Finish接着可以看到我们已经创建好一个5.0的模拟器了 image 这次我们再运行，选择模拟器启动看下最终效果（模拟器的启动很慢，大家耐心等待） image image","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://smuwjs.github.io/tags/AndroidStudio/"}]},{"title":"Android Studio系列教程一--下载与安装","date":"2016-09-11T17:01:01.000Z","path":"2016/09/12/android-studio-tutorial1/","text":"原文地址 背景相信大家对Android Studio已经不陌生了，Android Studio是Google于2013 I/O大会针对Android开发推出的新的开发工具，目前很多开源项目都已经在采用，Google的更新速度也很快，明显能感觉到这是Android开发的未来，那么我们还有什么理由不去拥抱未来呢？ 虽然推出了很久，但是国内貌似普及的程度并不高，鉴于很多朋友求studio的详细教程，那么今天我就手把手教大家下载、安装、使用，Studio之路从这里开始。 Android Studio VS Eclipse相信目前国内用Eclipse的还是大多数，那么首先就来说一下Studio的一些优点，比较才能更有说服力，才能说明为什么我们要从Eclipse迁移到Studio。 1、Google推出的 毫无疑问，这个是它的最大优势，Android Stuido是Google推出，专门为Android“量身订做”的，是Google大力支持的一款基于IntelliJ IDEA改造的IDE，这个应该能说明为什么它是Android的未来 2、速度更快 Eclipse的启动速度、响应速度、内存占用一直被诟病，相信大家这点应该深有体会，而且经常遇到卡死状态。Studio不管哪一个方面都全面领先Eclipse 3、UI更漂亮 I/O上演示的那款黑色主题真是太棒了，极客范，Stuido自带的Darcula主题的炫酷黑界面实在是高大上，相比而言Eclipse下的黑色主题太low了 4、更加智能 提示补全对于开发来说意义重大， Studio则更加智能，智能保存，从此再也不用每次都 Ctrl + S了。熟悉Studio以后效率会大大提升。 5、整合了Gradle构建工具 Gradle是一个新的构建工具，自Studio亮相之处就支持Gradle，可以说Gradle集合了Ant和Maven的优点，不管是配置、编译、打包都非常棒。 6、强大的UI编辑器 Android Studio的编辑器非常的智能，除了吸收Eclipse+ADT的优点之外，还自带了多设备的实时预览，相对这对Android开发者来说简直是神器啊。 7、内置终端 Studio内置终端，这对于习惯命令行操作的人来说简直是福音啊，再也不用来回切换了，一个Studio全部搞定。 8、更完善的插件系统 Studio下支持各种插件，如Git、Markdown、Gradle等等，你想要什么插件，直接搜索下载。 9、完美整合版本控制系统 安装的时候就自带了如GitHub, Git, SVN等流行的版本控制系统，可以直接check out你的项目。 大家看完以上是不是很动心呢，优点是很多，但是大家学习的时候会遇到很多问题，如Studio和Eclipse的目录结构、快捷键等等完全不一样，需要适应一段时间，Gradle同样增加了学习成本，虽然Google的更新速度已经相当快了，但是目前最新的是1.0RC版本，仍未推出正式版，说明可能会有一些小问题等，Studio官方解释暂未支持NDK，所以如果你的项目用到了NDK最好也不要使用Studio。 但是相信Google会越来越完善的，学习成本与适应阶段是我们做技术一直要保持的心态，一旦上手相信你要离不开它了。 最后这里先上一张我本地Studio的截图： image 准备因为Google Android的一些官方网站在国内访问有限制，原因你懂得。所以在开始下载安装Studio之前，你需要自备梯子，关于如何翻墙有很多种方法，这里就不做过多介绍，私以为作为一个Android开发者，不懂翻墙基本没法做下去。所以这点投入是值得的，这里推荐大家直接购买VPN吧，因为我曾经折腾了很多翻墙的玩意，要么不稳定，要么速度慢，后来想通了，凡是花点钱能解决的问题都不是问题，这里推荐云梯VPN，价格算是很便宜的了，别再问我速度、稳定性如何，我已经使用并续费快两年了。（通过这个链接购买的，你的账户可以优惠10元） 下载官方下载有两个地方，均需要翻墙。 Android Developer官网 Android开发者官网的网站，可直接下载，但是这个网站貌似只更新Beta和正式版，目前只更新到Beta 0.8.14版本。 Android Tools Project Site Android开发工具的网站，上面链接是Studio的canary渠道，列出了Studio各种实时预览版等，目前最新的是1.0RC版本。 创建HelloWorld项目至于安装就没什么可说的了，点击直接运行了。这里我以Mac系统的1.0RC版本为例，来创建第一个HelloWorld项目。其他平台基本上差不多，在这之前假设你已经配置好了JDK和Android SDK环境，并且你是第一次安装Studio。 1、首先运行时的欢迎画面 image 2、之后第一次的话会进入到设置向导页 点击Next进入选择设置类型向导页 这里有两个选项“Standard”和“Custom”，即标准和自定义，如果你本机的Android SDK没有配置过，那么建议直接选择“Standard”, 点击“Finish”按钮 因为我本地已经下载SDK并配置好了环境变量，所以我选择”Custom”，然后到下一步： 这一步选择你本地SDK的位置，可以看到有个2.25GB的SDK要下载，那是因为Studio 1.0默认要下载5.0的SDK以及一些Tools之类的，然后点击”Finish”按钮 （PS: 这个选择并下载2.25G的组件是studio的一个bug，评论里有人提醒，感谢这位同学。如果网速不行想跳过这步的可以在bin目录的idea.properties增加一行：disable.android.first.run=true就行了，mac平台的右键安装包-&gt;Show Package Contents 就找到bin目录了。） 3、下载依赖组件 image 之后便到下载组件页面，这个过程需要翻墙，而且依赖你的网速，时间有点久，大家耐心等待… image 下载完成后点击”Finish”按钮 4、新建项目 image 在这个页面我们可以新建项目，也可以导入项目本地或者GitHub上的项目等，左边可以查看最近打开的项目等，这里我直接新建项目 然后到如下界面 image 我们填上项目名称和报名以及项目路径等然后”Next” image 这个页面支持你适配TV、Wear、Glass等，我们只选择第一项就ok，选好最小SDK然后”Next” image 这个页面选择一个Activity模板，和Eclipse很像，我们直接选择一个Blank Activity好了 image 点击”Finish”后等一会出来如下一个进度条，很多人容易卡在这里，这里需要下载Gradle，只第一次会下载，有点慢，需要翻墙，大家也耐心等待下 image 下载成功后变看到如下完整的项目界面 image 至此一个简单的Studio项目就完成了，图片中也可以看到默认是一个白色主题，不够酷炫？Studio默认自带一款高大上的黑色主题，只需要简单修改下就OK。 到Preference -&gt; Appearance下更改主题到Darcula image 之后我们再来看一下更改后的主题 image 很酷炫有木有？至此第一期的Studio简单介绍就到这里，后面会介绍目录结构、快捷键、导入项目、集成GitHub、Gradle等等，敬请期待。","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"https://smuwjs.github.io/tags/AndroidStudio/"}]},{"title":"用SoureceTree管理Git项目","date":"2016-09-11T03:12:58.000Z","path":"2016/09/11/vcs-git-gitlab-sourecetree/","text":"Update update: Windows用户在初始化Souretree工具时，需要用到Atlassian ID，新建用户时需要加载google 验证码，这一步需要VPN的支持，请注意。 找到一个版本的SourceTree工具可以不需要以上验证也能使用，下载链接：SourceTreeSetup_1.6.14.exe 补充1 ：Git学习网站 猴子都能学会的git教程 常用 Git 命令清单 廖雪峰的git教程 Why Git is Better than X 补充2 ：利用Git协同开发 团队中的Git实践 Git 使用规范流程 Git分支管理模型 图解Git 1. 关于 SourceTreeSourceTree 是一款免费且同时支持Windows 和Mac 的git项目管理软件，本文旨在给大家介绍这款应用的基础使用，并用它来管理你的项目。 官网： https://www.sourcetreeapp.com/ 2. git帐号建立1. 新员工入职之后，你的公司邮箱内会收到一封来自Gitlab的邮件，如下图： image 2. 点击邮件中的 “Click here to set your password”，设置gitlab登陆密码。 image 3. 登陆gitlab帐号，将会出现这个界面： image 4. 设定个人信息： image 5. sshKey5.1 在Linux和Mac上生成sshkey：123456789101112131415161718192021222324➜ ~ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/Users/Alex/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/Alex/.ssh/id_rsa.Your public key has been saved in /Users/Alex/.ssh/id_rsa.pub.The key fingerprint is:SHA256:98jE3jhBhFT5nQlZRj34a3WOk1t6XF+Dbf/hliXl4WQ Alex@Alex-MacThe key&apos;s randomart image is:+---[RSA 2048]----+| ..oo. +=. || ... oo ..|| .. o.o.|| o . +E+|| S = **=|| = * .=BB|| * o oOO|| . +o*|| .oo|+----[SHA256]-----+➜ ~ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvuQAq65b+nLZPqqc3b3Mj9e7Pt8oWKasJFa2QH1VIEkDvxKLFGcHsT7Ur4zXwEi9YiW2tVRrBSjcMALxuBjVm2IxYV6Lk8SLuGadyYy5telWGJmHsQ3VIPRuKwpzTkLN643kjqc6JFSlnZG/XoP9SPtCOsp2ql4u0s7Auc2bZay4RaTDXbcpJVU9OA0xM8Zy4oTTNYdZ4tvGittVmn+wLrhN255J7clORF5126dmDYxV3E8ZboaDdQpdLGIWmDNcBJQvl0CLwpKUCi7EUDqDVtm4bNgwIX9fEIkTxGdaWjBW1iXBk8TGXWkgB+Qp8B1IwaJ4GHUwUhQrefWvw9XeJ Alex@Alex-Mac➜ ~ 5.2 在Windows上生成sshkey：因为windows没有自带openssl模块，所以在Windows环境中使用第三方工具puttygen.exe生成sshkey 下载地址步骤如下： image image image 当sourcetree首次启动时，会弹出加载sshkey的提示，按提示操作，找到之前保存的private.ppk文件 image 5.3 上传sshkey： image 6. 回到 dashboard ，点击项目名称进入详情： image 7. 使用souretree将项目从git服务器clone到本地7.1 安装souretree 软件 ［略］7.2 clone项目到本地 image image 8. 进入项目工作台： image 9. 关于sourcetree工具的使用，下面是一些git操作的释疑。 检出仓库: 将在本地创建一个git仓库的克隆版本 工作流: 本地仓库由 git 维护的三棵“树”组成。第一个是 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存改动；最后是 HEAD，指向最近一次提交后的结果。 提交：可以计划改动（把它们添加到缓存区),将改动提交到了 HEAD，但是还没到提交到远端仓库。 拉取：从远端仓库拉取最新版本状态，特别是在其他人员有所改动之后。 推送：改动现在已经在本地仓库的 HEAD 中了。这时可以使用它将这些改动提交到远端仓库。 分支：分支是用来将特性开发分离出来的。在创建仓库的时候，master 是“默认的”。创建分支将可以从主线开发上分离开来，然后在不影响主线的同时继续工作，完成后再将它们合并到主分支上。 合并： 将分支功能并入主分支。","tags":[{"name":"Git","slug":"Git","permalink":"https://smuwjs.github.io/tags/Git/"}]},{"title":"Git分布式版本管理","date":"2016-09-09T03:12:58.000Z","path":"2016/09/09/vcs-git-gitflow/","text":"Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 本节不是Git的教程，而是介绍一下项目中Git的分支策略以及流程管理，同时也涉及一种广泛应用的商用Git工具BitBucket，顺便也会涉及一些代码托管Github以及这两年开始流行的Gitlab的使用方法，当然Github与Gitlab已不单单是版本控制，也包括后文将会提到的知识管理和持续集成。Git使用教程 上一张比较经典的分支策略的图，涵盖版本发布，新Sprint开发，bug fix。 分布式而非集中式 对于这种分支模型，我们设置了一个版本库称为原始库（origin）。每个开发者都对原始库（origin）库拉取（pull）代码和推送（push）代码。但是除了集中式的存取代码关系，每个开发者也可以从子团队的其他队友那里获得代码版本变更。例如，对于2个或多个开发者一起完成的大版本变更，为了防止过早地向origin库提交工作内容，这种机制就变得非常有用。在上述途中，有如下子团队：Alice和Bob，Alice和David，Clair和David。从技术上将，这意味着，Alice创建了一个Git的远程节点，而对于Bob，该节点指向了Bob的版本库，反之亦然。 主分支 中心库有2个分支（branch）： master分支 develop分支 每个Git用户都要熟悉原始的master分支。与master分支并行的另一个分支，我们称之为develop分支。我们把origin/master库认作为主分支，HEAD默认指向master。我们把origin/develop库认为是主分支，该分支HEAD默认指向develop。当develop分支的源码到达了一个稳定状态待发布，所有的代码变更需要以某种方式合并到master分支，然后标记一个版本号。如何操作将在稍后详细介绍。所以，每次变更都合并到了master，这就是新产品的定义，并为之打上标签（tag）。 ###辅助性分支我们的开发模型使用了各种辅助性分支，这些分支与关键分支（master和develop）一起，用来支持团队成员们并行开发，使得易于追踪功能，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支总是有一个有限的生命期，因为他们最终会被移除。我们用到的分支类型包括： 功能分支 发布分支 热修复分支 每一种分支有一个特定目的，并且受限于严格到规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。我们马上将进行演练。从技术角度来看，这些分支绝不是特殊分支。分支的类型基于我们使用的方法来进行分类。它们理所当然是普通的Git分支。 ###功能分支（feature） 可能是develop分支的分支版本，最终必须合并到develop分支中。分支命名规则：除了master、develop、release-或者hotfix-之外，其他命名均可。feature分支通常为即将发布或者未来发布版开发新的功能。当新功能开始研发，包含该功能的发布版本在这时还是无法确定发布时间的。feature版本的实质是只要这个功能处于开发状态它就会存在，但是最终会合并到develop分支或取消。功能分支通常存在于开发者的软件库，而不是在源代码库中。 创建一个功能分支开始一项功能的开发工作时，基于develop创建分支。12$ git checkout -b myfeature developSwitched to a new branch \"myfeature\" 合并一个功能到develop分支完成的功能可以合并进develop分支，以明确加入到未来的发布：12345678$ git checkout developSwitched to branch 'develop'$ git merge --no-ff myfeatureUpdating ea1b82a..05e9557(Summary of changes)$ git branch -d myfeatureDeleted branch myfeature (was 05e9557).$ git push origin develop –no-ff标志导致合并操作创建一个新commit对象，即使该合并操作可以fast-forward。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。 比较: 后一种情况，不可能从Git历史中看到哪些提交一起实现了一个功能，你必须手工阅读全部的日志信息。如果对整个功能进行回退 (比如一组提交)，后一种方式会是一种真正头痛的问题，而使用–no-ff的情况则很容易。 Release 分支Release分支可能从develop分支分离而来，但是一定要合并到develop和master分支上，它的习惯命名方式为：release-*。Release分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。他们允许小bugs的修改和准备发布元数据（版本号，开发时间等等）。从develop分支创建新的Release分支的关键时刻是develop分支达到了发布的理想状态。至少所有这次要发布的features必须在这个点及时合并到develop分支。对于所有未来准备发布的features必须等到Release分支创建以后再合并。在Release分支创建的时候要为即将发行版本分配一个版本号。直到那时，develop分支反映的变化都是为了下一个发行版，但是在Release分支创建之前，下一个发行版到底叫0.3还是1.0是不明确的。这个决定是在Release分支创建时根据项目在版本号上的规则制定的。 创建一个release分支Release分支是从develop分支创建的。例如，当前产品的发行版本号为1.1.5，同时我们有一个大的版本即将发行。develop 分支已经为下次发行做好了准备，我们得决定下一个版本是1.2（而不是1.1.6或者2.0）。所以我们将Release分支分离出来，给一个能够反映新版本号的分支名。1234567$ git checkout -b release-1.2 developSwitched to a new branch \"release-1.2\"$ ./bump-version.sh 1.2Files modified successfully, version bumped to 1.2.$ git commit -a -m \"Bumped version number to 1.2\"[release-1.2 74d9424] Bumped version number to 1.21 files changed, 1 insertions(+), 1 deletions(-) 创建新分支以后，切换到该分支，添加版本号。这里，bump-version.sh 是一个虚构的shell脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到develop分支上）。在这里严格禁止增加大的新features。他们必须合并到develop分支上，然后等待下一次大的发行版。 完成一个release分支当一个release分支准备好成为一个真正的发行版的时候，有一些工作必须完成。首先，release分支要合并到master上（因为每一次提交到master上的都是一个新定义的发行版，记住）。然后，提交到master上必须打一个标签，以便以后更加方便的引用这个历史版本。最后，在release分支上的修改必须合并到develop分支上，以便未来发行版也包含这些bugs的修复。123456$ git checkout masterSwitched to branch 'master'$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes)$ git tag -a 1.2 为了是修改保持在release分支上，我们需要合并这些到develop分支上去。12345$ git checkout developSwitched to branch 'develop'$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes) 这个步骤可能会导致合并冲突（可能由于改变版本号更是如此）。如果是这样，修复它然后提交。现在我们真正的完成了，这个release分支将被删除，因为我们不再需要它了。12$ git branch -d release-1.2Deleted branch release-1.2 (was ff452fe). 热修复分支 可以基于master分支，必须合并回develop和master分支。分支名约定：hotfix-*热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于master分支上对应与线上版本的tag创建。其本质是团队成员（在develop分支上）的工作可以继续，而另一个人准备生产环境的快速修复。 创建修补bug分支hotfix branch（修补bug分支）是从Master分支上面分出来的。例如，1.2版本是当前生产环境的版本并且有bug。但是开发分支（develop）变化还不稳定。我们需要分出来一个修补bug分支（hotfix branch）来解决这种情况。1234567$ git checkout -b hotfix-1.2.1 masterSwitched to a new branch \"hotfix-1.2.1\"$ ./bump-version.sh 1.2.1Files modified successfully, version bumped to 1.2.1.$ git commit -a -m \"Bumped version number to 1.2.1\"[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11 files changed, 1 insertions(+), 1 deletions(-) 分支关闭的时侯不要忘了更新版本号(bump the version)然后，修复bug，一次提交或者多次分开提交。123$ git commit -m \"Fixed severe production problem\"[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) 完成一个hotfix分支完成一个bugfix之后，需要把bugfix合并到master和develop分支去，这样就可以保证修复的这个bug也包含到下一个发行版中。这一点和完成release分支很相似。首先，更新master并对release打上tag：123456$ git checkout masterSwitched to branch 'master'$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes)$ git tag -a 1.2.1 下一步，把bugfix添加到develop分支中：12345$ git checkout developSwitched to branch 'develop'$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes) 规则的一个例外是： 如果一个release分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支。当release分支完成后， 将bugfix分支合并回release分支也会使得bugfix被合并到develop分支。（如果在develop分支的工作急需这个bugfix，等不到release分支的完成，那你也可以把bugfix合并到develop分支）最后，删除临时分支：12$ git branch -d hotfix-1.2.1Deleted branch hotfix-1.2.1 (was abbe5d6).","tags":[{"name":"Git","slug":"Git","permalink":"https://smuwjs.github.io/tags/Git/"}]},{"title":"Eclipse关联JDK源码","date":"2016-09-08T16:00:00.000Z","path":"2016/09/09/java-source-analysis-start/","text":"Eclipse关联JDK源码 阅读JDK源码是Java程序员的基本功，也是必经之路。在使用Eclipse编写代码时，常常需要查看JDK的源码实现。第三方的依赖包源码可以用Maven辅助下载，这里主要记录下如何关联JDK源码。 源码其实在安装JDK时，已经有一份源码，在目录 %JAVA_HOME%/jdk1.8.0/，可以看到一个src.zip的压缩包，这就是JDK的源码。 操作 有两种关联的方法可供参考。 方法一 按照下面的顺序操作，即可正常关联JDK源码。 1.打开eclipse选择Window-&gt;Preference。 2.选择Java-&gt;Installed JREs 或者直接搜索Installed JREs 选择Java->Installed JRES 3.此时”Installed JRES”右边是列表窗格，列出了系统中的 JRE 环境，选择你的JRE，然后点边上的 “Edit…”。 4.会出现一个窗口(Edit JRE)，选中rt.jar文件的这一项。 5.展开后，可以看到“Source Attachment:(none)”，点这一项，点右边的按钮“Source Attachment…”, 选择你的JDK目录下的 “src.zip”文件。 6.在对话框中，点击External File，选择你所安装的jdk目录下的src.zip文件，一路点OK即可。 注：dt.jar是关于运行环境的类库,主要是swing的包 。dt.jar是关于运行环境的类库,主要是swing的包 。tools.jar是关于一些工具的类库 。dt.jar是关于运行环境的类库,主要是swing的包 。tools.jar是关于一些工具的类库 。rt.jar包含了jdk的基础类库，也就是你在java doc里面看到的所有的类的class文件。 方法二 如果不想去设置，也有懒方法。 打开一个.java文件中，点击Java原生对象，如Object，就会弹出Class File Editor ，点击Attach Source按钮，选择External location –&gt; External File，输入src.zip压缩包所在路径，确认即可关联。操作示意图如下。 1.点击Object对象。 2.弹出Class File Editor关联窗口。 ​ 3.输入路径，关联src.zip压缩包。 4.如果出现如下源码，即关联成功。","tags":[{"name":"Java源码分析","slug":"Java源码分析","permalink":"https://smuwjs.github.io/tags/Java源码分析/"}]},{"title":"mina学习笔记七：串口编程","date":"2016-09-08T12:12:19.000Z","path":"2016/09/08/mina-study-node7/","text":"原文：http://blog.csdn.net/yoara/article/details/37726817 1.基于java.comm的串口编程以前做过一个针对串口扫描枪解析的项目，当时是用的java.comm包。回忆一下当时是怎么做的。 第一步：下载comm包，它包含有三个文件win32com.dll、comm.jar、javax.comm.properties 第二步：分别将他们拷到对应的文件夹 123xcopy \"system\\win32com.dll\" \"%JAVA_HOME%\\jre6\\bin\\\" /E xcopy \"system\\comm.jar\" \"%JAVA_HOME%\\jre6\\lib\\\" /E xcopy \"system\\javax.comm.properties\" \"%JAVA_HOME%\\jre6\\lib\\\" /E 第三步：编码，代码大致如下 12345678910111213141516171819private CommPortIdentifier portId; private SerialPort serialPort; private InputStream is; private ReaderThread t; private static final String PortName = \"COM1\"; //串口号 private static final int DATABITS = 8; //数据位 private static final int STOPBITS = 1; //停止位 private static final int RATE = 9600; //波特率 try&#123; this.portId = CommPortIdentifier.getPortIdentifier(getPortName()); this.serialPort = ((SerialPort)this.portId.open(\"Bar_Scan\", 20000)); this.is = this.serialPort.getInputStream(); this.serialPort.addEventListener(this.t); this.serialPort.notifyOnDataAvailable(true); this.serialPort.setSerialPortParams(getRATE(), getDATABITS(), getSTOPBITS(), 0); this.t.init(this.serialPort, this.is); &#125;catch()&#123;&#125; 12345678910111213141516171819202122public class ReaderThread extends Thread implements SerialPortEventListener&#123; private SerialPort serialPort; private InputStream is; public void init(SerialPort serialPort, InputStream is) &#123; this.serialPort = serialPort; this.is = is; &#125; public void serialEvent(SerialPortEvent event) &#123; switch (event.getEventType()) &#123; case SerialPortEvent.DATA_AVAILABLE: while (true) try &#123; ...; int b = this.is.read(); ... &#125; catch (IOException e)&#123; log4J.error(e); &#125; &#125; &#125; &#125; 2.为什么用mina封装串口通讯可以看出，用sun自带的comm方式针对串口编程也很简单，同时comm包自带了非常丰富的参考例子。但是用mina封装的好处是能复用mina的连接模型，包括filter、listener、handler等等，把对底层的通讯和业务解耦，是系统结构清晰，权责分明。 不过估计mina也觉得用串口编程或通过mina框架串口编程的人士不会很多，所以在官方的标准发布包中并未包含serial部分，需要重新下载。 同时该serial包依赖于rxtx的串口并口包。由于sun的comm包很久都没有维护了，RXTX事实上是对comm再支持，他是开源的，基本思想和开发的模式跟comm几乎一样。编程时最明显的不同是要包含的包名由javax.comm.改成了gnu.io.。 2.1 RXTX的配置方式RXTX官网的下载链接失效了，可以使用这里的。和comm一样，RXTX在使用前需要进行配置（Window下，linux请看包内install） 123Copy RXTXcomm.jar ---&gt; &lt;JAVA_HOME&gt;\\jre\\lib\\ext Copy rxtxSerial.dll ---&gt; &lt;JAVA_HOME&gt;\\jre\\bin Copy rxtxParallel.dll ---&gt; &lt;JAVA_HOME&gt;\\jre\\bin 2.2 mina中的集成使用方式串行通信只提供了一个IoConnector接口，因为串行通信是基于点对点的。要连接到一个串行通信端口上，需要创建一个SerialConnector。 123456//创建串口连接 SerialConnector connector = new SerialConnector(); //绑定处理handler connector.setHandler(new MyHandler()); //设置过滤器 connector.getFilterChain().addLast(\"logger\",new LoggingFilter()); 现在创建一个地址连接到一个串行端口： 123//配置串口连接 SerialAddress address = new SerialAddress (\"COM1\", 9600, DataBits.DATABITS_8,StopBits.BITS_1 , Parity.NONE, FlowControl.NONE); 第一个参数是串行端口标识符，对于Windows系统来说，串行端口被称作“COM1”、“COM2”等，对于Linux和Unix系统来说，则是”/dev/ttyS0”、”/dev/ttyS1”和”/dev/ttyUsb0”等。 剩余的参数取决于所使用的设备，在SerialAddress类中定义了相关的枚举量可参考： 波特率：这是一个衡量符号传输速率的参数。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。一般调制速率大于波特率，比如曼彻斯特编码）。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。 数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是6、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。 停止位：用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。 奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位为1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。 最后建立链接 1234ConnectFuture future = connector.connect(address); future.await(); IoSession session = future.getSession(); session.write(\"good mina\"); 2.3 测试效果手头上没有串口工具，所以用VSPD虚拟了串口出来。测试可用正常。 3.mina serial处理方式分析连接代码被调用时SerialConnector.connect0方法被执行 1234567SerialPort serialPort = initializePort(\"Apache MINA\", portId, portAddress); ConnectFuture future = new DefaultConnectFuture(); SerialSessionImpl session = new SerialSessionImpl(this, getListeners(), portAddress, serialPort); initSession(session, future, sessionInitializer); session.start(); return future; 串口的session，不仅继承了AbstractIoSession ，同时他还实现了SerialSession, SerialPortEventListener。 1class SerialSessionImpl extends AbstractIoSession implements SerialSession, SerialPortEventListener 我们注意他的start方法 123456789101112131415void start() throws IOException, TooManyListenersException &#123; inputStream = port.getInputStream(); outputStream = port.getOutputStream(); ReadWorker w = new ReadWorker(); w.start(); port.addEventListener(this); ((SerialConnector) getService()).getIdleStatusChecker0().addSession(this); try &#123; getService().getFilterChainBuilder().buildFilterChain(getFilterChain()); serviceListeners.fireSessionCreated(this); &#125; catch (Throwable e) &#123; getFilterChain().fireExceptionCaught(e); processor.remove(this); &#125; &#125; 其中有个ReadWorker线程，他首先等待Object readReadyMonitor的资源，如果readReadyMonitor被notify，那线程就开始读数据 1234567891011121314151617181920212223try &#123; readReadyMonitor.wait(); &#125; catch (InterruptedException e) &#123; log.error(\"InterruptedException\", e); &#125; if (isClosing() || !isConnected()) &#123; break; &#125; int dataSize; try &#123; dataSize = inputStream.available(); byte[] data = new byte[dataSize]; int readBytes = inputStream.read(data); if (readBytes &gt; 0) &#123; IoBuffer buf = IoBuffer.wrap(data, 0, readBytes); buf.put(data, 0, readBytes); buf.flip(); getFilterChain().fireMessageReceived(buf); &#125; &#125; catch (IOException e) &#123; getFilterChain().fireExceptionCaught(e); &#125; 而readReadyMonitor被notify的事件就发生在串口有数据读入，因SerialSessionImpl实现了SerialPortEventListener，所以他就可以监听事件 1234567public void serialEvent(SerialPortEvent evt) &#123; if (evt.getEventType() == SerialPortEvent.DATA_AVAILABLE) &#123; synchronized (readReadyMonitor) &#123; readReadyMonitor.notifyAll(); &#125; &#125; &#125; 结语补充了一下mina对串口的支持，框架确实是个剥离业务与底层的好东西。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"mina学习笔记六：补刀","date":"2016-09-08T12:12:18.000Z","path":"2016/09/08/mina-study-node6/","text":"原文：http://blog.csdn.net/yoara/article/details/37612703 补充一些可能没讲到的细节。 1.WriteRequest每一个session.write()操作都会被封装成writeRequest并被添加到WriteRequestQueue队列中。过滤器的每一次责任链流转都是以writeRequest为传参的。我们的老祖父AbstractIoService在实例化时，自带了一个非常重要的属性字段。是不得不注意的参数哟，虽然他对我们基本上是透明的。 1private IoSessionDataStructureFactory sessionDataStructureFactory = new DefaultIoSessionDataStructureFactory(); 这个参数就包括了两个鸟不得的结构体，一个就是attribute的map，另一个就是我们可爱的WriteRequestQueue了。 2.IoBufferIoBuffer是mina框架对Nio中Buffer的再封装，Buffer应已经是很好用了，mina为什么还要继续封装呢？他给出的原因有2： Buffer没有提供实用的工具型getter和setter方法，比如fill, get/putString, and get/putAsciiInt() 。 原生的Buffer是固定长度的，非常不利于用于操作可变长度的数据。 说实话，这两个原因看上去都不怎么靠谱，要我说，真正的原因就是，框架没有点自己的封装就不是高大上了嘛~哈哈。 mina自身也有点后悔这样的选择，据说在mina3中将采取不同的策略。下面是官方的原话： This will change in MINA 3\\. The main reason why MINA has its own wrapper on top of nio ByteBuffer is to have extensible buffers.This was a very bad decision.Buffers are just buffers : a temporary place to store temporary data, before it is used. Many other solutions exist, like defining a wrapper which relies on a list of NIO ByteBuffers, instead of copying the existing buffer to a bigger one just because we want to extend the buffer capacity. It might also be more comfortable to use an InputStream instead of a byte buffer all along the filters, as it does not imply anything about the nature of the stored data : it can be a byte array, strings, messages... Last, not least, the current implementation defeat one of the target : zero-copy strategy (ie, once we have read the data from the socket, we want to avoid a copy being done later). As we use extensible byte buffers, we will most certainly copy those data if we have to manage big messages. Assuming that the MINA ByteBuffer is just a wrapper on top of NIO ByteBuffer, this can be a real problem when using direct buffers. 3.用到的设计模式3.1抽象工厂ProtocolCodecFactory机智的过滤器ProtocolCodecFilter需要机智的解编码器。以TextLineCodecFactory为例： 3.2 建造者模式这里的导演类就是我们添加filter的设置代码，而产生出的产品则是顺序不同的filter链。 3.3 适配器模式![](http://opesdt6ii.bkt.clouddn.com/17-5-5/66833683-file_1493967343756_e360.jpg) 3.4 装饰者模式writeRequest这一家子就是很好的例子。 3.5 外观模式我们劳苦功高的IoServiceListenerSupport，为filter和listener提供了一致性的操作接口 3.6 桥接模式这就太多了，但凡存在属性字段是接口的，几乎都是桥接模式。只画个类图示意： 3.7 组合模式过滤器链里面的用到的模式之一。 3.8 享元模式每个在数组pool里的IoProcessor都是一个享元。 3.9 模板方法大量的实现都用到了模板方法，这个模式是子类延迟实现的典范。 3.10 观察者模式在背后默默支持我们的IoServiceListenerSupport，就担负着通知观察者的重任。 3.11 策略模式每一种filter的具体实现都是一种策略 3.12 责任链模式在过滤器链中，每个节点都持有对下一个节点的引用。其中节点并非filter实例，而是封装了filter、上一个filter、下一个filter、下一个filter操作对象的Entry对象。 3.13 命令模式比如session.wirte，发送的消息将被封装到WriteRequest中，最终经过一系列的过滤器被提交到WriteRequestQueue中等待发送。IoProcessor通过轮询将消息队列flush出去。在这里，消息的请求者是session、消息发送实现者是Processor，而消息及消息处理的future被封装到WriteRequest这个对象中。 一般命令模式的主体会持有执行者的引用，命令模式通过调用执行者的方法执行命令，这里是放到一个队列里被轮询执行，所以不能算是完整的命令模式。但命令模式关注的是“行为请求者”和“行为执行者”的解耦，并封装调用请求的变化，这里是符合这个思想的。 4.为什么NioDatagramAcceptor不使用SimpleIoProcessorPool我们知道在前面讲到NioSocketAcceptor在初始化时会生成SimpleIoProcessorPool的IoProcessor的池，池中每个processor都会处理一组session。而NioDatagramAcceptor没有使用池化的IoProcessor，而是选择实现了IoProcessor，即他本身就是一个IoProcessor，在他自身的executer中只有一个Acceptor勤劳的为他做着接受新数据的 但是为什么呢？ 我们知道，UDP是无连接的协议，select()应答器响应有通道的数据到来时，通过receive()方法获取buffer内容。NioDatagramAcceptor只开启了单个DatagramChannel用于数据传输，因为他不需要像NioSocketAcceptor那样维持一个通讯会话session。 对于远程地址相同的请求，NioDatagramAcceptor使用可重用的ExpiringSessionRecycler对象sessionRecycler来复用session。而NioSocketAcceptor会为把每个session分配到指定的IoProcessor池中的一个去处理。 12345678910111213141516171819202122232425262728293031323334353637383940AbstractPollingConnectionlessIoAcceptor.newSessionWithoutLock( SocketAddress remoteAddress, SocketAddress localAddress ) throws Exception &#123; H handle = boundHandles.get( localAddress ); if ( handle == null ) &#123; throw new IllegalArgumentException( \"Unknown local address: \" + localAddress ); &#125; IoSession session; synchronized ( sessionRecycler ) &#123; session = sessionRecycler.recycle( remoteAddress ); if ( session != null ) &#123; return session; &#125; // If a new session needs to be created. S newSession = newSession( this, handle, remoteAddress ); getSessionRecycler().put( newSession ); session = newSession; &#125; initSession( session, null, null ); try &#123; this.getFilterChainBuilder().buildFilterChain( session.getFilterChain() ); getListeners().fireSessionCreated( session ); &#125; catch ( Throwable t ) &#123; ExceptionMonitor.getInstance().exceptionCaught( t ); &#125; return session; &#125; 究其原因，应该是NioDatagramAcceptor对于会话的维护不需要付出NioSocketAcceptor那么大的代价。NioDatagramAcceptor只用了一个Selector去监听会话请求，而NioSocketAcceptor用了1个监听连接、CPU+1个去监听不同的session，可见一斑。 结语客户端的IoConnector部分就不分析了。相信通过这几节的了解，框架结构都非常清楚了。应该没有别的落下= =不过其中有很多对网络的实现方面的细节还不是很清楚，看来要了解网络传输底层的东西才行。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"mina学习笔记五：做嫁衣的IoFilter和IoListener","date":"2016-09-08T12:12:17.000Z","path":"2016/09/08/mina-study-node5/","text":"原文：http://blog.csdn.net/yoara/article/details/37597141 总有那么一群人，他们默默无闻的工作在自己的岗位上，你永远都接触不到他们，可是离了他们完整的做好一件事。譬如只注意在荧光屏上的明星，却不知道谁给他们打得灯光、谁给他们踩得位、谁给他们化妆端茶送水等等。IoFilter也是这群人中的一员，每个session的请求和事件离不了他们，IoFilter在IoService和IoHandler之间提供了各个层面的切面支持，让其他两个组件安心做自己的事而不用关注其他细节。软件工程的魅力也在于此——解耦。 1.IoFilter的一家子IoFilter家族的类图结构非常简单明快，mina非常贴心的为广大使用者提供了丰富的Filter实现子类，很多标准服务我们都不需要自己实现。 图5.1 IoFilter类图 我们先简单介绍一下这个家族成员和他们各自的作用吧：| Filter | class | Description || —————————- | —————————————- | —————————————- || Blacklist | BlacklistFilter | 黑名单过滤器 || BufferedWrite | BufferedWriteFilter | 发送缓存过滤器，缓存发送的消息，避免短小消息频繁发送 || Compression | CompressionFilter | 数据压缩过滤器 || ConnectionThrottle | ConnectionThrottleFilter | 连接控制过滤器，对同一IP地址频繁的创建连接的时间间隔进行控制 || ErrorGenerating | ErrorGeneratingFilter | 花数据过滤器，增加、修改、移除接受的数据包内容，可作为加密的方式 || Executor | ExecutorFilter | 处理线程池过滤器，让每个请求或者事件都通过线程池去执行 || FileRegionWrite | FileRegionWriteFilter | 文件转换过滤器，通常应该由IoProcess做这件事，但若需要压缩或者修改时，可通过过滤器链之间的配合来实现 || KeepAlive | KeepAliveFilter | 心跳包过滤器，在idle状态时发送心跳包，并能对超时进行处理 || Logging | LoggingFilter | 日志记录过滤器，最常用之一 || MDC Injection | MdcInjectionFilter | 日志信息注入过滤器，MDC(Mapped Diagnostic Context有译作线程映射表)是日志框架维护的一组信息键值对，可向日志输出信息中插入一些想要显示的内容。 || Noop | NoopFilter | 用作内部测试的filter，什么也没做 || Profiler | ProfilerTimerFilter | 时间分析过滤器，记录各种事件消耗的时间 || ProtocolCodec | ProtocolCodecFilter | 编解码过滤器，最常用之二 || Proxy | ProxyFilter | 是IoConnector在连接握手时自动加入的过滤器，握手成功后就透明了 || Reference counting | ReferenceCountingFilter | 引用数过滤器，能记录该过滤器被加入或移除过滤器链的次数，真实使用是继承他。 || RequestResponse | RequestResponseFilter | 继承WriteRequest || SessionAttributeInitializing | SessionAttributeInitializingFilter | 初始化过滤器 || StreamWrite | StreamWriteFilter | InputStream直接转换成IoBuffer的过滤器 || SslFilter | SslFilter | TCP/IP层面的SSl加解密过滤器 || WriteRequest | WriteRequestFilter | 简化IoFilter IoEventType.WRITE事件的实现的抽象过滤器 | 还有两个FIlter是mina自带并且不为用户管理的，当生成过滤器链自动注入： HeadFilter（当发生write操作时，将写buffer加入到session.scheduledWriteMessages队列，并执行发送调用IoProcessor执行write()操作），位于过滤器链头。 TailFilter（当所有过滤器都处理完后，他将调用IoHandler的对应方法）。位于过滤器链尾。 2.IoFilter执行顺序搞清楚了 在事件端，我们以messageSent事件被执行的代码来详解下过程；在操作端我们的例子是session.write。 2.1 messageSent顺序调用过滤器链当IoProcessor的remove(session)方法被调用时，该session将被添加进Processor内部的removingSessions的ConcurrentLinkedQueue等待被移除。 12345678public final void remove(S session) &#123; scheduleRemove(session); startupProcessor(); &#125; private void scheduleRemove(S session) &#123; removingSessions.add(session); &#125; 当IoProcessor工作线程执行一个循环，调用removeSessions()方法，状态为SessionState.OPENED的session将被移除，移除的代码中就包括刷新消息队列，其中代码如下，从而引发一次过滤器链的调用。 123456789101112if (message instanceof IoBuffer) &#123; IoBuffer buf = (IoBuffer) message; if (buf.hasRemaining()) &#123; buf.reset(); failedRequests.add(req); &#125; else &#123; IoFilterChain filterChain = session.getFilterChain(); filterChain.fireMessageSent(req); &#125; &#125; else &#123; failedRequests.add(req); &#125; 最终调用的是TailFilter，他的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static class TailFilter extends IoFilterAdapter &#123; public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception &#123; session.getHandler().sessionCreated(session); &#125;  public void sessionOpened(NextFilter nextFilter, IoSession session) throws Exception &#123; session.getHandler().sessionOpened(session); &#125;  public void sessionClosed(NextFilter nextFilter, IoSession session) throws Exception &#123; AbstractIoSession s = (AbstractIoSession) session; try &#123; s.getHandler().sessionClosed(session); &#125; finally &#123; try &#123; s.getWriteRequestQueue().dispose(session); &#125; finally &#123; try &#123; s.getAttributeMap().dispose(session); &#125; finally &#123; try &#123; // Remove all filters. session.getFilterChain().clear(); &#125; finally &#123; if (s.getConfig().isUseReadOperation()) &#123; s.offerClosedReadFuture(); &#125; &#125; &#125; &#125; &#125; &#125;  public void sessionIdle(NextFilter nextFilter, IoSession session, IdleStatus status) throws Exception &#123; session.getHandler().sessionIdle(session, status); &#125;  public void exceptionCaught(NextFilter nextFilter, IoSession session, Throwable cause) throws Exception &#123; AbstractIoSession s = (AbstractIoSession) session; try &#123; s.getHandler().exceptionCaught(s, cause); &#125; finally &#123; if (s.getConfig().isUseReadOperation()) &#123; s.offerFailedReadFuture(cause); &#125; &#125; &#125;  public void messageReceived(NextFilter nextFilter, IoSession session, Object message) throws Exception &#123; session.getHandler().messageReceived(s, message); &#125; public void messageSent(NextFilter nextFilter, IoSession session, WriteRequest writeRequest) throws Exception &#123; session.getHandler().messageSent(session, writeRequest.getMessage()); &#125; public void filterWrite(NextFilter nextFilter, IoSession session, WriteRequest writeRequest) throws Exception &#123; nextFilter.filterWrite(session, writeRequest); &#125;  public void filterClose(NextFilter nextFilter, IoSession session) throws Exception &#123; nextFilter.filterClose(session); &#125; &#125; 2.2 session.write逆序调用过滤器链在Handler中持有session的对象，调用session.write(date.toString());，session会调用具体方法： 123456AbstractIoSession.write(Object message) &#123; ... IoFilterChain filterChain = getFilterChain(); filterChain.fireFilterWrite(writeRequest); ... &#125; 1234DefaultIoFilterChain.fireFilterWrite(WriteRequest writeRequest) &#123; Entry tail = this.tail; callPreviousFilterWrite(tail, session, writeRequest); &#125; 触发逆序的过滤器链，最终到HeadFilter中： 123456789101112131415161718...其他Filter HeadFilter.filterWrite(NextFilter nextFilter, IoSession session, WriteRequest writeRequest) throws Exception &#123; AbstractIoSession s = (AbstractIoSession) session; ... WriteRequestQueue writeRequestQueue = s.getWriteRequestQueue(); if (!s.isWriteSuspended()) &#123; if (writeRequestQueue.size() == 0) &#123; // We can write directly the message s.getProcessor().write(s, writeRequest); &#125; else &#123; s.getWriteRequestQueue().offer(s, writeRequest); s.getProcessor().flush(s); &#125; &#125; else &#123; s.getWriteRequestQueue().offer(s, writeRequest); &#125; &#125; 3.IoHandler APIHandler虽然是直面用户的对象，但由上述可知，他其实只是整个操作链上最后的一环，也是最简单的一环，给出IoHander的API清单 sessionCreated(IoSession)：session创建时调用 sessionOpened(IoSession)：session打开时调用，实际上是在sessionCreated后立即执行 sessionClosed(IoSession)：session关闭时调用 sessionIdle(IoSession, IdleStatus)：session空闲时调用 exceptionCaught(IoSession, Throwable)：异常时调用 messageReceived(IoSession, Object)：接收到新的request时调用 messageSent(IoSession, Object)：发送在消息队列中未完成的消息时调用 4. IoFilter API和Handler有一部分一致： init() filter初始化方法，在下面4个on方法调用之前必须先被调用。 destroy() 该方法被ReferenceCountingFilter引用到，如果不继承ReferenceCountingFilter，不需实现该方法。 onPreAdd(IoFilterChain, String, NextFilter) 过滤器被添加之前调用。 onPostAdd(IoFilterChain, String, NextFilter) 过滤器被添加之后调用。 onPreRemove(IoFilterChain, String, NextFilter) 过滤器被移除之前调用。 onPostRemove(IoFilterChain, String, NextFilter) 过滤器被移除之后调用。 sessionCreated(NextFilter, IoSession) sessionOpened(NextFilter, IoSession) sessionClosed(NextFilter, IoSession) sessionIdle(NextFilter, IoSession, IdleStatus) exceptionCaught(NextFilter, IoSession, Throwable) messageReceived(NextFilter, IoSession, Object) messageSent(NextFilter, IoSession, WriteRequest) filterClose(NextFilter, IoSession) session.close(）方法中调用。 filterWrite(NextFilter, IoSession, WriteRequest) session.write(）方法中调用。 5. IoListener上面用了比较多的篇幅介绍了IoFilter，现在我们也该讲讲二号后台人物——IoListerner。在mina中主要有两类，一个是IoServiceListener，另一个就是IoFutureListener。 5.1 IoServiceListenerIoServiceListener负责Service的各个生命周期节点事件通知。我们曾在学习笔记三中提到过IoServiceListenerSupport，此类对象是该service所有IoServiceListener对象的持有类并管理着监听器的回调入口，同时还管理着当前Service的所有session。当时没有详细的介绍，现在我们重点说说这个类在做嫁衣方面的独到之处。 IoServiceListenerSupport是在AbstractIoService的构造函数中被生成的，也就是说，恭喜，无论你是Acceptor还是Connector，你都拥有这个强大的助手了。为了支持监听器的功能，可爱的祖父AbstractIoService还贴心的为我们实现好了addListener(IoServiceListener listener)和removeListener(IoServiceListener listener)方法。 我们先看看的API吧： serviceActivated(IoService) 当service生效时被调用。当新的service被bind时或第一个session生成时，IoServiceListenerSupport.fireServiceActivated被调用同时调用此方法。 serviceIdle(IoService, IdleStatus) 当service空闲时被调用，不过此方法没有在mina中真正使用。 serviceDeactivated(IoService) 当service失效时被调用。当service被unbind或最后个session注销时，IoServiceListenerSupport.fireServiceDeactivated被调用同时调用此方法。 sessionCreated(IoSession) 当新的session生成时被调用。IoServiceListenerSupport.fireSessionCreated sessionDestroyed(IoSession) 当session被注销时调用。IoServiceListenerSupport.fireSessionDestroyed 如此一看，还是很简单清晰的，监听器可以在任意时刻被添加或移除。我们的使用方法也很简单： 123456789101112131415IoServiceListener listener = new IoServiceListener() &#123; public void sessionDestroyed(IoSession session) throws Exception &#123; &#125; public void sessionCreated(IoSession session) throws Exception &#123; &#125; public void serviceIdle(IoService service, IdleStatus idleStatus) throws Exception &#123; &#125; public void serviceDeactivated(IoService service) throws Exception &#123; &#125; public void serviceActivated(IoService service) throws Exception &#123; &#125; &#125;; acceptor.addListener(listener); acceptor.removeListener(listener); 5.1 IoFutureListener还有一种Listener就是IoFutureListener，他在学习笔记四种也出现过，确实也比较简单，能在IoFuture任务完成后被调用，唯一的API： 123public interface IoFutureListener&lt;F extends IoFuture&gt; extends EventListener &#123; void operationComplete(F future); &#125; 因为大部分的future都被mina集成在框架里，所以future的listener支持一项特性：若任务已经执行完后添加的listener将被立刻执行。我们先看看future是怎么实现该功能的。 1234567891011121314151617181920212223242526public IoFuture addListener(IoFutureListener&lt;?&gt; listener) &#123; if (listener == null) &#123; throw new IllegalArgumentException(\"listener\"); &#125; boolean notifyNow = false; synchronized (lock) &#123; if (ready) &#123; notifyNow = true; &#125; else &#123; if (firstListener == null) &#123; firstListener = listener; &#125; else &#123; if (otherListeners == null) &#123; otherListeners = new ArrayList&lt;IoFutureListener&lt;?&gt;&gt;(1); &#125; otherListeners.add(listener); &#125; &#125; &#125; 是这里了！如果ready完成了，则马上执行 if (notifyNow) &#123; notifyListener(listener); &#125; return this; &#125; 那不用说就知道啦，在notiffyListener中将会回调监听器的方法。 6. 结语mina框架核心部件基本上都讲的差不多了，看看如果有需要补余的，留在下一章节。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"mina学习笔记四：交互的核心IoSession","date":"2016-09-08T12:12:16.000Z","path":"2016/09/08/mina-study-node4/","text":"原文：http://blog.csdn.net/yoara/article/details/37568027 这一章讲的就是IoSession，session这个词做web应用的人应该都是耳熟能详，在mina中IoSession也是起着相同的作用。mina为每个客户端提供了会话session，session是服务器端和客户端的连接持有者，直到连接中断session才会被销毁。 IoSession不仅是connection的相关信息，同时，服务器端还能通过他存储其他可能需要的数据信息。好，让我们一步一步剖析IoSession那不平凡的一生吧。 1. IoSession在服务器端的创建第一步：accept(processor,handle)接着上节说，我们已经知道，NioSocketAcceptor.bind()后，最终会生成一个在自身维护的executor线程池内提交的任务Acceptor（单一线程），该任务不断的轮询判断服务是否关闭、同时等待新的连接接入。当有新的连接接入时： 123456Acceptor.run()&#123; ... //selectedHandles()获取一个selector中注册的服务监听的serversocketchannel的迭代器 processHandles(selectedHandles()); ...&#125; 创建session、并为其分配指定IoProcessor的秘密都在AbstractPollingIoAcceptor.processHandles()这个方法中。我们接着看： 12345678910111213141516171819private void processHandles(Iterator&lt;ServerSocketChannel&gt; handles) throws Exception &#123; while (handles.hasNext()) &#123; H handle = handles.next(); handles.remove(); // 创建session并将本地的processor处理池当参数传递给session // 注意这里还未分配具体的processor S session = accept(processor, handle); if (session == null) &#123; continue; &#125; // 初始化Session initSession(session, null, null); // 将session分配给具体的processor session.getProcessor().add(session); &#125; &#125; 第一步accept(processor,handle)方法，调用子类实现的NioSession accept(...)方法，判断了SelectionKey的有效性后，获得连接的通道SocketChannel ch = handle.accept();最后以此为传参创建IoSession对象return new NioSocketSession(this, processor, ch);我们看下构造函数做了什么（为了方便起见，相关的父类构造函数都写在一块了）： 1234567891011121314151617181920212223242526272829303132333435 public NioSocketSession(IoService service, IoProcessor&lt;NioSession&gt; processor, SocketChannel channel) &#123;//AbstractIoSession(IoService service) this.service = service; this.handler = service.getHandler(); //保存当前的处理时间信息 long currentTime = System.currentTimeMillis(); creationTime = currentTime; lastThroughputCalculationTime = currentTime; lastReadTime = currentTime; lastWriteTime = currentTime; lastIdleTimeForBoth = currentTime; lastIdleTimeForRead = currentTime; lastIdleTimeForWrite = currentTime; //在关闭时的动作，下面以此展开对IoFuture的探讨。 closeFuture.addListener(SCHEDULED_COUNTER_RESETTER); //为session创建唯一的ID sessionId = idGenerator.incrementAndGet();//END AbstractIoSession(IoService service)//NioSession(IoProcessor&lt;NioSession&gt; processor, IoService service, Channel channel)//即当前session的SocketChannelthis.channel = channel;//这是ioservice中的processor池哦 this.processor = processor;//这步过滤器链厉害了，后面细说 filterChain = new DefaultIoFilterChain(this);//END NioSession(IoProcessor&lt;NioSession&gt; processor, IoService service, Channel channel)//设置各种初始参数 config = new SessionConfigImpl(); this.config.setAll(service.getSessionConfig()); &#125; 右边这张图是IoSession的类图结构，比较清晰。 我们细细的分析一下NioSocketSession在初始化时做了哪些工作，首先持有了sevice及其处理类引用，并设置了一些初始时间信息，然后他在关闭时注册了监听操作closeFuture.addListener(SCHEDULED_COUNTER_RESETTER)。 1.1 IoFuture我们已经很多次看到IoFuture，有必要来详细了解一下IoFuture的作用。那用过Executor的同学都知道，submit()提交Callback的任务后将返回一个Future表示这个任务的操作结果，这里的IoFuture的作用是类似的，他代表一次相关于IoSession的操作的操作结果，同时，还可以在他完成时获取定义相关的操作。我们看下他的子类结构图 图4.1 IoFuture子类结构图 由图中可见，对session相关的操作例如关闭、连接、写、读等操作，IoFuture全都有子类去支持。session的操作可以很方便的通过IoFuture查看处理的结果。我们看下IoFuture接口的API清单： 12345678910addListener(IoFutureListener&lt;?&gt;)await()await(long)await(long, TimeUnit)awaitUninterruptibly()awaitUninterruptibly(long)awaitUninterruptibly(long, TimeUnit)getSession()isDone()removeListener(IoFutureListener&lt;?&gt;) 从清单我们了解到：1.IoFuture支持添加操作完成的监听器，2.IoFuture支持可中断、可设置超时时间的阻塞式操作。3.isDone()则返回操作的完成状态。 123public interface IoFutureListener&lt;F extends IoFuture&gt; extends EventListener &#123; void operationComplete(F future);&#125; 在他的直接实现子类DefaultIoFuture里面，我们看一下该类很主要一个实现方法setValue(Object newValue)，所有其他子类都会调用该方法以完成具体的操作： 123456789101112131415161718 public void setValue(Object newValue) &#123; synchronized (lock) &#123; // 已经完成则直接返回 if (ready) &#123; return; &#125; //设置结果 result = newValue; //设置完成状态 ready = true; //唤醒所有等待线程 if (waiters &gt; 0) &#123; lock.notifyAll(); &#125; &#125;//通知监听器执行完成操作 notifyListeners(); &#125; DefaultIoFuture中个还有一个检查死锁的方法，大家有兴趣可以看下是怎么判断死锁的： 12345678910111213141516171819202122232425262728293031323334353637383940private void checkDeadLock() &#123; // Only read / write / connect / write future can cause dead lock. if (!(this instanceof CloseFuture || this instanceof WriteFuture || this instanceof ReadFuture || this instanceof ConnectFuture)) &#123; return; &#125; // Get the current thread stackTrace. // Using Thread.currentThread().getStackTrace() is the best solution, // even if slightly less efficient than doing a new Exception().getStackTrace(), // as internally, it does exactly the same thing. The advantage of using // this solution is that we may benefit some improvement with some // future versions of Java. StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); // Simple and quick check. for (StackTraceElement s : stackTrace) &#123; if (AbstractPollingIoProcessor.class.getName().equals(s.getClassName())) &#123; IllegalStateException e = new IllegalStateException(\"t\"); e.getStackTrace(); throw new IllegalStateException(\"DEAD LOCK: \" + IoFuture.class.getSimpleName() + \".await() was invoked from an I/O processor thread. \" + \"Please use \" + IoFutureListener.class.getSimpleName() + \" or configure a proper thread model alternatively.\"); &#125; &#125; // And then more precisely. for (StackTraceElement s : stackTrace) &#123; try &#123; Class&lt;?&gt; cls = DefaultIoFuture.class.getClassLoader().loadClass(s.getClassName()); if (IoProcessor.class.isAssignableFrom(cls)) &#123; throw new IllegalStateException(\"DEAD LOCK: \" + IoFuture.class.getSimpleName() + \".await() was invoked from an I/O processor thread. \" + \"Please use \" + IoFutureListener.class.getSimpleName() + \" or configure a proper thread model alternatively.\"); &#125; &#125; catch (Exception cnfe) &#123; // Ignore &#125; &#125;&#125; 1.2 IoSession的过滤器链IoSession是有状态的，它包括： Connected ：IoSession已被创建且生效。 Idle ：会话在一定时间内没有处理任何请求，它包括下面三个子状态： Idle for read ： 一段时间内没有接受数据。 Idle for write ： 一段时间内没有发送数据。 Idle for both ： 一段时间内没有产生接受或发送数据的操作。 Closing : IoSession正在关闭中。 Closed : session已经被关闭。 图4.2 IoSession状态变化图 每个状态都会引起一系列的过滤器的对应的操作，从这句代码中我们了解到，每个IoSession都有他自己的过滤器链，即我们可以为每个session定制过滤器链。 1filterChain = new DefaultIoFilterChain(this); IoSession会先继承IoService的过滤器链，过滤器链将放在下一节统一分析。 2. IoSession在服务器端的创建第二步：initSession(session, null, null)这一步initSession(session, null, null);主要的有两段可配置的属性，一个就是存储attribute属性键值对的Map，默认是ConcurrentHashMap；另一个就是发送队列，默认是ConcurrentLinkedQueue。若要实现自己的数据结构，需要重写接口IoSessionDataStructureFactory或继承DefaultIoSessionDataStructureFactory。 1234567891011121314151617try &#123; ((AbstractIoSession) session).setAttributeMap(session.getService().getSessionDataStructureFactory() .getAttributeMap(session)); &#125; catch (IoSessionInitializationException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new IoSessionInitializationException(\"Failed to initialize an attributeMap.\", e); &#125; try &#123; ((AbstractIoSession) session).setWriteRequestQueue(session.getService().getSessionDataStructureFactory() .getWriteRequestQueue(session)); &#125; catch (IoSessionInitializationException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new IoSessionInitializationException(\"Failed to initialize a writeRequestQueue.\", e); &#125; 3. IoSession在服务器端的创建第三步：session.getProcessor().add(session);这一步就是为我们新生成的IoSession在IoService的Processor池中指定一个Processor处理。分配的方式就是取模分配，完成后在分配Processor中增加该IoSession的引用。SimpleIoProcessorPool中的代码如下： 12345 public final void add(S session) &#123; //请注意这里是两步，第一步getProcessor(session)在下面段代码，创建（若没有）并返回Processor //第二步在该Processor中add(session),这里就是调用AbstractPollingIoProcessor.add()，后面有更多描述 getProcessor(session).add(session); &#125; 12345678910111213141516171819private IoProcessor&lt;S&gt; getProcessor(S session) &#123; IoProcessor&lt;S&gt; processor = (IoProcessor&lt;S&gt;) session.getAttribute(PROCESSOR); if (processor == null) &#123; if (disposed || disposing) &#123; throw new IllegalStateException(\"A disposed processor cannot be accessed.\"); &#125; processor = pool[Math.abs((int) session.getId()) % pool.length]; if (processor == null) &#123; throw new IllegalStateException(\"A disposed processor cannot be accessed.\"); &#125; session.setAttributeIfAbsent(PROCESSOR, processor); &#125; return processor; &#125; 4. SimpleIoProcessorPool、IoProcess和NioSocketAcceptor之间的关系上节我们留了个悬念，SimpleIoProcessorPool、IoProcess和IoServices之间的到底是关系呢？我们从SimpleIoProcessorPool初始化池说起： 12345for (int i = 1; i &lt; pool.length; i++) &#123; ... pool[i] = processorConstructor.newInstance(this.executor); ... &#125; 这段代码将生成的线程池当做构造传参传递给所有的NioProcess，即数组池中所有NioProcess都是共享一个Executro线程池的（newCashedThreadPool）。AbstractPollingIoProcessor.add()方法做了这些工作： 12345678910 public final void add(S session) &#123; if (disposed || disposing) &#123; throw new IllegalStateException(\"Already disposed.\"); &#125; // 将session添加到ConcurrentLinkedQueue的队列中，并启动Processor 的worker线程 newSessions.add(session); //启动Processor线程 tartupProcessor(); &#125; 我们很有必要具体看一下Processor线程做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041private class Processor implements Runnable &#123; public void run() &#123; ... for (;;) &#123; try &#123; // 监控空闲时间 long t0 = System.currentTimeMillis(); int selected = select(1000); long t1 = System.currentTimeMillis(); long delta = (t1 - t0); ... // 注册新的session连接，并初始化session信息，如过滤器链， // 通知service的监听器 nSessions += handleNewSessions(); ... // 处理新的请求 if (selected &gt; 0) &#123; process(); &#125; ... // 移除 nSessions -= removeSessions(); // 通知空闲监听器 notifyIdleSessions(currentTime); ... //关闭 if (isDisposing()) &#123; for (Iterator&lt;S&gt; i = allSessions(); i.hasNext();) &#123; scheduleRemove(i.next()); &#125; wakeup(); &#125; &#125; catch ... &#125; ... &#125; &#125; 其中，handlesNewSessions()做了如下工作： 1234567891011 //在selector上注册感兴趣的相应集合读操作 SelectableChannel ch = (SelectableChannel) session.getChannel(); ch.configureBlocking(false); session.setSelectionKey(ch.register(selector, SelectionKey.OP_READ, session));  //将service的过滤器链设置在session上 IoFilterChainBuilder chainBuilder = session.getService().getFilterChainBuilder(); chainBuilder.buildFilterChain(session.getFilterChain()); //回调监听器 IoServiceListenerSupport listeners = ((AbstractIoService) session.getService()).getListeners(); listeners.fireSessionCreated(session); 至此SimpleIoProcessorPool、IoProcess和IoServices的关系就清晰了。 SimpleIoProcessorPool维护一组IoProcess[] ，每个IoProcess都在线程池中绑定了工作线程，该工作线程开启一个selector并监听session交互OP_READ。 123456789public NioProcessor(Executor executor) &#123; super(executor); try &#123; selector = Selector.open(); &#125; catch (IOException e) &#123; throw new RuntimeIoException(\"Failed to open a selector.\", e); &#125; &#125; NioSocketAcceptor持有一个pool的引用 NioSocketAcceptor自身也有个单线程的executor，用于监听新的session的链接OP_ACCEPT。 123NioSocketAcceptor.init() throws Exception &#123; selector = Selector.open(); &#125; 结语今天分析了IoSession后，mina的框架体系就比较清晰了，不过还有重要的filter、handler等，我们接下来几章继续探讨。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"mina学习笔记三：一切的源头IoService","date":"2016-09-08T12:12:15.000Z","path":"2016/09/08/mina-study-node3/","text":"原文:http://blog.csdn.net/yoara/article/details/37382137 1.IoService介绍从上节的例子已经了解到，创建服务端服务第一步是： 1IoAcceptor acceptor = new NioSocketAcceptor(); 而创建客户端连接的第一步是： 1IoConnector connector = new NioSocketConnector(); 这两个接口的父接口正是IoService。IoService是mina的核心组件，他提供标准的I/O 服务并且管理I/O 会话Session。IoService为大部分mina服务提供了底层的API支持。AbstractIoService是IoService的子类，他提供了基本的服务实现。先由下图简单的了解下IoService及其子类AbstractIoService的在mina体系结构中所担负的责任。 职责分解图 如图所见，IoService的权责主要包括： 会话Session管理：创建和销毁会话，检测session等待等。 过滤器链管理：管理过滤器链，提供多个切面的服务，并允许用户在运行时动态变更过滤器链。 处理调用：当有新消息或其他session生命周期触发事件响应时，回调用户的业务代码。 统计管理：更新消息发送量、字节发送量等等信息。 监听器管理：提供服务各个生命周期触发时间的监听器管理，如服务有效时、服务空闲时、会话创建时等。 传输管理：可在服务端客户端有效的控制数据流的传输，平衡负载。 2.IoService API分析那了解了IoService所承担的责任，以及知道他是服务端和客户端的共同祖先接口，我们有必要看一下他的API 清单： void addListener(IoServiceListener)：为service添加监听器 void removeListener(IoServiceListener)：移除一个监听器 Set broadcast(Object)：向持有的所有session广播消息 void dispose()：关闭service并释放相关联的资源，如果有session还未关闭，此方法会一直堵塞。 void dispose(boolean)：如果参数为true，service会一直阻塞直到ExecutorService线程池关闭后，才会关闭。 boolean isDisposed()：是否已经注销service boolean isDisposing()：是否正在注销service boolean isActive()：是否service还在服务 long getActivationTime()：获取最新活动的时间，如果sevice已经停止，则返回最后一次活动时间 DefaultIoFilterChainBuilder getFilterChain()：获得默认的过滤器链，如果用户没有使用自定义的，将会抛IllegalStateException异常。 void setFilterChainBuilder(IoFilterChainBuilder)：设置过滤器链对象 IoFilterChainBuilder getFilterChainBuilder()：获得过滤器链对象 void setHandler(IoHandler)：设置处理类 IoHandler getHandler()：获得处理类 int getManagedSessionCount()：获得有效的连接session数量 Map&lt;Long, IoSession&gt; getManagedSessions() ：获得当前只读的有效session int getScheduledWriteBytes()：获取尚未发送的字节数 int getScheduledWriteMessages()：获取尚未发送的消息数量 IoSessionConfig getSessionConfig()：获得连接配置信息 void setSessionDataStructureFactory(IoSessionDataStructureFactory)：设置初始化session用的数据信息，注意，服务启动后不可设置。 IoSessionDataStructureFactory getSessionDataStructureFactory()：获得初始化session时用到的一些数据信息 IoServiceStatistics getStatistics()：获得统计数据信息 TransportMetadata getTransportMetadata()：session相关的元数据信息 3.从IoAcceptor开始吧显然，该接口的名称来源于耳熟能详的accept()方法。mina框架已经为我们封装了大部分网络通讯的实现类。因此我们大可不必自己重新去实现（除非有特殊的应用场景）。我们可根据自己的情况从下选择： NioSocketAcceptor ：非阻塞的套接字TCP（Socket） IoAcceptor NioDatagramAcceptor : 非阻塞的数据包UDP IoAcceptor AprSocketAcceptor : 基于 APR 的阻塞式套接字 IoAcceptor VmPipeSocketAcceptor : 基于虚拟机管道的 IoAcceptor 下图是IoAccceptor一支的类图结构： 图3.2 IoAccceptor类图结构 3.1 创建IoAcceptor上节我们已经了解到，IoService开启服务的第一步是创建IoAcceptor： 12//首先，我们为服务端创建IoAcceptor，NioSocketAcceptor是基于NIO的服务端监听器IoAcceptor acceptor = new NioSocketAcceptor(); NioSocketAcceptor 继承自 AbstractPollingIoAcceptor&lt;NioSession, ServerSocketChannel&gt;并实现了SocketAcceptor接口。NioSocketAcceptor共有四个构造函数签名： NioSocketAcceptor() NioSocketAcceptor(int) NioSocketAcceptor(IoProcessor) NioSocketAcceptor(Executor, IoProcessor) 分别调用父类的四个对应构造函数如下。从这里我们知道，IoAcceptor在实例化是必须依赖3个接口，他们分别是IoSessionConfig、IoProcessor、Executor。 AbstractPollingIoAcceptor(IoSessionConfig, Class&lt;? extends IoProcessor&gt;) AbstractPollingIoAcceptor(IoSessionConfig, Class&lt;? extends IoProcessor&gt;, int) AbstractPollingIoAcceptor(IoSessionConfig, IoProcessor) AbstractPollingIoAcceptor(IoSessionConfig, Executor, IoProcessor) 3.1.1先从IoSessionConfig说起无论是NioSocketAcceptor或者NioDatagramAcceptor，具体实现类都是new一个DefaultDatagramSessionConfig实例做为传参： 1234public NioSocketAcceptor() &#123; super(new DefaultSocketSessionConfig(), NioProcessor.class); ((DefaultSocketSessionConfig) getSessionConfig()).init(this); &#125; boolean tcpNoDelay：表示立即发送数据。默认false boolean reuseAddress：表示是否允许重用Socket所绑定的本地地址。默认false int soLinger：表示当执行Socket的close()方法时，是否立即关闭底层的Socket。默认-1 int sendBufferSize：表示发送数据的缓冲区的大小。默认-1 int receiveBufferSize：表示接收数据的缓冲区的大小。默认-1 boolean keepAlive：表示对于长时间处于空闲状态的Socket，是否要自动把它关闭。默认false boolean oobInline：表示是否支持发送一个字节的TCP紧急数据。默认false。 int trafficClass：IP服务类型，底成本：0x02/高可靠：0x04/最高吞吐量：0x08/最小延迟：0x10 同时祖父类AbstractIoSessionConfig还包括如下参数： private int minReadBufferSize = 64; private int readBufferSize = 2048; private int maxReadBufferSize = 65536; private int idleTimeForRead; private int idleTimeForWrite; private int idleTimeForBoth; private int writeTimeout = 60; private boolean useReadOperation;//当IoSession.read()方法可用时，为true。接受到的所有消息将被存储在内部的BlockingQueue中，使用客户端程序可使用更加方便的读取方式。但使该操作生效并不会在服务端应用中产生什么好处反倒会导致不可预料的内存泄露，默认是关闭的。 private int throughputCalculationInterval = 3;//每次throughputCalculation（吞吐量计算？）的间隔时间，默认是3秒。 这些设置主要是传输相关的参数设置，默认就可以了，我们经常用到的估计就是BufferSize和idleTime了。 3.1.2 IoProcessor如果自己不实现IoProcess的话，默认的传递参数是NioProcessor.class（NioDatagramAcceptor构造函数是不需要该参数的）。在父类AbstractPollingIoAcceptor将调用 1new SimpleIoProcessorPool&lt;S&gt;(processorClass) 方法新建一个SimpleIoProcessorPool的实例。IoProcessor提供一个IoProcessor[处理器数+1] 数组类型的池，未处理每一种IoSessions分类。大多数的Services的实现子类都在内部使用该IoProcessor已达到在多核环境下更好的性能。我们不需要直接使用它。但是，如果在本地JVM中需要存在多个IoServices，那有必要让这些services共享一个SimpleIoProcessorPool。如使用一下方法： 1234SimpleIoProcessorPool&lt;NioSession&gt; pool = new SimpleIoProcessorPool&lt;NioSession&gt;(NioProcessor.class, 16);SocketAcceptor acceptor = new NioSocketAcceptor(pool);SocketConnector connector = new NioSocketConnector(pool); 来看一看SimpleIoProcessorPool的构造方法吧：其中，传递的参数processorType为NioProcessor.class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public SimpleIoProcessorPool(Class&lt;? extends IoProcessor&lt;S&gt;&gt; processorType, Executor executor, int size) &#123; if (processorType == null) &#123; throw new IllegalArgumentException(\"processorType\"); &#125; if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"size: \" + size + \" (expected: positive integer)\"); &#125; // 事实上，&lt;span style=\"font-family: Arial, Helvetica, sans-serif;\"&gt;executor在框架内必然是null，除非我们实现自己的子类。&lt;/span&gt; createdExecutor = (executor == null); if (createdExecutor) &#123; &lt;span style=\"color:#ff0000;\"&gt;this.executor = Executors.newCachedThreadPool();&lt;/span&gt; //饱和策略选择了由调度者执行的机制。不过newCachedThreadPool不是无限线程池么，怎么又回饱和呢？ //难道是并发过载导致线程生成不过来？这样的话，负荷过载就会蔓延到IoServices的主线程，这样的饱和策略真的好么？ //我觉得不如抛弃任务，并抛出异常让上层捕获比较好。 ((ThreadPoolExecutor) this.executor).setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); &#125; else &#123; this.executor = executor; &#125; pool = new IoProcessor[size]; boolean success = false; Constructor&lt;? extends IoProcessor&lt;S&gt;&gt; processorConstructor = null; boolean usesExecutorArg = true; try &#123; // 首先保证至少能生成一个processor：默认的话就是newCachedThreadPool()返回的ThreadPoolExecutor，可自行实现 // 这里的初始化策略是：1.首先调用参数类型为ExecutorService 子类的构造函数， // 如果失败则2.调用参数类型为Executor子类的构造函数， // 否则3.调用无参的构造函数 try &#123; try &#123; processorConstructor = processorType.getConstructor(ExecutorService.class); pool[0] = processorConstructor.newInstance(this.executor); &#125; catch (NoSuchMethodException e1) &#123; // To the next step... try &#123; processorConstructor = processorType.getConstructor(Executor.class); pool[0] = processorConstructor.newInstance(this.executor); &#125; catch (NoSuchMethodException e2) &#123; // To the next step... try &#123; processorConstructor = processorType.getConstructor(); usesExecutorArg = false; pool[0] = processorConstructor.newInstance(); &#125; catch (NoSuchMethodException e3) &#123; // To the next step... &#125; &#125; &#125; &#125; catch (RuntimeException re) &#123; LOGGER.error(\"Cannot create an IoProcessor :&#123;&#125;\", re.getMessage()); throw re; &#125; catch (Exception e) &#123; String msg = \"Failed to create a new instance of \" + processorType.getName() + \":\" + e.getMessage(); LOGGER.error(msg, e); throw new RuntimeIoException(msg, e); &#125; if (processorConstructor == null) &#123; // Raise an exception if no proper constructor is found. String msg = String.valueOf(processorType) + \" must have a public constructor with one \" + ExecutorService.class.getSimpleName() + \" parameter, a public constructor with one \" + Executor.class.getSimpleName() + \" parameter or a public default constructor.\"; LOGGER.error(msg); throw new IllegalArgumentException(msg); &#125; // 生成其他的Processor，重复上述步骤 for (int i = 1; i &lt; pool.length; i++) &#123; try &#123; if (usesExecutorArg) &#123; pool[i] = processorConstructor.newInstance(this.executor); &#125; else &#123; pool[i] = processorConstructor.newInstance(); &#125; &#125; catch (Exception e) &#123; // Won't happen because it has been done previously &#125; &#125; success = true; &#125; finally &#123; if (!success) &#123; dispose(); &#125; &#125; &#125; 如果创建失败，则调用dispose方法，遍历IoProcess[]数组并释放所有的资源。 有人会问了，那SimpleIoProcessorPool、IoProcess和IoServices的服务之间有什么关联，为什么NioDatagramAcceptor不需要IoProcess呢？我们将在后面详细阐述。 3.1.3 Executor如果不传入Executor的而实现，mina会默认生成一个newCashedThreadPool，具体代码在非常底层的AbstractIoService类中，即无论是哪种连接方式、服务端、客户端，Executor的默认初始化方式都是一致的。 1234567if (executor == null) &#123; this.executor = Executors.newCachedThreadPool(); createdExecutor = true;&#125; else &#123; this.executor = executor; createdExecutor = false;&#125; 又有问题了，这里的Executor和SimpleIoProcessorPool中为每个IoProcess所共享的Executor有什么关系呢？再卖个关子。 3.2 IoAcceptor的构造函数做了什么？搞清楚了传入参数，我们来看下构造器做了哪些初始化的动作。以NioSocketAcceptor为例。上面我们已经知道底层的AbstractIoService类做了executor的初始化，不仅如此，在这之前他还做了元数据判断和初始化监听器链的工作： 12345678910 if (!getTransportMetadata().getSessionConfigType().isAssignableFrom(sessionConfig.getClass())) &#123; throw new IllegalArgumentException(\"sessionConfig type: \" + sessionConfig.getClass() + \" (expected: \" + getTransportMetadata().getSessionConfigType() + \")\"); &#125; // 创建监听器链，并增加第一个监听器// 该监听器的作用就是在service被激活时，设置IoServiceStatistics的// setLastReadTime、setLastWriteTime、setLastThroughputCalculationTime为激活时间 listeners = new IoServiceListenerSupport(this); listeners.add(serviceActivationListener); 同时，AbstructIoService类还实例化了IoFilterChainBuilder 对象，用于维护过滤器链。 1private IoFilterChainBuilder filterChainBuilder = new DefaultIoFilterChainBuilder(); 有必要提一下IoServiceListenerSupport，此类是所有监听器对象的持有类并管理着监听器的回调入口，同时还管理着当前Service的所有session。 1234567891011/** 当前service的引用 **/private final IoService service;/** 基于COW线程保护的listeners集合 */private final List&lt;IoServiceListener&gt; listeners = new CopyOnWriteArrayList&lt;IoServiceListener&gt;();/** 线程安全的session集合 */private final ConcurrentMap&lt;Long, IoSession&gt; managedSessions = new ConcurrentHashMap&lt;Long, IoSession&gt;();/** session集合的只读视图 **/private final Map&lt;Long, IoSession&gt; readOnlyManagedSessions = Collections.unmodifiableMap(managedSessions); 以其中的方法fireServiceActivated()为例，此方法是Service被激活时调用 1234567891011121314151617 public void fireServiceActivated() &#123; if (!activated.compareAndSet(false, true)) &#123; // 如果已经激活，则返回 return; &#125;//设置激活时间 activationTime = System.currentTimeMillis(); // 观察者模式，回调观察者listener的serviceActivated()方法 for (IoServiceListener listener : listeners) &#123; try &#123; listener.serviceActivated(service); &#125; catch (Throwable e) &#123; ExceptionMonitor.getInstance().exceptionCaught(e); &#125; &#125; &#125; 监听器的每个方法都是在IoServiceListenerSupport里被回调的： 1234fireServiceActivated()fireServiceDeactivated()fireSessionCreated(IoSession)fireSessionDestroyed(IoSession) 同时，service的getActivationTime()、isActive()方法等跟生命周期相关的信息获取方法，都是通过IoServiceListenerSupport的同名方法获得，可以说，IoServiceListenerSupport贯穿了整个IoService的生命周期。 至此，AbstructIoService完成了他的工作，接着AbstructIoAcceptor把defaultLocalAddresses设置为null，不知道这个defaultLocalAddresses的什么用？ 12super(sessionConfig, executor);defaultLocalAddresses.add(null); AbstructIoAcceptor老爹唱罢，儿子AbstractPollingIoAcceptor登场。这儿子就干了一件正经事儿，回调了孙子NioSocketAccept的init()方法。 123protected void init() throws Exception &#123; selector = Selector.open();&#125; 于是，选择器开启。在NIO的时代，Selector.open后紧接着就是注册了channel了，然后select()阻塞起等待连接了。而我们的mina接着是怎么做的呢？我们先跳过fliter链的设置和连接参数的设置，进入 12//绑定端口acceptor.bind(new InetSocketAddress(PORT)); 在一步老精彩了，儿子AbstractPollingIoAcceptor再也不是打酱油的角色了。老爹霹雳啪啦一大串模板方法，引出儿子关键的一步： 123456789...try &#123; &lt;span style=\"color:#ff0000;\"&gt;Set&lt;SocketAddress&gt; addresses = bindInternal(localAddressesCopy);&lt;/span&gt; synchronized (boundAddresses) &#123; boundAddresses.addAll(addresses); &#125;&#125;... 我们看看bindInternal在AbstractPollingIoAcceptor中做了什么 1234567891011121314151617181920212223242526272829303132333435363738394041424344 protected final Set&lt;SocketAddress&gt; bindInternal(List&lt;? extends SocketAddress&gt; localAddresses) throws Exception &#123;// 创建了与selector注册相关的任务，并添加至registerQueue中 AcceptorOperationFuture request = new AcceptorOperationFuture(localAddresses); registerQueue.add(request); // 在私有变量executor线程池中启动具体的Acceptor执行线程 &lt;span style=\"color:#ff0000;\"&gt;startupAcceptor();&lt;/span&gt; // As we just started the acceptor, we have to unblock the select() // in order to process the bind request we just have added to the // registerQueue. try &#123; lock.acquire(); // 让线程池任务运行Acceptor任务 // 实际上不需要这一步，我们知道wakeup()方法，如果当前没有select()执行，则会解除下一次select()阻塞状态 Thread.sleep(10); // 这个wakeup()方法很巧妙，因为Acceptor监听线程已经开启 // 但是没有连接接入，因此select()方法是阻塞的， // 为了让必要的request完成操作，调用一次wakeup(); wakeup(); &#125; finally &#123; lock.release(); &#125; // 等待request任务完成注册 request.awaitUninterruptibly(); if (request.getException() != null) &#123; throw request.getException(); &#125; // Update the local addresses. // setLocalAddresses() shouldn't be called from the worker thread // because of deadlock. Set&lt;SocketAddress&gt; newLocalAddresses = new HashSet&lt;SocketAddress&gt;(); for (H handle : boundHandles.values()) &#123; newLocalAddresses.add(localAddress(handle)); &#125; return newLocalAddresses; &#125; 这里我们看到，bindInternal()方法主要完成了selector的注册和启动。其中主要的方法是startupAcceptor(); 12345678910111213141516171819private void startupAcceptor() throws InterruptedException &#123; if (!selectable) &#123; registerQueue.clear(); cancelQueue.clear(); &#125; // 如果acceptor已经启动，则什么也不做，否则启动之。 Acceptor acceptor = acceptorRef.get(); if (acceptor == null) &#123; lock.acquire(); &lt;span style=\"color:#ff0000;\"&gt;acceptor = new Acceptor();&lt;/span&gt; if (acceptorRef.compareAndSet(null, acceptor)) &#123; executeWorker(acceptor); &#125; else &#123; lock.release(); &#125; &#125;&#125; Acceptor继承自Runnable，用于提交到线程池中执行，而这个线程池就是作为参数（或者默认newCashedThreadPool返回）的Executor。Acceptor线程任务以循环的方式调用select()，第一次运行时将注册选择器。后续主要完成3个工作： 12345678// 将 selector 设置监听 OP_ACCEPT，只在选择器第一次运行执行该代码，该方法依赖registerQueue队列nHandles += registerHandles(); // 如有连接接入，处理sessionprocessHandles(selectedHandles()); // 关闭selector监听，若关闭，则循环break跳出，线程任务结束，&lt;span style=\"font-family: Arial, Helvetica, sans-serif;\"&gt;该方法依赖cancelQueue队列&lt;/span&gt;nHandles -= unregisterHandles(); 启动和关闭selector的操作比较NIO，就不解释了，直接截取registerHandles()和unregisterHandles()部分方法源码 123456789101112131415161718192021222324252627282930313233343536373839protected ServerSocketChannel open(SocketAddress localAddress) throws Exception &#123; // Creates the listening ServerSocket ServerSocketChannel channel = ServerSocketChannel.open(); boolean success = false; try &#123; // This is a non blocking socket channel channel.configureBlocking(false); // Configure the server socket, ServerSocket socket = channel.socket(); // Set the reuseAddress flag accordingly with the setting socket.setReuseAddress(isReuseAddress()); // and bind. socket.bind(localAddress, getBacklog()); // Register the channel within the selector for ACCEPT event channel.register(selector, SelectionKey.OP_ACCEPT); success = true; &#125; finally &#123; if (!success) &#123; close(channel); &#125; &#125; return channel;&#125;protected void close(ServerSocketChannel handle) throws Exception &#123; SelectionKey key = handle.keyFor(selector); if (key != null) &#123; key.cancel(); &#125; handle.close();&#125; processHandles(selectedHandles()); 而最最关键也最最精彩的则是处理客户端连接的部分，我们下节继续。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"mina学习笔记二：从官方例子开始","date":"2016-09-08T12:12:14.000Z","path":"2016/09/08/mina-study-node2/","text":"原文：http://blog.csdn.net/yoara/article/details/37324821 本节内容只介绍mina总体架构，同时给出官方的几个实用TCP、UDP的经典服务端客户端例子。 mina体系结构mina位于用户程序和网络处理之间，将用户从复杂的网络处理中解耦，那我们就可以更加关注业务领域。 图2.1 mina鸟瞰图 让我们再深入进去，mina框架内部的各个组件是怎么协调工作的呢？ mina组件结构图 显然，mina框架被分成了主要的3个组件部分： I/O Service，具体提供服务的组件。 I/O Filter Chain，过滤器链，用于支持各种切面服务。 I/O Handler，用于处理用户的业务逻辑。 相对应的，为了创建一个基于mina的应用程序，我们需要： 创建I/O Service ：可选择mina提供的Services如（*Acceptor）或实现自己的Service。 创建I/O Filter ：同样可以选择mina提供的各类filter，也可以实现自己的编解码过滤器等。 实现I/O Handler，实现Handler接口，处理各种消息。 服务端结构服务端的作用就是开启监听端口，等待请求的到来、处理他们、以及将发送对请求的响应。同时，服务端会为每个连接创建session，在session周期内提供各种精度的服务，比如连接创建时(sessionCreated(IoSession session))、连接等待时(sessionIdle(IoSession session, IdleStatus status))、连接销毁时(sessionClosed(IoSession session))等。mina的api为TCP/UDP提供的一致性Server端操作。 Server结构图 IOAcceptor 监听来自网络的请求。 当新的连接建立时，一个新的session会被创建，该session用作对同一IP/端口组合的客户端提供服务。 数据包需经过一系列的过滤器，这些过滤器可用来修改数据包的内容（如转换对象、添加或修改信息等），其中将原始字节流转换成POJO对象是非常有用的。当然这需要解编码器提供支持。 最后这些数据包或转化后的对象将交由IOHandler处理，我们将实现IOHandler用于处理具体的业务逻辑。 客户端结构客户端需要连接服务端，发送请求并处理响应。实际上客户端的结构和服务端极其相似。 客户端首先需要创建IOConnector对象，绑定服务端的IP和端口。 一旦连接成功，一个于本次连接绑定的session对象将被创建。 客户端发送给服务端的请求都需要经过一系列的fliter。 同样，响应消息的接受也会经过一系列的filter再到IOHandler被处理。 所以整体上，mina提供良好的一致性调用和封装结构。在使用mina创建基于网络的程序应用时，投入的学习成本比较低。 TCP连接的例子依赖的Jar包： MINA 2.x Core JDK 1.5 或以上 SLF4J 1.3.0 或以上 Log4J 1.2： slf4j-api.jar, slf4j-log4j12.jar, Log4j 1.2.x Log4J 1.3： slf4j-api.jar, slf4j-log4j13.jar, Log4j 1.3.x（注意，请确认log4j的版本） TCP Server端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MinaTimeTest &#123; private static final int PORT = 9123; public static void main(String[] args) throws IOException &#123; //首先，我们为服务端创建IoAcceptor，NioSocketAcceptor是基于NIO的服务端监听器 IoAcceptor acceptor = new NioSocketAcceptor(); //接着，如结构图示，在Acceptor和IoHandler之间将设置一系列的Fliter //包括记录过滤器和编解码过滤器。其中TextLineCodecFactory是mina自带的文本解编码器 acceptor.getFilterChain().addLast(\"logger\", new LoggingFilter()); acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new TextLineCodecFactory(Charset.forName(\"UTF-8\")))); //配置事务处理Handler，将请求转由TimeServerHandler处理。 acceptor.setHandler(new TimeServerHandler()); //配置Buffer的缓冲区大小 acceptor.getSessionConfig().setReadBufferSize(2048); //设置等待时间，每隔IdleTime将调用一次handler.sessionIdle()方法 acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10); //绑定端口 acceptor.bind(new InetSocketAddress(PORT)); &#125; static class TimeServerHandler extends IoHandlerAdapter &#123; public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123; cause.printStackTrace(); &#125; public void messageReceived(IoSession session, Object message) throws Exception &#123; String str = message.toString(); if (str.trim().equalsIgnoreCase(\"quit\")) &#123; session.close(false); return; &#125; Date date = new Date(); session.write(date.toString()); System.out.println(\"Message written...\"); &#125; public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123; System.out.println(\"IDLE \" + session.getIdleCount(status)); &#125; &#125;&#125; TCP Client端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class TimeClient &#123; private static final String HOSTNAME = \"127.0.0.1\"; private static final int PORT = 9123; private static final long CONNECT_TIMEOUT = 30 * 1000L; // 30 seconds public static void main(String[] args) throws Throwable &#123; //创建Connector连接器 NioSocketConnector connector = new NioSocketConnector(); //设置连接超时时间 connector.setConnectTimeoutMillis(CONNECT_TIMEOUT); connector.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new TextLineCodecFactory())); connector.getFilterChain().addLast(\"logger\", new LoggingFilter()); //非常简单的处理Handler，向服务器发送一个数字 connector.setHandler(new ClientSessionHandler(1)); IoSession session = null; try &#123; //连接远程主机，设置IP和端口 ConnectFuture future = connector.connect(new InetSocketAddress( HOSTNAME, PORT)); //等待连接建立 future.awaitUninterruptibly(); //连接建立后返回会话session session = future.getSession(); &#125; catch (RuntimeIoException e) &#123; System.err.println(\"Failed to connect.\"); e.printStackTrace(); Thread.sleep(5000); &#125; finally&#123; if(session!=null)&#123; //等待本次连接通话结束，不可中断式的阻塞等待 session.getCloseFuture().awaitUninterruptibly(); &#125; &#125; //关闭连接 connector.dispose(); &#125; static class ClientSessionHandler extends IoHandlerAdapter &#123; private final int value; public ClientSessionHandler(int value) &#123; this.value = value; &#125; @Override public void sessionOpened(IoSession session) &#123; session.write(value); &#125; @Override public void messageReceived(IoSession session, Object message) &#123; System.out.println(message); session.close(true); &#125; @Override public void exceptionCaught(IoSession session, Throwable cause) &#123; session.close(true); &#125; &#125;&#125; UDP连接的例子UDP服务端： 123456789101112131415161718192021222324252627public class UdpServer &#123; private final static int PORT = 9234; public static void main(String[] args) throws IOException &#123; //创建UDPAcceptor NioDatagramAcceptor acceptor = new NioDatagramAcceptor(null); //这次不设置字符解编码器filter，消息直接用Buffer字节流传递 acceptor.getFilterChain().addLast(\"logger\", new LoggingFilter()); acceptor.setHandler(new UDPHandler()); acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10); acceptor.getSessionConfig().setReuseAddress(true);//&lt;span style=\"font-family: Arial, Helvetica, sans-serif;\"&gt;NioDatagramAcceptor 设置为null，才能重复使用端口&lt;/span&gt; acceptor.bind(new InetSocketAddress(PORT)); &#125; static class UDPHandler extends IoHandlerAdapter&#123; @Override public void messageReceived(IoSession session, Object message) throws Exception &#123; IoBuffer buffer = (IoBuffer)message; System.out.println(buffer.getLong()); session.close(false); &#125; @Override public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123; System.out.println(\"IDLE \" + session.getIdleCount(status)); &#125; &#125;&#125; UDP客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UdpClient &#123; private static IoSession session = null; public static void main(String[] args) &#123; NioDatagramConnector connect = new NioDatagramConnector(); connect.setHandler(new UDPClientHandler()); try&#123; ConnectFuture future = connect.connect(new InetSocketAddress(\"127.0.0.1\",9234)); future.awaitUninterruptibly(); session = future.getSession(); //增加连接建立完成后的监听器。 //若在建立完成后才添加监听器，监听器将马上执行 future.addListener(new IoFutureListener&lt;ConnectFuture&gt;()&#123; public void operationComplete(ConnectFuture future) &#123; if( future.isConnected() )&#123; try &#123; sendData(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; System.out.println((\"Not connected...exiting\")); &#125; &#125; &#125;); &#125;catch(Exception e)&#123; &#125;finally&#123; if(session!=null)&#123; session.getCloseFuture().awaitUninterruptibly(); &#125; &#125; connect.dispose(); &#125; private static void sendData() throws InterruptedException &#123; long free = Runtime.getRuntime().freeMemory(); IoBuffer buffer = IoBuffer.allocate(8); buffer.putLong(free); buffer.flip(); session.write(buffer); //因为是UDP，客户端需主动关闭连接 session.close(false); &#125; static class UDPClientHandler extends IoHandlerAdapter&#123;&#125;&#125; 结语这一节介绍了mina的组件结构和框架体系，用几个案例简单介绍了下mina的使用方法。在日常的开发中，其实已经足够了。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"mina学习笔记一：mina上路","date":"2016-09-08T12:12:13.000Z","path":"2016/09/08/mina-study-node1/","text":"原文：http://blog.csdn.net/yoara/article/details/37117477 很久以前用mina做过项目，当时的感觉就是很轻松简单，几行代码就能写好复杂的网络连接雏形，不用考虑请求阻塞，不用考虑客户端的负荷压力。做了好些年业务代码，有时候回头看看自己的技术底蕴真的有些欠缺。最近重拾起NIO和并发编程的内容，java api了解了大概，通过对mina的学习，也算是巩固和升华吧。 起篇的意义在于对mina的背景了解和mina框架的鸟瞰，NIO是什么？为什么还需要在NIO的基础上重新开发出一套mina框架？带着问题我们进入主题。 NIO VS IONIO即所谓的new IO(也称为Non-Blocking IO)，是Java在1.4版本引入的用以解决java.io在系统伸缩性上瓶颈的新的架构设计。java.io类主要分为字符流（Reader/Writer）和字节流(Input/OutputStream)，无一例外的是阻塞式的。阻塞式代码带来的问题就是系统的性能瓶颈就受制于串行的挂起等待，线程因为磁盘IO操作或套接字的连接传输等而被挂起，在这其间不仅CPU资源被闲置浪费，也不能通过横向的增加硬件设备以得到很好的缓解负荷提升性能的目的。 于是NIO引入了一套非阻塞的机制。 java.nio框架主要包含以下几个构成部分： Buffer：缓冲区，数据的载体。 Channel：数据通道，他要么从Buffer中获取数据并向flie或socket写，要么从file或socket中获取数据往Buffer中写。 Selector：提供多路复用的非阻塞IO选择器。 Charset：用于字节到Unicode字符集的转码工具。 Regexp：正则表达式工具类 NIO提供多路复用的机制，他把读写IO的操作委托给操作系统（select()/poll()）。当操作系统从数据源读入数据，并将它存放到nio指定的Buffer缓冲区后，就会提醒Selector选择器，某一Channel通道的数据已经准备就绪。这时Selector告诉用户线程数据已到位可以来做对应的业务处理了。如图1.1 图1.1 nio总体结构 相较于IO，NIO的优势在于，用户线程不需要在串行的等待数据的IO操作，操作系统代替了用户去准备，这时用户线程可以从当前阻塞中脱离并去做其他的事情。同时在服务器端也不必为连接客户端而持有大量的处理线程，只需单线程的selector负责监听即可实现高伸缩性的网络应用。（事实上NIO主要分为文件(File)IO和套接字(Socket)IO，File 类操作依旧是阻塞式的。FileChannel没有实现SelectedChannel，而选择器只接受实现自此接口的通道注册。本质的原因是基于文件的IO操作系统已经有了足够的优化和预读取机制，并且更重要的一点是可以实现异步IO。而多路复用其实是一种同步的IO，具体可参详LInux的5种IO方式。） 为什么需要mina相较于业务功能的开发，网络通讯更偏向于底层。可能大多数程序员在学校里学完以后，在以后的工作中就很难用到。毕竟，Java的好处就是取之不尽的框架，不同的人把焦点集中在不同层面，既避免了重复造轮子也提高了生产效率。 对于阻塞式的IO，线程需要等待；而对于非阻塞式的IO，仍然需要单线程去轮询selector的状态。mina将封装了这些网络层的处理，对用户是透明的。它简化了TCP、UDP、串行通信程序等网络连接的使用；简化了服务端和客户端的使用。在高扩展性、性能和内存使用（据说netty做的更好，不过这两个框架基本思想差不多）方面给用户提供有力的支持。 mina是简单但功能齐全的网络应用程序框架，它的主要特性包括： 为各种网络通讯提供统一的API。 基于Java NIO 的TCP/IP UDP/IP。 基于RXTX的串行通信程序。 基于VM内部的管道通讯。 支持自定义实现。 可扩展的过滤器链，类似Serlvet的过滤器模型。 底层和抽象层的数据API。 底层：可基于ByteBuffer使用。 抽象层：用户自定义的消息对象和解编码方式。 高度可定制的线程模型。 单线程 单线程池 多个线程池 基于Java 5 SSLEngine进行了封装，支持开箱即用的SSL、TLS、StartTLS等。（？） 过载保护和流量控制。 可使用mock对象进行方便的单元测试。 集成JMX的管理架构 支持流IO（Stream-Base I/O）的操作，通过实现StreamIoHandle。 可被常用的容器框架集成管理，如Spring。 能从Netty平滑的迁移过度到Mina。 结语 总体介绍就是这样了，下一节从官方的例子开始，一步一步的剖析mina吧。 版权声明：本文为博主原创文章，未经博主允许不得转载。","tags":[{"name":"Java","slug":"Java","permalink":"https://smuwjs.github.io/tags/Java/"},{"name":"MINA","slug":"MINA","permalink":"https://smuwjs.github.io/tags/MINA/"}]},{"title":"使用GitHub搭建Hexo博客","date":"2016-09-08T12:12:12.000Z","path":"2016/09/08/hexo-site-build-github/","text":"来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，我的个性博客，最近在学习JS后端Node.js, 现在火的不行, 异步IO的机制, 所以在学习过程中发现了hexo是由Node.js驱动的一款快速、简单且功能强大的博客框架。比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。 概况 为什么选择GitHub Pages1、GitHub Pages有免费的代码托管空间，资料自己管理，保存可靠；2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；3、顺便理解 GitHub 工作原理，最好的团队协作流程；4、GitHub建立私有仓库才会收费，所以会有很多开源代码。 GitHub Pages是什么应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 。 hexo出自何人hexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。 安装准备 环境搭建： Node.js：下载地址 Git：下载地址 Sublime：下载地址 安装Node到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi 安装GitGit的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。 安装SublimeSublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。 GitHub注册与配置 注册：访问：GitHub，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考官方文档 配置和使用Github以下教程主要参考beiyuu的《使用Github Pages建独立博客》写成。 配置SSH keys我们如何让本地git项目与远程的github建立联系呢？用SSH keys。打开Git Bash工具，执行以下操作 检查SSH keys的设置 123456789101112 首先我们需要检查你电脑上现有的ssh key：$ cd ~/. ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 生成新的SSH Key：$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」 然后系统会要你输入密码： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置ssh key了：12 添加SSH Key到GitHub在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了 测试 1234567891011121314151617181920212223242526 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：$ ssh -T git@github.com 如果是下面的反馈：The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到：Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 设置用户信息： 现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。 GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。$ git config --global user.name &quot;cnfeat&quot;//用户名$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱 SSH Key配置成功，本机已成功连接到github。 Hexo博客 HexoHexo的作者是tommy351，根据官方介绍，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 Hexo Themes。 我比较喜欢 pacman ， modernist 、 ishgo ， raytaylorism 。 安装Hexo打开Git Bash工具（前提确保Node.js已经安装，环境配置OK） $ npm install -g hexo 注释： 执行命令：npm install -g hexo，报错如下： 12345678910111213141516171819202122232425262728293031npm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgznpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2npm ERR! Actual: 41de7d67a9b764352eb07c49c32fc38dd7f479b9npm ERR! From: https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgznpm ERR! at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.js:38:8npm ERR! at ReadStream.&lt;anonymous&gt; (d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.js:85:7)npm ERR! at ReadStream.emit (events.js:117:20)npm ERR! at _stream_readable.js:943:16npm ERR! at process._tickCallback (node.js:419:13)npm ERR! If you need help, you may report this *entire* log,npm ERR! including the npm and node versions, at:npm ERR! &lt;http://github.com/npm/npm/issues&gt;npm ERR! System Windows_NT 6.2.9200npm ERR! command &quot;d:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;d:\\\\Program Files\\\\nodejs\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; &quot;-g&quot; &quot;hexo&quot;npm ERR! cwd C:\\Users\\Administrator\\Desktopnpm ERR! node -v v0.10.31npm ERR! npm -v 1.4.23npm ERR! registry error parsing jsonnpm ERR!npm ERR! Additional logging details can be found in:npm ERR! C:\\Users\\Administrator\\Desktop\\npm-debug.lognpm ERR! not ok code 0 莫非是因为被墙了？换国内镜像源试试。npm config set registry=&quot;http://registry.cnpmjs.org&quot;， 然后再次执行npm install -g hexo，成功！ 部署Hexo123456789101112131415161718192021 在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。$ hexo init 如果无法使用右击“Git Bash”，则可以切换到指定目录 UUhike@UUhike-pc MINGW64 ~$ cd j:/github/hexo UUhike@UUhike-pc MINGW64 /j/github/hexo 安装依赖包$ npm install Hexo随后会自动在目标文件夹建立网站所需要的所有文件。 现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。 本地查看$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） 部署到GitHub123456789编辑E:\\hexo下的_config.yml，修改Deployment部分：# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/luuman/luuman.github.io.git branch: master 注释： hexo d，执行该命令，报错： 1234567891011121314151617181920212223242526272829303132333435ERROR Deployer not found: git执行命令：npm install hexo-deployer-git --save再次执行hexo d,报错：INFO Deploying: gitINFO Clearing .deploy folder...INFO Copying files from public folder...warning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.The file will have its original line endings in your working directory.......*** Please tell me who you are.Run git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;to set your account&apos;s default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got &apos;Administrator@PC-201505290750.(none)&apos;)Username for &apos;https://github.com&apos;: voidkingPassword for &apos;https://voidking@github.com&apos;:error: src refspec master does not match any.error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: error: src refspec master does not match any.error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos; at ChildProcess.&lt;anonymous&gt; (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17) at ChildProcess.emit (events.js:98:17) at maybeClose (child_process.js:756:16) at Process.ChildProcess._handle.onexit (child_process.js:823:5) hexo d，执行该命令，报错： 复制cnfeat的主题以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。 12345678910111213$ hexo clean$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）建立了Hexo文件，复制我的主题了到themes文件夹中yilia$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yiliamodernist$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernistjacman$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman 启用cnfeat的主题修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。theme: jacman 注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。 更新主题 $ cd themes/jacman $ git pull 注意：为避免出错，请先备份你的_config.yml 文件后再升级本地查看调试 1234567891011121314$ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试或者直接作用组合命令$ hexo deploy -g$ hexo server -g简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 4、浏览器中查看效果 浏览器输入http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。 #进阶篇：Hexo设置 网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。 默认目录结构： 1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json hexo/_config.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #整站的基本信息title: 1000 words a Day #网站标题subtitle: Writing 1000 Words a Day Changes My Life #网站副标题description: 学习总结 思考感悟 知识管理 #网站描述author: cnFeat #网站作者，在下方显示email: cnFeat@gmail.com #联系邮箱language: zh-CN #主题实际的文件名称timezone:# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 日期格式，不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 每页显示文章数，可以自定义，我将10改成了5## Set per_page to 0 to disable paginationper_page: 5pagination_dir: page# Disqus Disqus插件，我们会替换成“多说”，不修改disqus_shortname:# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: spfk# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml# Deployment 站点部署到github要配置，上一节中已经讲过## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: git repository: git@github.com:luuman/luuman.github.io.git branch: master 修改局部页面 页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中： hexo\\themes\\ 1234567891011121314151617├── languages #多语言| ├── default.yml#默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget#小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css#css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml#主题配置文件└── README.md #用GitHub的都知道 主题文档的配置 hexo\\themes/_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔# SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #douban: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# Contentexcerpt_link: morefancybox: truemathjax: true# Miscellaneousgoogle_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar: &quot;&quot;#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: 奥巴马的博客: http://localhost:4000/ 卡卡的美丽传说: http://localhost:4000/ 本泽马的博客: http://localhost:4000/ 吉格斯的博客: http://localhost:4000/ 习大大大不同: http://localhost:4000/ 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货… 参考资料：hexo你的博客如何搭建一个独立博客——简明Github Pages与Hexo教程Hexo的使用介绍Hexo插件安装","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://smuwjs.github.io/tags/Hexo/"}]},{"title":"Hexo插件安装","date":"2016-09-07T14:33:55.000Z","path":"2016/09/07/hexo-site-build-plugin/","text":"自用笔记：本文属于自用笔记，不做详解，仅供参考。在此记录自己已理解并开始遵循的前端代码规范。What How Why 最近，使用Hexo遇到了很多问题，在设立进行整理。 同步instagram图片 新建页面 12执行命令：hexo new page &quot;instagram&quot; 修改文件 12345678910111213在目录yourBlog\\source\\instagram下，修改index.md内容为：---layout: postslug: &quot;instagram&quot;title: &quot;相册&quot;noDate: &quot;true&quot;---&lt;div class=&quot;instagram&quot; data-client-id=&quot;a0d4bd ab154b4c689aff70602cb34a2c&quot; data-user-id=&quot;438522285&quot;&gt; &lt;a href=&quot;http://instagram.com/litten225&quot; target=&quot;_blank&quot; class=&quot;open-ins&quot;&gt;图片来自instagram，正在加载中…&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;/js/jquery.lazyload.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/instagram.js&quot;&gt;&lt;/script&gt; 获取ID 123456789101112131415data-client-id：[注册新客户端](http://instagram.com/developer/clients/manage/)获取CLIENT ID：a0d4bdab154b4c689aff70602cb34a2c用client_id去换取token：在浏览器中请求： https://instagram.com/oauth/authorize/?client_id=&#123;CLIENT_ID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=token https://instagram.com/oauth/authorize/?client_id=a0d4bdab154b4c689aff70602cb34a2c&amp;redirect_uri=http://luuman.github.io/&amp;response_type=token 花括号里面的值，对应上一步最终得到的client_id和自己设定的redirect_uri。 请求到的是一个授权页面，授权完毕后，则重定向到你的redirect_uri。 注意看授权成功后的url，hash部分会附带给你的token。至此，token成功获取，将至放在data-client-id。data-user-id：需要到[lookup-user-id](http://jelled.com/instagram/lookup-user-id#)填写用户名并查找。 分享按钮 添加代码 123456789101112131415161718192021222324252627282930以下代码是百度分享的页面24页面分享的代码，可以自行选择以下标签。配置vim themes/light/layout/_partial/article.ejs删除&lt;%-partial(&apos;post/share&apos;)%&gt;替换为刚刚获取的分享代码&lt;div class=&quot;bdsharebuttonbox&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-weibo bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-weixin bds_weixin&quot; data-cmd=&quot;weixin&quot; title=&quot;分享到微信&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-qq bds_sqq&quot; data-cmd=&quot;sqq&quot; title=&quot;分享到QQ好友&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-facebook-official bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-twitter bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-linkedin bds_linkedin&quot; data-cmd=&quot;linkedin&quot; title=&quot;分享到linkedin&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-files-o bds_copy&quot; data-cmd=&quot;copy&quot; title=&quot;分享到复制网址&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-plus-square bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-tencent-weibo bds_tqq&quot; data-cmd=&quot;tqq&quot; title=&quot;分享到腾讯微博&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-renren bds_renren&quot; data-cmd=&quot;renren&quot; title=&quot;分享到人人网&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-paw bds_tieba&quot; data-cmd=&quot;tieba&quot; title=&quot;分享到百度贴吧&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-envelope-o bds_mail&quot; data-cmd=&quot;mail&quot; title=&quot;分享到邮件分享&quot;&gt;&lt;/a&gt;&lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-print bds_print&quot; data-cmd=&quot;print&quot; title=&quot;分享到打印&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa-share-alt bds_mshare&quot; data-cmd=&quot;mshare&quot; title=&quot;分享到一键分享&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa- bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;fx fa- bds_evernotecn&quot; data-cmd=&quot;evernotecn&quot; title=&quot;分享到印象笔记&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script&gt;window._bd_share_config=&#123;&quot;common&quot;:&#123;&quot;bdSnsKey&quot;:&#123;&#125;,&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;1&quot;,&quot;bdMiniList&quot;:false,&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;2&quot;,&quot;bdSize&quot;:&quot;24&quot;&#125;,&quot;share&quot;:&#123;&#125;&#125;;with(document)0[(getElementsByTagName(&apos;head&apos;)[0]||body).appendChild(createElement(&apos;script&apos;)).src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 修改样式 1234567891011121314151617181920212223242526272829303132\\themes\\spfk\\source\\css\\_partial\\article.styl/* bd share button box */.bdshare-button-style2-24&#123; width: 330px; margin: auto; .fx &#123; color: #999; padding: 0; margin: 6px; height: 54px; display: inline-block; font: normal normal normal 36px/1 FontAwesome; background: none; text-rendering: auto; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; .fx:hover&#123; color: #FFF; opacity: 1; &#125;&#125;themes\\spfk\\source\\css\\_partial\\mobile.styl/* bd share button box */.bdshare-button-style2-24&#123; width: 289px; .fx &#123; font: normal normal normal 30px/1 FontAwesome; &#125;&#125; 百度统计 添加代码 1234567891011121314151617181920212223242526去百度统计获取统计代码vim themes/light/layout/_partial/baidu_analytics.ejs&lt;% if (theme.baidu_analytics)&#123; %&gt;&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(&quot;script&quot;); hm.src = &quot;//hm.baidu.com/hm.js?819b1c6493df653afb8c784db6&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;&lt;% &#125; %&gt;vim hexo/themes/light/_config.ymlbaidu_analytics: truevim hexo/themes/light/layout/_partial/head.ejs在/head前添加&lt;%- partial(&apos;baidu_analytics&apos;) %&gt;&lt;/head&gt; 不蒜子 添加代码 123456789101112131415161718192021222324252627themes/你的主题/layout/_partial/footer.ejs&lt;footer id=&quot;footer&quot;&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt; Theme &lt;a href=&quot;https://github.com/luuman/hexo-theme-spfk&quot; target=&quot;_blank&quot;&gt;spfk&lt;/a&gt; by luuman &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;visit&quot;&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; &lt;span id=&quot;site-visit&quot; &gt;本站到访数: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&apos;display:none&apos;&gt; &lt;span id=&quot;page-visit&quot;&gt;, 本页阅读量: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;/footer&gt; 修改样式 移动端出现上移themes\\spfk\\source\\css_partial\\mobile.styl1234567891011121314#footer &#123; bottom: 10px; .footer-left&#123; float: initial; margin-bottom: 10px; &#125; .footer-right&#123; float: initial; margin-bottom: 10px; &#125;&#125;#container .visit &#123; margin-top: 1em;&#125; 版权声明 添加代码 123456789101112131415161718192021222324252627282930313233343536373839404142\\layout\\_partial\\post\\nav.ejs&lt;% if (post.original != false &amp;&amp; !is_page())&#123; %&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;请访问 &lt;%=theme.author%&gt; 博客&quot;&gt;&lt;%=theme.author%&gt;&lt;/a&gt;&lt;/p&gt; &lt;!-- &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&lt;%= post.date.format(&quot;YYYY年MM月DD日 - HH时mm分&quot;) %&gt;&lt;/p&gt; --&gt; &lt;!-- &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&lt;%= post.updated.format(&quot;YYYY年MM月DD日 - HH时mm分&quot;) %&gt;&lt;/p&gt; --&gt; &lt;p&gt; &lt;span&gt;原始链接:&lt;/span&gt;&lt;a class=&quot;post-url&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot; title=&quot;&lt;%= post.title %&gt;&quot;&gt;&lt;%= post.permalink %&gt;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; data-clipboard-text=&quot;原文: &lt;%= post.permalink %&gt; 作者: &lt;%=theme.author%&gt;&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;script src=&quot;/js/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var clipboard = new Clipboard(&apos;.copy-path&apos;); &lt;/script&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; title=&quot;中国大陆 (CC BY-NC-SA 3.0 CN)&quot;&gt;&quot;署名-非商用-相同方式共享 3.0&quot;&lt;/a&gt; 转载请保留原文链接及作者。 &lt;/p&gt; &lt;/div&gt;&lt;% &#125; %&gt;&lt;% if (post.prev || post.next)&#123; %&gt;&lt;nav id=&quot;article-nav&quot;&gt; &lt;% if (post.prev)&#123; %&gt; &lt;a href=&quot;&lt;%- url_for(post.prev.path) %&gt;&quot; id=&quot;article-nav-newer&quot; class=&quot;article-nav-link-wrap&quot;&gt; &lt;strong class=&quot;article-nav-caption&quot;&gt;&lt;&lt;/strong&gt; &lt;div class=&quot;article-nav-title&quot;&gt; &lt;% if (post.prev.title)&#123; %&gt; &lt;%= post.prev.title %&gt; &lt;% &#125; else &#123; %&gt; (no title) &lt;% &#125; %&gt; &lt;/div&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;% if (post.next)&#123; %&gt; &lt;a href=&quot;&lt;%- url_for(post.next.path) %&gt;&quot; id=&quot;article-nav-older&quot; class=&quot;article-nav-link-wrap&quot;&gt; &lt;div class=&quot;article-nav-title&quot;&gt;&lt;%= post.next.title %&gt;&lt;/div&gt; &lt;strong class=&quot;article-nav-caption&quot;&gt;&gt;&lt;/strong&gt; &lt;/a&gt; &lt;% &#125; %&gt;&lt;/nav&gt;&lt;% &#125; %&gt; 修改样式12345678910111213141516171819202122232425262728293031323334353637383940\\themes\\spfk\\source\\css\\_partial\\article.styl/* copyright */.copyright &#123; width: 85%; max-width: 45em; margin: 0 auto; padding: .5em 1.8em; border: 1px solid lightgray; font-size: .93em; line-height: 1.6em; word-break: break-word; background: rgba(255, 255, 255, .4); span &#123; margin-right: 1em; color: #B5B5B5; font-weight: bold; &#125; a &#123; color: gray; &amp;:hover &#123; font-weight: bold; color: #a3d2a3; text-decoration: underline; &#125; &#125; &amp;:hover p .copy-path::after &#123; content: &quot;复制&quot;; &#125; .post-url:hover &#123; font-weight: normal; &#125; .copy-path &#123; margin-left: 1em; &amp;:hover &#123; color: gray; cursor: pointer; &#125; &#125;&#125; 社交账号图标修改 添加代码 123456789\\themes\\spfk\\layout\\_partial\\left-col.ejs&lt;nav class=&quot;header-nav&quot;&gt; &lt;div class=&quot;social&quot;&gt; &lt;% for (var i in theme.subnav)&#123; %&gt; &lt;a class=&quot;fl &lt;%= i %&gt;&quot; target=&quot;_blank&quot; href=&quot;&lt;%- url_for(theme.subnav[i]) %&gt;&quot; title=&quot;&lt;%= i %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt; &lt;%&#125;%&gt; &lt;/div&gt;&lt;/nav&gt; 修改样式 站内搜索框 添加代码用ajax+json搜索 完美解决Hexo静态博客搜索问题 站点Swiftype搜索框 添加代码 12345678910111213141516171819202122232425\\themes\\spfk\\layout\\_partial\\left-col.ejs&lt;form&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input search&quot; id=&quot;search&quot; placeholder=&quot; Search...&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot;&gt;&lt;/form&gt;D:\\Hexo\\Hexo\\themes\\spfk\\layout\\_partial\\after-footer.ejs&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&quot;search&quot;).onclick = function()&#123; console.log(&quot;search&quot;) search(); &#125; &#125; function search()&#123; (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;A1Pz-LKMXbrzcFg2FWi6&apos;,&apos;2.0.0&apos;); &#125;&lt;/script&gt; 修改样式1234567891011121314151617181920212223242526272829303132333435363738394041.search &#123; width: 68%; height: 18px; margin-top: 1px; padding: 0; font-family: inherit; border: 2px solid transparent; border-bottom: 2px solid lightgray; border-radius: 2px; opacity: .7; background: none; &amp;:hover &#123; border: 0px solid lightgray; opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); &#125;;&#125;display: inline-block; width: 190px; height: 16px; padding: 7px 11px 7px 28px; border: 1px solid #bbb; border: 1px solid rgba(0,0,0,0.25); font-weight: 400; color: #444; font-size: 14px; line-height: 16px; box-sizing: content-box; background: #fff 8px 8px no-repeat url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6%2BR8AAAACXB…Hx4Taq1nrnKaW8K6XUUsrHWuvNevdRRLzFGwzvDbXAB9cDAHvhedDruuxSAAAAAElFTkSuQmCC); background-clip: padding-box; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; -webkit-box-shadow: none; -moz-box-shadow: none; box-shadow: none; font-family: &quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Lucida Grande&quot;,sans-serif; RSS不显示123456789 安装RSS插件$ npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/themes_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 sitemap网站地图12345678910111213141516171819202122232425262728293031323334353637381、安装插件：$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save2、在博客目录的hexo/_config.yml中添加如下代码：# 自动生成sitemap编辑sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml3、hexo编译的时候会自动在根目录生成站点地图 UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master) $ npm install hexo-generator-sitemap --save npm WARN install Couldn&apos;t install optional dependency: Unsupported npm WARN install Couldn&apos;t install optional dependency: Unsupported hexo-site@0.0.0 D:\\Hexo\\Hexo └── hexo-generator-sitemap@1.0.1 UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master) $ npm install hexo-generator-baidu-sitemap --save npm WARN install Couldn&apos;t install optional dependency: Unsupported npm WARN install Couldn&apos;t install optional dependency: Unsupported hexo-site@0.0.0 D:\\Hexo\\Hexo └── hexo-generator-baidu-sitemap@0.1.2 UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master) $ hexo g INFO Files loaded in 2.42 s INFO Generated: baidusitemap.xml INFO Generated: sitemap.xml INFO 2 files generated in 477 ms 多说评论插件 添加代码 123456789101112131415161718192021222324252627282930313233343536373839 ├── spfk ├── _config.yml #主题配置文件 #是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/） #若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论 duoshuo: true复制到 themes\\landscape\\layout\\_partial\\article.ejs把&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt;改为&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;!-- 多说评论框 start --&gt;&lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=&quot;text/javascript&quot;&gt;var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt;&lt;/section&gt;&lt;% &#125; %&gt; 修改样式：V说：设计达人：设计达人： 添加方法：添加方法：打开「后台」 &gt; 「多说评论」 &gt; 「设置」 &gt; 「基本设置」 &gt; 然后把样式粘贴到「自定义CSS」文本框 &gt; 「保存」 个性样式： 1#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current&#123;border:0;color:#848568;text-shadow:none;background:#dddfc2&#125;#ds-thread #ds-reset .ds-highlight&#123;font-family:Arial,Helvetica,sans-serif;font-size:14px;font-weight:700;color:#848568!important&#125;#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current:hover&#123;color:#696a52;background:#d4d6ba&#125;#ds-thread #ds-reset a.ds-highlight:hover&#123;color:#696a52!important&#125;#ds-thread&#123;padding-left:30px&#125;#ds-thread #ds-reset #ds-hot-posts,#ds-thread #ds-reset li.ds-post&#123;overflow:visible&#125;#ds-thread #ds-reset .ds-post-self&#123;padding:10px 0 10px 10px&#125;#ds-thread #ds-reset .ds-post-self,#ds-thread #ds-reset li.ds-post&#123;border:0!important&#125;#ds-reset .ds-avatar,#ds-thread #ds-reset ul.ds-children .ds-avatar&#123;position:absolute;top:26px;left:-14px;padding:5px;width:36px;height:36px;box-shadow:-1px 0 1px rgba(0,0,0,.15) inset;border-radius:46px;background:#E5E6D0&#125;#ds-thread #ds-reset ul.ds-children .ds-avatar&#123;left:-23px&#125;#ds-thread .ds-avatar a&#123;display:inline-block;padding:1px;width:32px;height:32px;border:1px solid #b9baa6;border-radius:50%;background-color:#fff!important&#125;#ds-thread .ds-avatar a:hover&#123;border-color:#de5a4e&#125;#ds-thread .ds-avatar&gt;img&#123;margin:2px 0 0 2px&#125;#ds-thread #ds-reset .ds-replybox&#123;box-shadow:none&#125;#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar,#ds-thread #ds-reset ul.ds-children .ds-replybox.ds-inline-replybox a.ds-avatar&#123;left:0;top:0;padding:0;width:32px!important;height:32px!important;background:0 0;box-shadow:none&#125;#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar img&#123;width:32px!important;height:32px!important;border-radius:50%&#125;#ds-reset .ds-replybox .ds-avatar img,#ds-reset .ds-replybox a.ds-avatar&#123;padding:0;width:50px!important;height:50px!important;border-radius:5px&#125;#ds-reset .ds-avatar img&#123;width:32px!important;height:32px!important;border-radius:32px;box-shadow:0 1px 3px rgba(0,0,0,.22);-webkit-transition:.4s all ease-in-out;-moz-transition:.4s all ease-in-out;-o-transition:.4s all ease-in-out;-ms-transition:.4s all ease-in-out;transition:.4s all ease-in-out&#125;.ds-post-self:hover .ds-avatar img&#123;-webkit-transform:rotate(360deg);-moz-transform:rotate(360deg);-o-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)&#125;#ds-thread #ds-reset .ds-comment-body&#123;background:#F0F0E3;padding:15px 15px 12px 32px;border-radius:5px;box-shadow:0 1px 2px rgba(0,0,0,.15),0 1px 0 rgba(255,255,255,.75) inset&#125;#ds-thread #ds-reset .ds-comment-body p&#123;color:#787968&#125;#ds-thread #ds-reset .ds-comments a.ds-user-name&#123;font-weight:700;color:#696A52!important&#125;#ds-thread #ds-reset .ds-comments a.ds-user-name:hover&#123;color:#D32!important&#125;#ds-thread #ds-reset #ds-hot-posts&#123;border:0&#125;#ds-reset #ds-hot-posts .ds-gradient-bg&#123;background:0 0&#125;#ds-reset #ds-bubble #ds-ctx .ds-ctx-entry&#123;padding:0&#125;#ds-reset #ds-bubble #ds-ctx-bubble .ds-avatar a,#ds-reset #ds-bubble .ds-avatar&#123;position:static;padding:0;border:0;background:0 0;box-shadow:none&#125;#ds-reset #ds-bubble #ds-ctx-bubble .ds-avatar a,#ds-reset #ds-bubble .ds-avatar img&#123;width:45px!important;height:45px!important&#125;#ds-reset #ds-bubble .ds-user-name&#123;padding-left:13px&#125;#ds-reset .ds-comment-body #ds-ctx&#123;border-left:1px solid #b9baa6;background-color:#e8e8dc!important&#125;#ds-reset #ds-ctx&#123;margin-right:-15px&#125;#ds-reset #ds-ctx .ds-ctx-entry&#123;position:relative;padding:10px 30px 10px 10px&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-avatar&#123;top:6px;left:5px;background:0 0;box-shadow:none&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-body&#123;margin-left:46px&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-content&#123;color:#787968&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a&#123;color:#696A52;font-weight:700&#125; 个性样式：[震动效果]: http://www.vsay.cn/wp-content/uploads/2012/09/7.gif1#ds-reset .ds-avatar img,#ds-reset .ds-avatar img:hover&#123;-webkit-animation-fill-mode:both;-moz-animation-fill-mode:both;-ms-animation-fill-mode:both;-o-animation-fill-mode:both;animation-fill-mode:both;-webkit-animation-duration:0s;-moz-animation-duration:0s;-ms-animation-duration:0s;-o-animation-duration:0s;animation-duration:0s;-webkit-animation-duration:.7s;-moz-animation-duration:.7s;-ms-animation-duration:.7s;-o-animation-duration:.7s;animation-duration:.7s&#125;@-webkit-keyframes wobble&#123;0%&#123;-webkit-transform:translateX(0)&#125;15%&#123;-webkit-transform:translateX(-25%) rotate(-5deg)&#125;30%&#123;-webkit-transform:translateX(20%) rotate(3deg)&#125;45%&#123;-webkit-transform:translateX(-15%) rotate(-3deg)&#125;60%&#123;-webkit-transform:translateX(10%) rotate(2deg)&#125;75%&#123;-webkit-transform:translateX(-5%) rotate(-1deg)&#125;100%&#123;-webkit-transform:translateX(0)&#125;&#125;@-moz-keyframes wobble&#123;0%&#123;-moz-transform:translateX(0)&#125;15%&#123;-moz-transform:translateX(-25%) rotate(-5deg)&#125;30%&#123;-moz-transform:translateX(20%) rotate(3deg)&#125;45%&#123;-moz-transform:translateX(-15%) rotate(-3deg)&#125;60%&#123;-moz-transform:translateX(10%) rotate(2deg)&#125;75%&#123;-moz-transform:translateX(-5%) rotate(-1deg)&#125;100%&#123;-moz-transform:translateX(0)&#125;&#125;@-o-keyframes wobble&#123;0%&#123;-o-transform:translateX(0)&#125;15%&#123;-o-transform:translateX(-25%) rotate(-5deg)&#125;30%&#123;-o-transform:translateX(20%) rotate(3deg)&#125;45%&#123;-o-transform:translateX(-15%) rotate(-3deg)&#125;60%&#123;-o-transform:translateX(10%) rotate(2deg)&#125;75%&#123;-o-transform:translateX(-5%) rotate(-1deg)&#125;100%&#123;-o-transform:translateX(0)&#125;&#125;@keyframes wobble&#123;0%&#123;transform:translateX(0)&#125;15%&#123;transform:translateX(-25%) rotate(-5deg)&#125;30%&#123;transform:translateX(20%) rotate(3deg)&#125;45%&#123;transform:translateX(-15%) rotate(-3deg)&#125;60%&#123;transform:translateX(10%) rotate(2deg)&#125;75%&#123;transform:translateX(-5%) rotate(-1deg)&#125;100%&#123;transform:translateX(0)&#125;&#125;#ds-reset .ds-avatar img:hover&#123;-webkit-animation-name:wobble;-moz-animation-name:wobble;-o-animation-name:wobble;animation-name:wobble&#125; 个性样式：[MOxFIVE]: http://www.vsay.cn/wp-content/uploads/2012/09/7.gif1#ds-ssr&#123;display:none !important&#125;#ds-reset&#123;font-weight:normal;font-size:13px;font-size-adjust:none;color:#333;line-height:1;text-align:left&#125;#ds-reset *&#123;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box&#125;#ds-reset input[type=button],#ds-reset input[type=submit],#ds-reset input[type=reset],#ds-reset button&#123;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box&#125;#ds-reset div,#ds-reset ul,#ds-reset ol,#ds-reset li,#ds-reset ul li,#ds-reset ol li,#ds-reset iframe,#ds-reset h1,#ds-reset h2,#ds-reset h3,#ds-reset h4,#ds-reset h5,#ds-reset h6,#ds-reset p,#ds-reset img,#ds-reset blockquote,#ds-reset a,#ds-reset span,#ds-reset pre,#ds-reset code,#ds-reset strong,#ds-reset sub,#ds-reset sup,#ds-reset fieldset,#ds-reset form,#ds-reset label,#ds-reset input,#ds-reset textarea,#ds-reset select&#123;border:0;padding:0;margin:0;vertical-align:baseline;font:inherit;line-height:inherit;background:none;width:auto;float:none;overflow:visible;transition:none&#125;#ds-reset strong&#123;font-weight:bold&#125;#ds-reset p&#123;text-indent:0;clear:none&#125;#ds-reset span,#ds-reset strong,#ds-reset label,#ds-reset input&#123;display:inline;margin:0&#125;#ds-reset textarea:focus,#ds-reset input:focus&#123;outline:none&#125;#ds-reset ul,#ds-reset ol,#ds-reset ul li,#ds-reset ol li&#123;list-style:none;display:block&#125;#ds-reset input,#ds-reset button&#123;-webkit-border-radius:3px;border-radius:3px&#125;#ds-indicator&#123;display:none;position:fixed;z-index:99999;top:150px;left:0;padding:8px;border-bottom-right-radius:3px;border-top-right-radius:3px;width:16px;height:16px;background:#666 url(&quot;data:image/gif;base64,R0lGODlhEAAQAPQAAGZmZv///2lpadzc3K+vr/r6+ufn5319fZmZmfDw8Le3t8DAwHV1daOjo4eHh9LS0srKygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAEAAQAAAFUCAgjmRpnqUwFGwhKoRgqq2YFMaRGjWA8AbZiIBbjQQ8AmmFUJEQhQGJhaKOrCksgEla+KIkYvC6SJKQOISoNSYdeIk1ayA8ExTyeR3F749CACH5BAkKAAAALAAAAAAQABAAAAVoICCKR9KMaCoaxeCoqEAkRX3AwMHWxQIIjJSAZWgUEgzBwCBAEQpMwIDwY1FHgwJCtOW2UDWYIDyqNVVkUbYr6CK+o2eUMKgWrqKhj0FrEM8jQQALPFA3MAc8CQSAMA5ZBjgqDQmHIyEAIfkECQoAAAAsAAAAABAAEAAABWAgII4j85Ao2hRIKgrEUBQJLaSHMe8zgQo6Q8sxS7RIhILhBkgumCTZsXkACBC+0cwF2GoLLoFXREDcDlkAojBICRaFLDCOQtQKjmsQSubtDFU/NXcDBHwkaw1cKQ8MiyEAIfkECQoAAAAsAAAAABAAEAAABVIgII5kaZ6AIJQCMRTFQKiDQx4GrBfGa4uCnAEhQuRgPwCBtwK+kCNFgjh6QlFYgGO7baJ2CxIioSDpwqNggWCGDVVGphly3BkOpXDrKfNm/4AhACH5BAkKAAAALAAAAAAQABAAAAVgICCOZGmeqEAMRTEQwskYbV0Yx7kYSIzQhtgoBxCKBDQCIOcoLBimRiFhSABYU5gIgW01pLUBYkRItAYAqrlhYiwKjiWAcDMWY8QjsCf4DewiBzQ2N1AmKlgvgCiMjSQhACH5BAkKAAAALAAAAAAQABAAAAVfICCOZGmeqEgUxUAIpkA0AMKyxkEiSZEIsJqhYAg+boUFSTAkiBiNHks3sg1ILAfBiS10gyqCg0UaFBCkwy3RYKiIYMAC+RAxiQgYsJdAjw5DN2gILzEEZgVcKYuMJiEAOwAAAAAAAAAAAA==&quot;) 8px 8px no-repeat;*background-image:url(&quot;//static.duoshuo.com/images/loading.gif&quot;);*position:absolute;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box&#125;#ds-waiting&#123;cursor:wait;display:block;width:16px;height:11px;padding:0 0 3px 5px;margin:0;background:url(&quot;data:image/gif;base64,R0lGODlhEAALAPQAAP///z2LqeLt8dvp7u7090GNqz2LqV+fuJ/F1IW2ycrf51aatHWswaXJ14i4ys3h6FmctUCMqniuw+vz9eHs8fb5+meku+Tu8vT4+cfd5bbT3tbm7PH2+AAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCwAAACwAAAAAEAALAAAFLSAgjmRpnqSgCuLKAq5AEIM4zDVw03ve27ifDgfkEYe04kDIDC5zrtYKRa2WQgAh+QQJCwAAACwAAAAAEAALAAAFJGBhGAVgnqhpHIeRvsDawqns0qeN5+y967tYLyicBYE7EYkYAgAh+QQJCwAAACwAAAAAEAALAAAFNiAgjothLOOIJAkiGgxjpGKiKMkbz7SN6zIawJcDwIK9W/HISxGBzdHTuBNOmcJVCyoUlk7CEAAh+QQJCwAAACwAAAAAEAALAAAFNSAgjqQIRRFUAo3jNGIkSdHqPI8Tz3V55zuaDacDyIQ+YrBH+hWPzJFzOQQaeavWi7oqnVIhACH5BAkLAAAALAAAAAAQAAsAAAUyICCOZGme1rJY5kRRk7hI0mJSVUXJtF3iOl7tltsBZsNfUegjAY3I5sgFY55KqdX1GgIAIfkECQsAAAAsAAAAABAACwAABTcgII5kaZ4kcV2EqLJipmnZhWGXaOOitm2aXQ4g7P2Ct2ER4AMul00kj5g0Al8tADY2y6C+4FIIACH5BAkLAAAALAAAAAAQAAsAAAUvICCOZGme5ERRk6iy7qpyHCVStA3gNa/7txxwlwv2isSacYUc+l4tADQGQ1mvpBAAIfkECQsAAAAsAAAAABAACwAABS8gII5kaZ7kRFGTqLLuqnIcJVK0DeA1r/u3HHCXC/aKxJpxhRz6Xi0ANAZDWa+kEAA7AAAAAAAAAAAA&quot;) 0 0 no-repeat;*background-image:url(&quot;//static.duoshuo.com/images/waiting.gif&quot;)&#125;#ds-reset .ds-highlight&#123;color:#d32 !important&#125;#ds-reset .ds-rounded&#123;-webkit-border-radius:3px;border-radius:3px&#125;#ds-reset .ds-rounded-top&#123;-webkit-border-top-right-radius:3px;-webkit-border-top-left-radius:3px;border-top-right-radius:3px;border-top-left-radius:3px&#125;#ds-reset .ds-rounded-bottom&#123;border-bottom-left-radius:3px;border-bottom-right-radius:3px;-webkit-border-bottom-left-radius:3px;-webkit-border-bottom-right-radius:3px&#125;#ds-reset .ds-gradient-bg&#123;background:url(&quot;//static.duoshuo.com/images/bg_sprites.png&quot;) 0 -60px repeat-x&#125;#ds-reset .ds-avatar&#123;box-shadow:0 1px 1px rgba(255,255,255,0.75);position:relative;-webkit-border-radius:3px;border-radius:3px;background-color:#fff;float:left&#125;#ds-reset .ds-avatar img&#123;display:block;width:50px;height:50px;max-width:none;box-shadow:0 1px 3px rgba(0,0,0,0.22);-webkit-border-radius:3px;border-radius:3px&#125;#ds-reset .ds-avatar .ds-service-icon&#123;display:block;position:absolute;bottom:-4px;right:-4px&#125;#ds-reset img.ds-smiley&#123;margin:0;padding:0;display:inline;border:none&#125;#ds-reset .ds-icon&#123;vertical-align:middle;display:inline-block;overflow:hidden;background:transparent url(&quot;//static.duoshuo.com/images/sprites.png&quot;) no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/sprites.gif&quot;)&#125;#ds-reset a .ds-icon&#123;opacity:.6;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;transition:opacity .15s linear&#125;#ds-reset a:hover .ds-icon&#123;opacity:1&#125;#ds-reset .ds-service-list a&#123;vertical-align:middle;padding-right:3px&#125;#ds-reset .ds-service-list li:hover a&#123;color:#333&#125;#ds-reset .ds-service-icon,#ds-reset .ds-service-icon-grey&#123;width:16px !important;height:16px !important;line-height:100px;display:inline-block;background:url(&quot;//static.duoshuo.com/images/service-icons-color.png?v=2&quot;) no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/service-icons-color.gif?v=2&quot;);overflow:hidden&#125;#ds-reset .ds-service-icon-grey&#123;background-image:url(&quot;//static.duoshuo.com/images/service-icons-grey.png&quot;);_background-image:url(&quot;//static.duoshuo.com/images/service-icons-grey.gif&quot;)&#125;#ds-reset .ds-service-link&#123;height:16px !important;line-height:16px;padding-left:20px;display:block;background:url(&quot;//static.duoshuo.com/images/service-icons-color.png?v=2&quot;) no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/service-icons-color.gif?v=2&quot;);overflow:hidden&#125;#ds-reset .ds-weibo&#123;background-position:0 0&#125;#ds-reset .ds-renren&#123;background-position:0 -32px&#125;#ds-reset .ds-qqt&#123;background-position:0 -64px&#125;#ds-reset .ds-kaixin&#123;background-position:0 -80px&#125;#ds-reset .ds-douban&#123;background-position:0 -96px&#125;#ds-reset .ds-qzone&#123;background-position:0 -128px&#125;#ds-reset .ds-duoshuo&#123;background-position:0 -144px&#125;#ds-reset .ds-qq&#123;background-position:0 -192px&#125;#ds-reset .ds-baidu&#123;background-position:0 -208px&#125;#ds-reset .ds-google&#123;background-position:0 -240px&#125;#ds-reset .ds-weixin&#123;background-position:0 -272px&#125;#ds-reset .ds-wechat&#123;background-position:0 -272px&#125;.ds-icons-32 a&#123;display:block;cursor:pointer;width:32px !important;height:32px !important;background:url(&quot;//static.duoshuo.com/images/icons_large.png&quot;) no-repeat !important;overflow:hidden;text-indent:-9999px&#125;.ds-icons-32 a.ds-weibo&#123;background-position:-37px 0 !important&#125;.ds-icons-32 a.ds-qzone&#123;background-position:0 0 !important&#125;.ds-icons-32 a.ds-qqt&#123;background-position:-74px 0 !important&#125;.ds-icons-32 a.ds-renren&#123;background-position:-148px 0 !important&#125;.ds-icons-32 a.ds-kaixin&#123;background-position:-111px 0 !important&#125;.ds-icons-32 a.ds-weixin&#123;background-position:-224px 0 !important&#125;.ds-icons-32 a.ds-wechat&#123;background-position:-224px 0 !important&#125;.ds-icons-32 a.ds-qq&#123;background-position:-488px 0 !important&#125;.ds-icons-32 a.ds-douban&#123;background-position:-186px 0 !important&#125;.ds-icons-32 a.ds-baidu&#123;background-position:-262px 0 !important&#125;#ds-reset #ds-ctx&#123;padding:0;margin:8px 0;max-width:640px&#125;#ds-reset #ds-ctx .ds-ctx-entry&#123;padding:6px;margin:0;border-bottom:1px solid #e6e6e6&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a&#123;color:#e77064&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a:hover&#123;color:#d32&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-avatar&#123;margin:0;width:30px;height:30px&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-avatar img&#123;width:30px;height:30px;box-shadow:none&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-body&#123;margin-left:38px&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head&#123;position:relative;_zoom:1;line-height:1em;padding:1px 0 0;margin:0 0 .25em&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-nth&#123;color:#999;font-size:12px;position:absolute;top:2px;right:0&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-time&#123;font-size:12px;*font-size:12px;margin-left:8px;color:#999;_zoom:1&#125;#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-content&#123;position:relative;_zoom:1;padding:0;margin:0;overflow:hidden;line-height:1.5em&#125;#ds-reset #ds-ctx .ds-ctx-entry:hover .ds-comment-actions&#123;display:block&#125;#ds-reset #ds-ctx .ds-comment-actions&#123;bottom:0;right:0;line-height:18px;position:absolute;display:none;*display:block&#125;#ds-reset #ds-ctx .ds-comment-actions a&#123;margin:0 0 0 6px&#125;#ds-reset.ds-touch #ds-ctx .ds-ctx-entry .ds-comment-actions&#123;display:block&#125;#ds-reset .ds-comment-body #ds-ctx&#123;border-left:3px solid #ccc;background-color:rgba(0,0,0,0.03)&#125;#ds-reset.ds-no-opacity .ds-comment-body #ds-ctx&#123;background:#f8f8f8&#125;#ds-reset .ds-dialog-body #ds-ctx .ds-ctx-entry:hover .ds-comment-actions&#123;display:none&#125;#ds-thread&#123;clear:both;position:relative;overflow:visible;_zoom:1&#125;#ds-thread #ds-reset a&#123;cursor:pointer;text-decoration:none;color:#777;background-color:transparent;-webkit-transition:color .15s linear;-moz-transition:color .15s linear;transition:color .15s linear&#125;#ds-thread #ds-reset a:hover&#123;color:#333&#125;#ds-thread #ds-reset ul,#ds-thread #ds-reset ul li&#123;background:none;margin:0;padding:0&#125;#ds-thread #ds-reset .ds-arrow&#123;position:absolute;width:0;height:0;font-size:0 !important;line-height:0 !important;_border-right-color:#ffc0cb !important;_border-left-color:#ffc0cb !important;_filter:chroma(color=#ffc0cb) !important&#125;#ds-thread #ds-reset .ds-arrow-down&#123;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid #fff&#125;#ds-thread #ds-reset button&#123;cursor:pointer;margin:0;padding:0;border-radius:0&#125;#ds-thread #ds-reset .ds-meta&#123;position:relative;padding:8px 0;line-height:24px;border-bottom:1px solid rgba(0,0,0,0.13)&#125;#ds-thread #ds-reset .ds-like-tooltip&#123;position:absolute;z-index:9999;background-color:#fcfcfc;background-repeat:repeat-x;background-image:-khtml-gradient(linear, left top, left bottom, from(#fcfcfc), to(#f9f9f9));background:-moz-linear-gradient(top, #fcfcfc 0, #f9f9f9 100%);background:-webkit-gradient(linear, left top, left bottom, color-stop(0, #fcfcfc), color-stop(100%, #f9f9f9));background:-webkit-linear-gradient(top, #fcfcfc 0, #f9f9f9 100%);background:-ms-linear-gradient(top, #fcfcfc 0, #f9f9f9 100%);background:linear-gradient(top, #fcfcfc 0, #f9f9f9 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#fcfcfc&apos;,endColorstr=&apos;#f9f9f9&apos;,GradientType=0);border:1px solid #aaa;box-shadow:0 0 2px rgba(0,0,0,0.2);text-shadow:0 1px 0 #fff;font-size:12px;padding:8px 14px&#125;#ds-thread #ds-reset .ds-like-tooltip ul&#123;width:84px;float:left&#125;#ds-thread #ds-reset .ds-like-tooltip li&#123;line-height:16px;margin:6px 0&#125;#ds-thread #ds-reset .ds-like-tooltip p&#123;clear:both;margin:6px 0&#125;#ds-thread #ds-reset .ds-like-tooltip .ds-like-tooltip-footer&#123;text-align:right&#125;#ds-thread #ds-reset a.ds-like-thread-button&#123;color:#555;padding:4px 8px;border:1px solid #ccc;border-bottom-color:#aaa;box-shadow:inset 0 0 1px #fff;margin-right:15px;text-shadow:0 1px 0 #fff;background-color:#e0e0e0;background-repeat:no-repeat;background-image:-webkit-gradient(linear, 0 0, 0 100%, from(#fff), color-stop(25%, #fff), to(#e0e0e0));background-image:-webkit-linear-gradient(#fff, #fff 25%, #e0e0e0);background-image:-moz-linear-gradient(top, #fff, #fff 25%, #e0e0e0);background-image:-ms-linear-gradient(#fff, #fff 25%, #e0e0e0);background-image:linear-gradient(#fff, #fff 25%, #e0e0e0)&#125;#ds-thread #ds-reset a.ds-like-thread-button .ds-icon-heart&#123;position:relative;top:-2px;opacity:1&#125;#ds-thread #ds-reset a.ds-like-thread-button span&#123;color:#555&#125;#ds-thread #ds-reset .ds-thread-cancel-like&#123;display:none&#125;#ds-thread #ds-reset a.ds-thread-liked&#123;background:#e9e9e9&#125;#ds-thread #ds-reset a.ds-thread-liked:hover .ds-thread-cancel-like&#123;display:inline&#125;#ds-thread #ds-reset a.ds-thread-liked:hover .ds-thread-like-text&#123;display:none&#125;#ds-thread #ds-reset #ds-hot-posts&#123;border:1px solid #ccc;overflow:hidden;margin:8px 0;padding:0;_height:100%&#125;#ds-thread #ds-reset .ds-header&#123;font-weight:bold;font-size:14px;color:#555;line-height:30px;padding:0 12px&#125;#ds-thread #ds-reset .ds-toolbar&#123;position:relative;z-index:5;font-size:12px;padding:8px 0;width:100%;clear:both&#125;#ds-thread #ds-reset .ds-toolbar:after&#123;content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden&#125;#ds-thread #ds-reset .ds-visitor&#123;float:right;line-height:1.5em;margin-right:6px&#125;#ds-thread #ds-reset .ds-account-control&#123;float:right;position:relative;font-size:12px;cursor:pointer;text-align:right;line-height:18px;padding-bottom:3px;width:75px&#125;#ds-thread #ds-reset .ds-account-control span&#123;display:block;float:left;color:#999&#125;#ds-thread #ds-reset .ds-account-control ul&#123;display:none;position:absolute;top:19px;left:0;border:1px solid #aaa;background:#f8f8f8;box-shadow:inset 0 1px 1px #fff,0 1px 1px rgba(0,0,0,0.3);border-radius:3px;text-align:center&#125;#ds-thread #ds-reset .ds-account-control ul li a&#123;border-top:1px solid #fff;border-bottom:1px solid #ddd;display:block;padding:3px 10px;text-shadow:0 1px 0 #fff&#125;#ds-thread #ds-reset .ds-account-control ul li a:hover&#123;color:#555&#125;#ds-thread #ds-reset .ds-account-control.ds-active span&#123;color:#555&#125;#ds-thread #ds-reset .ds-account-control.ds-active ul&#123;display:block&#125;#ds-thread #ds-reset .ds-alert&#123;margin:.5em 0;border:1px solid #fbeed5;border-radius:3px;padding:6px 6px;color:#c09853;background-color:#fcf8e3;line-height:1.5em&#125;#ds-thread #ds-reset .ds-login-buttons&#123;width:100%;position:relative;padding:10px 0 6px&#125;#ds-thread #ds-reset .ds-login-buttons p&#123;float:left;line-height:24px;margin:0&#125;#ds-thread #ds-reset .ds-login-buttons .ds-service-list li&#123;float:left;height:16px;width:54px;padding:4px 0;margin:0 0 0 6px&#125;#ds-thread #ds-reset .ds-login-buttons .ds-more-services&#123;color:#d32 !important;line-height:16px;display:block&#125;#ds-thread #ds-reset .ds-login-buttons .ds-more-services:hover&#123;color:#e77064 !important&#125;#ds-thread #ds-reset .ds-login-buttons .ds-additional-services&#123;display:none&#125;#ds-thread #ds-reset .ds-login-buttons .ds-social-links&#123;float:left;width:306px&#125;#ds-thread #ds-reset .ds-login-buttons:after&#123;content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden&#125;#ds-thread #ds-reset a.ds-unread-comments-count&#123;display:none;background-color:#d32;color:#fff !important;margin-right:6px;padding:1px 5px;font-weight:bold;-webkit-border-radius:5px;border-radius:5px;box-shadow:inset 0 1px 1px rgba(255,255,255,0.4),0 1px 1px rgba(0,0,0,0.3);text-shadow:0 1px 1px rgba(0,0,0,0.3)&#125;#ds-thread #ds-reset a.ds-unread-comments-count:hover&#123;background:#f00&#125;#ds-thread #ds-reset .ds-replybox&#123;width:auto;font-size:12px;z-index:3;margin:8px 0;padding:0 0 0 60px;position:relative;_zoom:1&#125;#ds-thread #ds-reset .ds-replybox:after&#123;content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden&#125;#ds-thread #ds-reset .ds-replybox .ds-avatar&#123;position:absolute;top:0;left:0&#125;#ds-thread #ds-reset .ds-replybox .ds-avatar img&#123;width:50px;height:50px;visibility:visible;margin:0&#125;#ds-thread #ds-reset .ds-inline-replybox&#123;margin:8px 0 2px 0;padding-left:38px&#125;#ds-thread #ds-reset .ds-inline-replybox .ds-avatar img&#123;width:30px;height:30px;box-shadow:0 1px 2px rgba(0,0,0,0.22)&#125;#ds-thread #ds-reset .ds-textarea-wrapper&#123;position:relative;border:1px solid #ccc;border-bottom:none;padding-right:20px;background:#fff url(&quot;//static.duoshuo.com/images/bg_sprites.png&quot;) 0 -90px repeat-x;overflow:hidden&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea&#123;box-shadow:none;-webkit-appearance:none;overflow:auto;padding:10px;height:54px;margin:0;resize:none;color:#999;width:100%&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea:focus&#123;color:#333&#125;#ds-thread #ds-reset .ds-textarea-wrapper .ds-hidden-text&#123;word-wrap:break-word;visibility:hidden;position:absolute;top:0;left:10px;right:10px&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea,#ds-thread #ds-reset .ds-textarea-wrapper .ds-hidden-text&#123;display:block;font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif;font-size:13px;line-height:20px;border:none&#125;#ds-thread #ds-reset .ds-post-toolbar&#123;position:relative;width:100%;box-shadow:0 1px 0 rgba(255,255,255,0.6)&#125;#ds-thread #ds-reset .ds-post-toolbar span,#ds-thread #ds-reset .ds-post-toolbar input,#ds-thread #ds-reset .ds-post-toolbar label,#ds-thread #ds-reset .ds-post-toolbar a&#123;vertical-align:middle;width:auto&#125;#ds-thread #ds-reset .ds-post-options&#123;position:relative;margin-right:100px;height:30px;border:1px solid #ccc;border-right:none;border-bottom-color:#aaa;border-bottom-left-radius:3px;-webkit-border-bottom-left-radius:3px&#125;#ds-thread #ds-reset .ds-toolbar-buttons&#123;position:absolute;top:5px;left:6px&#125;#ds-thread #ds-reset .ds-toolbar-button&#123;display:block;width:19px !important;height:19px;float:left;margin-right:4px;background:transparent url(&quot;//static.duoshuo.com/images/sprites.png&quot;) no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/sprites.gif&quot;);vertical-align:middle;opacity:.6;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;transition:opacity .15s linear&#125;#ds-thread #ds-reset .ds-toolbar-button:hover&#123;opacity:1&#125;#ds-thread #ds-reset .ds-add-image&#123;background-position:0 -48px&#125;#ds-thread #ds-reset .ds-add-image:hover&#123;background-position:0 -66px&#125;#ds-thread #ds-reset .ds-add-emote&#123;background-position:0 -12px&#125;#ds-thread #ds-reset .ds-add-emote:hover&#123;background-position:0 -30px&#125;#ds-thread #ds-reset .ds-sync&#123;font-size:12px;color:#999;line-height:30px;position:absolute;right:5px&#125;#ds-thread #ds-reset .ds-sync label&#123;color:#777;cursor:pointer;-webkit-transition:color .15s linear;-moz-transition:color .15s linear;transition:color .15s linear&#125;#ds-thread #ds-reset .ds-sync label:hover&#123;color:#555&#125;#ds-thread #ds-reset .ds-sync a.ds-service-icon,#ds-thread #ds-reset .ds-sync a.ds-service-icon-grey&#123;margin:7px 2px 7px 3px&#125;#ds-thread #ds-reset .ds-post-button&#123;font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif;position:absolute;right:0;top:0;height:32px;width:100px;text-align:center;text-shadow:0 1px 0 #fff;color:#555;font-size:14px;font-weight:bold;border:1px solid #ccc;border-bottom-color:#aaa;border-bottom-right-radius:3px;-webkit-border-bottom-right-radius:3px;background-color:#e6e6e6;background-repeat:no-repeat;background-image:-webkit-gradient(linear, 0 0, 0 100%, from(#fcfcfc), color-stop(25%, #fcfcfc), to(#e6e6e6));background-image:-webkit-linear-gradient(#fcfcfc, #fcfcfc 25%, #e6e6e6);background-image:-moz-linear-gradient(top, #fcfcfc, #fcfcfc 25%, #e6e6e6);background-image:-ms-linear-gradient(#fcfcfc, #fcfcfc 25%, #e6e6e6);background-image:linear-gradient(#fcfcfc, #fcfcfc 25%, #e6e6e6);-webkit-transition:all .15s linear;-moz-transition:all .15s linear;transition:all .15s linear;box-shadow:inset 0 0 1px #fff&#125;#ds-thread #ds-reset .ds-post-button:hover&#123;background-position:0 -15px;color:#333&#125;#ds-thread #ds-reset .ds-post-button:active&#123;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)&#125;#ds-thread #ds-reset .ds-comments-info&#123;width:100%;font-size:13px;margin-top:10px;padding:8px 0;line-height:25px;position:relative&#125;#ds-thread #ds-reset .ds-sort&#123;position:absolute;right:0;top:8px&#125;#ds-thread #ds-reset .ds-sort a&#123;color:#999;padding:0 4px;margin:0 2px&#125;#ds-thread #ds-reset .ds-sort a:hover&#123;color:#333&#125;#ds-thread #ds-reset .ds-sort a.ds-current,#ds-thread #ds-reset .ds-sort a:active&#123;color:#d32&#125;#ds-thread #ds-reset ul.ds-comments-tabs .ds-highlight&#123;margin:0 2px 0 0&#125;#ds-thread #ds-reset ul.ds-comments-tabs .ds-service-icon&#123;vertical-align:middle;margin:0 2px 1px 0&#125;#ds-thread #ds-reset li.ds-tab&#123;display:inline;font-size:13px;margin:0 5px 0 0;padding:0&#125;#ds-thread #ds-reset li.ds-tab a&#123;text-shadow:0 1px 0 #fff;padding:3px 5px;display:inline;-webkit-border-radius:5px;border-radius:5px&#125;#ds-thread #ds-reset li.ds-tab a.ds-current&#123;border:1px solid #ccc;background-color:rgba(0,0,0,0.04)&#125;#ds-thread #ds-reset li.ds-tab a:hover&#123;background-color:rgba(0,0,0,0.04)&#125;#ds-thread #ds-reset .ds-comments&#123;width:100%;border-bottom:1px solid rgba(0,0,0,0.13)&#125;#ds-thread #ds-reset .ds-comments:after&#123;content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden&#125;#ds-thread #ds-reset li.ds-post&#123;width:100%;overflow:hidden;clear:both;border-top:1px solid rgba(0,0,0,0.13);margin:0;padding:0;list-style:none&#125;#ds-thread #ds-reset li.ds-post-placeholder&#123;text-align:center;color:#999;padding:1em 0&#125;#ds-thread #ds-reset .ds-post-self&#123;position:relative;padding:10px;border-top:1px solid rgba(255,255,255,0.7)&#125;#ds-thread #ds-reset .ds-post-self:after&#123;content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden&#125;#ds-thread #ds-reset .ds-post-self:hover .ds-post-delete,#ds-thread #ds-reset .ds-post-self:hover .ds-post-report&#123;display:inline-block&#125;#ds-thread #ds-reset.ds-touch .ds-post-self .ds-post-delete,#ds-thread #ds-reset.ds-touch .ds-post-self .ds-post-report&#123;display:inline-block&#125;#ds-thread #ds-reset .ds-comment-body&#123;padding-left:60px&#125;#ds-thread #ds-reset .ds-comment-body p&#123;font-size:13px;line-height:1.5em;margin:.5em 0;word-wrap:break-word&#125;#ds-thread #ds-reset .ds-comment-body img&#123;max-width:100%;vertical-align:text-bottom;box-shadow:none&#125;#ds-thread #ds-reset .ds-comment-body embed&#123;max-width:100%&#125;#ds-thread #ds-reset .ds-comment-body code&#123;display:block;font-size:12px;font-family:Monaco,Menlo,Consolas,&quot;Courier New&quot;,monospace;padding:8px 12px;background-color:#f0f0f0;margin:8px 0;border-radius:3px;border:1px solid #ddd;color:#666&#125;#ds-thread #ds-reset .ds-comment-body a&#123;color:#777&#125;#ds-thread #ds-reset .ds-comment-body a:hover&#123;color:#555&#125;#ds-thread #ds-reset a.ds-comment-context&#123;position:relative;margin:.5em 0;color:#e77064&#125;#ds-thread #ds-reset a.ds-comment-context:hover&#123;color:#d32&#125;#ds-thread #ds-reset #ds-bubble&#123;position:absolute;background-color:#fff;-webkit-border-radius:5px;border-radius:5px;padding:10px;color:#333;border:1px solid #aaa;box-shadow:0 0 2px rgba(0,0,0,0.2);z-index:9999;font-size:13px&#125;#ds-thread #ds-reset #ds-bubble a&#123;color:#e77064&#125;#ds-thread #ds-reset #ds-bubble a:hover&#123;color:#d32&#125;#ds-thread #ds-reset #ds-bubble p&#123;line-height:18px&#125;#ds-thread #ds-reset #ds-bubble .ds-arrow-border&#123;border-top-color:#aaa;bottom:-6px&#125;#ds-thread #ds-reset #ds-bubble .ds-arrow&#123;left:32px;bottom:-5px&#125;#ds-thread #ds-reset #ds-ctx-bubble&#123;width:300px&#125;#ds-thread #ds-reset #ds-ctx-bubble .ds-bubble-footer&#123;padding:6px 0 0 0;line-height:18px&#125;#ds-thread #ds-reset #ds-user-card&#123;width:276px;min-height:50px&#125;#ds-thread #ds-reset #ds-user-card .ds-avatar&#123;margin-right:10px&#125;#ds-thread #ds-reset #ds-user-card .ds-avatar img&#123;width:50px;height:50px&#125;#ds-thread #ds-reset #ds-user-card .ds-user-name&#123;vertical-align:top;display:inline-block;max-width:8em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-size:14px&#125;#ds-thread #ds-reset #ds-user-card .ds-user-card-meta&#123;margin:14px 0 0 62px&#125;#ds-thread #ds-reset #ds-user-card .ds-user-description&#123;border-top:1px dotted #ddd;margin-top:.5em;color:#aaa&#125;#ds-thread #ds-reset #ds-user-card .ds-service-icon&#123;margin-right:3px&#125;#ds-thread #ds-reset .ds-comment-header&#123;padding-top:1px&#125;#ds-thread #ds-reset .ds-comment-footer&#123;line-height:1.5em&#125;#ds-thread #ds-reset .ds-comment-footer a&#123;margin:0 6px 0 0;padding:0 6px 0 0&#125;#ds-thread #ds-reset .ds-comment-actions a&#123;font-size:12px;color:#999&#125;#ds-thread #ds-reset .ds-comment-actions a .ds-icon&#123;position:relative;top:-1px&#125;#ds-thread #ds-reset .ds-user-name&#123;color:#777;font-size:13px;margin-right:8px&#125;#ds-thread #ds-reset .ds-post-liked .ds-icon-like&#123;background-position:0 -130px&#125;#ds-thread #ds-reset .ds-post-liked a.ds-post-likes&#123;color:#d32&#125;#ds-thread #ds-reset .ds-reply-active&#123;display:block&#125;#ds-thread #ds-reset .ds-reply-active .ds-post-reply&#123;color:#333&#125;#ds-thread #ds-reset .ds-reply-active .ds-post-reply .ds-icon&#123;opacity:1&#125;#ds-thread #ds-reset .ds-post-delete,#ds-thread #ds-reset .ds-post-report&#123;display:none&#125;#ds-thread #ds-reset .ds-icon-heart&#123;width:14px;height:13px;background-position:0 -130px&#125;#ds-thread #ds-reset .ds-icon-settings&#123;width:12px;height:12px;margin:3px 4px 0;opacity:1&#125;#ds-thread #ds-reset .ds-icon-like&#123;width:14px;height:13px;background-position:0 -117px&#125;#ds-thread #ds-reset .ds-icon-share&#123;width:18px;height:13px;background-position:0 -234px&#125;#ds-thread #ds-reset .ds-icon-reply&#123;width:18px;height:13px;background-position:0 -105px&#125;#ds-thread #ds-reset .ds-icon-delete&#123;width:13px;height:13px;background-position:0 -176px&#125;#ds-thread #ds-reset .ds-icon-report&#123;width:12px;height:12px;background-position:0 -189px&#125;#ds-thread #ds-reset .ds-time&#123;font-size:12px;*font-size:12px;margin-right:8px;color:#999;_zoom:1&#125;#ds-thread #ds-reset ul.ds-children&#123;margin-left:38px&#125;#ds-thread #ds-reset ul.ds-children .ds-avatar&#123;width:30px;height:30px&#125;#ds-thread #ds-reset ul.ds-children .ds-avatar img&#123;width:30px;height:30px&#125;#ds-thread #ds-reset ul.ds-children .ds-post-self&#123;padding-left:0&#125;#ds-thread #ds-reset ul.ds-children .ds-comment-body&#123;padding-left:38px&#125;#ds-thread #ds-reset .ds-paginator&#123;border-bottom:1px solid rgba(0,0,0,0.13);text-align:right;padding-bottom:15px;clear:both;line-height:1em&#125;#ds-thread #ds-reset .ds-paginator div.ds-border&#123;border-top:1px solid rgba(255,255,255,0.7);margin-bottom:15px&#125;#ds-thread #ds-reset .ds-paginator a&#123;font-size:12px;margin:0 3px;padding:2px 5px;border:1px solid transparent&#125;#ds-thread #ds-reset .ds-paginator a:hover,#ds-thread #ds-reset .ds-paginator a.ds-current&#123;-webkit-border-radius:3px;border-radius:3px;background-color:rgba(0,0,0,0.03)&#125;#ds-thread #ds-reset .ds-paginator a.ds-current&#123;color:#d32;border:1px solid #ccc&#125;#ds-thread #ds-reset .ds-powered-by&#123;font-size:12px;text-align:right;padding:10px 0&#125;#ds-thread #ds-reset .ds-powered-by a&#123;color:#999;text-decoration:none&#125;#ds-thread #ds-reset .ds-powered-by a:hover&#123;color:#555&#125;#ds-thread #ds-reset.ds-no-transition .ds-post-button,#ds-thread #ds-reset.ds-no-transition .ds-more a&#123;background:url(&quot;//static.duoshuo.com/images/bg_sprites.png&quot;) repeat-x !important&#125;#ds-thread #ds-reset.ds-no-transition .ds-post-button:hover,#ds-thread #ds-reset.ds-no-transition .ds-more a:hover&#123;background-position:0 -30px !important&#125;#ds-thread #ds-reset.ds-no-transition .ds-like-thread-button&#123;background:url(&quot;//static.duoshuo.com/images/bg_sprites.png&quot;) repeat-x&#125;#ds-thread #ds-reset.ds-no-opacity li.ds-post&#123;border-top:1px solid #ddd&#125;#ds-thread #ds-reset.ds-no-opacity .ds-comments,#ds-thread #ds-reset.ds-no-opacity .ds-paginator&#123;border-bottom:1px solid #ddd&#125;#ds-thread #ds-reset.ds-no-opacity .ds-post-self&#123;border-top:none&#125;#ds-thread #ds-reset.ds-no-opacity .ds-tab a.ds-current&#123;background:#f8f8f8&#125;#ds-thread #ds-reset.ds-ie6 .ds-post-report,#ds-thread #ds-reset.ds-ie6 .ds-post-delete&#123;display:inline !important&#125;#ds-thread #ds-reset.ds-ie6 .ds-textarea-wrapper&#123;padding:10px 10px&#125;#ds-thread #ds-reset.ds-ie6 .ds-textarea-wrapper textarea&#123;width:95%;color:#333;padding:0&#125;#ds-thread #ds-reset.ds-ie6 .ds-post&#123;width:100%;float:left&#125;#ds-thread #ds-reset.ds-ie6 .ds-tab a.ds-current&#123;padding-bottom:5px&#125;#ds-thread #ds-reset.ds-ie6 #ds-ctx-bubble .ds-arrow&#123;bottom:-8px&#125;#ds-thread #ds-reset.ds-ie6 #ds-ctx-bubble .ds-arrow-border&#123;bottom:-9px&#125;#ds-thread.ds-narrow #ds-reset .ds-post-self&#123;padding:8px&#125;#ds-thread.ds-narrow #ds-reset .ds-comment-body,#ds-thread.ds-narrow #ds-reset .ds-replybox&#123;padding-left:38px&#125;#ds-thread.ds-narrow #ds-reset .ds-avatar img&#123;width:30px;height:30px&#125;#ds-thread.ds-narrow #ds-reset .ds-post-button&#123;width:70px&#125;#ds-thread.ds-narrow #ds-reset .ds-post-options&#123;margin-right:70px&#125;#ds-smilies-tooltip&#123;border:1px solid #aaa;position:absolute;width:400px;background-color:#fff;z-index:9999;box-shadow:0 0 2px rgba(0,0,0,0.2);text-shadow:0 1px 0 #fff;-webkit-border-radius:3px;border-radius:3px&#125;#ds-smilies-tooltip a&#123;cursor:pointer&#125;#ds-smilies-tooltip ul&#123;list-style-type:none;padding:0;margin:0&#125;#ds-smilies-tooltip ul.ds-smilies-tabs&#123;width:119px;position:absolute;top:0;left:0;height:159px;overflow-y:auto;background:#f8f8f8;border-right:1px solid #ccc;border-top-left-radius:3px;border-bottom-left-radius:3px&#125;#ds-smilies-tooltip ul.ds-smilies-tabs li a&#123;color:#999;padding:6px 10px;display:block;border-bottom:1px solid #ccc;background-color:#fff;background-repeat:repeat-x;background-image:-khtml-gradient(linear, left top, left bottom, from(#fff), to(#e9e9e9));background:-moz-linear-gradient(top, #fff 0, #e9e9e9 100%);background:-webkit-gradient(linear, left top, left bottom, color-stop(0, #fff), color-stop(100%, #e9e9e9));background:-webkit-linear-gradient(top, #fff 0, #e9e9e9 100%);background:-ms-linear-gradient(top, #fff 0, #e9e9e9 100%);background:linear-gradient(top, #fff 0, #e9e9e9 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&apos;#ffffff&apos;,endColorstr=&apos;#e9e9e9&apos;,GradientType=0);font-size:12px;line-height:1.3em&#125;#ds-smilies-tooltip ul.ds-smilies-tabs li:first-child a&#123;border-top-left-radius:3px&#125;#ds-smilies-tooltip ul.ds-smilies-tabs li a.ds-current&#123;color:#666;background:#e3e3e3;filter:none;box-shadow:inset 0 0 4px rgba(0,0,0,0.1)&#125;#ds-smilies-tooltip .ds-smilies-container&#123;padding:10px 5px;height:140px;margin-left:125px;overflow-y:auto&#125;#ds-smilies-tooltip .ds-smilies-container li&#123;list-style:none;float:left;width:26px;height:26px;text-align:center;cursor:pointer&#125;#ds-smilies-tooltip .ds-smilies-container li img&#123;visibility:visible&#125;#ds-smilies-tooltip .ds-smilies-container li:hover&#123;position:relative;top:-1px&#125;#ds-wrapper&#123;left:0;right:0;top:20%;bottom:0;width:100%;margin:auto;z-index:9999;position:fixed;_position:absolute;text-align:center;color:#777&#125;#ds-wrapper .ds-dialog,#ds-wrapper #ds-reset.ds-dialog&#123;margin:0 auto;text-align:left;_zoom:1;width:480px;max-width:100%&#125;#ds-wrapper #ds-reset.ds-dialog-bind-more .ds-service-list&#123;width:50%&#125;#ds-wrapper #ds-reset a&#123;cursor:pointer;text-decoration:none;color:#777&#125;#ds-wrapper #ds-reset .ds-dialog-inner&#123;width:100%;position:relative;border:1px solid #aaa;background:#fff url(&quot;//static.duoshuo.com/images/bg_sprites.png&quot;) 0 -90px repeat-x;text-shadow:0 1px 0 #fff;box-shadow:inset 0 1px 1px #fff,0 2px 6px rgba(0,0,0,0.4)&#125;#ds-wrapper #ds-reset .ds-dialog-inner .ds-unread-list&#123;max-height:300px;overflow-y:auto&#125;#ds-wrapper #ds-reset .ds-control-group&#123;margin:18px 0;position:relative;padding-right:80px;max-width:166px&#125;#ds-wrapper #ds-reset .ds-control-group input&#123;color:#777;width:100%;font-size:13px;border:1px solid #ccc;padding:4px 80px 6px 6px;box-shadow:inset 0 1px 3px rgba(0,0,0,0.1)&#125;#ds-wrapper #ds-reset .ds-control-group input:focus&#123;border-color:#08b5fb&#125;#ds-wrapper #ds-reset .ds-control-group label&#123;font-size:13px;color:#ccc;letter-spacing:1px;position:absolute;right:0;top:8px&#125;#ds-wrapper #ds-reset tr&#123;height:45px&#125;#ds-wrapper #ds-reset button&#123;cursor:pointer;color:#555;background-color:#e6e6e6;background-repeat:no-repeat;background-image:-webkit-gradient(linear, 0 0, 0 100%, from(#fff), color-stop(25%, #fff), to(#e6e6e6));background-image:-webkit-linear-gradient(#fff, #fff 25%, #e6e6e6);background-image:-moz-linear-gradient(top, #fff, #fff 25%, #e6e6e6);background-image:-ms-linear-gradient(#fff, #fff 25%, #e6e6e6);background-image:linear-gradient(#fff, #fff 25%, #e6e6e6);-webkit-transition:all .15s linear;-moz-transition:all .15s linear;transition:all .15s linear;border:1px solid #aaa;display:inline-block;font-size:15px;height:30px;width:100px;padding:0&#125;#ds-wrapper #ds-reset button:hover&#123;background-position:0 -15px;color:#333&#125;#ds-wrapper #ds-reset button:active&#123;top:0;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)&#125;#ds-wrapper #ds-reset h2&#123;display:block;font-weight:normal;font-size:16px;margin:0 0 15px 0;color:#555&#125;#ds-wrapper #ds-reset .ds-dialog-body&#123;padding:30px 30px 25px;position:relative;overflow:hidden&#125;#ds-wrapper #ds-reset .ds-icons-32&#123;height:32px;margin-bottom:20px;overflow:hidden&#125;#ds-wrapper #ds-reset .ds-icons-32 a&#123;float:left;margin:0 5px 0 0&#125;#ds-wrapper #ds-reset ul li&#123;margin:10px 0&#125;#ds-wrapper #ds-reset .ds-service-list&#123;width:45%;float:left&#125;#ds-wrapper #ds-reset .ds-service-list .ds-more-services&#123;display:none&#125;#ds-wrapper #ds-reset .ds-icon-ok&#123;background-position:0 -203px;width:12px;height:12px&#125;#ds-wrapper #ds-reset .ds-quote&#123;margin:10px 0;padding:6px 10px;background:#f8f8f8;line-height:1.5em;font-size:12px;overflow-y:auto;max-height:180px&#125;#ds-wrapper #ds-reset .ds-textarea-wrapper&#123;border:1px solid #ccc;padding:0 20px 0 0;position:relative;margin:12px 0&#125;#ds-wrapper #ds-reset .ds-textarea-wrapper textarea&#123;width:100%;height:54px;margin:0;resize:none;padding:6px 10px;overflow:auto&#125;#ds-wrapper #ds-reset .ds-textarea-wrapper .ds-hidden-text&#123;top:0;left:10px;right:10px;position:absolute;visibility:hidden;word-wrap:break-word&#125;#ds-wrapper #ds-reset .ds-textarea-wrapper textarea,#ds-wrapper #ds-reset .ds-textarea-wrapper .ds-hidden-text&#123;font-size:13px;line-height:1.5em&#125;#ds-wrapper #ds-reset .ds-actions&#123;position:relative;height:30px&#125;#ds-wrapper #ds-reset .ds-actions button&#123;display:block;position:absolute;top:0;right:0&#125;#ds-wrapper #ds-reset .ds-dialog-close&#123;position:absolute;bottom:13px;right:11px;display:block;width:13px;height:13px;overflow:hidden;background:transparent url(&quot;//static.duoshuo.com/images/sprites.png&quot;) 0 -163px no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/sprites.gif&quot;)&#125;#ds-wrapper #ds-reset .ds-dialog-close:hover&#123;background-position:0 -176px&#125;#ds-wrapper #ds-reset .ds-logo&#123;display:inline-block;width:64px;height:21px;margin-right:10px;background:url(&quot;//static.duoshuo.com/images/logo.png&quot;) 0 0 no-repeat&#125;#ds-wrapper #ds-reset .ds-dialog-footer&#123;clear:both;border-top:1px dotted #ccc;padding:10px 15px 6px&#125;#ds-wrapper #ds-reset .ds-dialog-footer span&#123;color:#999;position:relative;top:-6px&#125;#ds-wrapper #ds-reset .ds-connect&#123;display:none&#125;#ds-wrapper #ds-reset .ds-unread-list li&#123;position:relative;margin:0;padding:8px 0;border-top:1px solid #eee;line-height:1.5em;color:#777&#125;#ds-wrapper #ds-reset .ds-unread-list li a&#123;color:#d32&#125;#ds-wrapper #ds-reset .ds-unread-list li a:hover&#123;color:#e45c4e&#125;#ds-wrapper #ds-reset .ds-unread-list li a[rel~=&quot;author&quot;]&#123;color:#777&#125;#ds-wrapper #ds-reset .ds-unread-list li .ds-delete&#123;display:none;position:absolute;right:0;bottom:10px;text-indent:-9999px;width:14px;height:14px;overflow:hidden;background:transparent url(&quot;//static.duoshuo.com/images/delete.gif&quot;) no-repeat scroll 0 -14px&#125;#ds-wrapper #ds-reset .ds-unread-list li:hover .ds-delete&#123;display:block&#125;#ds-wrapper #ds-reset.ds-touch .ds-unread-list li .ds-delete&#123;display:block&#125;#ds-wrapper.ds-no-transition #ds-reset button&#123;background:url(&quot;//static.duoshuo.com/images/bg_sprites.png&quot;) repeat-x !important&#125;#ds-wrapper.ds-no-transition #ds-reset button:hover&#123;background-position:0 -30px !important&#125;#ds-wrapper.ds-no-transition #ds-reset.ds-dialog&#123;background-image:url(&quot;//static.duoshuo.com/images/black.png&quot;)&#125;#ds-wrapper.ds-ie6 #ds-reset&#123;margin-top:0&#125;#ds-wrapper.ds-ie6 #ds-reset .ds-dialog-footer span&#123;top:-3px&#125;#ds-notify&#123;position:fixed;*position:absolute;z-index:9999;max-width:144px;_width:130px;display:block;float:none;padding:8px 12px;background-color:#fff;-webkit-border-radius:5px;border-radius:5px;box-shadow:0 1px 1px rgba(0,0,0,0.25);border:1px solid #aaa&#125;#ds-notify #ds-reset&#123;line-height:14px&#125;#ds-notify #ds-reset a.ds-logo&#123;width:18px;height:14px;background:transparent url(&quot;//static.duoshuo.com/images/sprites.png&quot;) 0 -220px no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/sprites.gif&quot;);position:absolute;display:block;top:8px;left:12px&#125;#ds-notify #ds-reset span.ds-unread-count&#123;font-weight:bold;color:#e32&#125;#ds-notify #ds-reset ul.ds-notify-unread&#123;line-height:150%;display:inline-block;margin:0 0 0 22px;padding:0&#125;#ds-notify #ds-reset ul.ds-notify-unread li a&#123;color:#d32;text-decoration:none&#125;#ds-recent-comments li.ds-comment&#123;list-style-type:none;position:relative !important;margin:0 !important;padding:6px 0 !important;_zoom:1;border-top:1px solid #dcdcdc;word-wrap:break-word;font-size:13px&#125;#ds-recent-comments li.ds-comment a&#123;display:inline&#125;#ds-recent-comments li.ds-comment div&#123;padding:0;margin:0&#125;#ds-recent-comments li.ds-comment .ds-avatar&#123;position:absolute !important;top:6px !important;left:0 !important&#125;#ds-recent-comments li.ds-comment .ds-avatar a&#123;display:block&#125;#ds-recent-comments li.ds-comment .ds-meta&#123;*margin-left:-15px;_margin-left:0&#125;#ds-recent-comments li.ds-comment .ds-time&#123;font-size:10px;color:#999;margin-left:5px&#125;#ds-recent-comments li.ds-comment .ds-thread-title&#123;margin:0 0 4px 0;line-height:13px;font-size:12px;color:#777&#125;#ds-recent-comments li.ds-comment .ds-thread-title a&#123;font-size:12px&#125;#ds-recent-comments li.ds-comment .ds-excerpt&#123;line-height:18px&#125;#ds-recent-comments li.ds-comment.ds-show-avatars&#123;padding-left:38px !important&#125;#ds-recent-visitors .ds-avatar&#123;display:inline;padding:0 !important;margin:4px !important&#125;#ds-login .ds-icons-32 a&#123;float:left;margin:0 5px 0 0&#125;#ds-share #ds-reset.ds-share-aside-left ul,#ds-share #ds-reset.ds-share-aside-right ul,#ds-share #ds-reset.ds-share-inline ul&#123;list-style:none;margin:0;padding:0;*zoom:1&#125;#ds-share #ds-reset.ds-share-aside-left ul:after,#ds-share #ds-reset.ds-share-aside-right ul:after,#ds-share #ds-reset.ds-share-inline ul:after&#123;content:&quot;.&quot;;display:block;height:0;clear:both;visibility:hidden&#125;#ds-share #ds-reset.ds-share-aside-left ul li,#ds-share #ds-reset.ds-share-aside-right ul li,#ds-share #ds-reset.ds-share-inline ul li&#123;list-style:none;float:left;font-size:14px;padding:7px 0&#125;#ds-share #ds-reset.ds-share-inline&#123;position:relative&#125;#ds-share #ds-reset.ds-share-inline ul li&#123;margin-left:8px&#125;#ds-share #ds-reset.ds-share-inline ul li:first-child&#123;margin-left:0&#125;#ds-share #ds-reset.ds-share-aside-left,#ds-share #ds-reset.ds-share-aside-right&#123;position:fixed;top:50%;z-index:1000;-webkit-transition:all .2s linear;-moz-transition:all .2s linear;transition:all .2s linear&#125;#ds-share #ds-reset.ds-share-aside-left&#123;left:0;-webkit-transform:translate(-100%, -50%);-ms-transform:translate(-100%, -50%);-o-transform:translate(-100%, -50%);transform:translate(-100%, -50%)&#125;#ds-share #ds-reset.ds-share-aside-right&#123;right:0;-webkit-transform:translate(100%, -50%);-ms-transform:translate(100%, -50%);-o-transform:translate(100%, -50%);transform:translate(100%, -50%)&#125;#ds-share #ds-reset .ds-share-aside-toggle&#123;width:28px;padding:23px 2px;background:#e94c4c;color:#fff;position:absolute;top:0;text-align:center;font-size:16px;font-weight:bolder;cursor:pointer&#125;#ds-share #ds-reset.ds-share-aside-left .ds-share-aside-toggle&#123;right:-32px;border-top-right-radius:3px;border-bottom-right-radius:3px&#125;#ds-share #ds-reset.ds-share-aside-left .ds-share-icons&#123;border-top-right-radius:0;border-top-left-radius:0;border-bottom-left-radius:0;border-left:none&#125;#ds-share #ds-reset.ds-share-aside-right .ds-share-aside-toggle&#123;left:-32px;border-top-left-radius:3px;border-bottom-left-radius:3px&#125;#ds-share #ds-reset.ds-share-aside-right .ds-share-icons&#123;border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:0;border-right:none&#125;#ds-share #ds-reset.slide-to-left&#123;-webkit-transform:translate(0, -50%);-ms-transform:translate(0, -50%);-o-transform:translate(0, -50%);transform:translate(0, -50%)&#125;#ds-share #ds-reset.slide-to-right&#123;-webkit-transform:translate(0, -50%);-ms-transform:translate(0, -50%);-o-transform:translate(0, -50%);transform:translate(0, -50%)&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-weibo,#ds-share #ds-reset .ds-share-icons-32 .ds-sohu,#ds-share #ds-reset .ds-share-icons-32 .ds-renren,#ds-share #ds-reset .ds-share-icons-32 .ds-netease,#ds-share #ds-reset .ds-share-icons-32 .ds-qqt,#ds-share #ds-reset .ds-share-icons-32 .ds-kaixin,#ds-share #ds-reset .ds-share-icons-32 .ds-douban,#ds-share #ds-reset .ds-share-icons-32 .ds-msn,#ds-share #ds-reset .ds-share-icons-32 .ds-qzone,#ds-share #ds-reset .ds-share-icons-32 .ds-duoshuo,#ds-share #ds-reset .ds-share-icons-32 .ds-360,#ds-share #ds-reset .ds-share-icons-32 .ds-alipay,#ds-share #ds-reset .ds-share-icons-32 .ds-qq,#ds-share #ds-reset .ds-share-icons-32 .ds-baidu,#ds-share #ds-reset .ds-share-icons-32 .ds-taobao,#ds-share #ds-reset .ds-share-icons-32 .ds-google,#ds-share #ds-reset .ds-share-icons-32 .ds-more,#ds-share #ds-reset .ds-share-icons-32 .ds-wechat,#ds-share #ds-reset .ds-share-icons-32 .ds-diandian,#ds-share #ds-reset .ds-share-icons-32 .ds-huaban,#ds-share #ds-reset .ds-share-icons-32 .ds-duitang,#ds-share #ds-reset .ds-share-icons-32 .ds-youdao,#ds-share #ds-reset .ds-share-icons-32 .ds-pengyou,#ds-share #ds-reset .ds-share-icons-32 .ds-facebook,#ds-share #ds-reset .ds-share-icons-32 .ds-twitter,#ds-share #ds-reset .ds-share-icons-32 .ds-linkedin,#ds-share #ds-reset .ds-share-icons-32 .ds-meilishuo,#ds-share #ds-reset .ds-share-icons-32 .ds-mogujie&#123;height:32px;width:32px;text-decoration:none;color:#999;display:block;overflow:hidden;background-image:url(&quot;//static.duoshuo.com/images/service-icons-color-32.png&quot;);background-repeat:no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/service-icons-color-32.gif&quot;)&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-weibo&#123;background-position:0 0&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-sohu&#123;background-position:0 -32px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-renren&#123;background-position:0 -64px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-netease&#123;background-position:0 -96px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-qqt&#123;background-position:0 -128px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-kaixin&#123;background-position:0 -160px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-douban&#123;background-position:0 -192px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-msn&#123;background-position:0 -224px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-qzone&#123;background-position:0 -256px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-duoshuo&#123;background-position:0 -288px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-360&#123;background-position:0 -320px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-alipay&#123;background-position:0 -352px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-qq&#123;background-position:0 -384px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-baidu&#123;background-position:0 -416px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-taobao&#123;background-position:0 -448px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-google&#123;background-position:0 -480px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-more&#123;background-position:0 -512px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-wechat&#123;background-position:0 -544px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-diandian&#123;background-position:0 -576px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-huaban&#123;background-position:0 -608px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-duitang&#123;background-position:0 -640px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-youdao&#123;background-position:0 -672px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-pengyou&#123;background-position:0 -704px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-facebook&#123;background-position:0 -736px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-twitter&#123;background-position:0 -768px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-linkedin&#123;background-position:0 -800px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-meilishuo&#123;background-position:0 -832px&#125;#ds-share #ds-reset .ds-share-icons-32 .ds-mogujie&#123;background-position:0 -864px&#125;#ds-share #ds-reset .ds-share-icons-32 .flat&#123;background-image:url(&quot;//static.duoshuo.com/images/service-icons-color-flat-32.png&quot;);_background-image:url(&quot;//static.duoshuo.com/images/service-icons-color-flat-32.gif&quot;)&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-weibo,#ds-share #ds-reset .ds-share-icons-16 .ds-sohu,#ds-share #ds-reset .ds-share-icons-16 .ds-renren,#ds-share #ds-reset .ds-share-icons-16 .ds-netease,#ds-share #ds-reset .ds-share-icons-16 .ds-qqt,#ds-share #ds-reset .ds-share-icons-16 .ds-kaixin,#ds-share #ds-reset .ds-share-icons-16 .ds-douban,#ds-share #ds-reset .ds-share-icons-16 .ds-msn,#ds-share #ds-reset .ds-share-icons-16 .ds-qzone,#ds-share #ds-reset .ds-share-icons-16 .ds-duoshuo,#ds-share #ds-reset .ds-share-icons-16 .ds-360,#ds-share #ds-reset .ds-share-icons-16 .ds-alipay,#ds-share #ds-reset .ds-share-icons-16 .ds-qq,#ds-share #ds-reset .ds-share-icons-16 .ds-baidu,#ds-share #ds-reset .ds-share-icons-16 .ds-taobao,#ds-share #ds-reset .ds-share-icons-16 .ds-google,#ds-share #ds-reset .ds-share-icons-16 .ds-more,#ds-share #ds-reset .ds-share-icons-16 .ds-wechat,#ds-share #ds-reset .ds-share-icons-16 .ds-diandian,#ds-share #ds-reset .ds-share-icons-16 .ds-huaban,#ds-share #ds-reset .ds-share-icons-16 .ds-duitang,#ds-share #ds-reset .ds-share-icons-16 .ds-youdao,#ds-share #ds-reset .ds-share-icons-16 .ds-pengyou,#ds-share #ds-reset .ds-share-icons-16 .ds-facebook,#ds-share #ds-reset .ds-share-icons-16 .ds-twitter,#ds-share #ds-reset .ds-share-icons-16 .ds-linkedin,#ds-share #ds-reset .ds-share-icons-16 .ds-meilishuo,#ds-share #ds-reset .ds-share-icons-16 .ds-mogujie&#123;line-height:16px;padding-left:20px;text-decoration:none;color:#999;display:block;overflow:hidden;background-image:url(&quot;//static.duoshuo.com/images/service-icons-color.png?v=2&quot;);background-repeat:no-repeat;_background-image:url(&quot;//static.duoshuo.com/images/service-icons-color.gif?v=2&quot;)&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-weibo&#123;background-position:0 0&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-sohu&#123;background-position:0 -16px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-renren&#123;background-position:0 -32px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-netease&#123;background-position:0 -48px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-qqt&#123;background-position:0 -64px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-kaixin&#123;background-position:0 -80px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-douban&#123;background-position:0 -96px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-msn&#123;background-position:0 -112px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-qzone&#123;background-position:0 -128px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-duoshuo&#123;background-position:0 -144px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-360&#123;background-position:0 -160px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-alipay&#123;background-position:0 -176px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-qq&#123;background-position:0 -192px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-baidu&#123;background-position:0 -208px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-taobao&#123;background-position:0 -224px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-google&#123;background-position:0 -240px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-more&#123;background-position:0 -256px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-wechat&#123;background-position:0 -272px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-diandian&#123;background-position:0 -288px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-huaban&#123;background-position:0 -304px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-duitang&#123;background-position:0 -320px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-youdao&#123;background-position:0 -336px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-pengyou&#123;background-position:0 -352px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-facebook&#123;background-position:0 -368px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-twitter&#123;background-position:0 -384px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-linkedin&#123;background-position:0 -400px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-meilishuo&#123;background-position:0 -416px&#125;#ds-share #ds-reset .ds-share-icons-16 .ds-mogujie&#123;background-position:0 -432px&#125;#ds-share #ds-reset .ds-share-icons-16 .flat&#123;background-image:url(&quot;//static.duoshuo.com/images/service-icons-color-flat.png&quot;);_background-image:url(&quot;//static.duoshuo.com/images/service-icons-color-flat.gif&quot;)&#125;#ds-share #ds-reset .ds-share-icons&#123;border:1px solid #ccc;background:#fff;border-radius:3px&#125;#ds-share #ds-reset .ds-share-icons .ds-share-icons-inner&#123;width:208px;padding:10px&#125;#ds-share #ds-reset .ds-share-icons .ds-share-icons-inner ul&#123;margin:0;padding:0&#125;#ds-share #ds-reset .ds-share-icons .ds-share-icons-inner ul li&#123;padding-left:8px;margin-left:0;width:92px;font-size:12px&#125;#ds-share #ds-reset .ds-share-icons .ds-share-icons-inner ul li:hover&#123;border-radius:3px;background:#eee&#125;#ds-share #ds-reset .ds-share-icons .ds-share-icons-inner ul li:nth-child(even)&#123;margin-left:8px&#125;#ds-share #ds-reset .ds-share-icons .ds-share-icons-footer&#123;text-align:right;line-height:30px;font-size:12px;color:#ccc;background-color:#eee;padding-right:10px&#125;#ds-share #ds-reset .ds-share-icons-more&#123;top:30px;left:0;position:absolute;z-index:1000&#125;#ds-share.ds-no-transition #ds-reset.ds-share-aside-left&#123;left:-229px;transform:none&#125;#ds-share.ds-no-transition #ds-reset.ds-share-aside-right&#123;right:-229px;transform:none&#125;#ds-share .ds-share-aside-left,#ds-share .ds-share-aside-right&#123;width:230px;_position:absolute;_bottom:auto;_top:expression(eval(document.documentElement.scrollTop+200))&#125;#ds-share .ds-share-aside-left&#123;_left:expression(eval(document.documentElement.scrollLeft-230))&#125;#ds-share .ds-share-aside-right&#123;_right:auto;_left:expression(eval(document.documentElement.scrollLeft+document.documentElement.clientWidth-this.offsetWidth)-(parseInt(this.currentStyle.marginLeft,10)||0)-(parseInt(this.currentStyle.marginRight,10)||0 - 230))&#125; 具体样式请参照：多说.css 为Hexo博客添加目录Hexo博客系统的核心支持生成目录（Table of Contents），但其默认的主题Landscape并不支持目录的显示。我们只需对Landscape的主题文件稍作修改并添加一点目录的CSS就可以在文章前面显示友好的目录了。 修改Landscape主题的ejs文件 我们首先要编辑文章显示页面的模板，也就是themes/landscape/layout/_partial/article.ejs文件。为了将目录生成在正文之前，我们首先在这个文件中找到&lt;%- post.content %&gt;，并在这一行之前加入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 引入文件_partial\\article.ejs &lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt; &lt;%- partial(&apos;_partial/toc&apos;) %&gt; &lt;% &#125; %&gt; &lt;% if (!index &amp;&amp; post.toc)&#123; %&gt; &lt;%- partial(&apos;post/toc&apos;) %&gt; &lt;% &#125; %&gt;&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt;&lt;/div&gt;&lt;style&gt; .left-col .switch-btn &#123; display: none; &#125; .left-col .switch-area &#123; display: none; &#125;&lt;/style&gt;&lt;input type=&quot;button&quot; id=&quot;tocButton&quot; value=&quot;隐藏目录&quot; title=&quot;点击按钮隐藏或者显示文章目录&quot;&gt;&lt;%- js(&apos;http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min&apos;) %&gt;&lt;script&gt; var toc_button = document.getElementById(&quot;tocButton&quot;); var toc_div = document.getElementById(&quot;toc&quot;); toc_button.onclick=function() &#123; if (toc_div.style.display == &quot;none&quot;) &#123; toc_div.style.display = &quot;block&quot;; toc_button.value = &quot;隐藏目录&quot;; document.getElementById(&quot;switch-btn&quot;).style.display = &quot;none&quot;; document.getElementById(&quot;switch-area&quot;).style.display = &quot;none&quot;; &#125; else &#123; toc_div.style.display = &quot;none&quot;; toc_button.value = &quot;显示目录&quot;; document.getElementById(&quot;switch-btn&quot;).style.display = &quot;block&quot;; document.getElementById(&quot;switch-area&quot;).style.display = &quot;block&quot;; &#125; &#125; if ($(&quot;.toc&quot;).length &lt; 1) &#123; $(&quot;#toc&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;#tocButton&quot;).css(&quot;display&quot;,&quot;none&quot;); $(&quot;.switch-btn&quot;).css(&quot;display&quot;,&quot;block&quot;); $(&quot;.switch-area&quot;).css(&quot;display&quot;,&quot;block&quot;); &#125;&lt;/script&gt;&lt;% if (theme.toc_nowrap) &#123; %&gt; &lt;style&gt; .toc &#123; white-space: nowrap; overflow-x: hidden; &#125; &lt;/style&gt; &lt;script&gt; $(document).ready(function() &#123; $(&quot;.toc li a&quot;).mouseover(function() &#123; var title = $(this).attr(&apos;href&apos;); $(this).attr(&quot;title&quot;, title); &#125;); &#125;) &lt;/script&gt;&lt;% &#125; %&gt; 这段代码的含义清晰明了，if语句中有两个条件，!index是为了不在首页的文章摘要中生成目录，post.toc确保了只在显式地标记了toc: true的文章中生成目录。若这两个条件满足，则创建一个目录的。 修改完这个文件之后，找一篇包含了多个子标题的文章，并在文章开头的front-matter中添加一句toc: true，在浏览器中访问这篇文章，应该可以看到文章的开头处已经有了带链接的目录。但是这样的目录实在太难看，我们还需要添加相应的CSS来将其指定为我们想要的样式。 为目录编写CSS文件 要指定目录的样式，我们要修改的文件是themes/landscape/source/css/_partial/article.styl。在文件的最后，添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/*toc*/#tocButton &#123; position: fixed; border: none; left: 220px; top: 382px; background: none; font-size: .9em; font-weight: bold; color: lightgray; cursor: pointer font-family: inherit; outline: none; /*Remove button border when clicked.*/ -webkit-appearance: none; /*Remove iOS button style*/ &amp;:hover &#123; color: #88acdb; &#125;&#125;.toc-article &#123; position: fixed; width: 230px; top: 378px; bottom: 1em; left: 0; margin-left: 0em; padding: 6px 10px 10px 50px; border-radius: 2.8%; overflow: auto;&#125;#toc &#123; float: right; font-size: .9em; line-height: 1.65em; z-index: 12; a &#123; color: gray; &amp;:visited &#123; color: rgba(244, 131, 133, 1); &#125; &amp;:hover &#123; color: #88acdb; text-decoration: none; &#125; &#125; li:hover &#123; background: none; li:hover &#123; background: rgba(158, 188, 226, .21); &#125; &#125; .toc-title &#123; font-weight: bold; color: gray; &#125; .toc &#123; padding: .7em; padding-right: 0; li &#123; list-style-type: none; &#125; &#125; ol &#123; margin-left: 0; &#125; .toc-child &#123; padding-left: 1.25em; margin: 4px 0; &#125; .toc-link:hover &#123; background: rgba(158, 188, 226, .21); &#125;&#125;.copyright &#123; width: 85%; max-width: 45em; margin: 0 auto; padding: .5em 1.8em; border: 1px solid lightgray; font-size: .93em; line-height: 1.6em; word-break: break-word; background: rgba(255, 255, 255, .4); span &#123; margin-right: 1em; color: #B5B5B5; font-weight: bold; &#125; a &#123; color: gray; &amp;:hover &#123; font-weight: bold; color: #a3d2a3; text-decoration: underline; &#125; &#125; &amp;:hover p .copy-path::after &#123; content: &quot;复制&quot;; &#125; .post-url:hover &#123; font-weight: normal; &#125; .copy-path &#123; margin-left: 1em; &amp;:hover &#123; color: gray; cursor: pointer; &#125; &#125;&#125; 第一段的toc-article指定了目录整个的背景色、边框色、倒角半径、各种间距以及最大的宽度。注意这里最好指定目录的最大宽度，我将其设为了28%，也就是文章正文那个框的宽度的28%，也可以设为一个固定的长度，比如在笔记本电脑上16em就是个不错的宽度，但为了能适配各种不同尺寸的屏幕，最好还是设置为百分比。如果不指定最大宽度，遇到比较长的标题时，生成的目录会非常难看。这个最大宽度的设置是我在网上其他添加目录的方法中没有见到的。 第二段的toc-title指的就是“文章目录”那四个字，这四个字要比其他字大一些，将其字号设为其他字的120%。 第三段的#toc.toc指定了目录列表的一些细节，将font-size设为0.9em会让目录的字比文章的字稍小一些。最后的.toc-child指定了二级目录的缩进量。 再次生成页面，应该已经可以显示比较美观的目录了。 收尾工作 通常情况下我们不需要为每一篇文章都添加目录，因为大部分文章的长度还是相对较短，或者结构简单而没有添加小标题。在我的博客上，需要添加目录的长文还是相对较少的。因为我选择了默认不生成目录，而手动为需要目录的文章添加显式地标记。 下面我就需要编辑每一篇需要添加目录的文章，在文章开头的front-matter中加入toc: true。 插入自定义页面仿照Hexo官网，了解到单页面的添加方式。 添加代码 1234567891011121314151617181920D:\\Hexo\\Hexos\\themes\\spfk\\layout\\plugins.swig&lt;div id=&quot;content-wrap&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header id=&quot;plugin-list-header&quot;&gt; &lt;h1 id=&quot;plugin-list-title&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/h1&gt; &lt;input type=&quot;search&quot; id=&quot;plugin-search-input&quot; placeholder=&quot;Search&quot;&gt; &lt;div id=&quot;plugin-list-count&quot;&gt;&#123;&#123; site.data[page.data].length &#125;&#125; items&lt;/div&gt; &lt;/header&gt; &lt;ul id=&quot;plugin-list&quot;&gt; &#123;% for plugin in _.sortBy(site.data[page.data], &apos;name&apos;) %&#125; &#123;&#123; partial(&apos;_partial/&apos; + page.partial, &#123;plugin: plugin&#125;) &#125;&#125; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;window.SEARCH_INDEX = &#123;&#123; lunr_index(site.data[page.data]) &#125;&#125;&lt;/script&gt; 1234567891011D:\\Hexo\\Hexos\\themes\\spfk\\layout\\_partial\\plugin.swig&lt;li class=&quot;plugin on&quot;&gt; &lt;a href=&quot;&#123;&#123; plugin.link &#125;&#125;&quot; class=&quot;plugin-name&quot; target=&quot;_blank&quot;&gt;&#123;&#123; plugin.name &#125;&#125;&lt;/a&gt; &lt;p class=&quot;plugin-desc&quot;&gt;&#123;&#123; plugin.description &#125;&#125;&lt;/p&gt; &lt;div class=&quot;plugin-tag-list&quot;&gt; &#123;% for tag in plugin.tags %&#125; &lt;a href=&quot;#&#123;&#123; tag &#125;&#125;&quot; class=&quot;plugin-tag&quot;&gt;&#123;&#123; tag &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/li&gt; 123456789101112131415161718D:\\Hexo\\Hexos\\themes\\spfk\\layout\\_partial\\work.swig&lt;li class=&quot;plugin on&quot;&gt; &lt;div class=&quot;plugin-screenshot&quot;&gt; &lt;img src=&quot;&#123;&#123; plugin.imgs &#125;&#125;&quot; class=&quot;plugin-screenshot-img&quot;&gt; &#123;% if plugin.preview %&#125; &lt;a href=&quot;&#123;&#123; plugin.preview &#125;&#125;&quot; class=&quot;plugin-preview-link&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;a href=&quot;&#123;&#123; plugin.link &#125;&#125;&quot; class=&quot;plugin-name&quot; target=&quot;_blank&quot;&gt;&#123;&#123; plugin.name &#125;&#125;&lt;/a&gt; &lt;p class=&quot;plugin-desc&quot;&gt;&#123;&#123; plugin.description &#125;&#125;&lt;/p&gt; &lt;div class=&quot;plugin-tag-list&quot;&gt; &#123;% for tag in plugin.tags %&#125; &lt;a href=&quot;#&#123;&#123; tag &#125;&#125;&quot; class=&quot;plugin-tag&quot;&gt;&#123;&#123; tag &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&lt;/li&gt; 1234引入样式文件D:\\Hexo\\Hexos\\themes\\spfk\\source\\css\\style.styl@import &quot;_partial/plugins&quot; 修改样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126D:\\Hexo\\Hexos\\themes\\spfk\\layout\\_partial\\plugin.swig#plugin-list-header clearfix() margin: 40px 0#plugin-list-title font-family: font-title font-size: 36px font-weight: 300 line-height: 1 float: left#plugin-list-count color: color-gray padding-top: 1em text-align: right @media mq-normal float: right line-height: 40px padding-top: 0 padding-right: 15px#plugin-search-input font-size: 16px font-family: inherit -webkit-appearance: none border: 1px solid color-border padding: 10px 10px width: 100% margin-top: 25px @media mq-normal float: right width: 50% margin-top: 0#plugin-list margin: 40px -20px display: flex flex-flow: column @media mq-tablet flex-flow: row wrap.plugin display: none padding: 20px @media mq-tablet flex: 0 0 50% @media mq-normal flex: 0 0 (100 / 3)% &amp;.on display: block.plugin-name font-family: font-title font-weight: bold color: color-link font-size: 20px text-decoration: none line-height: 1 &amp;:hover color: color-link-hover.plugin-desc line-height: line-height margin: 1em 0.plugin-tag-list clearfix() line-height: 1.3.plugin-tag color: color-gray font-size: 0.9em text-decoration: none float: left margin-right: 10px &amp;:hover color: color-link-hover &amp;:before content: &quot;#&quot;.plugin-screenshot margin-bottom: 15px position: relative padding-top: (10 / 16 * 100)% // 16:10 ratio height: 0 overflow: hidden.plugin-screenshot-img position: absolute top: 0 left: 0 width: 100% height: auto.plugin-preview-link position: absolute top: 0 left: 0 width: 100% height: 100% background: rgba(0, 0, 0, 0.7) color: #fff text-align: center opacity: 0 transition: 0.15s &amp;:hover opacity: 1 .fa opacity: 1 transform: scale(1) .fa position: absolute top: 0 left: 0 bottom: 0 right: 0 margin: auto font-size: 50px width: @font-size height: @font-size opacity: 0 transform: scale(6) transition: 0.2s transition-delay: 0.15s 自定义挂件除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\\themes\\modernist\\layout_widget\\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\\themes\\modernist_config.yml中配置。1234567widgets: - myWidget用上述方法可以添加新浪微博小挂件。生成自己的微博组件。添加hexo\\themes\\modernist\\layout\\_widget\\weibo.ejs文件。配置hexo\\themes\\modernist\\_config.yml。 Hexo语法高亮查阅格式高亮代码，了解到本主题，通过特定的规律进行语法高亮！好像无法识别不同代码的语法高亮！ 测试： 通过测试代码，查看后台代码逻辑，了解到可以识别Apache、C++、bash等，还有部分不可识别。那么这个主题用的是什么的语法高亮？ 代码code，table-gutter-pre是代码前面的序号。class=”highlight apache”123456789101112131415161718192021J:\\Hexo\\Hexo\\themes\\spfk\\source\\css\\_partial\\highlight.styl// https://github.com/luuman/hexo-theme-spfkcode-bgc = #002B36code-tag = #F92672code-attr = #A6E22Ecode-word = #FFFFFFcode-value = #E6DB74code-number = #9E90FFcode-keyword = #66D9EFcode-comment = #75715Ecode-argument = #FD971F$code-block background: code-bgc margin: 10px 0 padding: 10px 10px overflow: auto color: #4C4C4C line-height: font-size * line-height 参考：highlight.js：Demo https://highlightjs.org/static/demo/Solarized DarkAtelier Sulphurpool Dark文档：http://highlightjs.readthedocs.org/en/latest/css-classes-reference.html下载：https://highlightjs.org/download/ 首页添加loading效果themes\\spfk\\layout\\index.ejs 123456789101112131415&lt;link rel=&quot;stylesheet&quot; href=&quot;css/loading-style.css&quot;&gt;&lt;div id=&quot;loader-wrapper&quot;&gt; &lt;div id=&quot;loader&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;%- partial(&apos;_partial/archive&apos;, &#123;pagination: 2, index: true&#125;) %&gt;&lt;!-- loading --&gt;&lt;script&gt;window.jQuery || document.write(&apos;&lt;script src=&quot;js/jquery-1.9.1.min.js&quot;&gt;&lt;\\/script&gt;&apos;)&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(window).load(function() &#123; // makes sure the whole site is loaded $(&apos;#loader&apos;).fadeOut(); // will first fade out the loading animation $(&apos;#loader-wrapper&apos;).delay(350).fadeOut(&apos;slow&apos;); // will fade out the white DIV that covers the website. $(&apos;body&apos;).delay(350).css(&#123;&apos;overflow-y&apos;:&apos;visible&apos;&#125;); &#125;)&lt;/script&gt; LoadingBar页面顶部加载进度条J:\\Hexo\\Hexo\\themes\\spfk\\layout_partial\\head.ejs 12345&lt;!-- 加载特效 --&gt;&lt;% if(theme.animate) &#123; %&gt; &lt;script src=&quot;/js/pace.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;/css/pace/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;% &#125; %&gt; highlight.js1234567891011121314151617J:\\Hexo\\Hexo\\node_modules\\hexo-renderer-marked\\node_modules\\hexo-util\\lib\\highlight.js: 37 &#125; 38 39: result += &apos;&lt;figure class=&quot;highlight&apos; + (data.language ? &apos; &apos; + data.language : &apos;&apos;) + &apos;&quot;&apos; + &apos;data-lang=&quot;&apos; + (data.language ? &apos; &apos; + data.language : &apos;&apos;) + &apos;&quot;&gt;&apos;; 40 41 if (caption) &#123;J:\\Hexo\\Hexo\\node_modules\\hexo-util\\lib\\highlight.js: 33 &#125; 34 35: result += &apos;&lt;figure class=&quot;highlight&apos; + (data.language ? &apos; &apos; + data.language : &apos;&apos;) + &apos;&quot;&gt;&apos;; 36 37 if (caption)&#123;6 matches across 2 files result += &apos;&lt;figure class=&quot;highlight&apos; + (data.language ? &apos; &apos; + data.language : &apos;&apos;) + &apos;&quot;&apos; + &apos;data-lang=&quot;&apos; + (data.language ? &apos; &apos; + data.language : &apos;&apos;) + &apos;&quot;&gt;&apos;; Hexo插件Swiftype 微搜索 不蒜子 百度统计 CNZZ数据 Font Awesome 百度脑图 ICON图标 Font Awesome FREE Icon Maker Icon Font 在线ico IcoMoon Disqus 多说评论 QQ邮箱开放平台 七牛云存储 百度分享 AddThis 分享一个方法解决Facebook,Linkedin,Twitter,Google+等SNS平台太多更新不过来的问题。 - 米课问答 GitCafe Coding.Net GitHub","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://smuwjs.github.io/tags/Hexo/"}]},{"title":"Hexo的使用介绍","date":"2016-09-07T13:33:01.000Z","path":"2016/09/07/hexo-site-build-start/","text":"自用笔记：本文属于自用笔记，不做详解，仅供参考。在此记录自己已理解并开始遵循的前端代码规范。What How Why 最近，使用Hexo遇到了很多问题，在设立进行整理。 写文章1234567891011121314151617181920212223242526272829$ hexo n #写文章 其中my new post为文章标题，执行命令后。 会在项目\\source_posts中生成my new post.md文件，用编辑器打开编写即可。 当然，也可以直接在\\source_posts中新建一个md文件，我就是这么做的。 文章开头语法：title: name #文章标题date: 2015-12-25 18:29:00 #写作时间description: #文章描述categories: #文章分类- 建站tags: #文章标签- 博客- 建站- Hexotoc: true # 生成目录author:comments:original:permalink: #指定链接--- 以上是摘要&lt;!--more--&gt; 以下是余下全文 写多种文章1234567891011121314151617181920212223242526$ hexo new [layout] &quot;postName&quot; #新建文章 [layout]：其中layout是可选参数，默认值为post。 有哪些layout呢，请到 scaffolds 目录下查看，这些文件名称就是layout名称。 当然你可以添加自己的layout，方法就是添加一个文件即可。 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md 关于hexo\\scaffolds\\photo.md配置文件的介绍：layout: &#123; &#123; layout &#125; &#125; #layout名称title: &#123; &#123; title &#125; &#125; #文章标题date: &#123; &#123; date &#125; &#125; #文章生成时间ategories: #文章分类目录tags: #文章标签- #photos: #- #---layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 自定义页面12345678910111213 执行new page命令$ hexo new page &quot;about&quot; 在 *hexo\\source\\* 下会生成 *about* 目录， 里面有个index.md，直接编辑就可以了， 然后在主题的 *_config.yml* 中将其配置显示出来。 上述步骤，也可以手工生成，在 *hexo\\source\\* 下手工新建 *about* 和 *index.md* 也是完全等价的。 因为markdown对table的支持不好，我是在about中直接 建立index.html，里面书写页面内容，hexo会帮你加上头和尾。 写页面（404）12345$ hexo new page &quot;404&quot;UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master)$ hexo new page &quot;404&quot;INFO Created: D:\\Hexo\\Hexo\\source\\404\\index-1.md 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071title: 404 Not Found：该页无法显示comments: falsepermalink: /404fancybox: false---&lt;style type=&quot;text/css&quot;&gt; .article-title &#123; font-size: 2.1em; &#125; strong a &#123; color: #747474; &#125; .share &#123; display: none; &#125; .player &#123; margin-left: -10px; &#125; .sign &#123; text-align: right; font-style: italic; &#125; #page-visit &#123; display: none; &#125; .center &#123; text-align: center; height: 2.5em; font-weight: bold; &#125; .search2 &#123; height: 2.2em; font-size: 1em; width: 50%; margin: auto 24%; color: #727272; opacity: .6; border: 2px solid lightgray; &#125; .search2:hover &#123; opacity: 1; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3) &#125;; .article-entry hr &#123; margin: 0; &#125; .pic &#123; text-align: center; margin: 0; &#125; .pic br &#123; display: none; &#125;&lt;/style&gt;***&lt;div class=&quot;pic&quot;&gt;&lt;img src=&quot;/resources/Mihawk-Wind.gif&quot; title=&quot;Mihawk-Wind&quot;&gt;&lt;/div&gt;&lt;p class=&quot;center&quot;&gt;很抱歉，您所访问的地址并不存在: &lt;/p&gt;&lt;p class=&quot;center&quot;&gt;&lt;a href=&quot;/&quot;&gt;回主页&lt;/a&gt; · &lt;a href=&quot;/archives&quot;&gt;所有文章&lt;/a&gt; · &lt;a href=&quot;/about&quot;&gt;留言板&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;center&quot;&gt;可在边栏搜索框中对本站进行检索，以获取相关信息。&lt;/p&gt;&lt;div style=&quot;text-align: center&quot;&gt;以下是博主喜欢的一些歌曲，可以听听，稍作休息~&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=320 height=330 src=&quot;http://music.163.com/outchain/player?type=0&amp;id=112513213&amp;auto=0&amp;height=430&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 发布博客内容实现发布，前提是配置好，部署到Github前需要配置_config.yml文件。 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: github repository: git@github.com:zhchnchn/zhchnchn.github.io.git branch: master 更新的最新版本，可能会有Bug，自行百度，好像要修改type：git。12345678910$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）Hexo 会监视文件变动并自动更新，您无须重启服务器。$ hexo g #生成$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）$ hexo d == hexo deploy#部署$ hexo d #部署 # 可与hexo g合并为 hexo d -g$ hexo deploy -g$ hexo server -g # 生成默认文件群再执行,开启本地静态html服务器 主题的更改123456789101112131415161718191. 将Git Shell 切到/D/Hexo目录下，然后执行下面的命令，将pacman下载到 themes/pacman 目录下。$ git clone https://github.com/A-limon/pacman.git themes/pacman2. 修改你的博客根目录/D/Hexo下的config.yml配置文件中的theme属性，将其设置为pacman。3. 更新pacman主题$ cd themes/pacman$ git pullNOTE：先备份_config.yml 文件后再升级主题： yilia$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia modernist$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist jacman$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman 文章图片路径Hexo如何方式图片，图片应该放置到哪里，不会应为上传而覆盖掉。然后把文章里的index.md删除，将文件存放在resource文件夹中间。 123456 发布页面$ hexo new page &quot;name&quot; # 新建一个页面，页面名称name UUhike@UUhike-pc MINGW64 /d/Hexo/Hexo (master)$ hexo new page &quot;resoures&quot; INFO Created: D:\\Hexo\\Hexo\\source\\resoures\\index.md Hexo文件备份1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 git-backup. Install if your hexo version is 2.x.x, you should install as follow:$ npm install hexo-git-backup@0.0.91 --save if version is 3.x.x, you should install as follow:$ npm install hexo-git-backup --save Update if you install with --save, you must remove firstly when you update it.$ npm remove hexo-git-backup$ npm install hexo-git-backup --save Configure You should configure this plugin in _config.yml.backup: type: git repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchNameUsinghexo backup orhexo bOptionsif you want to back up with your theme,just add theme: your theme name,your theme name in _config.yml.backup: type: git theme: coney,landscape,xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchNameAttention: if you do as above, the dir themes/coney/.gitwill be removedif you want DIY commit message, just add &apos;message: update xxx&apos;.backup: type: git message: update xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchNameNow you can backup all the blog!ProblemsYou may get some troubles by your computer&apos; permission。Error: EISDIR, openit is caused by permission. just do &apos;sudo hexo b&apos;sudo hexo b 参考资料：使用GitHub搭建Hexo博客Hexo插件安装hexo你的博客如何搭建一个独立博客——简明Github Pages与Hexo教程","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://smuwjs.github.io/tags/Hexo/"}]},{"title":"Hello World","date":"2016-09-06T10:29:00.000Z","path":"2016/09/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post12$ hexo new \"My New Post\" More info: Writing Run server12$ hexo server More info: Server Generate static files12$ hexo generate More info: Generating Deploy to remote sites12$ hexo deploy More info: Deployment","tags":[]}]